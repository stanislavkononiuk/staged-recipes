Index: applications/dmrg/mps/framework/dmrg/models/op_handler.h
===================================================================
--- applications/dmrg/mps/framework/dmrg/models/op_handler.h	(revision 7816)
+++ applications/dmrg/mps/framework/dmrg/models/op_handler.h	(revision 7817)
@@ -143,6 +143,7 @@
     typedef TagHandler<Matrix, SymmGroup> base;
     typedef typename OPTable<Matrix, SymmGroup>::tag_type tag_type;
     typedef typename base::op_t op_t;
+    typedef typename base::pair_map_it_t pair_map_it_t;
 
 public:
 
Index: applications/dmrg/mps/framework/dmrg/models/op_handler.hpp
===================================================================
--- applications/dmrg/mps/framework/dmrg/models/op_handler.hpp	(revision 7815)
+++ applications/dmrg/mps/framework/dmrg/models/op_handler.hpp	(revision 7816)
@@ -94,14 +94,10 @@
 
     // return tag of product, if already there
     try {
-#if defined(__xlC__) || defined(__FCC_VERSION)
-        if (product_tags.count(std::make_pair(t1, t2)) == 0)
+        pair_map_it_t match = product_tags.find(std::make_pair(t1, t2));
+        if (match == product_tags.end())
             throw std::out_of_range("");
-
-        return product_tags[std::make_pair(t1, t2)];
-#else
-        return product_tags.at(std::make_pair(t1, t2));
-#endif
+        return match->second;
     }
 
     // compute and register the product, then return the new tag
Index: applications/dmrg/mps/framework/dmrg/sim/sim.hpp
===================================================================
--- applications/dmrg/mps/framework/dmrg/sim/sim.hpp	(revision 7815)
+++ applications/dmrg/mps/framework/dmrg/sim/sim.hpp	(revision 7816)
@@ -148,12 +148,8 @@
 {
     std::ostringstream oss;
     oss.str("");
-#if defined(__xlC__) || defined(__FCC_VERSION)
     typename status_type::const_iterator match = status.find("sweep");
     oss << "/spectrum/iteration/" << match->second;
-#else
-    oss << "/spectrum/iteration/" << status.at("sweep");
-#endif
     return oss.str();
 }
Index: applications/dmrg/mps/framework/dmrg/models/op_handler.hpp
===================================================================
--- applications/dmrg/mps/framework/dmrg/models/op_handler.hpp	(revision 7816)
+++ applications/dmrg/mps/framework/dmrg/models/op_handler.hpp	(revision 7817)
@@ -163,14 +163,10 @@

     // return tag of kronecker product, if already there
     try {
-#if defined(__xlC__) || defined(__FCC_VERSION)
-        if (kron_tags.count(std::make_pair(t1, t2)) == 0)
-            throw std::out_of_range("");
-
-        return kron_tags[std::make_pair(t1, t2)].first;
-#else
-        return kron_tags.at(std::make_pair(t1, t2)).first;
-#endif
+      pair_map_it_t match = kron_tags.find(std::make_pair(t1, t2));
+      if (match == kron_tags.end())
+          throw std::out_of_range("");
+      return match->second.first;
     }
     // compute and register the product, then return the new tag
     catch(const std::out_of_range& e) {
Index: applications/dmrg/mps/framework/dmrg/mp_tensors/mps_initializers.h
===================================================================
--- applications/dmrg/mps/framework/dmrg/mp_tensors/mps_initializers.h	(revision 7818)
+++ applications/dmrg/mps/framework/dmrg/mp_tensors/mps_initializers.h	(revision 7819)
@@ -462,7 +462,7 @@
         std::vector<boost::tuple<charge, size_t> > state(mps.length());
         for (int i=0; i<mps.length(); ++i)
             state[i] = boost::make_tuple(C, occupation[i]);
-        mps = state_mps<Matrix>(state, phys_dims, site_type);
+        mps = state_mps<Matrix, SymmGroup>(state, phys_dims, site_type);
     }

 private:
@@ -497,7 +497,7 @@
         std::vector<boost::tuple<charge, size_t> > state(mps.length());
         for (int i=0; i<mps.length(); ++i)
             state[i] = boost::make_tuple(C, occupation[i] + occupation[i]*N);
-        mps = state_mps<Matrix>(state, phys_rho_dims, site_type);
+        mps = state_mps<Matrix, SymmGroup>(state, phys_rho_dims, site_type);
     }

 private:
@@ -546,7 +546,7 @@
         if (mps.length() != state.size())
             throw std::runtime_error("Size of the initial state does not match the MPS size.");
  
-        mps = state_mps<Matrix>(state, phys_dims, site_type);
+        mps = state_mps<Matrix, SymmGroup>(state, phys_dims, site_type);
         if (mps[mps.length()-1].col_dim()[0].first != right_end)
             throw std::runtime_error("Initial state does not satisfy total quantum numbers.");
     }
