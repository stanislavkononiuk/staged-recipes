diff -r ef8470f9d682 .hgtags
--- a/.hgtags	Sun Feb 12 15:25:10 2017 +0100
+++ b/.hgtags	Mon Apr 27 19:55:56 2020 -0700
@@ -19,4 +19,4 @@
 f1e30de071451f190d1f8064764ce873c43c8bfc Release-1_3-20040523
 d394f60f8edfe4b0373a4f0146b2e71fb59ceb2c Release-4_0-20091213
 e2e8180028fd1761eca6e6af598e0137384f4e6d Release-4_1-20121208
-a7a247e1e64bf920050f49c5c95a641825c6e2e8 Release-4_2-20160329
+f8a34cfab8c143dac7b785806085aa929037512b Release-4_1_5-20160322
diff -r ef8470f9d682 CMakeLists.txt
--- a/CMakeLists.txt	Sun Feb 12 15:25:10 2017 +0100
+++ b/CMakeLists.txt	Mon Apr 27 19:55:56 2020 -0700
@@ -6,7 +6,7 @@
 #                  , Harry van der Wolf <hvdwolf@gmail.com>
 # Original file from lyx-project, heavily modified
 #
-cmake_minimum_required(VERSION 2.8)
+cmake_minimum_required(VERSION 3.8)
 
 set(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS true)
 
@@ -98,12 +98,15 @@
 
 # Configurable options
 OPTION(ENABLE_OPENMP "OpenMP Support" OFF)
+OPTION(ENABLE_OPENCL "OpenCL Support" OFF)
 OPTION(ENABLE_TCMALLOC "TCmalloc Support" OFF)
 IF(NOT WIN32)
 # dynamic loading on windows is supported by own class
 OPTION(ENABLE_DLOPEN "Dlopen Support" ON)
 ENDIF()
 OPTION(DOC "Create Documentation" OFF)
+OPTION(PREFER_SEPARATE_OPENCL_SOURCE "Define if you want to access OpenCL files, not compile-in their string equivalents" OFF)
+OPTION(ENABLE_METADATA_TRANSFER "Support for copying of metadata into output files" OFF)
 
 IF(NOT CMAKE_CL_64)
   OPTION(ENABLE_SSE2 "SSE2 Support(Release builds only)" OFF)
@@ -113,20 +116,19 @@
 IF(NOT WIN32)
   OPTION(ENABLE_DMALLOC "Use the dmalloc debugging package" OFF)
   OPTION(ENABLE_DMALLOC_FUNC_CHECK "Enable dmalloc function checking" OFF)
+  SET(DEFAULT_OPENCL_PATH "/usr/local/share/enblend/kernels:/usr/share/enblend/kernels" CACHE STRING "Default search path for OpenCL files")
 ELSE(NOT WIN32)
   SET(ENABLE_DMALLOC OFF CACHE INTERNAL "")
   SET(ENABLE_DMALLOC_FUNC_CHECK OFF CACHE INTERNAL "")
 ENDIF(NOT WIN32)
 
-# Compiler specific tweaks and optimizations
-# Microsoft Visual C++ compiler does not need any addtional switches for C++11
-# so check only other compilers
-IF (NOT MSVC)
-  FIND_PACKAGE(CXX11Compiler)
-  IF(NOT CXX11COMPILER_FOUND)
-    MESSAGE(FATAL_ERROR "A C++11 compatible compiler is required.")
-  ENDIF()
-  SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${CXX11_FLAG}")
+# we need a C++17 compliant compiler
+SET(CMAKE_CXX_STANDARD 17)
+SET(CMAKE_CXX_STANDARD_REQUIRED ON)
+# MSVC 2017 has removed some deprecated functions with C++17
+# but there are still used by vigra, so bring they back for now
+IF(MSVC_VERSION GREATER 1900)
+  ADD_DEFINITIONS(-D_HAS_AUTO_PTR_ETC=1)
 ENDIF()
 
 IF(CMAKE_COMPILER_IS_GNUCXX)
@@ -189,6 +191,7 @@
 # Required Libraries first
 FIND_PACKAGE(LCMS2 REQUIRED)
 ADD_DEFINITIONS(-DHAVE_LIBLCMS2)
+ADD_DEFINITIONS(-DCMS_NO_REGISTER_KEYWORD)
 FIND_PACKAGE(TIFF REQUIRED)
 FIND_PACKAGE(Perl REQUIRED)
 # this one is needed in doc. (Especially the program "convert")
@@ -197,36 +200,21 @@
 ADD_DEFINITIONS(-DHAVE_LIBGSL)
 ADD_DEFINITIONS(-DHAVE_LIBGSLCBLAS)
 LIST(APPEND common_libs ${LCMS2_LIBRARIES} ${TIFF_LIBRARIES} ${GSL_LIBRARIES})
+IF(CMAKE_COMPILER_IS_GNUCXX)
+# gnu c++ requires -lstdc++fs for C++17 <filesystem> support
+LIST(APPEND common_libs stdc++fs)
+ENDIF()
 include_directories(${TIFF_INCLUDE_DIR} ${LCMS2_INCLUDE_DIR})
 
 # Platform specifics required libraries
 IF(WIN32)
-  SET(Boost_USE_STATIC_LIBS ON)
   # path for getopt library
   INCLUDE_DIRECTORIES(${TOP_SRC_DIR}/src/win32helpers)
 ENDIF(WIN32)
 
-# Boost headers are required, but filesystem is optional
-if(WIN32)
-  IF( NOT Boost_root_suffix )
-    SET( Boost_root_suffix _1_51_0 CACHE STRING "suffix of boost root dir." FORCE )
-  ENDIF( NOT Boost_root_suffix )
-  SET(Boost_USE_STATIC_LIBS ON)
-  if (NOT BOOST_ROOT AND NOT $ENV{BOOST_ROOT} STREQUAL "")
-    set(BOOST_ROOT $ENV{BOOST_ROOT})
-  else(NOT BOOST_ROOT AND NOT $ENV{BOOST_ROOT} STREQUAL "")
-    set(BOOST_ROOT ${SOURCE_BASE_DIR}/boost${Boost_root_suffix})
-  endif(NOT BOOST_ROOT AND NOT $ENV{BOOST_ROOT} STREQUAL "")
-endif()
-
-# Boost headers are required
-FIND_PACKAGE(Boost 1.55 REQUIRED)
-
 #check some header and functions
 include(ConfigureChecks.cmake)
 
-include_directories(${Boost_INCLUDE_DIR})
-
 # Optional Libraries
 FIND_PACKAGE(ZLIB)
 FIND_PACKAGE(JPEG)
@@ -275,6 +263,15 @@
   MESSAGE(STATUS "OpenEXR support disabled")
 ENDIF(OPENEXR_FOUND)
 
+IF(ENABLE_METADATA_TRANSFER)
+  FIND_PACKAGE(EXIV2 REQUIRED)
+  SET(HAVE_EXIV2 ON)
+  list(APPEND common_libs ${EXIV2_LIBRARIES})
+  include_directories(${EXIV2_INCLUDE_DIR})
+ELSE()
+  SET(HAVE_EXIV2 OFF)
+ENDIF()
+
 # Now that packages are / are not detected, handle config options
 
 IF(ENABLE_OPENMP)
@@ -282,6 +279,13 @@
   add_definitions(${OpenMP_CXX_FLAGS})
 ENDIF(ENABLE_OPENMP)
 
+IF(ENABLE_OPENCL)
+  FIND_PACKAGE(OpenCL REQUIRED)
+  INCLUDE_DIRECTORIES(${OPENCL_INCLUDE_DIR})
+  LIST(APPEND common_libs ${OPENCL_LIBRARY})
+  add_definitions("-D_OPENCL=1")
+ENDIF(ENABLE_OPENCL)
+
 IF(ENABLE_SSE2)
   set_sse_cxx_flags()
 ENDIF(ENABLE_SSE2)
@@ -417,7 +421,7 @@
     endif()	
     set(PAPERSIZE "a4" CACHE STRING "Papersize for some converters: a4, a5, b5, executive, legal, letter")
     set(PRINTRESOLUTION "600" CACHE STRING "Resolution for some converters in dots-per-inch")
-    set(DYNAMIC_TEX_PREAMBLE "\\def\\finishdynamicpreamble{\\relax}" CACHE STRING "LaTeX commands to add to preamble")
+    set(DYNAMIC_TEX_PREAMBLE "\\def\\finishdynamicpreamble{\\overfullrule=2pt\\relax}" CACHE STRING "LaTeX commands to add to preamble")
 endif()
 
 MESSAGE(STATUS "")
@@ -434,9 +438,23 @@
 MESSAGE(STATUS "Features Enabled:")
 IF(NOT WIN32)
 MESSAGE(STATUS "enable malloc debugging: ${ENABLE_DMALLOC}")
+MESSAGE(STATUS "Dlopen Support:          ${ENABLE_DLOPEN}")
 ENDIF(NOT WIN32)
 MESSAGE(STATUS "use OpenMP:              ${ENABLE_OPENMP}")
+MESSAGE(STATUS "use OpenCL:              ${ENABLE_OPENCL}")
 MESSAGE(STATUS "use TCmalloc:            ${ENABLE_TCMALLOC}")
+IF(NOT WIN32 AND ENABLE_OPENCL)
+MESSAGE(STATUS "Search path for OpenCL:  ${DEFAULT_OPENCL_PATH}")
+ENDIF()
+IF(ENABLE_OPENCL)
+  IF(PREFER_SEPARATE_OPENCL_SOURCE)
+    MESSAGE(STATUS "OpenCL sources:          Use separate files")
+  ELSE()
+    MESSAGE(STATUS "OpenCL sources:          Use build-in strings")
+  ENDIF()
+ENDIF()
+MESSAGE(STATUS "Metadata transfer:       ${HAVE_EXIV2}")
+MESSAGE(STATUS "Build documentation:     ${DOC}")
 MESSAGE(STATUS "")
 MESSAGE(STATUS "Image Formats Enabled:")
 MESSAGE(STATUS "OpenEXR:                 ${OPENEXR_FOUND}")
diff -r ef8470f9d682 CMakeModules/FindCXX11Compiler.cmake
--- a/CMakeModules/FindCXX11Compiler.cmake	Sun Feb 12 15:25:10 2017 +0100
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,89 +0,0 @@
-# Check if compiler supports C++11 features 
-# and which compiler switches are necessary
-# CXX11_FLAG : contains the necessary compiler flag
-
-#
-# Copyright (c) 2013 Thomas Modes <tmodes@@users.sourceforge.net>
-#
-# This file is part of Enblend.
-#
-#  Redistribution and use in source and binary forms, with or without
-#  modification, are permitted provided that the following conditions
-#  are met:
-#
-#  1. Redistributions of source code must retain the copyright
-#         notice, this list of conditions and the following disclaimer.
-#  2. Redistributions in binary form must reproduce the copyright
-#         notice, this list of conditions and the following disclaimer in the
-#         documentation and/or other materials provided with the distribution.
-#  3. The name of the author may not be used to endorse or promote products
-#         derived from this software without specific prior written permission.
-#
-# This file is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Enblend; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-#
-
-INCLUDE(CheckCXXSourceCompiles)
-INCLUDE(FindPackageHandleStandardArgs)
-
-SET(CXX11_FLAG_CANDIDATES
-  "--std=gnu++11"
-  "--std=c++11"
-  "--std=gnu++0x"
-)
-
-# sample openmp source code to test
-SET(CXX11_TEST_SOURCE 
-"
-template <typename T>
-struct check
-{
-    static_assert(sizeof(int) <= sizeof(T), \"not big enough\");
-};
-
-typedef check<check<bool>> right_angle_brackets;
-
-class TestDeleted
-{
-public:
-    TestDeleted() = delete;
-};
-
-
-int a;
-decltype(a) b;
-
-typedef check<int> check_type;
-check_type c;
-check_type&& cr = static_cast<check_type&&>(c);
-
-auto d = a;
-
-int main() {
-  return 0;
-};
-")
-
-# check c compiler
-FOREACH(FLAG ${CXX11_FLAG_CANDIDATES})
-  SET(SAFE_CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS}")
-  SET(CMAKE_REQUIRED_FLAGS "${FLAG}")
-  UNSET(CXX11_FLAG_DETECTED CACHE)
-  CHECK_CXX_SOURCE_COMPILES("${CXX11_TEST_SOURCE}" CXX11_FLAG_DETECTED)
-  SET(CMAKE_REQUIRED_FLAGS "${SAFE_CMAKE_REQUIRED_FLAGS}")
-  IF(CXX11_FLAG_DETECTED)
-    SET(CXX11_FLAG "${FLAG}")
-    BREAK()
-  ENDIF()
-ENDFOREACH()
-
-# handle the standard arguments for find_package
-FIND_PACKAGE_HANDLE_STANDARD_ARGS(CXX11Compiler DEFAULT_MSG CXX11_FLAG)
-
-MARK_AS_ADVANCED(CXX11_FLAG)
diff -r ef8470f9d682 CMakeModules/FindEXIV2.cmake
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/CMakeModules/FindEXIV2.cmake	Mon Apr 27 19:55:56 2020 -0700
@@ -0,0 +1,150 @@
+# - Try to find the Exiv2 library
+# Once done this will define
+#
+#  EXIV2_FOUND - system has libexiv2
+#  EXIV2_INCLUDE_DIR - the libexiv2 include directory
+#  EXIV2_LIBRARIES - Link these to use libexiv2
+#  EXIV2_DEFINITIONS - Compiler switches required for using libexiv2
+#
+
+if (EXIV2_INCLUDE_DIR AND EXIV2_LIBRARIES)
+
+  # in cache already
+  SET(EXIV2_FOUND TRUE)
+
+else (EXIV2_INCLUDE_DIR AND EXIV2_LIBRARIES)
+  if (NOT WIN32)
+    # use pkg-config to get the directories and then use these values
+    # in the FIND_PATH() and FIND_LIBRARY() calls
+    INCLUDE(UsePkgConfig)
+  
+    PKGCONFIG(exiv2 _EXIV2IncDir _EXIV2LinkDir _EXIV2LinkFlags _EXIV2Cflags)
+
+    if(_EXIV2LinkFlags)
+      # query pkg-config asking for a Exiv2 >= 0.12
+      EXEC_PROGRAM(${PKGCONFIG_EXECUTABLE} ARGS --atleast-version=0.12 exiv2 RETURN_VALUE _return_VALUE OUTPUT_VARIABLE _pkgconfigDevNull )
+      if(_return_VALUE STREQUAL "0")
+        message(STATUS "Found Exiv2 release >= 0.12")
+        set(EXIV2_VERSION_GOOD_FOUND TRUE)
+      else(_return_VALUE STREQUAL "0")
+        message(STATUS "Found Exiv2 release < 0.12")
+      endif(_return_VALUE STREQUAL "0")
+    else(_EXIV2LinkFlags)
+        set(EXIV2_FOUND FALSE)
+        set(EXIV2_VERSION_GOOD_FOUND FALSE)
+        message(STATUS "Cannot find Exiv2 library!")
+    endif(_EXIV2LinkFlags)
+
+  if(EXIV2_VERSION_GOOD_FOUND)
+     set(EXIV2_DEFINITIONS ${_EXIV2Cflags})
+ 
+     FIND_PATH(EXIV2_INCLUDE_DIR exiv2/exif.hpp
+       ${_EXIV2IncDir}
+     )
+  
+     FIND_LIBRARY(EXIV2_LIBRARIES NAMES exiv2 libexiv2
+       PATHS
+       ${_EXIV2LinkDir}
+     )
+  
+     if (EXIV2_INCLUDE_DIR AND EXIV2_LIBRARIES)
+        set(EXIV2_FOUND TRUE)
+     endif (EXIV2_INCLUDE_DIR AND EXIV2_LIBRARIES)
+   endif(EXIV2_VERSION_GOOD_FOUND)
+   if (EXIV2_FOUND)
+      if (NOT EXIV2_FIND_QUIETLY)
+       message(STATUS "Found Exiv2: ${EXIV2_LIBRARIES}")
+      endif (NOT EXIV2_FIND_QUIETLY)
+   else (EXIV2_FOUND)
+     if (EXIV2_FIND_REQUIRED)
+       if (NOT EXIV2_INCLUDE_DIR)
+         message(FATAL_ERROR "Could NOT find Exiv2 header files")
+       endif (NOT EXIV2_INCLUDE_DIR)
+       if (NOT EXIV2_LIBRARIES)
+           message(FATAL_ERROR "Could NOT find Exiv2 library")
+       endif (NOT EXIV2_LIBRARIES)
+     endif (EXIV2_FIND_REQUIRED)
+   endif (EXIV2_FOUND)
+
+  else(NOT WIN32)
+     FIND_PATH(EXIV2_INCLUDE_DIR exiv2/exif.hpp
+               /usr/local/include
+               /usr/include
+               ${SOURCE_BASE_DIR}/exiv2/include
+               ${SOURCE_BASE_DIR}/exiv2/msvc2012/include
+               ${SOURCE_BASE_DIR}/exiv2/msvc/include
+               ${SOURCE_BASE_DIR}/exiv2-0.25/msvc2012/include
+               ${SOURCE_BASE_DIR}/exiv2-0.24/msvc2012/include
+              )
+
+     include(FindLibraryWithDebug)
+
+     find_library_with_debug(EXIV2_LIBRARIES
+        WIN32_DEBUG_POSTFIX d
+        NAMES exiv2s exiv2 libexiv2
+        PATHS ${SYSTEM_LIB_DIRS} 
+              ${SOURCE_BASE_DIR}/exiv2/lib 
+              ${SOURCE_BASE_DIR}/exiv2/msvc2012/lib 
+              ${SOURCE_BASE_DIR}/exiv2/msvc/lib 
+              ${SOURCE_BASE_DIR}/exiv2-0.25/msvc/lib 
+              ${SOURCE_BASE_DIR}/exiv2-0.24/msvc/lib 
+     )
+
+     find_library_with_debug(EXIV2EXPAT_LIBRARIES
+        WIN32_DEBUG_POSTFIX d
+        NAMES libexpat expat wxexpat
+        PATHS ${SYSTEM_LIB_DIRS} 
+              ${SOURCE_BASE_DIR}/expat/lib 
+              ${SOURCE_BASE_DIR}/exiv2/msvc2012/lib 
+              ${SOURCE_BASE_DIR}/exiv2/msvc/lib 
+              ${SOURCE_BASE_DIR}/exiv2-0.25/msvc/lib 
+              ${SOURCE_BASE_DIR}/exiv2-0.24/msvc/lib
+     )
+
+     # since exiv 0.19, xmpsdk needs explicit linked in static build
+     find_library_with_debug(XMP_LIBRARIES
+        WIN32_DEBUG_POSTFIX d
+        NAMES xmpsdk xmp
+        PATHS 
+              ${SOURCE_BASE_DIR}/exiv2/lib
+              ${SOURCE_BASE_DIR}/exiv2/msvc2012/lib
+              ${SOURCE_BASE_DIR}/exiv2-0.25/msvc2012/lib
+              ${SOURCE_BASE_DIR}/exiv2-0.24/msvc2012/lib
+     )
+     IF(XMP_LIBRARIES)
+       SET(EXIV2_LIBRARIES ${EXIV2_LIBRARIES} ${XMP_LIBRARIES})
+     ENDIF(XMP_LIBRARIES)
+
+     SET(EXIV2_LIBRARIES ${EXIV2_LIBRARIES} ${EXIV2EXPAT_LIBRARIES})
+
+     include(FindPackageHandleStandardArgs)
+     find_package_handle_standard_args(EXIV2 DEFAULT_MSG 
+                                       EXIV2_INCLUDE_DIR EXIV2_LIBRARIES)
+
+  endif (NOT WIN32)
+
+  if(EXIV2_FOUND)
+    #check that exiv2 is recent enough
+    INCLUDE(CheckCXXSourceCompiles)
+    SET(EXIV2_TEST_SOURCE
+      "#include <exiv2/exiv2.hpp>
+       int main()
+       {
+          Exiv2::Image::UniquePtr anImage;
+          return 0;
+       };")
+    UNSET(EXIV2_COMPILES_FLAG CACHE)
+    SET(SAFE_CMAKE_REQUIRED_INCLUDES ${CMAKE_REQUIRED_INCLUDES})
+    SET(SAFE_CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES})
+    SET(CMAKE_REQUIRED_INCLUDES ${EXIV2_INCLUDE_DIR})
+    SET(CMAKE_REQUIRED_LIBRARIES ${EXIV2_LIBRARIES})
+    CHECK_CXX_SOURCE_COMPILES("${EXIV2_TEST_SOURCE}" EXIV2_COMPILES_FLAG)
+    SET(CMAKE_REQUIRED_INCLUDES ${SAFE_CMAKE_REQUIRED_INCLUDES})
+    SET(CMAKE_REQUIRED_LIBRARIES ${SAFE_CMAKE_REQUIRED_LIBRARIES})
+    if(NOT EXIV2_COMPILES_FLAG)
+      MESSAGE(FATAL_ERROR "Found exiv2 library, but this library is not recent enough to compile enblend/enfuse.")
+    endif()
+  endif()
+  MARK_AS_ADVANCED(EXIV2_INCLUDE_DIR EXIV2_LIBRARIES)
+
+endif (EXIV2_INCLUDE_DIR AND EXIV2_LIBRARIES)
diff -r ef8470f9d682 CMakeModules/FindJPEG.cmake
--- a/CMakeModules/FindJPEG.cmake	Sun Feb 12 15:25:10 2017 +0100
+++ b/CMakeModules/FindJPEG.cmake	Mon Apr 27 19:55:56 2020 -0700
@@ -24,9 +24,9 @@
   ${SOURCE_BASE_DIR}/jpeg-7
 )
 
-include(FindLibraryForCPU)
+include(FindLibraryWithDebug)
 
-find_library_for_cpu(JPEG_LIBRARIES
+find_library_with_debug(JPEG_LIBRARIES
   WIN32_DEBUG_POSTFIX d
   NAMES jpeg libjpeg
   PATHS 
diff -r ef8470f9d682 CMakeModules/FindLCMS2.cmake
--- a/CMakeModules/FindLCMS2.cmake	Sun Feb 12 15:25:10 2017 +0100
+++ b/CMakeModules/FindLCMS2.cmake	Mon Apr 27 19:55:56 2020 -0700
@@ -26,7 +26,7 @@
     include(FindLibraryWithDebug)
     find_library_with_debug(LCMS2_LIBRARIES
       WIN32_DEBUG_POSTFIX d    
-      NAMES lcms2 lcms2_static
+      NAMES lcms2 lcms2_static lcms
       PATHS ${LCMS2_ROOT_DIR}/Lib/MS
     )
     
diff -r ef8470f9d682 CMakeModules/FindLibraryWithDebug.cmake
--- a/CMakeModules/FindLibraryWithDebug.cmake	Sun Feb 12 15:25:10 2017 +0100
+++ b/CMakeModules/FindLibraryWithDebug.cmake	Mon Apr 27 19:55:56 2020 -0700
@@ -9,81 +9,147 @@
 # Redistribution and use is allowed according to the terms of the BSD license.
 # For details see the accompanying COPYING-CMAKE-SCRIPTS file.
 
-MACRO(FIND_LIBRARY_WITH_DEBUG var_name)
-  IF(NOT WIN32)
-    FIND_LIBRARY(${var_name} ${ARGN})
-  ELSE(NOT WIN32)
-    PARSE_ARGUMENTS(FIND_LIB_WITH_DEBUG "WIN32_DEBUG_POSTFIX;WIN32_DEBUG_PATH_SUFFIX;WIN32_RELEASE_PATH_SUFFIX;NAMES;PATHS" "" ${ARGN})
+MACRO(FIND_LIBRARY_WITH_DEBUG var_name win32_dbg_postfix_name dgb_postfix libname)
+
+  IF((NOT "${win32_dbg_postfix_name}" STREQUAL "WIN32_DEBUG_POSTFIX") AND (NOT VCPKG_TOOLCHAIN))
+
+     # no WIN32_DEBUG_POSTFIX -> simply pass all arguments to FIND_LIBRARY
+     FIND_LIBRARY(${var_name}
+                  ${win32_dbg_postfix_name}
+                  ${dgb_postfix}
+                  ${libname}
+                  ${ARGN}
+     )
+
+  ELSE()
+
+    IF(NOT WIN32)
+      # on non-win32 we don't need to take care about WIN32_DEBUG_POSTFIX
+
+      FIND_LIBRARY(${var_name} ${libname} ${ARGN})
+
+    ELSE(NOT WIN32)
+
+      # 1. get all possible libnames
+      IF(VCPKG_TOOLCHAIN AND (NOT "${win32_dbg_postfix_name}" STREQUAL "WIN32_DEBUG_POSTFIX"))
+        SET(DBG_POSTFIX "d")
+        IF("${win32_dbg_postfix_name}" STREQUAL "NAMES")
+          UNSET(SINGLE_LIBNAME)
+          SET(args ${dgb_postfix})
+          LIST(APPEND args ${libname})
+          LIST(APPEND args ${ARGN})
+        ELSE()
+          SET(SINGLE_LIBNAME "${win32_dbg_postfix_name}")
+          SET(args ${libname})
+          LIST(APPEND args ${ARGN})
+        ENDIF()
+      ELSE()
+        SET(DBG_POSTFIX ${dgb_postfix})
+        IF("${libname}" STREQUAL "NAMES")
+          UNSET(SINGLE_LIBNAME)
+        ELSE()
+          SET(SINGLE_LIBNAME "${libname}")
+        ENDIF()
+        SET(args ${ARGN})
+      ENDIF()
+      SET(newargs "")
+      SET(libnames_release "")
+      SET(libnames_debug "")
+
+      LIST(LENGTH args listCount)
+
+      IF(NOT SINGLE_LIBNAME)
+        SET(append_rest 0)
+        LIST(APPEND args " ")
+
+        FOREACH(i RANGE ${listCount})
+          LIST(GET args ${i} val)
 
-    IF(NOT FIND_LIB_WITH_DEBUG_NAMES)
-      LIST(GET FIND_LIB_WITH_DEBUG_DEFAULT_ARGS 0 FIND_LIB_WITH_DEBUG_NAMES)
-	  LIST(REMOVE_AT FIND_LIB_WITH_DEBUG_DEFAULT_ARGS 0)
-    ENDIF(NOT FIND_LIB_WITH_DEBUG_NAMES)
-  
-    IF(NOT FIND_LIB_WITH_DEBUG_PATHS)
-      LIST(GET FIND_LIB_WITH_DEBUG_DEFAULT_ARGS 0 FIND_LIB_WITH_DEBUG_PATHS)
-    ENDIF(NOT FIND_LIB_WITH_DEBUG_PATHS)
-	
-	IF(NOT FIND_LIB_WITH_DEBUG_WIN32_DEBUG_POSTFIX AND NOT FIND_LIB_WITH_DEBUG_WIN32_DEBUG_PATH_SUFFIX AND NOT FIND_LIB_WITH_DEBUG_WIN32_RELEASE_PATH_SUFFIX)
-	  FIND_LIBRARY(${var_name} NAMES ${FIND_LIB_WITH_DEBUG_NAMES} PATHS ${FIND_LIB_WITH_DEBUG_PATHS})
-	ELSE(NOT FIND_LIB_WITH_DEBUG_WIN32_DEBUG_POSTFIX AND NOT FIND_LIB_WITH_DEBUG_WIN32_DEBUG_PATH_SUFFIX AND NOT FIND_LIB_WITH_DEBUG_WIN32_RELEASE_PATH_SUFFIX)
-	  SET(libpaths_release "")
-	  SET(libpaths_debug "")
-	  
-	  SET(libnames_release "")
-	  SET(libnames_debug "")
-	  
-	  FOREACH(libpath ${FIND_LIB_WITH_DEBUG_PATHS})
-        FOREACH(rel_suffix ${FIND_LIB_WITH_DEBUG_WIN32_RELEASE_PATH_SUFFIX})
-		  LIST(APPEND libpaths_release "${libpath}/${rel_suffix}")
-	    ENDFOREACH(rel_suffix ${FIND_LIB_WITH_DEBUG_WIN32_RELEASE_PATH_SUFFIX})
-		IF(NOT DEFINED ${FIND_LIB_WITH_DEBUG_WIN32_RELEASE_PATH_SUFFIX})
-          LIST(APPEND libpaths_release "${libpath}")
-		ENDIF(NOT DEFINED ${FIND_LIB_WITH_DEBUG_WIN32_RELEASE_PATH_SUFFIX})
+          IF(append_rest)
+            LIST(APPEND newargs ${val})
+          ELSE(append_rest)
+            IF("${val}" STREQUAL "PATHS")
+              # LIST(APPEND newargs ${val})
+              SET(append_rest 1)
+            ELSE("${val}" STREQUAL "PATHS")
+              LIST(APPEND libnames_release "${val}")
+              LIST(APPEND libnames_debug   "${val}${DBG_POSTFIX}")
+              IF(VCPKG_TOOLCHAIN)
+                # in VCPKG the debug library does often not contain a postfix, 
+                # so search also for this variant
+                LIST(APPEND libnames_debug "${val}")
+              ENDIF()
+            ENDIF("${val}" STREQUAL "PATHS")
+          ENDIF(append_rest)
+
+        ENDFOREACH(i)
+
+      ELSE()
 
-		FOREACH(deb_suffix ${FIND_LIB_WITH_DEBUG_WIN32_DEBUG_PATH_SUFFIX})
-		  LIST(APPEND libpaths_debug "${libpath}/${deb_suffix}")
-		ENDFOREACH(deb_suffix ${FIND_LIB_WITH_DEBUG_WIN32_DEBUG_PATH_SUFFIX})
-		IF(NOT DEFINED ${FIND_LIB_WITH_DEBUG_WIN32_DEBUG_PATH_SUFFIX})
-		  LIST(APPEND libpaths_debug "${libpath}")
-		ENDIF(NOT DEFINED ${FIND_LIB_WITH_DEBUG_WIN32_DEBUG_PATH_SUFFIX})
-	  ENDFOREACH(libpath ${FIND_LIB_WITH_DEBUG_PATHS})
-	  
- 	  FOREACH(libname ${FIND_LIB_WITH_DEBUG_NAMES})
-	    LIST(APPEND libnames_release "${libname}")
-		LIST(APPEND libnames_debug "${libname}${FIND_LIB_WITH_DEBUG_WIN32_DEBUG_POSTFIX}")
- 	  ENDFOREACH(libname ${FIND_LIB_WITH_DEBUG_NAMES})
-	  
-      # search the release lib
-      find_library_for_cpu(${var_name}_RELEASE
-                   NAMES ${libnames_release}
-				   PATHS ${libpaths_release}
-      )
+        # just one name
+        LIST(APPEND libnames_release "${SINGLE_LIBNAME}")
+        LIST(APPEND libnames_debug   "${SINGLE_LIBNAME}${DBG_POSTFIX}")
+        IF(VCPKG_TOOLCHAIN)
+          # in VCPKG the debug library does often not contain a postfix, 
+          # so search also for this variant
+          LIST(APPEND libnames_debug "${SINGLE_LIBNAME}")
+        ENDIF()
+
+        SET(newargs ${args})
+
+      ENDIF()
 
-      # search the debug lib
-      find_library_for_cpu(${var_name}_DEBUG
-                   NAMES ${libnames_debug}
-                   PATHS ${libpaths_debug}
-      )
+      # search the release and debug lib
+      IF(VCPKG_TOOLCHAIN)
+        FIND_LIBRARY(${var_name}_RELEASE
+                     NAMES ${libnames_release}
+                     PATHS ${_VCPKG_INSTALLED_DIR}/${VCPKG_TARGET_TRIPLET}/lib
+                     NO_DEFAULT_PATH
+          )
+        FIND_LIBRARY(${var_name}_DEBUG
+                     NAMES ${libnames_debug}
+                     PATHS ${_VCPKG_INSTALLED_DIR}/${VCPKG_TARGET_TRIPLET}/debug/lib
+                     ${newargs}
+                     NO_DEFAULT_PATH
+          )
+      ELSE()
+        FIND_LIBRARY(${var_name}_RELEASE
+                     NAMES ${libnames_release}
+                     ${newargs}
+        )
+        FIND_LIBRARY(${var_name}_DEBUG
+                     NAMES ${libnames_debug}
+                     ${newargs}
+        )
+      ENDIF()
 
       IF(${var_name}_RELEASE AND ${var_name}_DEBUG)
+
         # both libs found
         SET(${var_name} optimized ${${var_name}_RELEASE}
                         debug     ${${var_name}_DEBUG})
+
       ELSE(${var_name}_RELEASE AND ${var_name}_DEBUG)
+
         IF(${var_name}_RELEASE)
+
           # only release found
           SET(${var_name} ${${var_name}_RELEASE})
+
         ELSE(${var_name}_RELEASE)
+
           # only debug (or nothing) found
           SET(${var_name} ${${var_name}_DEBUG})
+
         ENDIF(${var_name}_RELEASE)
+       
       ENDIF(${var_name}_RELEASE AND ${var_name}_DEBUG)
 
       MARK_AS_ADVANCED(${var_name}_RELEASE)
       MARK_AS_ADVANCED(${var_name}_DEBUG)
-	  
-	ENDIF(NOT FIND_LIB_WITH_DEBUG_WIN32_DEBUG_POSTFIX AND NOT FIND_LIB_WITH_DEBUG_WIN32_DEBUG_PATH_SUFFIX AND NOT FIND_LIB_WITH_DEBUG_WIN32_RELEASE_PATH_SUFFIX)
-  ENDIF(NOT WIN32)
-	
+
+    ENDIF(NOT WIN32)
+
+  ENDIF()
+
 ENDMACRO(FIND_LIBRARY_WITH_DEBUG)
diff -r ef8470f9d682 CMakeModules/FindOpenEXR.cmake
--- a/CMakeModules/FindOpenEXR.cmake	Sun Feb 12 15:25:10 2017 +0100
+++ b/CMakeModules/FindOpenEXR.cmake	Mon Apr 27 19:55:56 2020 -0700
@@ -24,18 +24,18 @@
   PKGCONFIG(OpenEXR _OpenEXRIncDir _OpenEXRLinkDir _OpenEXRLinkFlags _OpenEXRCflags)
 ENDIF (NOT WIN32 OR MINGW)
   FIND_PATH(OPENEXR_INCLUDE_DIR ImfRgbaFile.h
-     ${_OpenEXRIncDir}
-     ${_OpenEXRIncDir}/OpenEXR/
-     /usr/include
-     /usr/local/include
-     ${SOURCE_BASE_DIR}/Deploy/include
-     ${SOURCE_BASE_DIR}/Deploy/include/OpenEXR
+     PATH_SUFFIXES OpenEXR
+     PATHS
+       ${_OpenEXRIncDir}
+       /usr/include
+       /usr/local/include
+       ${SOURCE_BASE_DIR}/Deploy/include
   )
   
   include(FindLibraryWithDebug)
   find_library_with_debug(OPENEXR_HALF_LIBRARY 
     WIN32_DEBUG_POSTFIX d
-    NAMES Half
+    NAMES Half-2_3 Half
     PATHS
       ${_OPENEXRLinkDir}
       ${SYSTEM_LIB_DIRS}
@@ -45,7 +45,7 @@
 
   find_library_with_debug(OPENEXR_IEX_LIBRARY
     WIN32_DEBUG_POSTFIX d
-    NAMES Iex-2_2 Iex
+    NAMES Iex-2_3 Iex-2_2 Iex
     PATHS
       ${_OPENEXRLinkDir}
       ${SYSTEM_LIB_DIRS}
@@ -55,7 +55,7 @@
 
   find_library_with_debug(OPENEXR_ILMTHREAD_LIBRARY 
     WIN32_DEBUG_POSTFIX d
-    NAMES IlmThread-2_2 IlmThread
+    NAMES IlmThread-2_3 IlmThread-2_2 IlmThread
     PATHS
       ${_OPENEXRLinkDir}
       ${SYSTEM_LIB_DIRS}
@@ -65,7 +65,7 @@
   
   find_library_with_debug(OPENEXR_IMATH_LIBRARY 
     WIN32_DEBUG_POSTFIX d
-    NAMES Imath-2_2 Imath
+    NAMES Imath-2_3 Imath-2_2 Imath
     PATHS
       ${_OPENEXRLinkDir}
       ${SYSTEM_LIB_DIRS}
@@ -76,7 +76,7 @@
   
   find_library_with_debug(OPENEXR_ILMIMF_LIBRARY 
     WIN32_DEBUG_POSTFIX d
-    NAMES IlmImf-2_2 IlmImf 
+    NAMES IlmImf-2_3 IlmImf-2_2 IlmImf 
     PATHS
       ${_OPENEXRLinkDir}
       ${SYSTEM_LIB_DIRS}
@@ -84,14 +84,20 @@
       ${SOURCE_BASE_DIR}/Deploy/lib/Release
   )
   
-  if (OPENEXR_INCLUDE_DIR AND OPENEXR_IMATH_LIBRARY AND OPENEXR_ILMIMF_LIBRARY AND OPENEXR_IEX_LIBRARY AND OPENEXR_HALF_LIBRARY)
+  include(FindPackageHandleStandardArgs)
+  find_package_handle_standard_args(PNG DEFAULT_MSG 
+                                  PNG_INCLUDE_DIR PNG_LIBRARIES)
+
+  FIND_PACKAGE(ZLIB)
+  
+  if (OPENEXR_INCLUDE_DIR AND OPENEXR_IMATH_LIBRARY AND OPENEXR_ILMIMF_LIBRARY AND OPENEXR_IEX_LIBRARY AND OPENEXR_HALF_LIBRARY AND ZLIB_INCLUDE_DIR AND ZLIB_LIBRARIES)
      set(OPENEXR_FOUND TRUE)
      if (OPENEXR_ILMTHREAD_LIBRARY)
-       set(OPENEXR_LIBRARIES ${OPENEXR_IMATH_LIBRARY} ${OPENEXR_ILMIMF_LIBRARY} ${OPENEXR_IEX_LIBRARY} ${OPENEXR_HALF_LIBRARY} ${OPENEXR_ILMTHREAD_LIBRARY} CACHE STRING "The libraries needed to use OpenEXR")
-     else (OPENEXR_ILMTHREAD_LIBRARY)
-       set(OPENEXR_LIBRARIES ${OPENEXR_IMATH_LIBRARY} ${OPENEXR_ILMIMF_LIBRARY} ${OPENEXR_IEX_LIBRARY} ${OPENEXR_HALF_LIBRARY} CACHE STRING "The libraries needed to use OpenEXR")
-     endif (OPENEXR_ILMTHREAD_LIBRARY)
-  endif (OPENEXR_INCLUDE_DIR AND OPENEXR_IMATH_LIBRARY AND OPENEXR_ILMIMF_LIBRARY AND OPENEXR_IEX_LIBRARY AND OPENEXR_HALF_LIBRARY)
+       set(OPENEXR_LIBRARIES ${OPENEXR_IMATH_LIBRARY} ${OPENEXR_ILMIMF_LIBRARY} ${OPENEXR_IEX_LIBRARY} ${OPENEXR_HALF_LIBRARY} ${OPENEXR_ILMTHREAD_LIBRARY} ${ZLIB_LIBRARIES} CACHE STRING "The libraries needed to use OpenEXR")
+     else ()
+       set(OPENEXR_LIBRARIES ${OPENEXR_IMATH_LIBRARY} ${OPENEXR_ILMIMF_LIBRARY} ${OPENEXR_IEX_LIBRARY} ${OPENEXR_HALF_LIBRARY} ${ZLIB_LIBRARIES} CACHE STRING "The libraries needed to use OpenEXR")
+     endif ()
+  endif ()
   
   
   
diff -r ef8470f9d682 ConfigureChecks.cmake
--- a/ConfigureChecks.cmake	Sun Feb 12 15:25:10 2017 +0100
+++ b/ConfigureChecks.cmake	Mon Apr 27 19:55:56 2020 -0700
@@ -186,52 +186,3 @@
   int main(){char b;char *a = strerror_r(0, &b, 0); return(0);}
   "
   STRERROR_R_CHAR_P)
-
-SET(SAFE_CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS}")
-SET(CMAKE_REQUIRED_FLAGS "${CMAKE_CXX_FLAGS}")
-check_cxx_source_compiles(
-  "
-    #include <string>
-    #include <type_traits>
-    #include <utility>
-    
-    int main()
-    {
-      std::string s(\"foo\");
-      const std::string& const_s = std::as_const(s);
-      return 0;
-    }
-  "  
-  
-  HAVE_AS_CONST
-)
-
-check_cxx_source_compiles(
-  "
-    #include <filesystem>
-    #include <string>
-    
-    int main()
-    {
-      std::tr2::sys::path filepath;
-      std::string s=filepath.filename().string();
-      return 0;    
-    };
-  "
-  HAVE_STD_FILESYSTEM
-)
-
-SET(CMAKE_REQUIRED_FLAGS "${SAFE_CMAKE_REQUIRED_FLAGS}")
-  
-# workaround for older boost versions (<1.55)
-set(CMAKE_REQUIRED_INCLUDES ${Boost_INCLUDE_DIR})
-check_cxx_source_compiles(
-  "
-    #include <boost/config/suffix.hpp>
-    #ifndef BOOST_FALLTHROUGH
-      #error \"BOOST_FALLTHROUGH not defined\"
-    #endif
-    int main(){return(0);}
-    "
-    HAVE_BOOST_FALLTHROUGH
-)
diff -r ef8470f9d682 NEWS
--- a/NEWS	Sun Feb 12 15:25:10 2017 +0100
+++ b/NEWS	Mon Apr 27 19:55:56 2020 -0700
@@ -1,19 +1,57 @@
-* Version 4.2.1
+* Version 4.3
+
+Unreleased.  Current line of development.
+
+** Improvements
+
+- All deprecated options and features of version 4.2 have been
+  removed.
+
+- Enblend and Enfuse transfer EXIF, IPTC, and XMP meta-data from the
+  input images to the output images.
 
-Currently unreleased.
+- Both Enblend and Enfuse can now send their output to files without a
+  filename extension, which included devices, like e.g. "/dev/stdout".
+  The output format is PNM (Portable aNyMap).  The same holds for the
+  output mask file.  The common abbreviation `-' for `/dev/stdout' is
+  understood.
+
+- Enfuse: The default saturation weight has been set to zero.  This
+  makes Enfuse's behavior more predictable.
+
+
+** New Commandline Options
+
+- To circumnavigate the lack of alpha-channel support of some common
+  image formats, add option `--output-mask', to let the user define a
+  mask filename for the output.
+
 
 ** Developer Stuff
 
-- Autoconf: configuration switches `--enable-image-cache' and its
-  opposite were removed.
+- Configuration switches `--enable-image-cache' and its opposite were
+  downgraded to nops.
+
+- The new configuration option "--enable-partially-static-linking"
+  controls whether all libraries are linked in their shared versions
+  (default) or some performance critical libraries are linked in with
+  the static versions.
+
 
-- CMake: Fix setting environment variable `TEXINPUTS' for LaTeX
-  documentation generation.
+** Package Maintainer Stuff
+
+- All Boost dependencies have been scrapped.
+
+- The environment variable SOURCE_DATE_EPOCH overrides the build
+  timestamp as recorded by the signatures.  See
+          https://reproducible-builds.org/specs/source-date-epoch/
+  for details.
+
 
 
 * Version 4.2  "Compressor Road"
 
-Released March 29, 2016.
+Released on March 29, 2016.
 
 ** Improvements
 
@@ -58,6 +96,14 @@
   is now up to the user.  The default still is the Gauss function as
   in all Enfuse versions before.
 
+- Enblend and Enfuse now both can make use of the tremendous computing
+  power in modern graphics cards.  To that end the binaries must be
+  compiled with OpenCL support and the necessary drivers and or
+  libraries must be installed on the host system.
+
+- Enfuse can access the OpenCL compiler to allow for user-defined
+  exposure weighting functions specified in OpenCl (source) files.
+
 
 ** New Commandline Options
 
@@ -98,20 +144,19 @@
   Options `--exposure-mu' and `--exposure-sigma' are scheduled for
   withdrawal in a later version of Enfuse.
 
+- For a long time Enblend has had an option to run the seam-line
+  optimizer on the GPU.  Now, both Enblend and Enfuse sport `--gpu'
+  options to offload computationally intensive tasks to any
+  OpenCL-compatible GPU device.
+
+  On systems with more than one device `--prefer-gpu' selects the
+  desired GPU and `--show-gpu-info' lists the available GPUs.
+
 - Long-time option `-a' got a long-form sibling called
   `--pre-assemble'.  The long form can be negated as
   `--no-pre-assemble', which is the default.
 
 
-** Idle Commandline Options
-
-- The Stable Branch of Enblend/Enfuse does not support any
-  acceleration with GPUs as the current Development Branch does.  For
-  commandline compatibility and easy script migration the options
-  `--gpu', `--prefer-gpu', and `--show-gpu-info' are accepted, but do
-  not have any functionality behind them.
-
-
 ** Developer Stuff
 
 - During configuration the name of Vigra's import-export library can
@@ -328,7 +373,7 @@
   ("--disable-image-cache").  Speedups of up to 30% have been reported
   on the amd64 architecture.
 
-- Enblend and Enfuse accept repsonse files in addition to literal
+- Enblend and Enfuse accept response files in addition to literal
   image files.  Response files contain lists of image filenames or
   names of other response files.
 
@@ -399,7 +444,7 @@
 - All Enfuse options have been converted to Enblend's option naming
   scheme.  This is, camel-casing has been replaced by lowercase plus
   dashes.  The new option name are more systematically constructed,
-  too.  The old options will completely dissapear in the next release,
+  too.  The old options will completely disappear in the next release,
   4.1.
 
                Old Option                New Option
@@ -509,6 +554,7 @@
   to be.  The culprit is Automake; see PR/486.
 
 
+
 * Version 3.2
 
 Released on September 8, 2008.
diff -r ef8470f9d682 README
--- a/README	Sun Feb 12 15:25:10 2017 +0100
+++ b/README	Mon Apr 27 19:55:56 2020 -0700
@@ -1,5 +1,5 @@
 Copyright (C) 2004-2009 Andrew Mihal.
-Copyright (C) 2009-2017 Christoph Spiel.
+Copyright (C) 2009-2019 Christoph Spiel.
 
 This file is part of Enblend.
 
@@ -50,6 +50,38 @@
 Makefiles contain pattern rules.
 
 
+** Hints for the migration to C++17
+
+*** Compiler
+
+Some C++ compilers already default to the C++17 Standard, others may
+have to be put into a conforming mode of operation with, for example,
+    -std=gnu++17
+or
+    -std=c++17
+in CXXFLAGS.
+
+
+*** Little CMS2
+
+Depending on the specific C++ compiler and the particular version of
+the lcms2 library it may or may not be necessary to add
+        -DCMS_NO_REGISTER_KEYWORD
+to CPPFLAGS because in C++17 `register' is a deprecated and reserved
+keyword.
+
+Library lcms2 is a mandatory prerequisite for both Enblend and Enfuse.
+
+
+*** Exiv2
+
+A sufficiently recent Exiv2 library is required because C++17 has
+abandoned std::auto_ptr<>, which older versions of the library heavily
+rely on; newer versions use std::unique_ptr<>.
+
+Library exiv2 is optional (see `--with-exiv2').
+
+
 ** Tarball
 
         ./configure YOUR-OPTIONS-IF-ANY-GO-HERE
@@ -128,6 +160,18 @@
 binaries.
 
 
+** --enable-partially-static-linking=NO/yes
+
+Link against static libraries if they are performance critical for
+Enblend or Enfuse.  Currently, these are the GSL libraries and
+LittleCMS2.  The performance gain is some five percent at the cost of
+only slightly larger binaries.  The configuration option may also be
+interesting if the target system should not require GSL libraries.
+
+If partial static linking is on, configure(1) looks for "libatlas.a"
+and "libcblas.a" to replace "libgslcblas.a" and use an optimized BLAS.
+
+
 ** --enable-openmp=yes/NO
    -DENABLE_OPENMP=ON/off    (CMake)
 
@@ -149,6 +193,28 @@
 on the usage of these variables.
 
 
+** --enable-opencl=YES/no
+
+Enable parallel execution of parts of Enblend and Enfuse with OpenCL
+on machines providing the proper hardware.  See
+        http://www.khronos.org/opencl/
+As Enblend and Enfuse are written in C++ we prefer the C++-header of
+OpenCL, namely "cl.hpp".  This file does not always come
+(pre-)installed, but can be downloaded from the canonical site,
+Khronos OpenCL API Registry
+        http://www.khronos.org/registry/cl/
+
+Currently, we compile and test against OpenCL API version 1.2.  The
+header files associated with the older versions 1.0 and 1.1 are
+flawed; They do not compile with some compilers (e.g. CLang++).
+
+It is advisable to match the API versions of C-headers and the
+C++-header file.  On systems with multiple header hierarchies
+(e.g. /usr/include and /usr/local/include) particular care must be
+taken that the correct headers are used at configuration time and at
+compile time.
+
+
 ** --enable-debug=yes/NO
 
 Compile without optimizations and enable all debug-checking code.  The
@@ -162,6 +228,13 @@
 unsuccessful for GLib implementation (gmodule).
 
 
+** --with-exiv2=CHECK/yes/no
+
+Use Exiv2 library for meta-data transfer of the input images to the
+result.  Without this library Enblend or Enfuse will not copy any EXIF
+meta data.
+
+
 ** --with-tcmalloc=CHECK/yes/no
    -DENABLE_TCMALLOC=OFF/on    (CMake)
 
@@ -449,13 +522,13 @@
 
 From the command line:
 
-    $ sudo port install make lcms boost jpeg tiff libpng OpenEXR mercurial
+    $ sudo port install make lcms jpeg tiff libpng OpenEXR mercurial
 
 Note that Enblend/Enfuse can be build via AutoConf/AutoMake and via
 CMake.  The latter is experimental.  If you want to build via CMake,
 add "cmake" to the previous command line after "mercurial" like this:
 
-    $ sudo port install make lcms boost jpeg tiff libpng OpenEXR mercurial cmake
+    $ sudo port install make lcms jpeg tiff libpng OpenEXR mercurial cmake
 
 
 **** Compile
@@ -534,10 +607,6 @@
 
 Enblend/Enfuse also depend on the following libraries:
 
-- Boost  [1.60 in boost_1_60_0]
-    - Only header files are used by default.
-    - Optionally, Enblend/Enfuse can use the Filesystem Library.
-      However, this library needs to compiled against STLport.
 - Little-CMS2  [2.4 in lcm2-2.4]
 
 
diff -r ef8470f9d682 VERSION
--- a/VERSION	Sun Feb 12 15:25:10 2017 +0100
+++ b/VERSION	Mon Apr 27 19:55:56 2020 -0700
@@ -1,1 +1,1 @@
-4.2.1-f0304648cc0f
+4.3-209eafc9748b
diff -r ef8470f9d682 config.h.cmake
--- a/config.h.cmake	Sun Feb 12 15:25:10 2017 +0100
+++ b/config.h.cmake	Mon Apr 27 19:55:56 2020 -0700
@@ -31,6 +31,12 @@
 /* define to 1 if you have dlfcn.h header file and dl lib. */
 #cmakedefine HAVE_DL 1
 
+/* define to 1 if you have opencl.h header file in "CL" dir. */
+#cmakedefine HAVE_CL_CL_HPP 1
+
+/* define to 1 if you have opencl.h header file in "OpenCL" dir. */
+#cmakedefine HAVE_OPENCL_CL_HPP 1
+
 /* Define to 1 if the system has the type `_Bool'. */
 /* #undef HAVE__BOOL */
 
@@ -71,18 +77,6 @@
 /* Define to 1 if strerror_r returns char *. */
 #cmakedefine STRERROR_R_CHAR_P 1
 
-/* Define to 1 if std::as_const (C++ 17) is available */
-#cmakedefine HAVE_AS_CONST
-
-/* workaround for older boost versions <1.55 */
-#cmakedefine HAVE_BOOST_FALLTHROUGH 1
-#ifndef HAVE_BOOST_FALLTHROUGH
-#define BOOST_FALLTHROUGH ((void) 0)
-#endif
-
-/* Define to if <filesystem> is available */
-#cmakedefine HAVE_STD_FILESYSTEM 1
-
 /* Version number of package */
 #define VERSION "${ENBLEND_VERSION_ONLY}"
 
@@ -102,9 +96,18 @@
   #define size_t unsigned int
 #endif
 
+/* Define to the implicit search path for OpenCL kernels. */
+#define DEFAULT_OPENCL_PATH "${DEFAULT_OPENCL_PATH}"
+
+/* Prefer separate OpenCL kernels or use build-in strings. */
+#cmakedefine PREFER_SEPARATE_OPENCL_SOURCE 1
+
 /* MSVC compiler is using _DEBUG instead of DEBUG, so redefine here */
 #if defined _DEBUG && !defined DEBUG
 #define DEBUG 1
 #endif
 
+/* Defined if exiv2 library is available for metadata transfer */
+#cmakedefine HAVE_EXIV2 1
+
 #endif
\ No newline at end of file
diff -r ef8470f9d682 configure.ac
--- a/configure.ac	Sun Feb 12 15:25:10 2017 +0100
+++ b/configure.ac	Mon Apr 27 19:55:56 2020 -0700
@@ -13,8 +13,7 @@
 AM_SILENT_RULES()
 
 AC_PROG_CXX
-AX_CXX_COMPILE_STDCXX_11(ext)
-AC_CXX_AS_CONST
+AX_CXX_COMPILE_STDCXX_17(ext)
 AC_PROG_CC
 AC_PROG_AR
 AM_PROG_AR
@@ -46,8 +45,8 @@
           AC_MSG_CHECKING([for on-demand dynamic linking])
           save_ldflags="$LDFLAGS"
           LDFLAGS="-Wl,--as-needed -Wl,--no-copy-dt-needed-entries ${LDFLAGS}"
-          AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <string.h>]],
-                                          [[strlen("foo")]])],
+          AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <cstring>]],
+                                          [[std::strlen("foo")]])],
                          [AC_MSG_RESULT(yes);
                           have_on_demand_dynamic_linking=yes],
                          AC_MSG_RESULT(no))
@@ -60,6 +59,15 @@
 
 # Checks for libraries.
 
+STDCXX_FILESYSTEM_LIBRARY='-lstdc++fs'
+AC_MSG_CHECKING([whether we must link with an extra library to get C++17 filesystem support])
+AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <filesystem>]],
+                                [[std::filesystem::path p;
+                                  p.parent_path()]])],
+               [AC_MSG_RESULT(no)],
+               [AC_MSG_RESULT(yes)
+                LIBS="$LIBS $STDCXX_FILESYSTEM_LIBRARY"])
+
 # We check for TCMalloc so early to make it the last user library on
 # the linker command line.  It will then gobble all undefined
 # references to malloc(3) and free(3) and thus relieve the O/S even
@@ -79,12 +87,8 @@
        fi])
 
 AC_CHECK_LIB([m], [sqrt])
-AC_CHECK_LIB([gslcblas], [cblas_dgemm])
-AC_CHECK_LIB([gsl], [gsl_blas_dgemm])
 
-AC_CHECK_LIB(z, gzopen,
-             [],
-             AC_MSG_NOTICE([Compiling without libz.]), [])
+AC_CHECK_LIB(z, gzopen, [], AC_MSG_NOTICE([Compiling without libz.]), [])
 AC_CHECK_LIB(jpeg, jpeg_finish_compress,
              [LIBS="-ljpeg ${LIBS}"; AC_DEFINE(HasJPEG, 1, [Define if you have the jpeg library])],
              AC_MSG_NOTICE([Compiling without support for jpeg files.]), [])
@@ -94,9 +98,6 @@
 AC_CHECK_LIB(tiff, TIFFOpen,
              [LIBS="-ltiff ${LIBS}"; AC_DEFINE(HasTIFF, 1, [Define if you have the tiff library])],
              AC_MSG_ERROR([libtiff is required to compile Enblend.]), [])
-AC_CHECK_LIB(lcms2, cmsCreateTransform,
-             [],
-             AC_MSG_ERROR([liblcms2 is required to compile Enblend.]), [])
 
 AC_MSG_CHECKING([if OpenEXR is wanted])
 AC_ARG_WITH([openexr],
@@ -108,7 +109,6 @@
       [AC_MSG_NOTICE([disabling OpenEXR])
        have_exr=no],
       [if test "$with_openexr" = yes || test "$with_openexr" = check; then
-          AC_MSG_RESULT(yes)
           PKG_CHECK_MODULES(OPENEXR, OpenEXR >= 1.0,
                             [AC_DEFINE(HasEXR, 1, [Define if you have EXR library])
                              have_exr=yes],
@@ -118,7 +118,6 @@
           CFLAGS="${OPENEXR_CFLAGS} $CFLAGS"
           CXXFLAGS="${OPENEXR_CFLAGS} $CXXFLAGS"
        else
-          AC_MSG_RESULT(no)
           have_exr=no
        fi])
 
@@ -134,6 +133,7 @@
                AC_MSG_RESULT(yes),
                [AC_MSG_RESULT(no)
                 AC_MSG_ERROR([libvigraimpex is required to compile Enblend.])])
+AC_MSG_CHECKING([whether Vigra import/export-library is sufficiently recent])
 AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <vigra/imageinfo.hxx>
                                   #include <vigra/impexalpha.hxx>]],
                                 [[vigra::BRGBImage image;
@@ -145,6 +145,79 @@
                [AC_MSG_RESULT(no)
                 AC_MSG_ERROR([Vigra was found, but it was not recent enough.])])
 
+use_exiv2=no
+AC_ARG_WITH([exiv2],
+            [AS_HELP_STRING([--with-exiv2], [use Exiv2 library @<:@default=check@:>@])],
+            [],
+            [with_exiv2=check])
+AS_IF([test "$with_exiv2" = check -o "$with_exiv2" = yes],
+      [AC_MSG_CHECKING([for Exiv2 library])
+       SAVED_LIBS=$LIBS
+       LIBS="$LIBS -lexiv2"
+       AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <exiv2/image.hpp>]],
+                                       [[Exiv2::Image* image {nullptr};
+                                         image->iptcData();]])],
+                      [AC_MSG_RESULT(yes)
+                       use_exiv2=yes
+                       AC_DEFINE(HAVE_EXIV2, 1, [Define if you have the Exiv2 library])],
+                      [AC_MSG_RESULT(no)
+                       LIBS="$SAVED_LIBS"])])
+if test "$use_exiv2" = yes; then
+  AC_MSG_CHECKING([whether Exiv2 library is sufficiently recent])
+  AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <exiv2/image.hpp>]],
+                                  [[Exiv2::Image::UniquePtr p {nullptr}]])],
+                 AC_MSG_RESULT(yes),
+                 [AC_MSG_RESULT(no)
+                  use_exiv2=no
+                  LIBS="$SAVED_LIBS"
+                  if test "$with_exiv2" = check; then
+                    AC_MSG_WARN([Exiv2 was found, but it was not recent enough.])
+                  else
+                    AC_MSG_ERROR([Exiv2 was found, but it was not recent enough.])
+                  fi])
+fi
+
+AC_MSG_CHECKING([for support of partially static linking])
+original_LIBS="${LIBS}"
+LIBS="-Wl,-Bstatic -lm -Wl,-Bdynamic ${LIBS}"
+AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <math.h>]],
+                                [[sin(0.5)]])],
+               [AC_MSG_RESULT(yes);
+                partially_static_linking_support=yes],
+               [AC_MSG_RESULT(no);
+                partially_static_linking_support=no])
+LIBS="${original_LIBS}"
+
+STATIC_LIBS=""
+partially_static_linking=no
+AC_ARG_ENABLE([partially-static-linking],
+              AC_HELP_STRING([--enable-partially-static-linking],
+                             [static link of performance critical libraries @<:@default=no@:>@]),
+              [partially_static_linking=$enableval],
+              [partially_static_linking=no])
+
+if test "$partially_static_linking_support" = yes && test "$partially_static_linking" = yes; then
+  dnl https://www.gnu.org/software/gsl/manual/html_node/Linking-with-an-alternative-BLAS-library.html
+  AC_CHECK_LIB(atlas, ATL_cputime, [], [])
+  AC_CHECK_LIB(cblas, cblas_dgemm, [have_cblas=true], [have_cblas=false], [-latlas])
+  if $have_cblas; then
+    STATIC_LIBS="-lcblas -latlas ${STATIC_LIBS}"
+    AC_CHECK_LIB(gsl, gsl_blas_dgemm, [STATIC_LIBS="-lgsl ${STATIC_LIBS}"], [], [-lcblas -latlas])
+  else
+    AC_CHECK_LIB(gslcblas, cblas_dgemm, [STATIC_LIBS="-lgslcblas ${STATIC_LIBS}"])
+    AC_CHECK_LIB(gsl, gsl_blas_dgemm, [STATIC_LIBS="-lgsl ${STATIC_LIBS}"], [], [-lgslcblas])
+  fi
+
+  AC_CHECK_LIB(lcms2, cmsCreateTransform, [STATIC_LIBS="-llcms2 ${STATIC_LIBS}"])
+  AC_SUBST(STATIC_LIBS, ["-Wl,-Bstatic ${STATIC_LIBS} -Wl,-Bdynamic"])
+else
+  AC_CHECK_LIB(gslcblas, cblas_dgemm)
+  AC_CHECK_LIB(gsl, gsl_blas_dgemm)
+  AC_CHECK_LIB(lcms2, cmsCreateTransform)
+  AC_SUBST(STATIC_LIBS)
+fi
+
+
 # Memory allocation debug support
 AC_MSG_CHECKING([if malloc debugging is wanted])
 AC_ARG_WITH(dmalloc,
@@ -214,7 +287,7 @@
 
 AC_CHECK_HEADERS([fenv.h limits.h stdlib.h string.h unistd.h])
 
-AC_CHECK_HEADER([sys/times.h],
+AC_CHECK_HEADER(sys/times.h,
                 [AC_DEFINE([HAVE_SYS_TIMES_H], [1], [Define if <sys/times.h> exists.])])
 AC_CHECK_HEADER(tiffio.h, [],
                 AC_MSG_ERROR([libtiff-devel header files are required to compile Enblend.]))
@@ -228,12 +301,6 @@
 AC_CHECK_HEADER(vigra/basicimage.hxx, [],
                 AC_MSG_ERROR([Vigra "basicimage.hxx" header file is required to compile Enblend.]))
 
-AX_BOOST_BASE([1.55], [],
-              AC_MSG_ERROR([Boost version 1.55 or later is required to compile Enblend.]))
-
-AC_CHECK_HEADER(boost/optional.hpp, [],
-                AC_MSG_ERROR([Boost "optional" header file is required to compile Enblend.]))
-
 AC_CHECK_HEADER(gsl/gsl_errno.h, [],
                 AC_MSG_ERROR([GNU Scientific Library (GSL) header file "gsl_errno" is required to compile Enblend.]))
 AC_CHECK_HEADER(gsl/gsl_min.h, [],
@@ -287,16 +354,6 @@
 AC_C99_FUNC_LRINT
 AC_C99_FUNC_LRINTF
 
-AC_MSG_CHECKING([for BOOST_FALLTHROUGH])
-AC_PREPROC_IFELSE([AC_LANG_PROGRAM([[#include <boost/config/suffix.hpp>]],
-                                   [[BOOST_FALLTHROUGH]])],
-                  [ac_found=yes; AC_MSG_RESULT([yes])],
-                  [ac_found=no]; AC_MSG_RESULT([no]))
-if test "$ac_found" = no; then
-    AC_DEFINE(BOOST_FALLTHROUGH, [((void) 0)],
-              [Define if Boost is not recent enough to define BOOST_FALLTHROUGH itself])
-fi
-
 AC_PATH_PROG(PERL, perl, false)
 if test "$PERL" = false; then
     AC_MSG_ERROR(cannot find perl)
@@ -485,7 +542,7 @@
 
 
 AC_ARG_VAR(DYNAMIC_TEX_PREAMBLE, [LaTeX commands to add to top of preamble])
-DYNAMIC_TEX_PREAMBLE=\\def\\finishdynamicpreamble{\\relax}
+DYNAMIC_TEX_PREAMBLE=\\def\\finishdynamicpreamble{\\overfullrule=2pt\\relax}
 
 
 AC_MSG_CHECKING(whether to enable debugging)
@@ -525,6 +582,22 @@
     enable_openmp=yes
 fi
 
+built_in_opencl_path=/usr/local/share/enblend/kernels:/usr/share/enblend/kernels
+AC_ARG_WITH([opencl-path],
+            AS_HELP_STRING([--with-opencl-path=<PATH>],
+                           [set to-be-built-in OpenCL search path]),
+            [opencl_path="$withval"],
+            [opencl_path="$built_in_opencl_path"])
+AC_DEFINE_UNQUOTED(DEFAULT_OPENCL_PATH, ["$opencl_path"], [Default search path for OpenCL files])
+AC_DEFINE(PREFER_SEPARATE_OPENCL_SOURCE, 1,
+          [Define if you want to access OpenCL files, not compile-in their string equivalents])
+
+
+AX_OPENCL([C++])
+CFLAGS="$CFLAGS $CL_CFLAGS"
+CXXFLAGS="$CXXFLAGS $CL_CFLAGS"
+LIBS="$LIBS $CL_LIBS"
+
 AC_CONFIG_FILES([doc/Makefile
                  doc/examples/Makefile
                  doc/examples/enfuse/Makefile
@@ -546,6 +619,7 @@
    CXXFLAGS:                       ${CXXFLAGS:-<none required>}
    LDFLAGS:                        ${LDFLAGS:-<none required>}
    LIBS:                           ${LIBS:-<none required>}
+   STATIC_LIBS:                    ${STATIC_LIBS:-<none defined>}
    EXTRA_LIBS (optional):          ${EXTRA_LIBS:-<none selected>}
 
  can build all documentation:      ${can_build_doc}${no_doc_reason}
@@ -556,5 +630,7 @@
    enable dynamic loading          ${enable_dynload} ${dynload_implementation}
    OpenEXR image format            ${have_exr}
    use OpenMP:                     ${enable_openmp}
+   use OpenCL:                     ${enable_opencl} (search path: $opencl_path)
+   use Exiv2:                      ${use_exiv2}
    use TCMalloc:                   ${use_tcmalloc}
 ${warnings}])
diff -r ef8470f9d682 doc/Makefile.am
--- a/doc/Makefile.am	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/Makefile.am	Mon Apr 27 19:55:56 2020 -0700
@@ -15,6 +15,8 @@
 ##    t    displays all *.tex files used
 TEXLOGANALYSER_FLAGS = $(if $(subst cat,,$(TEXLOGANALYSER)),-hrt,)
 
+GREP_LATEX_LOG_FLAGS = --quiet --fixed-strings
+
 MAKEINDEX_FLAGS = $(if $(subst false,,$(AM_V_P)),,-q)
 
 ## Papersize for some converters, usually:
@@ -111,7 +113,7 @@
 
 .PHONY: clean-local
 clean-local:
-	- rm -f *.eps *.png *.pstex *.gp
+	- rm -f *.eps *.png *.pstex
 	- rm -f *.{g,o,p,a}nd *.{g,o,p,a}dx
 	- rm -f *.idx *.ilg *.ind *.lo{a,f,t,x} *.toc
 	- rm -f *.aux *.log *.dvi *.ps *.pdf
@@ -229,8 +231,9 @@
 	@ max_iter=5; \
           iter=2; \
           while [ $$iter -le $$max_iter ] && \
-                $(GREP) '^LaTeX Warning: There were undefined references' $*.log >/dev/null && \
-                $(GREP) '^LaTeX Warning: Label(s) may have changed' $*.log >/dev/null; \
+                $(GREP) $(GREP_LATEX_LOG_FLAGS) \
+                    --regexp='LaTeX Warning: There were undefined references' \
+                    --regexp='LaTeX Warning: Label(s) may have changed' $*.log; \
           do \
             iter=$$((iter + 1)); \
             if $(AM_V_P); then :; else printf '  LATEX    [pass %d] %s\n' $$iter $@; fi; \
diff -r ef8470f9d682 doc/common-advanced-options.tex
--- a/doc/common-advanced-options.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/common-advanced-options.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -7,8 +7,8 @@
   \genidx{options!advanced}%
   Advanced Options\commonpart}
 
-Advanced options control e.g.\ the channel depth, color model, and the cropping of the output
-image.
+Advanced options control for example the channel depth, color model, and the cropping of the
+output image.
 
 \begin{codelist}
   \label{opt:blend-colorspace}%
@@ -19,7 +19,7 @@
 \item[--blend-colorspace=\metavar{COLORSPACE}]\itemend
   Force blending in selected \metavar{COLORSPACE}.  Given well matched images this option should
   not change the output image much.  However, if \App{} must blend vastly different colors (as
-  e.g.\ anti-colors) the resulting image heavily depends on the \metavar{COLORSPACE}.
+  for example anti-colors) the resulting image heavily depends on the \metavar{COLORSPACE}.
 
   Usually, \App{} chooses defaults depending on the input images:
 
@@ -86,13 +86,6 @@
   \fi
 
 
-  \label{opt-ciecam}%
-  \optidx{--ciecam}%
-  \shoptidx{-c}{--ciecam}%
-\item[\itempar{-c \\ --ciecam}]\itemend
-  Deprecated.  Use \sample{--blend-colorspace=ciecam} instead.  To emulate the negated
-  option~\option{--no-ciecam}\optidx{--no-ciecam} use \code{--blend-colorspace=identity}.
-
   \label{opt:depth}%
   \optidx[\defininglocation]{--depth}%
   \shoptidx{-d}{--depth}%
@@ -230,16 +223,53 @@
   \gensee{associated alpha channel}{alpha channel, associated}%
   \gensee{unassociated alpha channel}{alpha channel, associated}%
 \item[-g]
-  Save alpha channel as ``associated''. See the
+  Save alpha channel as ``associated''.  See the
   \uref{\awaresystemsbeextrasamples}{\acronym{TIFF} documentation} for an explanation.
 
   \appidx{Gimp}%
   \appidx{Cinepaint}%
   \application{The Gimp} before version~2.0 and \application{CinePaint} (see
-  \appendixName~\fullref{sec:helpful-programs}) exhibit unusual behavior when loading images
-  with unassociated alpha channels.  Use option~\option{-g} to work around this problem.  With
-  this flag \App{} will create the output image with the ``associated alpha tag'' set, even
-  though the image is really unassociated alpha.
+  \appendixName~\fullref{sec:helpful-programs}) exhibit problems when loading images with
+  unassociated alpha channels.  Use option~\option{-g} to work around.  With this flag \App{}
+  will create the output image with the ``associated alpha tag'' set, even though the image is
+  really unassociated alpha.
+
+
+  \label{opt:output-mask}%
+  \optidx[\defininglocation]{--output-mask}%
+  \genidx{mask!output}%
+  \gensee{output mask}{mask, output}%
+\item[--output-mask\optional{=\metavar{FILE}}]\itemend
+  Write the mask of the output to \metavar{FILE}.  The output mask always is a single-channel,
+  1~bit deep image, just as the alpha channel to be represented.  If the option
+  argument~\metavar{FILE} is omitted, \App{} writes the resulting mask to
+  \filename{\val{val:default-output-mask-filename}}.
+
+  The option can become important if the output-file format does not support an alpha channel
+  and nevertheless the final mask is desired after \appisdoing.
+
+  The output file itself always remains unaffected of this option.  In particular it gets its
+  alpha channel, this is its mask, whenever the output-file format supports one.  To mimic
+  option~\option{--output-mask} with such formats, use for example
+
+  \begin{literal}
+    convert \val*{val:default-output-filename} -alpha extract \val*{val:default-output-mask-filename}
+  \end{literal}
+
+  For \metavar{FILE}s with an unknown extension or without an extension, the type of
+  \metavar{FILE} defaults to \code{\val{val:default-fallback-output-mask-file-type}}.
+
+  Examples:
+
+  \begin{literal}
+    \# PPM only supports RGB, not RGBA; write \val*{val:default-output-mask-filename} \\
+    \app{} --output-mask --output=a.ppm ?.tif \\
+    \# Request separate mask as TIFF file \\
+    \app{} --output-mask=mask.tif image-??.tif
+  \end{literal}
+
+  See also option~\flexipageref{\option{--output}}{opt:output}, which controls the name of the
+  output file and \sectionName~\fullref{sec:helpful-libraries} for the \acronym{NetPBM}~library.
 
 
   \label{opt:wrap}%
diff -r ef8470f9d682 doc/common-bug-reports.tex
--- a/doc/common-bug-reports.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/common-bug-reports.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -23,6 +23,9 @@
 In order for a bug report to serve its purpose, you must include the information that makes it
 possible to fix the bug.
 
+\propername{Eric Steven~Raymond} and \propername{Rick Moen} have collected some extensive wisdom
+on \uref{\smartquestions}{How To Ask Questions The Smart Way}.
+
 
 \section[Found a Bug?]{\label{sec:have-you-really-found-a-bug}%
   \genidx{bug!reports!identification of bugs}%
diff -r ef8470f9d682 doc/common-color-spaces.tex
--- a/doc/common-color-spaces.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/common-color-spaces.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -64,7 +64,7 @@
   L = t L_1 + (1 - t) L_2 \quad \mbox{with} \quad 0 \leq t \leq 1,
 \end{equation}
 where the luminances~$L_i, i = 1, 2,$ range from zero to their data-type dependent maximum
-value~$L_{\mathrm{max}}$, thereby defining a ``luminance interval''. We can always map this
+value~$L_{\mathrm{max}}$, thereby defining a ``luminance interval''.  We can always map this
 interval to $(0, 1)$ by dividing the luminances by the maximum, which is why we call the latter
 \emph{``normalized luminance interval''}:
 \begin{equation}\label{equ:luminance-normalization}
@@ -169,7 +169,7 @@
 \end{equation}
 
 \noindent which is undone by the inverse transform after blending.  Here, $\log(x)$ with a
-lower-case initial denotes the natural logarithmic function (i.e.\ to base~$e$).
+lowercase initial denotes the natural logarithmic function this is to base~$e$.
 \figureName~\ref{fig:log-transform} shows the forward transform in the range from $-20$ to~100.
 Around $L = 0$ function~$\mbox{Log}(L)$ has the series expansion
 \[
@@ -190,7 +190,7 @@
 
 \begin{itemize}
 \item
-  During blending, even completely non-negative images can result in negative pixels.  A
+  During blending, even completely nonnegative images can result in negative pixels.  A
   \LogTransform-transform followed by the inverse guarantees all-positive output.
 
 \item
@@ -246,7 +246,7 @@
 \gensee{sRGB@\acronym{sRGB} color cube}{color cube, \acronym{sRGB}}%
 In Case~\ref{enum:no-profile}.\ the applications blend grayscale images in the normalized
 luminance interval and color images inside the \acronym{sRGB}-cube.  To override the default
-\acronym{sRGB}-profile select the desired profile with
+\acronym{sRGB}~profile select the desired profile with
 option~\flexipageref{\option{--fallback\hyp profile}}{opt:fallback-profile}.
 
 In Case~\ref{enum:same-profile}.\ the images first are by default transformed to
@@ -269,9 +269,10 @@
   Blending Color Spaces}
 
 \App{} and \OtherApp{} offer to work inside the \acronym{RGB}-cube~\eqnref{equ:rgb-cube} or in
-several perceptually uniform color spaces.  To override the default select a particular blending
-color space with option~\flexipageref{\option{--blend-colorspace}}{opt:blend-colorspace}.  Here
-are the four available color spaces.
+several perceptually (more or less) uniform color spaces.  To override the default select a
+particular blending color space with
+option~\flexipageref{\option{--blend-colorspace}}{opt:blend-colorspace}.  There are the four
+available color spaces.
 
 \begin{description}
   \genidx{color cube!\acronym{RGB}}%
@@ -281,11 +282,11 @@
   for grayscale images and inside the \acronym{RGB}-color cube as given in
   \eqnref{equ:trivial-rgb-blend}.
 
-  This is the fastest color space to do computations within, i.e.\ it consumes by far the least
-  computing power, because no transform to or from any of the perceptually uniform color spaces
-  is done.  Moreover, this blend-colorspace exhibits no color artifacts even in high contrast
-  scenes, which is good when fusing.  However, it may come up with out-of-whack blended colors,
-  which is bad when blending.
+  This is the fastest color space to do computations within, this is it consumes by far the
+  least computing power, because no transform to or from any of the perceptually uniform color
+  spaces is done.  Moreover, this blend-colorspace exhibits no color artifacts even in high
+  contrast scenes, which is good when fusing.  However, it may come up with out-of-whack blended
+  colors, which is undesirable when blending.
 
   \genidx{colorspace!\acronym{L*a*b*}}%
   \gensee{L*a*b*@\acronym{L*a*b*} colorspace}{colorspace, \acronym{L*a*b*}}%
@@ -297,17 +298,17 @@
   all perceivable colors.  It is completely independent of any device characteristics,
   approximates human vision, and is perceptually uniform.
 
-  \App{} uses perceptual rendering intent and either the input profile's white-point or, if the
-  \acronym{ICC}-profile lacks the \code{cms\shyp Sig\shyp
-    Media\shyp White\shyp Point\shyp Tag}, fall back to the
-  \acronym{D50} white-point (see, e.g.\ \uref{\wikipediastandardilluminant}{Standard
-    illuminant}).
+  \App{} uses perceptual rendering intent throughout and either the input profile's white-point
+  or, if the \acronym{ICC} profile lacks the \code{cms\shyp Sig\shyp Media\shyp White\shyp
+    Point\shyp Tag}, falls back to the \acronym{D50} white-point (see for example
+  \uref{\wikipediastandardilluminant}{Standard illuminant}).
 
   The conversions from and to \acronym{L*a*b*} are moderately fast to compute; \acronym{L*a*b*}
   mode is two to three times slower than working within the \acronym{RGB}-color cube.  It
   operates the \acronym{LittleCMS} color-space conversion engine in
   \uref{\littlecmscomunboundedcmm}{unbounded} mode which rarely causes color artifacts to show
-  up in the shadows in extreme contrast images.
+  up in the shadows in extreme contrast images.  Prefer linear gamma encoded images to avoid
+  this kind of artifacts.
 
   \genidx{colorspace!\acronym{CIEL*u*v*}}%
   \gensee{CIEL*u*v*@\acronym{CIEL*u*v*} colorspace}{colorspace, \acronym{CIEL*u*v*}}%
@@ -323,7 +324,8 @@
   The conversions from and to \acronym{L*u*v*} are almost as fast to compute as
   \acronym{L*a*b*}.  It operates the \acronym{LittleCMS} color-space conversion engine in
   \uref{\littlecmscomunboundedcmm}{unbounded} mode which sometimes causes color artifacts to
-  show up in the shadows in strong contrast images.
+  show up in the shadows in strong contrast images.  Prefer linear gamma encoded images to avoid
+  this kind of artifacts.
 
   \genidx{colorspace!\acronym{CIECAM02}}%
   \gensee{CIECAM02@\acronym{CIECAM02} colorspace}{colorspace, \acronym{CIECAM02}}%
@@ -341,9 +343,9 @@
   \end{geeknote}
 
   The transformations to \acronym{CIECAM02} color space and back use perceptual rendering
-  intent, the \acronym{D50} white point (see, e.g.\ \uref{\wikipediastandardilluminant}{Standard
-    illuminant}), 500\dmn{lumen} surrounding light (``average'' in \acronym{CIECAM02} parlance),
-  and assume complete adaption.
+  intent, the \acronym{D50} white point (see for example
+  \uref{\wikipediastandardilluminant}{Standard illuminant}), 500\dmn{lumen} surrounding light
+  (``average'' in \acronym{CIECAM02} parlance), and assume complete adaption.
 
   Both \acronym{CIELUV} and \acronym{CIELAB} only model the color information generated for
   small and isolated color samples.  They cannot model the contextual effects of color
@@ -355,7 +357,7 @@
   appreciable number of pixels need additional refinement steps the speed of the transformation
   further drops.  Expect \acronym{CIECAM02} mode to be 8--800 times slower than blending within
   the \acronym{RGB}-color cube.  It operates the \acronym{LittleCMS} color-space conversion
-  engine in \uref{\littlecmscomunboundedcmm}{unbounded} mode, however it tries very hard to
+  engine in \uref{\littlecmscomunboundedcmm}{unbounded} mode.  However, it tries very hard to
   recover the visually best-matching color for each pixel thus gone rogue.
 \end{description}
 
@@ -419,7 +421,7 @@
 \fi% enfuse
 
   \item
-    Prefer linear (i.e.\ $\mathrm{gamma} = 1$) color profiles in the input images, when the
+    Prefer linear, this is $\mathrm{gamma} = 1$, color profiles in the input images, when the
     contrast of the scene is high.  To avoid banding it is advisable to use at that least
     16~bits per color channel with linear color profiles.
 
diff -r ef8470f9d682 doc/common-common-options.tex
--- a/doc/common-common-options.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/common-common-options.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -80,33 +80,32 @@
   \item[Any other format.]\itemend
     Other formats do not accept a \metavar{COMPRESSION} setting.  However, the underlying
     \uref{\hciiwrvigra}{\acronym{VIGRA}} library automatically compresses \filename{png}-files
-    with the \propername{Deflate} method.  (\acronym{VIGRA} is the image manipulation library
+    with the \propername{Deflate} algorithm.  (\acronym{VIGRA} is the image manipulation library
     upon which \App{} is based.)
   \end{description}
 
 
-%% -- Commented out for Stable Branch 4.2
-%%   \label{opt:gpu}%
-%%   \optidx[\defininglocation]{--gpu}%
-%%   \genidx{graphics processing unit}%
-%%   \gensee{GPU@\acronym{GPU}}{graphics processing unit}%
-%%   \genidx{central processing unit}%
-%%   \gensee{CPU@\acronym{CPU}}{central processing unit}%
-%%   \genidx{OpenCL@\acronym{OpenCL}}%
-%% \item[--gpu \restrictednote{\acronym{OpenCL}-enabled versions
-%%     only.}]\itemend
-%%   Employ one of the graphics processing units (\acronym{GPU}s) to perform computing instead of
-%%   the central processing units (\acronym{CPU}s) alone.  \App{} must have been compiled with
-%%   support for \acronym{OpenCL} access to the \acronym{GPU} for this feature.
-%%
-%%   Depending on the input images, the options passed to \App{}, and the relative performance of
-%%   the \acronym{CPU}s to the \acronym{GPU}s this option may or may not increase performance.
-%%
-%%   This option enables \acronym{GPU} processing on the selected \acronym{GPU}s.  To choose a
-%%   particular \acronym{GPU} or override \App's default choice use
-%%   option~\flexipageref{\option{--pre\shyp fer\hyp gpu}}{opt:prefer-gpu}.
-%%
-%%   Negate this option with \sample{--no-gpu}\optidx[\defininglocation]{--no-gpu}.
+  \label{opt:gpu}%
+  \optidx[\defininglocation]{--gpu}%
+  \genidx{graphics processing unit}%
+  \gensee{GPU@\acronym{GPU}}{graphics processing unit}%
+  \genidx{central processing unit}%
+  \gensee{CPU@\acronym{CPU}}{central processing unit}%
+  \genidx{OpenCL@\acronym{OpenCL}}%
+\item[--gpu \restrictednote{\acronym{OpenCL}-enabled versions
+    only.}]\itemend
+  Employ one of the graphics processing units (\acronym{GPU}s) to perform computing instead of
+  the central processing units (\acronym{CPU}s) alone.  \App{} must have been compiled with
+  support for \acronym{OpenCL} access to the \acronym{GPU} for this feature.
+
+  Depending on the input images, the options passed to \App{}, and the relative performance of
+  the \acronym{CPU}s to the \acronym{GPU}s this option may or may not increase performance.
+
+  This option enables \acronym{GPU} processing on the selected \acronym{GPU}s.  To choose a
+  particular \acronym{GPU} or override \App's default choice use
+  option~\flexipageref{\option{--pre\shyp fer\hyp gpu}}{opt:prefer-gpu}.
+
+  Negate this option with \sample{--no-gpu}\optidx[\defininglocation]{--no-gpu}.
 
 
   \label{opt:levels}%
@@ -170,6 +169,38 @@
   Place \appdid{} output image in \metavar{FILE}.  If \sample{--output} is omitted, \App{}
   writes the resulting image to \filename{\val{val:default-output-filename}}.
 
+  For \metavar{FILE}s with an unknown extension or without one, the type of \metavar{FILE}
+  defaults to \code{\val{val:default-fallback-output-file-type}}.  This allows for the output
+  image to be redirected or piped.
+
+  \begin{geeknote}
+    \App{} refrains from utilizing the \acronym{TIFF} as fallback output file type, because some
+    of the libraries which implement \acronym{TIFF} ``seek'' the output image file.
+    Technically, this means they call fseek(3) or related functions, which would preclude, for
+    example, \filename{/dev/stdout} to be used as \metavar{FILE}.
+
+    The \uref{\hciiwrvigra}{\acronym{VIGRA}} implementation of
+    \val{val:default-fallback-output-file-type} does not seek.  Moreover, it is completely
+    implemented inside of \acronym{VIGRA}, without referring to another library.  The format
+    supports 8, 16, and 32~bits per channel, grayscale and color images.  The lack of alpha
+    channels can easily be compensated by adding
+    option~\flexipageref{\option{--output-mask}}{opt:output-mask} to the \appcmd{}~command line.
+  \end{geeknote}
+
+  Examples:
+  \begin{literal}
+    \# redirect \\
+    \app{} -o~- [0-9].tif > a.\val*{val:default-fallback-output-file-type} \\
+    \# pipe \\
+    \app{} --output=/dev/stdout image-??.tif | \bslash \\
+    ~~~~convert \val*{val:default-fallback-output-file-type}:-
+    -bordercolor~teal -border~10x10
+    \val*{val:default-output-filename}
+  \end{literal}
+
+  See also option~\flexipageref{\option{--output-mask}}{opt:output-mask}, which controls the
+  generation of a separate output-mask file.
+
 
   \label{opt:verbose}%
   \optidx[\defininglocation]{--verbose}%
@@ -180,7 +211,7 @@
   Without an argument, increase the verbosity of progress reporting.  Giving more
   \option{--verbose}~options will make \App{} more verbose; see
   \sectionName~\fullref{sec:finding-out-details} for an exemplary output.  Directly set a
-  verbosity level with a non-negative integral~\metavar{LEVEL}.
+  verbosity level with a nonnegative integral~\metavar{LEVEL}.
   \tableName~\ref{tab:verbosity-levels} shows the messages available at a particular
   \metavar{LEVEL}.
 
diff -r ef8470f9d682 doc/common-expert-options.tex
--- a/doc/common-expert-options.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/common-expert-options.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -32,7 +32,7 @@
   \genidx{RGB-cube@\acronym{RGB}-cube}%
 \item[--fallback-profile=\metavar{PROFILE-FILENAME}]\itemend
   Use the \acronym{ICC} profile in \metavar{PROFILE-FILENAME} instead of the default
-  \acronym{sRGB}. This option only is effective if the input images come \emph{without} color
+  \acronym{sRGB}.  This option only is effective if the input images come \emph{without} color
   profiles \emph{and} blending is not performed in the trivial luminance interval or
   \acronym{RGB}-cube.
 
@@ -126,7 +126,7 @@
   \sample{--no-parameter}, which takes one or more \metavar{KEY}s and removes them from the list
   of defined parameters.  The special key~\sample{*} deletes all parameters at once.
 
-  Parameters allow the developers to change the internal workings of \App{} without the need to
+  Parameters enable the developers to change the internal workings of \App{} without the need to
   recompile or relink.
 
 \begin{sgquote}
@@ -150,7 +150,7 @@
   \item[\itempar{-a \\ --pre-assemble}]\itemend
     Pre-assemble non-overlapping images before each blending iteration.
 
-    This overrides the default behavior which is to blend the images sequentially in the order
+    This overrides the default procedure, which is to blend the images sequentially in the order
     given on the command line.  \App{} will use fewer blending iterations, but it will do more
     work in each iteration.
 
@@ -159,35 +159,33 @@
 \fi
 
 
-%% -- Commented out for Stable Branch 4.2
-%%   \label{opt:prefer-gpu}%
-%%   \optidx[\defininglocation]{--prefer-gpu}%
-%%   \genidx{OpenCL}%
-%%   \genidx{OpenCL!device}%
-%%   \genidx{OpenCL!platform}%
-%% \item[--prefer-gpu=\optional{\metavar{PLATFORM}:}\metavar{DEVICE}
-%%   \restrictednote{\acronym{OpenCL}-enabled versions only.}]\itemend
-%%   Direct \App{} towards a particular \acronym{OpenCL} \metavar{DEVICE} on the first
-%%   auto-detected \metavar{PLATFORM} or directly to the given \metavar{PLAT\shyp
-%%     FORM}\slash\metavar{DE\shyp VICE} combination.  Use the numbers of platform and
-%%   device found either with
-%%
-%%   \begin{terminal}
-%%     \$ \app{} --verbose --version
-%%   \end{terminal}
-%%   or
-%%   \begin{terminal}
-%%     \$ \app{} --show-gpu-info
-%%   \end{terminal}
-%%
-%%   Note that this option only selects \acronym{GPU}-devices; it does not \emph{activate} any, use
-%%   option~\flexipageref{\option{--gpu}}{opt:gpu} for that.
-%%
-%%   When told to employ the \acronym{GPU} with \sample{--gpu}, by default \App{} uses the first
-%%   device on the first auto-detected platform it finds via queries of the \acronym{OpenCL}
-%%   subsystem, where neither the device, nor the platform may be the ones the user wants.  Usually
-%%   she will select the device with the highest performance, maximum possible number of
-%%   work-items, and largest associated memory.
+  \label{opt:prefer-gpu}%
+  \optidx[\defininglocation]{--prefer-gpu}%
+  \genidx{OpenCL}%
+  \genidx{OpenCL!device}%
+  \genidx{OpenCL!platform}%
+\item[--prefer-gpu=\optional{\metavar{PLATFORM}:}\metavar{DEVICE}
+  \restrictednote{\acronym{OpenCL}-enabled versions only.}]\itemend
+  Direct \App{} toward a particular \acronym{OpenCL} \metavar{DEVICE} on the first auto-detected
+  \metavar{PLATFORM} or directly to the given \metavar{PLAT\shyp FORM}\slash\metavar{DE\shyp
+    VICE} combination.  Use the numbers of platform and device found either with
+
+  \begin{terminal}
+    \$ \app{} --verbose --version
+  \end{terminal}
+  or
+  \begin{terminal}
+    \$ \app{} --show-gpu-info
+  \end{terminal}
+
+  Note that this option only selects \acronym{GPU}-devices; it does not \emph{activate} any, use
+  option~\flexipageref{\option{--gpu}}{opt:gpu} for that.
+
+  When told to employ the \acronym{GPU} with \sample{--gpu}, by default \App{} uses the first
+  device on the first auto-detected platform it finds via queries of the \acronym{OpenCL}
+  subsystem, where neither the device, nor the platform may be the ones the user wants.  Usually
+  she will select the device with the highest performance, maximum possible number of
+  work-items, and largest associated memory.
 
 
 \ifenblend
diff -r ef8470f9d682 doc/common-helpful-programs.tex
--- a/doc/common-helpful-programs.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/common-helpful-programs.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -175,20 +175,51 @@
 
   The nifty \command{tiffinfo} command in the LibTIFF distribution quickly inquires the most
   important properties of \acronym{TIFF} files.
+
+  \label{lib:netpbm}%
+  \genidx{Netpbm@\acronym{Netpbm}}%
+  \genidx{PBM@\acronym{PBM}}%
+  \genidx{PGM@\acronym{PGM}}%
+  \genidx{PNM@\acronym{PNM}}%
+  \genidx{PPM@\acronym{PPM}}%
+\item
+  \uref{\netpbm}{Netpbm} is a toolkit for manipulation of images, including conversion of images
+  between a variety of different formats.  There are plenty of tools in the package including
+  converters for about 100~graphics formats.
+
+  The library and the tools handle
+
+  \begin{compactitemize}
+  \item
+    The portable pixmap format (\acronym{PPM}) for \acronym{RGB}-color images.
+  \item
+    The portable graymap format (\acronym{PGM}) for grayscale images.
+  \item
+    The portable bitmap format (\acronym{PBM}) for black-and-white (1~bit depth) images.
+  \end{compactitemize}
+
+  They are also referred to collectively as the portable anymap format (\acronym{PNM}).
 \end{itemize}
 
 
-\section[Meta-Data Handling]{\label{sec:meta-data-handling}%
-  \genidx{helpful programs!meta-data handling}%
-  Meta-Data Handling}
+\section[Metadata Handling]{\label{sec:metadata-handling}%
+  \genidx{helpful programs!metadata handling}%
+  Metadata Handling}
 
 \begin{itemize}
   \label{app:exiftool}%
   \prgidx{exiftool}%
   \genidx{EXIF@\acronym{EXIF}}%
 \item
-  \uref{\snophyqueensucaexiftool}{EXIFTool} reads and writes \acronym{EXIF} meta-data.  In
-  particular it copies meta-data from one image to another.
+  \uref{\snophyqueensucaexiftool}{EXIFTool} reads and writes \acronym{EXIF} metadata.  In
+  particular it copies metadata from one image to another.
+
+  \label{app:exivii}%
+  \prgidx{exiv2 \textrm{(LibExiv2)}}%
+  \genidx{exiv2}%
+\item
+  The \uref{\exiviiorg}{Exiv2}~package comes with \prgidx{exiv2}, a tool to manipulate
+  \acronym{EXIF}, \acronym{IPTC}, and \acronym{XMP} image metadata and image comments.
 
   \label{app:littlecms}%
   \appidx{LittleCMS}%
diff -r ef8470f9d682 doc/common-information-options.tex
--- a/doc/common-information-options.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/common-information-options.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -28,62 +28,61 @@
   different globbing algorithms.  See \sectionName~\fullref{sec:globbing-algorithms}.
 
 
-%% -- Commented out for Stable Branch 4.2
-%%   \label{opt:show-gpu-info}%
-%%   \optidx[\defininglocation]{--show-gpu-info}%
-%%   \genidx{GPU@\acronym{GPU}}%
-%%   \genidx{OpenCL@\acronym{OpenCL}}%
-%%   \genidx{GPU@\acronym{GPU}!information on}%
-%%   \gensee{information!on \acronym{GPU}}{\acronym{GPU}, information}%
-%%   \genidx{OpenCL@\acronym{OpenCL}!information on configuration}%
-%%   \gensee{information!on \acronym{OpenCL} configuration}{\acronym{OpenCL}, information}%
-%% \item[--show-gpu-info \restrictednote{\acronym{OpenCL}-enabled versions only.}]\itemend
-%%   Print a list of all available \acronym{GPU}~devices under \acronym{OpenCL}~control on all
-%%   accessible platforms, the current preferences, and then exit; it is the same enumeration that
-%%   \begin{literal}
-%%     \app{} --verbose --version
-%%   \end{literal}
-%%   reveals.  \exampleName~\ref{ex:opencl-config} shows a complete output.
-%%
-%%   \begin{exemplar}
-%%     \begin{maxipage}
-%%       \begin{terminal}
-%%         \$ \app{} --show-gpu-info \\
-%%         Available, OpenCL-compatible platform(s) and their device(s) \\
-%%         ~~- Platform \#1:~Advanced Micro Devices, Inc., \\
-%%         ~~~~~~~~~~~~~~~~~AMD Accelerated Parallel Processing, \\
-%%         ~~~~~~~~~~~~~~~~~OpenCL 1.2 AMD-APP (1526.3) \\
-%%         ~~~~* no GPU devices found on this platform \\
-%%         ~~- Platform \#2:~NVIDIA Corporation, \\
-%%         ~~~~~~~~~~~~~~~~~NVIDIA CUDA, \\
-%%         ~~~~~~~~~~~~~~~~~OpenCL 1.1 CUDA 6.5.51 \\
-%%         ~~~~* Device \#1:~max.~1024 work-items \\
-%%         ~~~~~~~~~~~~~~~~~1047872 KB global memory with 32 KB read/write cache \\
-%%         ~~~~~~~~~~~~~~~~~48 KB dedicated local memory \\
-%%         ~~~~~~~~~~~~~~~~~64 KB maximum constant memory \\
-%%         ~~~~~~~~~~~~~~~~~Extensions: \\
-%%         ~~~~~~~~~~~~~~~~~~~~~cl\_khr\_byte\_addressable\_store \\
-%%         ~~~~~~~~~~~~~~~~~~~~~cl\_khr\_fp64 \\
-%%         ~~~~~~~~~~~~~~~~~~~~~cl\_khr\_gl\_sharing \\
-%%         ~~~~~~~~~~~~~~~~~~~~~cl\_khr\_global\_int32\_base\_atomics \\
-%%         ~~~~~~~~~~~~~~~~~~~~~cl\_khr\_global\_int32\_extended\_atomics \\
-%%         ~~~~~~~~~~~~~~~~~~~~~cl\_khr\_icd \\
-%%         ~~~~~~~~~~~~~~~~~~~~~cl\_khr\_local\_int32\_base\_atomics \\
-%%         ~~~~~~~~~~~~~~~~~~~~~cl\_khr\_local\_int32\_extended\_atomics \\
-%%         ~~~~~~~~~~~~~~~~~~~~~cl\_nv\_compiler\_options \\
-%%         ~~~~~~~~~~~~~~~~~~~~~cl\_nv\_copy\_opts \\
-%%         ~~~~~~~~~~~~~~~~~~~~~cl\_nv\_device\_attribute\_query \\
-%%         ~~~~~~~~~~~~~~~~~~~~~cl\_nv\_pragma\_unroll \\
-%%         ~~Search path (expanding ENBLEND\_OPENCL\_PATH and appending built-in path) \\
-%%         ~~~~/usr/local/share/enblend/kernels:/usr/share/enblend/kernels \\
-%%         Currently preferred GPU is device \#1 on platform \#2 (auto-detected).
-%%       \end{terminal}
-%%     \end{maxipage}
-%%
-%%     \caption[Sample \acronym{OpenCL} configuration.]%
-%%             {\label{ex:opencl-config}%
-%%               A sample \acronym{OpenCL} configuration as detected by \App.}
-%%   \end{exemplar}
+  \label{opt:show-gpu-info}%
+  \optidx[\defininglocation]{--show-gpu-info}%
+  \genidx{GPU@\acronym{GPU}}%
+  \genidx{OpenCL@\acronym{OpenCL}}%
+  \genidx{GPU@\acronym{GPU}!information on}%
+  \gensee{information!on \acronym{GPU}}{\acronym{GPU}, information}%
+  \genidx{OpenCL@\acronym{OpenCL}!information on configuration}%
+  \gensee{information!on \acronym{OpenCL} configuration}{\acronym{OpenCL}, information}%
+\item[--show-gpu-info \restrictednote{\acronym{OpenCL}-enabled versions only.}]\itemend
+  Print a list of all available \acronym{GPU}~devices under \acronym{OpenCL}~control on all
+  accessible platforms, the current preferences, and then exit; it is the same enumeration that
+  \begin{literal}
+    \app{} --verbose --version
+  \end{literal}
+  reveals.  \exampleName~\ref{ex:opencl-config} shows a complete output.
+
+  \begin{exemplar}
+    \begin{maxipage}
+      \begin{terminal}
+        \$ \app{} --show-gpu-info \\
+        Available, OpenCL-compatible platform(s) and their device(s) \\
+        ~~- Platform \#1:~Advanced Micro Devices, Inc., \\
+        ~~~~~~~~~~~~~~~~~AMD Accelerated Parallel Processing, \\
+        ~~~~~~~~~~~~~~~~~OpenCL 1.2 AMD-APP (1526.3) \\
+        ~~~~* no GPU devices found on this platform \\
+        ~~- Platform \#2:~NVIDIA Corporation, \\
+        ~~~~~~~~~~~~~~~~~NVIDIA CUDA, \\
+        ~~~~~~~~~~~~~~~~~OpenCL 1.1 CUDA 6.5.51 \\
+        ~~~~* Device \#1:~max.~1024 work-items \\
+        ~~~~~~~~~~~~~~~~~1047872 KB global memory with 32 KB read/write cache \\
+        ~~~~~~~~~~~~~~~~~48 KB dedicated local memory \\
+        ~~~~~~~~~~~~~~~~~64 KB maximum constant memory \\
+        ~~~~~~~~~~~~~~~~~Extensions: \\
+        ~~~~~~~~~~~~~~~~~~~~~cl\_khr\_byte\_addressable\_store \\
+        ~~~~~~~~~~~~~~~~~~~~~cl\_khr\_fp64 \\
+        ~~~~~~~~~~~~~~~~~~~~~cl\_khr\_gl\_sharing \\
+        ~~~~~~~~~~~~~~~~~~~~~cl\_khr\_global\_int32\_base\_atomics \\
+        ~~~~~~~~~~~~~~~~~~~~~cl\_khr\_global\_int32\_extended\_atomics \\
+        ~~~~~~~~~~~~~~~~~~~~~cl\_khr\_icd \\
+        ~~~~~~~~~~~~~~~~~~~~~cl\_khr\_local\_int32\_base\_atomics \\
+        ~~~~~~~~~~~~~~~~~~~~~cl\_khr\_local\_int32\_extended\_atomics \\
+        ~~~~~~~~~~~~~~~~~~~~~cl\_nv\_compiler\_options \\
+        ~~~~~~~~~~~~~~~~~~~~~cl\_nv\_copy\_opts \\
+        ~~~~~~~~~~~~~~~~~~~~~cl\_nv\_device\_attribute\_query \\
+        ~~~~~~~~~~~~~~~~~~~~~cl\_nv\_pragma\_unroll \\
+        ~~Search path (expanding ENBLEND\_OPENCL\_PATH and appending built-in path) \\
+        ~~~~/usr/local/share/enblend/kernels:/usr/share/enblend/kernels \\
+        Currently preferred GPU is device \#1 on platform \#2 (auto-detected).
+      \end{terminal}
+    \end{maxipage}
+
+    \caption[Sample \acronym{OpenCL} configuration.]%
+            {\label{ex:opencl-config}%
+              A sample \acronym{OpenCL} configuration as detected by \App.}
+  \end{exemplar}
 
 
   \label{opt:show-image-formats}%
@@ -116,7 +115,7 @@
   \optidx[\defininglocation]{--show-signature}%
   \genidx{signature}%
 \item[--show-signature]\itemend
-  Show the user name of the person who compiled the binary, when the binary was compiled, and on
+  Show the username of the person who compiled the binary, when the binary was compiled, and on
   which machine this was done.
 
   This information can be helpful to ensure the binary was created by a trustworthy builder.
diff -r ef8470f9d682 doc/common-interaction.tex
--- a/doc/common-interaction.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/common-interaction.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -15,9 +15,9 @@
   \genidx{detailed configuration}%
   Finding Out Details About \app}
 
-An \appcmd{} binary can come in several configurations.  The exact name of the binary may vary
+An \appcmd{} binary can come in several configurations.  The exact name of the binary may vary,
 and it may or may not reflect the ``kind of \app''.  Therefore, \appcmd{} offers several options
-that allow the user to query exactly\dots
+to query exactly\dots
 
 \begin{compactitemize}
 \item
@@ -160,6 +160,34 @@
         ~ \\
         Extra feature: dynamic linking support: yes \\
         Extra feature: OpenMP: no \\
+        Extra feature: OpenCL: yes \\
+        ~~- Platform \#1:~Advanced Micro Devices, Inc., \\
+        ~~~~~~~~~~~~~~~~~AMD Accelerated Parallel Processing, \\
+        ~~~~~~~~~~~~~~~~~OpenCL 1.2 AMD-APP (1526.3) \\
+        ~~~~* no GPU devices found on this platform \\
+        ~~- Platform \#2:~NVIDIA Corporation, \\
+        ~~~~~~~~~~~~~~~~~NVIDIA CUDA, \\
+        ~~~~~~~~~~~~~~~~~OpenCL 1.1 CUDA 6.5.51 \\
+        ~~~~* Device \#1:~max.~1024 work-items \\
+        ~~~~~~~~~~~~~~~~~1047872 KB global memory with 32 KB read/write cache \\
+        ~~~~~~~~~~~~~~~~~48 KB dedicated local memory \\
+        ~~~~~~~~~~~~~~~~~64 KB maximum constant memory \\
+        ~~~~~~~~~~~~~~~~~Extensions: \\
+        ~~~~~~~~~~~~~~~~~~~~~cl\_khr\_byte\_addressable\_store \\
+        ~~~~~~~~~~~~~~~~~~~~~cl\_khr\_fp64 \\
+        ~~~~~~~~~~~~~~~~~~~~~cl\_khr\_gl\_sharing \\
+        ~~~~~~~~~~~~~~~~~~~~~cl\_khr\_global\_int32\_base\_atomics \\
+        ~~~~~~~~~~~~~~~~~~~~~cl\_khr\_global\_int32\_extended\_atomics \\
+        ~~~~~~~~~~~~~~~~~~~~~cl\_khr\_icd \\
+        ~~~~~~~~~~~~~~~~~~~~~cl\_khr\_local\_int32\_base\_atomics \\
+        ~~~~~~~~~~~~~~~~~~~~~cl\_khr\_local\_int32\_extended\_atomics \\
+        ~~~~~~~~~~~~~~~~~~~~~cl\_nv\_compiler\_options \\
+        ~~~~~~~~~~~~~~~~~~~~~cl\_nv\_copy\_opts \\
+        ~~~~~~~~~~~~~~~~~~~~~cl\_nv\_device\_attribute\_query \\
+        ~~~~~~~~~~~~~~~~~~~~~cl\_nv\_pragma\_unroll \\
+        ~~Search path (expanding ENBLEND\_OPENCL\_PATH and appending built-in path) \\
+        ~~~~/usr/local/share/enblend/kernels:/usr/share/enblend/kernels \\
+        Extra feature: metadata (EXIF, IPTC, XMP) transfer: yes \\
         ~ \\
         Copyright (C) 2004-2009 Andrew Mihal. \\
         Copyright (C) 2009-2015 Christoph Spiel. \\
@@ -216,15 +244,14 @@
       number of threads''.
     \end{qandaanswer}
 
-  %% -- Commented out for Stable Branch 4.2
-  %% \item
-  %%   ``My \appcmd{} has \acronym{OpenCL} enabled.  Does it need separate \acronym{OpenCL} source
-  %%   files?''
-  %%   \begin{qandaanswer}
-  %%     Under extra feature \acronym{OpenCL} look for ``Search path''.  If there is none, all
-  %%     sources have been included in the binary, otherwise the \acronym{OpenCL} source files
-  %%     should be put somewhere on the \acronym{OpenCL} search path.
-  %%   \end{qandaanswer}
+  \item
+    ``My \appcmd{} has \acronym{OpenCL} enabled.  Does it need separate \acronym{OpenCL} source
+    files?''
+    \begin{qandaanswer}
+      Under extra feature \acronym{OpenCL} look for ``Search path''.  If there is none, all
+      sources have been included in the binary, otherwise the \acronym{OpenCL} source files
+      should be put somewhere on the \acronym{OpenCL} search path.
+    \end{qandaanswer}
 \end{qandalist}
 
 
@@ -293,11 +320,11 @@
 prominent image formats.
 
 %% With the exception of TIFF, VIFF, PNG, and PNM all file types
-%% store only 1 byte (gray scale and mapped RGB) or 3 bytes (RGB)
+%% store only 1 byte (grayscale and mapped RGB) or 3 bytes (RGB)
 %% per pixel.
 %%
 %% PNG can store UInt8 and UInt16 values, and supports 1 and 3
-%% channel images. One additional alpha channel is also supported.
+%% channel images.  One additional alpha channel is also supported.
 %%
 %% PNM can store 1 and 3 channel images with UInt8, UInt16 and
 %% UInt32 values in each channel.
@@ -356,7 +383,7 @@
             formats themselves, not \App's.  The ``Mask''-column indicates whether the format
             supports an image mask (alpha-channel), see also
             \chapterName~\ref{sec:understanding-masks}.  Column~``Profile'' shows whether the
-            image format allows for \acronym{ICC}-profiles to be included; see also
+            image format allows for \acronym{ICC}~profiles to be included; see also
             \chapterName~\ref{sec:color-spaces}.}
 \end{table}
 
@@ -410,6 +437,11 @@
     ~~implementing Cilk version 2.0 \\
     ~~~~without support of "\_Cilk\_for" keyword \\
     ~ \\
+    OpenCL APIs \\
+    ~~1.0 \\
+    ~~1.1 \\
+    ~~1.2  \\
+    ~ \\
     Libraries \\
     ~~GSL:~~~~~~~~1.15 \\
     ~~Little CMS:~2.7.0 \\
@@ -496,9 +528,9 @@
 
   \genidx{message!foreign sources}%
 \item[Foreign Sources:] \appcmd{} depends on various foreign software components that issue
-  their own messages.  We try to catch them and press them in our category scheme, but some of
-  them invariably slip through.  The most prominent members of this rogue fraction are the
-  notices of \uref{\hciiwrvigra}{\acronym{VIGRA}} as e.g.
+  their own messages.  \App{} tries to catch them and press them in the category scheme, but
+  some of them invariably slip through.  The most prominent members of this rogue fraction are
+  the notices of \uref{\hciiwrvigra}{\acronym{VIGRA}} as for example
 
   \begin{literal}
     enfuse: an exception occurred \\
@@ -557,37 +589,36 @@
   \envvar{OMP\_NUM\_THREADS} (see below) does for \acronym{OpenMP}.  It can be helpful for load
   balancing.
 
-%% -- Commented out for Stable Branch 4.2
-%%   \genidx{environment variable!ENBLEND\_OPENCL\_PATH@\envvar{ENBLEND\_OPENCL\_PATH}}%
-%%   \gensee{ENBLEND\_OPENCL\_PATH@\envvar{ENBLEND\_OPENCL\_PATH}}%
-%%          {environment variable, \envvar{ENBLEND\_OPENCL\_PATH}}%
-%%   \genidx{OpenCL@\acronym{OpenCL}}%
-%% \item[\envvar{ENBLEND\_OPENCL\_PATH}\xitemspace (direct)\xitemspace
-%%   \restrictednote{\acronym{OpenCL}-enabled versions only.}]\itemend
-%%   Search path for \uref{\khronosorgopencl}{\acronym{OpenCL}} (\filename{.cl}) source files.
-%%   \appcmd{} will refuse to run if required \acronym{OpenCL}~source files are missing, but can be
-%%   convinced to start by resigning \acronym{OpenCL} with \sample{--no-gpu}.  If the compiled-in
-%%   features (see \sectionName~\fullref{sec:compiled-in-features}) do not show an \acronym{OpenCL}
-%%   search path, \appcmd{} came with internalized \acronym{OpenCL} sources and neither needs nor
-%%   uses \envvar{ENBLEND\_OPENCL\_PATH}.
-%%
-%%   \ifenfuse
-%%     \restrictednote{\application{Enfuse} only.} \command{enfuse} uses the environment variable
-%%     \envvar{ENBLEND\_OPENCL\_PATH} as search path for User-Defined \acronym{OpenCL} Exposure
-%%     Weighting Functions.  See \sectionName~\fullref{sec:user-defined-opencl-functions}.
-%%   \fi
-%%
-%%   Note that the environment variable is called \envvar{ENBLEND\_OPENCL\_PATH} for \emph{both}
-%%   applications, even for \command{enfuse}!
+  \genidx{environment variable!ENBLEND\_OPENCL\_PATH@\envvar{ENBLEND\_OPENCL\_PATH}}%
+  \gensee{ENBLEND\_OPENCL\_PATH@\envvar{ENBLEND\_OPENCL\_PATH}}%
+         {environment variable, \envvar{ENBLEND\_OPENCL\_PATH}}%
+  \genidx{OpenCL@\acronym{OpenCL}}%
+\item[\envvar{ENBLEND\_OPENCL\_PATH}\xitemspace (direct)\xitemspace
+  \restrictednote{\acronym{OpenCL}-enabled versions only.}]\itemend
+  Search path for \uref{\khronosorgopencl}{\acronym{OpenCL}} (\filename{.cl}) source files.
+  \appcmd{} will refuse to run if required \acronym{OpenCL}~source files are missing, but can be
+  convinced to start by resigning \acronym{OpenCL} with \sample{--no-gpu}.  If the compiled-in
+  features (see \sectionName~\fullref{sec:compiled-in-features}) do not show an \acronym{OpenCL}
+  search path, \appcmd{} came with internalized \acronym{OpenCL} sources and neither needs nor
+  uses \envvar{ENBLEND\_OPENCL\_PATH}.
+
+  \ifenfuse
+    \restrictednote{\application{Enfuse} only.} \command{enfuse} uses the environment variable
+    \envvar{ENBLEND\_OPENCL\_PATH} as search path for User-Defined \acronym{OpenCL} Exposure
+    Weighting Functions.  See \sectionName~\fullref{sec:user-defined-opencl-functions}.
+  \fi
+
+  Note that the environment variable is called \envvar{ENBLEND\_OPENCL\_PATH} for \emph{both}
+  applications, even for \command{enfuse}!
 
   \genidx{environment variable!OMP\_DYNAMIC@\envvar{OMP\_DYNAMIC}}%
   \gensee{OMP\_DYNAMIC@\envvar{OMP\_DYNAMIC}}{environment variable, \envvar{OMP\_DYNAMIC}}%
   \genidx{OpenMP@\acronym{OpenMP}}%
 \item[\envvar{OMP\_DYNAMIC}\xitemspace (implicit)\xitemspace
   \restrictednote{\acronym{OpenMP}-enabled versions only.}]\itemend
-  Control whether the \uref{\openmporg}{\acronym{OpenMP}} sub-system should parallelize nested
+  Control whether the \uref{\openmporg}{\acronym{OpenMP}} subsystem should parallelize nested
   parallel regions.  This environment variable will only have an effect is the \acronym{OpenMP}
-  sub-system is capable of dynamic adjustment of the number of threads (see explanations in
+  subsystem is capable of dynamic adjustment of the number of threads (see explanations in
   \sectionName~\fullref{sec:compiled-in-features}).
 
   \begin{geeknote}
@@ -602,7 +633,7 @@
 \item[\envvar{OMP\_NUM\_THREADS}\xitemspace (implicit)\xitemspace
   \restrictednote{\acronym{OpenMP}-enabled versions only.}]\itemend
   Control -- which typically means: reduce -- the number of threads under supervision of the
-  \uref{\openmporg}{\acronym{OpenMP}} sub-system.  By default \appcmd{} uses as many
+  \uref{\openmporg}{\acronym{OpenMP}} subsystem.  By default \appcmd{} uses as many
   \acronym{OpenMP}\hyp{}threads as there are \acronym{CPU}s.  Use this variable for example to
   free some \acronym{CPU}s for other processes than \appcmd.
 
diff -r ef8470f9d682 doc/common-known-limitations.tex
--- a/doc/common-known-limitations.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/common-known-limitations.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -12,11 +12,13 @@
 
 \begin{itemize}
 \item
-  The \genidx{BigTIFF@\acronym{BigTIFF}}\acronym{BigTIFF} image format is not supported.
+  The \genidx{BigTIFF@\acronym{BigTIFF}}\acronym{BigTIFF} image format is not automatically
+  selected. For TIFF images bigger 4 GB you have to add the 
+  option~\sample{--parameter=export-bigtiff} manually.
 
 \item
   Total size of \emph{any} -- even intermediate -- image is limited to $2^{31}$~pixels, this is
-  two giga-pixels.
+  two gigapixels.
 
 \ifenblend
   \genidx{blending!sequential}%
@@ -32,8 +34,8 @@
   \begin{geeknote}
     The overlap is exclusively defined by the masks of the overlapping images.  This is exactly
     what the input masks are built for.  Let $A$ be the number of pixels that overlap in both
-    masks.  We use $A$ as a measure of the overlap area -- something 2\hyp dimensional;
-    technically it is a pixel count.
+    masks.  \App{} uses $A$ as a measure of the overlap area -- something 2\hyp dimensional;
+    technically a pixel count.
 
     Construct the smallest circumscribed, par-axial rectangle of the overlap area.  The
     rectangle has a circumference
@@ -42,14 +44,16 @@
     \]
     which is of course 1-dimensional.  Internally $U$ again is a number of pixels just as $A$.
 
-    The threshold when we consider a pair of images sufficiently different is when $A$ is larger
-    than \val{val:overlap-check-threshold}~times the number of pixels on the circumference~$U$
-    \[
+    The threshold for \App{} to consider a pair of images sufficiently different is if $A$ is
+    larger than \val{val:overlap-check-threshold}~times the number of pixels on the
+    circumference~$U$
+    \begin{equation}\label{equ:overlap-threshold}
     A > \val{val:overlap-check-threshold} \times U.
-    \]
-    Avoiding the term ``fractal dimension'', we have constructed a simple measure of how 2\hyp
-    dimensional the overlap area is.  This way we steer clear of feeding later processing stages
-    with nearly 1\hyp dimensional overlap regions, something that wreaks havoc on them.
+    \end{equation}
+    Avoiding the term ``fractal dimension'', \eqnref{equ:overlap-threshold} is a simple measure
+    of how 2\hyp dimensional the overlap area is.  This way \App{} steers clear of feeding later
+    processing stages with nearly 1\hyp dimensional overlap regions, something that wreaks havoc
+    on them.
   \end{geeknote}
 
   \optidx{--wrap}%
@@ -75,9 +79,60 @@
     option~\flexipageref{\option{--blend-colorspace}}{opt:blend-colorspace}.
 
   \item
-    Use linear (i.e.\ $\mathrm{gamma} = 1$) color profiles in the input images.  Also see
+    Use linear, this is $\mathrm{gamma} = 1$, color profiles in the input images.  Also see
     \chapterName~\fullref{sec:color-spaces} on ``Color Spaces And Color Profiles''.
   \end{enumerate}
+
+\genidx{images!non-overlapping}%
+\gensee{non-overlapping images}{images, non-overlapping}%
+\item
+  No image contributing: If at a particular pixel or set of pixels the input images do not
+  overlap at all, the output image will have a hole.  Such a non-overlapping area either occurs
+
+  \begin{compactitemize}
+  \item
+    naturally, this is, it is induced by the images' geometries and positions, or
+
+  \item
+    artificially by manually manipulating the masks of the input images for example to mask out
+    moving objects.
+  \end{compactitemize}
+
+  Neither \App{} nor \OtherApp{} will even try to fill the hole by ``dreaming up'' pixels.
+
+  For output image formats that support masks, the mask will have zero values at the hole.
+  Output formats without masks will set all pixels of the hole to pure black.  Note that in any
+  case an output mask reflecting the hole can be requested with
+  option~\flexipageref{\option{--output-mask}}{opt:output-mask}.
+
+\item
+  Just a single image contributing: If at a particular set of pixels the input images do not
+  overlap, but only a single image covers the region (for the same reasons as mentioned in the
+  previous item), \App{} and \OtherApp{} simply copy the pixels of this region to the output
+  image if they are away far enough from the overlap area.
+
+  \begin{geeknote}
+    If the \propername{Laplacian} pyramids do not contain ``interesting'' information, this is,
+    they have been built from only one image, only the \propername{Gaussian} pyramids are
+    totaled and scaled up until reaching the original image's scale.  That way the possibly
+    sharp seam between the images gets smoothed out pyramid level by pyramid level and thus the
+    transition between the images is softly feathered.
+
+    For a quantitative estimate of how far away of the overlap boundary the non-overlapping
+    parts are influenced look for the message
+
+    \begin{literal}
+      \app: info: using $N$ blending levels
+    \end{literal}
+
+    which is available at verbosity level~\val{val:verbosity-level-pyramid} and higher.  Here,
+    $N$ is the number of pyramid levels.  Non-overlapping parts more than approximately
+    $2^N$~pixels away from the image intersection bounding box will be unaffected by the blend
+    process and pixels within this distance are influenced by the overlap.
+
+    The location and size of the ``image intersection bounding box'' is available from verbosity
+    level~\val{val:verbosity-level-ibb} on.
+  \end{geeknote}
 \end{itemize}
 
 \genidx[\rangeendlocation]{known limitations}
diff -r ef8470f9d682 doc/common-layer-selection.tex
--- a/doc/common-layer-selection.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/common-layer-selection.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -6,10 +6,10 @@
   \genidx[\rangebeginlocation]{layer!selection}%
   Layer Selection\commonpart}
 
-Some image formats, like for example \acronym{TIFF}, allow for storing more than one image in a
+Some image formats, like for example \acronym{TIFF}, permit to store more than one image in a
 single file, where all the contained images can have different sizes, number of channels,
-resolutions, compression schemes, etc.  The file there acts as a container for an \emph{ordered}
-set of images.
+resolutions, compression schemes, and so on.  The file there acts as a container for an
+\emph{ordered} set of images.
 
 \genidx[\defininglocation]{file!multi-page}%
 \gensee{multi-page file}{file, multi-page}%
@@ -38,7 +38,7 @@
 
 To give the user the same flexibility in specifying and ordering images as with single-layer
 images, both \App{} and \OtherApp{} offer a special syntax to select layers in multi-page files
-by appending a \metavar{layer-specification} to the image file name.
+by appending a \metavar{layer-specification} to the image filename.
 \tableName~\ref{tab:layer-selection-grammar} defines the grammar of
 \metavar{layer-specification}\/s.
 
@@ -73,7 +73,7 @@
 
 The simplest \metavar{layer-specification} are the layer-\metavar{index}es.  The first layer
 gets index~1, the second layer~2, and so on.  Zero never is a valid index!  For convenience
-indexing backwards\footnotemark{} is also possible. This means by prefixing an index with a
+indexing backward\footnotemark{} is also possible.  This means by prefixing an index with a
 minus-sign~(\sample{-}) counting will start with the last layer of the \emph{associated}
 multi-page image, such that the last layer always has index~\code{-1}, the next to last
 index~\code{-2} and so on.  Out-of-range indexes are silently ignored whether forward or
@@ -87,7 +87,7 @@
 
 Select a contiguous \metavar{range} of indexes with the range
 operator~\sample{\val{val:layer-range-separator}}, where the \metavar{range-bound}\/s are
-forward or backward indices.  Leaving out a bound or substituting the open-range
+forward or backward indexes.  Leaving out a bound or substituting the open-range
 indicator~\sample{\val{val:layer-range-empty-index-symbol}} means a maximal range into the
 respective direction.
 
@@ -117,7 +117,7 @@
 
 \item[\lspec{2 :\ 4 :\ 5}] Select only layers~2, 4, and~5 in this order.
 
-\item[\lspec{2 :\ -4 :\ -3}] Like before, but with some backwards-counting indices.
+\item[\lspec{2 :\ -4 :\ -3}] Like before, but with some backward-counting indexes.
 
 \item[\lspec{1 \val*{val:layer-range-separator}\ 4}] Layers 1~to 4, this is 1, 2, 3, and~4 in
   this order.
@@ -149,9 +149,9 @@
 \end{codelist}
 
 \begin{geeknote}
-  Shell expansion will not work anymore with a file name terminated by a layer specification
-  expression (or anything else), because to the shell it is not a file name anymore.  Work
-  around with, for example,
+  Shell expansion will not work anymore with a filename terminated by a layer specification
+  expression (or anything else), because to the shell it is not a filename anymore.  Work around
+  with, for example,
 
   \begin{terminal}
     \$ \app{} `for x in image-??.tif; do echo \$x[2]; done`
@@ -163,7 +163,7 @@
     \$ \app{} \$(ls -1 image-??.tif | sed -e 's/\$/[2]/')
   \end{terminal}
 
-  The order of the indices determines the order of the layers, this is, the images.  An index
+  The order of the indexes determines the order of the layers, this is, the images.  An index
   can occur multiple times, which causes layer to be considered \emph{again}.  Consequently,
   this will lead to an error with \application{Enblend}, but may be desired with
   \application{Enfuse} in \code{soft-mask}~mode to give the image more weight by mentioning it
@@ -204,8 +204,8 @@
     \textrm{(ImageMagick)}}\command{display} use a
   \uref{\imagemagickorgcommandlineprocessinginput}{similar syntax} as \App{} to select layers
   (which in \application{ImageMagick} parlance are called ``frames'') in multi-page files.
-  Please note that \application{ImageMagick} tools start indexing at zero, whereas we start at
-  one.
+  Please note that \application{ImageMagick} tools start indexing at zero, whereas \App{} starts
+  counting at one.
 
 \item
   \App{} and \OtherApp{} by default apply the \sample{\val{val:layer-selector}} selector (see
diff -r ef8470f9d682 doc/common-mask-template-characters.tex
--- a/doc/common-mask-template-characters.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/common-mask-template-characters.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -29,7 +29,7 @@
 
 
     \genidx{mask!template character!n@\sample{n}}\code{\%n} & Expands to the number of the mask
-    file starting at one. Otherwise it behaves identically to \sample{\%i}, including pad
+    file starting at one.  Otherwise it behaves identically to \sample{\%i}, including pad
     character and width specification. \\
 
 
diff -r ef8470f9d682 doc/common-metadata.tex
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/doc/common-metadata.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -0,0 +1,102 @@
+%% This file is part of Enblend.
+%% Licence details can be found in the file COPYING.
+
+
+\section{\label{sec:metadata}%
+  \genidx{metadata}%
+  \gensee{image metadata}{metadata}%
+  Image Metadata}
+
+\App{} transparently handles some image metadata.
+
+See \sectionName~\ref{sec:compiled-in-features} on how to check whether your \App{} has been
+compiled with this feature.
+
+\begin{geeknote}
+  \genidx{Harvey@\propername{Phil Harvey}}%
+  \propername{Phil Harvey}, the author of \uref{\snophyqueensucaexiftool}{EXIFTool} collects an
+  intimidating number of \uref{\snophyqueensucaexiftooltagnames}{tag names} not only for
+  \acronym{EXIF} on his website.  Furthermore, the \uref{\exiviiorg}{Exiv2}~project hosts
+  some extensive \uref{\exiviiorgtags}{metadata reference tables}.
+\end{geeknote}
+
+
+\subsection{\label{sec:metadata-exif-iptc-xmp}%
+  \genidx{metadata!EXIF@\acronym{EXIF}}%
+  \gensee{EXIF@\acronym{EXIF}}{metadata, \acronym{EXIF}}%
+  \genidx{metadata!IPTC@\acronym{IPTC}}%
+  \gensee{IPTC@\acronym{IPTC}}{metadata, \acronym{IPTC}}%
+  \genidx{metadata!XMP@\acronym{XMP}}%
+  \gensee{XMP@\acronym{XMP}}{metadata, \acronym{XMP}}%
+  \acronym{EXIF}, \acronym{IPTC}, and \acronym{XMP} Data}
+
+\App{} automatically copies selected photo metadata, this is
+
+\begin{itemize}
+\item
+  \acronym{EXIF} tags (see \uref{\exiforg}{Exchangeable Image Format} and
+  \appendixName~\fullref{sec:metadata-handling}),
+
+\item
+  \acronym{IPTC} tags (see \uref{\iptcorg}{International Press Telecommunications Council}), and
+
+\item
+  \acronym{XMP} data (see \uref{\adobexmp}{Extensible Metadata Platform})
+\end{itemize}
+
+\noindent of the first input image to the output image.  The metadata in all other input files
+is ignored.
+
+\genidx{metadata!EXIF@\acronym{EXIF}!tag~\code{ProcessingSoftware}}%
+This version of \App{} adds only one entry to the \acronym{EXIF}~tags, namely
+\code{Exif.Image.ProcessingSoftware}.  The tag value holds the application name and its exact
+version number.
+
+
+\subsection{\label{sec:metadata-icc}%
+  \genidx{metadata!\acronym{ICC} color profile}%
+  \gensee{ICC@\acronym{ICC} metadata}{metadata, \acronym{ICC}}%
+  \acronym{ICC} Color Profiles}
+
+For grayscale or color input images with \acronym{ICC} profiles attached (see also
+\sectionName~\fullref{sec:image-requirements} on the consistency of \acronym{ICC} metadata
+across the input images), \App{} honors the profiles in the whole \appisdoing{} process and
+writes the output using \acronym{ICC} profile of the first input image and well as attaching it
+to the output image.
+
+\App{} has no provisions to force a particular \acronym{ICC} profile for the output image if the
+input images contain profiles.  Use programs like for example
+\flexipageref{\command{tificc}}{app:littlecms} to apply profiles to \acronym{TIFF} images.
+
+For input images without color profiles see in particular
+options~\flexipageref{\option{--fall\shyp back-pro\shyp file}}{opt:fallback-profile} and
+\flexipageref{\option{--blend-col\shyp or\shyp space}}{opt:blend-colorspace}.
+
+\chapterName~\fullref{sec:color-spaces} discusses \acronym{ICC} profiles and color spaces in
+detail.
+
+
+\subsection[Format Specific]{\label{sec:metadata-specific}%
+  \genidx{metadata!image-format specific}%
+  \gensee{image-format specific metadata}{metadata, image-format specific}%
+  \gensee{format specific metadata}{metadata, image-format specific}%
+  Image-Format Specific}
+
+\genidx{metadata!image-format specific!pixel resolution}%
+\gensee{pixel resolution}{metadata, image-format specific, pixel resolution}%
+\gensee{resolution of pixels}{metadata, image-format specific, pixel resolution}%
+\genidx{metadata!image-format specific!image offset}%
+\gensee{image}{metadata, image-format specific, image offset}%
+\gensee{offset of image}{metadata, image-format specific, image offset}%
+Depending on the input-image type (\acronym{TIFF}, \acronym{PNG}, \acronym{BMP}, \dots) the
+underlying image library, \uref{\hciiwrvigra}{\acronym{VIGRA}}, supplies both \App{} and
+\OtherApp{} with some metadata most notably the $x$- and $y$-resolutions and the $x$- and
+$y$-offset of the image with respect to the canvas.
+
+\App{} always honors this kind of metadata if it is available and will warn of inconsistencies
+in the input images.
+
+
+%%% Local Variables:
+%%% fill-column: 96
+%%% End:
diff -r ef8470f9d682 doc/common-notation.tex
--- a/doc/common-notation.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/common-notation.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -56,7 +56,7 @@
     Optional part & Optional part of a syntax description in square brackets &
     \option{--verbose}~\optional{=\metavar{LEVEL}} \\
 
-    Placehoder & Meta-syntactic variable that stands in for the actual text &
+    Placeholder & Meta-syntactic variable that stands in for the actual text &
     \metavar{ICC-PROFILE} \\
 
     Proper name & Name of a person or algorithm & \propername{Dijkstra} \\
@@ -64,7 +64,7 @@
     Restricted note & Annotation that applies only to a particular program, configuration,~or
     operating system & \restrictednote{\App.} \\
 
-    Sample & Literal text in quotes & \sample{\%} or \sample{--help} \\
+    Sample & Literal text in quotes & \sample{\%} or \sample{--prefer-gpu} \\
 
     Side note & Non-essential or ``geeky'' material & {\geekytext Gory details} \\
 
@@ -74,10 +74,10 @@
 \end{center}
 
 \ifhevea\relax\else
-If we must break an identifier like for example \option{--show-soft\shyp ware-com\shyp po\shyp
-nents} or \envvar{EN\shyp BLEND\_OPEN\shyp CL\_PATH} at the end of a line, we indicate the
-additional character which does not occur when the identifier is written as one word with
-a \sample{\signalinghyphenchar}-character.
+If identifiers like for example \option{--show-soft\shyp ware-com\shyp po\shyp nents}
+or \envvar{EN\shyp BLEND\_OPEN\shyp CL\_PATH} must be broken at the end of a line, the break is
+indicated with an additional character that does not occur if the identifier is written as one
+word with a \sample{\signalinghyphenchar}-character.
 \fi
 
 
diff -r ef8470f9d682 doc/common-option-delimiters.tex
--- a/doc/common-option-delimiters.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/common-option-delimiters.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -8,8 +8,8 @@
   \gensea{delimiters}{options, delimiters}%
   Option Delimiters\commonpart}
 
-\App{} and \OtherApp{} allow the arguments supplied to the programs' options to be separated by
-different separators.  The online documentation and this manual, however, exclusively use the
+\App{} and \OtherApp{} accept the arguments supplied to the programs' options to be separated by
+different separators.  The online documentation and this manual, exclusively use the
 colon~\sample{:} in every syntax definition and in all examples.
 
 
diff -r ef8470f9d682 doc/common-response-files.tex
--- a/doc/common-response-files.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/common-response-files.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -153,7 +153,7 @@
 
 \item[Image filenames cannot start with \code{\val{val:response-file-prefix-char}}]\itemend
   A \code{\val{val:response-file-prefix-char}}~sign invariably introduces a response file, even
-  if the filename's extension hints towards an image.
+  if the filename's extension hints toward an image.
 \end{description}
 
 \genidx{response file!force recognition of}%
@@ -258,7 +258,7 @@
     \begin{codelist}
       \genidx{globbing algorithm!\code{literal}}%
     \item[literal]\itemend
-      Do not glob.  Interpret all filenames in response files as literals. This is the default.
+      Do not glob.  Interpret all filenames in response files as literals.  This is the default.
 
       Please remember that white-space at both ends of a line in a response file \emph{always}
       gets discarded.
@@ -280,8 +280,7 @@
     \item[shell]\itemend
       The \code{shell} globbing algorithm works as \code{literal} does.  In addition, it
       interprets the wildcard characters~\sample{\{}, \sample{\atsign}, and \sample{\squiggle}.
-      This makes the expansion process behave more like common \acronym{UN*X}
-      shells.
+      This makes the expansion process act more like common \acronym{UN*X} shells.
 
       \genidx{globbing algorithm!\code{sh}}
     \item[sh]\itemend
diff -r ef8470f9d682 doc/common-standard-workflow.tex
--- a/doc/common-standard-workflow.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/common-standard-workflow.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -29,7 +29,7 @@
 
 \begin{description}
 \item[Take Images]\itemend
-  Take \emph{multiple} images to form a panorama, an exposure series, a focus stack, etc.\dots
+  Take \emph{multiple} images to form a panorama, an exposure series, a focus stack,\dots
 
   There is one exception with \application{Enfuse} when a single raw image is converted multiple
   times to get several -- typically differently ``exposed'' -- images.
@@ -69,7 +69,7 @@
   This step submits the images to affine transformations.
 
   \genidx{lens distortion!correction of}%
-  If necessary, it rectifies the lens' distortions (e.g.\ barrel or pincushion), too.
+  If necessary, it rectifies the lens' distortions (for example barrel or pincushion), too.
 
   \genidx{alignment!photometric}%
   \gensee{photometric alignment}{alignment, photometric}%
diff -r ef8470f9d682 doc/common-understanding-masks.tex
--- a/doc/common-understanding-masks.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/common-understanding-masks.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -15,8 +15,7 @@
 contributes, zero again meaning ``no contribution''.
 
 Masks arise in two places: as part of the input files and as separate files, showing the actual
-pixel weights prior to image blending or fusion.  We shall explore both occurrences in the next
-sections.
+pixel weights prior to image blending or fusion.  The following sections will expore both.
 
 
 \section[Masks In Input Files]{\label{sec:masks-in-input-files}%
@@ -121,8 +120,9 @@
 \end{description}
 
 \App{} and \OtherApp{} only consider pixels that have an associated mask value other than zero.
-If an input image does not have an alpha channel, \application{Enblend} warns and assumes a mask
-of all non-zero values, that is, it will use every pixel of the input image for fusion.
+If an input image does not have an alpha channel, \application{Enfuse} warns and assumes a mask
+of all nonzero values, that is, it will use every pixel of the input image for fusion;
+\application{Enblend} immediately stops and complains about the lack of an alpha channel.
 
 \prgidx{nona \textrm{(Hugin)}}%
 Stitchers like \command{nona} add a mask to their output images.
diff -r ef8470f9d682 doc/common-workflow.tex
--- a/doc/common-workflow.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/common-workflow.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -22,6 +22,7 @@
 \input{common-standard-workflow}
 \input{common-external-masks}
 \input{common-interaction}
+\input{common-metadata}
 
 \genidx[\rangeendlocation]{photographic workflow}
 
diff -r ef8470f9d682 doc/enblend-expert-mask-generation-options.tex
--- a/doc/enblend-expert-mask-generation-options.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/enblend-expert-mask-generation-options.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -7,7 +7,7 @@
   \genidx{options!mask generation for experts}%
   Expert Mask Generation Options}
 
-These options allow for a detailed control of the seam-line optimizers which govern the mask
+These options permit a detailed control of the seam-line optimizers which govern the mask
 generation.
 
 \begin{codelist}
@@ -141,7 +141,7 @@
   \end{codelist}
 
   \begin{sloppypar}
-    Both \metavar{LUMINANCE\hyp{}WEIGHT} and \metavar{CHROMINANCE\hyp{}WEIGHT} are non-negative.
+    Both \metavar{LUMINANCE\hyp{}WEIGHT} and \metavar{CHROMINANCE\hyp{}WEIGHT} are nonnegative.
     \App{} automatically normalizes the sum of \metavar{LUMINANCE\hyp{}WEIGHT} and
     \metavar{CHROMINANCE\hyp{}WEIGHT} to one.  Thus,
   \end{sloppypar}
@@ -251,7 +251,7 @@
   cusps or loops (see option~\flexipageref{\option{--visualize}}{opt:visualize}), reduce
   \metavar{MISMATCH\hyp{}WEIGHT} or increase \metavar{DISTANCE\hyp{}WEIGHT}.
 
-  Both weights must be non-negative.  They cannot be both zero at the same time.  Otherwise,
+  Both weights must be nonnegative.  They cannot be both zero at the same time.  Otherwise,
   their absolute values are not important as \App{} normalizes their sum.
 
 
diff -r ef8470f9d682 doc/enblend-flow-charts.tex
--- a/doc/enblend-flow-charts.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/enblend-flow-charts.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -2,7 +2,7 @@
 %% Licence details can be found in the file COPYING.
 
 
-\subsection[Program Flow Charts]{\label{sec:program-flow-and-option-settings}%
+\subsection[Program Flowcharts]{\label{sec:program-flow-and-option-settings}%
   \genidx[\rangebeginlocation]{program flow}%
   \genidx{options!program flow}%
   \gensee{flow}{program flow}%
diff -r ef8470f9d682 doc/enblend-image-requirements.tex
--- a/doc/enblend-image-requirements.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/enblend-image-requirements.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -32,7 +32,7 @@
   \acronym{RGB}-color images (three channels and alpha channel).
 
 \item
-  The images agree on their number of bits-per-channel, i.e., their ``depth'':
+  The images agree on their number of bits-per-channel, this is their ``depth'':
 
   \begin{itemize}
   \item
@@ -45,7 +45,7 @@
     \code{float},
 
   \item
-    etc.
+    \dots
   \end{itemize}
 
   See option~\flexipageref{\option{--depth}}{opt:depth} for an explanation of different output
@@ -67,7 +67,7 @@
   \emph{same} \acronym{ICC} profile.
 
 \item
-  If the images' meta-data contains resolution information (``\acronym{DPI}''), it is the same
+  If the images' metadata contains resolution information (``\acronym{DPI}''), it is the same
   for all pictures.
 \end{itemize}
 
diff -r ef8470f9d682 doc/enblend-mask-generation-options.tex
--- a/doc/enblend-mask-generation-options.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/enblend-mask-generation-options.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -124,10 +124,10 @@
   \gensee{save mask}{mask, save}%
 \item[--save-masks\optional{=\metavar{IMAGE-TEMPLATE}}]\itemend
   Save the generated masks to \metavar{IMAGE-TEMPLATE}, which defaults to
-  \mbox{\sample{\val{val:default-mask-template}}}.  \App{} saves masks as 8~bit grayscale,
-  i.e.\ single channel images.  For accuracy we recommend to choose a lossless format.
+  \mbox{\sample{\val{val:default-mask-template}}}.  \App{} saves masks as 8~bit grayscale, this
+  is single channel images.  For accuracy we recommend to choose a lossless format.
 
-  Use this option if you wish to edit the location of the seam line by hand.  This will give you
+  Use this option if you want to edit the location of the seam line by hand.  This will give you
   images of the right sizes that you can edit to make your changes.  Later, use
   option~\flexipageref{\option{--load-masks}}{opt:load-masks} to blend the project with your
   custom seam lines.
diff -r ef8470f9d682 doc/enblend-overview.tex
--- a/doc/enblend-overview.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/enblend-overview.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -34,11 +34,13 @@
 that certain portions of an input image should not contribute to the final image.
 
 \genidx{feathering}%
+\gensee{feather width}{feathering}%
+\gensee{width!feather}{feathering}%
 \appidx{Hugin}%
 \appidx{PanoTools}%
 \App{} does \emph{not} align images.  Use a tool such as \application{Hugin} or PanoTools to do
 this.  The \acronym{TIFF}~files produced by these programs are exactly what \App{} is designed
-to work with.  Sometimes these \acronym{GUI}s allow to select feathering for the edges the
+to work with.  Sometimes these \acronym{GUI}s offer to select feathering for the edges the
 images.  This treatment is detrimental to \App{}.  Turn off feathering by deselecting it or
 setting the ``feather width'' to zero.
 
diff -r ef8470f9d682 doc/enblend-seam-generators.tex
--- a/doc/enblend-seam-generators.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/enblend-seam-generators.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -45,10 +45,10 @@
 \genidx{seam generation!details}%
 The most significant difference between the two algorithms is the output mask gradation.
 \acronym{NFT} produces a coarse approximation of the seam, running as far away from the
-overlap-region borders as possible.  The resulting mask could then be blended as-is, however,
-\App{} by default runs image-content dependent optimizers to increase the mask gradation and for
-example omits the regions where the images differ.  The result is a finer seam line, which only
-loosely follows the shape of \acronym{NFT}'s primary seam.
+overlap-region borders as possible.  The resulting mask could then be blended as-is.  However,
+\App{} by default runs image-content dependent optimizers to increase the mask gradation, and
+for example omits the regions where the images differ.  The result is a finer seam line, which
+only loosely follows the shape of \acronym{NFT}'s primary seam.
 
 \genidx{graphcut!details}%
 Graph-Cut, on the other hand, is capable of producing the final mask in one pass without the
diff -r ef8470f9d682 doc/enblend.tex
--- a/doc/enblend.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/enblend.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -29,11 +29,13 @@
 \newcommand*{\app}{enblend}
 \newcommand*{\appcmd}{\command{enblend}}
 \newcommand*{\appdoes}{blend}
+\newcommand*{\appisdoing}{blending}
 \newcommand*{\appdid}{blended}
 
 \newcommand*{\OtherApp}{\application{Enfuse}}
 \newcommand*{\otherapp}{enfuse}
 \newcommand*{\otherappcmd}{\command{enfuse}}
+\newcommand*{\otherappdoes}{fuse}
 
 
 \finishdynamicpreamble
diff -r ef8470f9d682 doc/enfuse-applications.tex
--- a/doc/enfuse-applications.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/enfuse-applications.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -104,20 +104,15 @@
 \mainpurpose{Reduce noise}
 
 With the default settings, \App{} computes a weighted average of the input pixels.  For a series
-of images, repeated with identical settings, this results in a reduction of (photon shot) noise.
-In other words, the dynamic range increases slightly, because the higher signal-to-noise ratio
-makes darker shades usable.  Furthermore, smooth or glossy surfaces get a ``cleaner'' look, and
-edges become visually sharper.  The nitty-gritty reportage look that sometimes stems from a high
-sensitivity setting disappears.
+of images, repeated with identical camera settings, this results in a reduction of photon~shot
+noise.  In other words, the dynamic range increases slightly, because the higher signal-to-noise
+ratio (\acronym{SNR}) makes darker shades usable.  Furthermore, smooth or glossy surfaces get a
+``cleaner'' look, and edges become visually sharper.  The nitty-gritty reportage look that
+sometimes stems from a high sensitivity setting disappears.
 
+\genidx{dark-frame subtraction}%
 Averaged images, and therefore low-noise images, are the base for a multitude of techniques
-like, for example, differences.  The most prominent method in this class is dark-frame
-subtraction.
-
-\App{} sets defaults for the exposure-weight to \val{val:default-weight-exposure}, for
-saturation-weight to \val{val:default-weight-saturation} and for all other weights to zero, a
-good combination for noise reduction.  Eliminating the saturation component with
-\option{--saturation\hyp weight=0.0} sometimes can be worth the extra run.
+like, for example, differences.  The most prominent one in this class is dark-frame subtraction.
 
 
 \section[Exposure Series -- Dynamic Range Increase]{\label{sec:exposure-series--dynamic-range-increase}%
@@ -130,21 +125,23 @@
 
 An exposure series is a set of images taken with identical parameters except for the exposure
 time.  Some cameras even provide special functions to automate recording exposure series.  See
-the instruction manual of your model for details.  Also check out the features that Magic
-Lantern offers to shoot \acronym{HDR}-series and to extend the dynamic range right in the
-camera.
+the instruction manual of your model for details.  Also check out the features that
+\uref{\magiclanternfm}{Magic Lantern} offers to shoot \acronym{HDR}-series and to extend the
+dynamic range right in the camera.
 
-\App{}'s defaults for exposure weight, \val{val:default-weight-exposure} and saturation weight,
-\val{val:default-weight-saturation} are well suited for fusion of \emph{color} images.  Remember
-that saturation weighting only works for \acronym{RGB} data.
-Option~\option{--saturation-weight} helps to control burnt-out highlights, as these are heavily
+\App{}'s defaults for $\mbox{exposure weight} = \val*{val:default-weight-exposure}$ and sets all
+other weights to zero which generally is well suited for fusion of \emph{color} and
+black-and-white images.
+
+Saturation weighting only works for \acronym{RGB}~data.  For color images,
+option~\option{--saturation-weight} helps to control burnt-out highlights, if they are heavily
 desaturated.  Alternatively, use option~\option{--exposure-cutoff} to suppress noise or
 blown-out highlights without altering the overall brightness too much.  If no image suffers from
 troublesome highlights, the relative saturation weight can be reduced and even be set to zero.
 
-For black and white images \sample{--entropy-weight} can be an alternative to
+For black-and-white images \sample{--entropy-weight} can be an alternative to
 \sample{--saturation-weight} because it suppresses overexposed pixels, as these contain little
-information.  However, entropy weighting is not limited to gray-scale data; it has been
+information.  However, entropy weighting is not limited to grayscale data; it has been
 successfully applied to \acronym{RGB} images, too.  Note that entropy weighting considers
 \emph{each} color channel of an \acronym{RGB} image separately and chooses the channel with the
 minimum entropy as representative for the whole pixel.
@@ -325,8 +322,8 @@
 
 \genidx{signal-to-noise ratio}%
 \gensee{SNR@\acronym{SNR}}{signal-to-noise ratio}%
-As in all image fusion operations it is preferable to use 16~bit linear (i.e. gamma = 1) images
-throughout, but 8~bit gamma-encoded images will do.  Naturally, high signal-to-noise
+As in all image fusion operations it is preferable to use 16~bit linear, this is $\mathrm{gamma}
+= 1$ images throughout, but 8~bit gamma-encoded images will do.  Naturally, high signal-to-noise
 (\acronym{SNR}) ratio input data always is welcome.
 
 
@@ -341,7 +338,6 @@
 \begin{terminal}
   \$ enfuse \bslash \\
   ~~~~--exposure-weight=0 \bslash \\
-  ~~~~--saturation-weight=0 \bslash \\
   ~~~~--contrast-weight=1 \bslash \\
   ~~~~--hard-mask \bslash \\
   ~~~~\dots{} \bslash \\
@@ -356,10 +352,6 @@
   Switch \strong{off} exposure based pixel selection.  The default weight is
   \val{val:default-weight-exposure}.
 
-\item[--saturation-weight=0]\itemend
-  Switch \strong{off} saturation based pixel selection.  The default weight is
-  \val{val:default-weight-saturation}.
-
 \item[--contrast-weight=1]\itemend
   Switch \strong{on} pixel selection based on local contrast.
 
@@ -543,8 +535,8 @@
 \noindent The option~\option{--contrast-min-curvature} option helps to mitigate both flaws.
 
 The argument to \option{--contrast-min-curvature}=\metavar{CURVATURE} either is an absolute
-lightness value, e.g.\ 0\dots255 for 8~bit data and 0\dots65535 for 16~bit data, or, when given
-with a \sample{\%}-sign it is a relative lightness value ranging from 0\% to~100\%.
+lightness value, for example 0\dots255 for 8~bit data and 0\dots65535 for 16~bit data, or, when
+given with a \sample{\%}-sign it is a relative lightness value ranging from 0\% to~100\%.
 
 To suppress unreal edges or counter excessive noise, use the \option{--contrast\hyp min\hyp
   curvature}~option with a \emph{negative} curvature measure~\metavar{CURVATURE}.  This forces
diff -r ef8470f9d682 doc/enfuse-expert-fusion-options.tex
--- a/doc/enfuse-expert-fusion-options.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/enfuse-expert-fusion-options.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -25,7 +25,7 @@
   \gensee{LoG@\acronym{LoG}}{\propername{Laplacian}-of-\propername{Gaussian}}%
 \item[\itempar{--contrast-edge-scale=\metavar{EDGE-SCALE}\optional{:\feasiblebreak
       \metavar{LCE-SCALE}:\feasiblebreak\metavar{LCE-FACTOR}}}]\itemend
-  A non-zero value for \metavar{EDGE-SCALE} switches on the
+  A nonzero value for \metavar{EDGE-SCALE} switches on the
   \propername{Laplacian}\hyp{}of\hyp{}\propername{Gaussian} (\acronym{LoG}) edge detection
   algorithm.  \metavar{EDGE-SCALE} is the radius of the \propername{Gaussian} used in the search
   for edges.  Default: \val{val:default-edge-scale}~pixels.
@@ -177,7 +177,7 @@
   the active exposure-weight function.
 
   For color images the values of \metalowercutoff{} and \metauppercutoff{} refer to the
-  gray-scale projection as selected with \metalowerprojector{} and \metaupperprojector.  This is
+  grayscale projection as selected with \metalowerprojector{} and \metaupperprojector.  This is
   similar to option~\option{--gray\hyp{}pro\shyp jec\shyp tor}.
 
   Append a \sample{\%}-sign to specify the cutoff relative to maximum pixel value in the source
@@ -228,12 +228,11 @@
   \metalowercutoff{} and \metauppercutoff{} thresholds.
 
   This option can be helpful if the user wants to exclude underexposed or overexposed pixels
-  from the fusing process in \emph{all} of the input images.  The values of
-  \metalowercutoff{} and \metauppercutoff{} as well as the gray-scale projector
-  determine which pixels are considered ``underexposed'' or ``overexposed''.  As any change of
-  the exposure-weight curve this option changes the brightness of the resulting image:
-  increasing \metalowercutoff{} lightens the final image and lowering \metauppercutoff{}
-  darkens it.
+  from the fusing process in \emph{all} of the input images.  The values of \metalowercutoff{}
+  and \metauppercutoff{} as well as the grayscale projector determine which pixels are
+  considered ``underexposed'' or ``overexposed''.  As any change of the exposure-weight curve
+  this option changes the brightness of the resulting image: increasing \metalowercutoff{}
+  lightens the final image and lowering \metauppercutoff{} darkens it.
 
   Defaults: \val{val:default-exposure-lower-cutoff} for \metalowercutoff{} and
   \val{val:default-exposure-upper-cutoff} for \metauppercutoff, that is, all pixels' values are
@@ -241,7 +240,7 @@
 
   \figureName~\ref{fig:exposure-cutoff} shows an example.
 
-  The gray-scale projectors \metalowerprojector{} and \metaupperprojector{} default to
+  The grayscale projectors \metalowerprojector{} and \metaupperprojector{} default to
   \sample{\val{val:default-exposure-lower-cutoff-projector}} and
   \sample{\val{val:default-exposure-upper-cutoff-projector}}, which are usually the best choices
   for effective cutoff operations on the respective ends.
@@ -385,7 +384,7 @@
       \genidx{exposure weight function!fullsine}%
       \genidx{exposure weight function!full-sine}%
     \item[\itempar{fullsine \\ full-sine}]\itemend
-      Full sine-wave shifted upwards by one to give all positive weights; exactly zero outside.
+      Full sine-wave shifted upward by one to give all positive weights; exactly zero outside.
       \begin{equation}\label{equ:weight:fullsine}
       w_{\mathrm{exp}} =
       \left\{\begin{array}{cl}
diff -r ef8470f9d682 doc/enfuse-exposure-weighting-user-dynamic.tex
--- a/doc/enfuse-exposure-weighting-user-dynamic.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/enfuse-exposure-weighting-user-dynamic.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -6,10 +6,8 @@
   \genidx{weighting!exposure!user-defined!dynamically-linked}%
   User-Defined, Dynamically-Linked Exposure Weighting Functions}
 
-%% -- Commented out for Stable Branch 4.2
-%% -- Commented out for Stable Branch 4.2
-%% See also \sectionName~\ref{sec:user-defined-opencl-functions} below on defining weighting
-%% functions via \acronym{OpenCL}.
+See also \sectionName~\ref{sec:user-defined-opencl-functions} below on defining weighting
+functions via \acronym{OpenCL}.
 
 \restrictednote{\acronym{Dynamic Linking}-enabled versions only.}
 
@@ -205,12 +203,12 @@
   \begin{sloppypar}
     Derive the weight function from the supplied C++ base-class~\code{ExposureWeight}, which is
     defined in header file~\filename{exposure\_weight\_base.h}.  It resides in the
-    \filename{src}~sub-directory of the source distribution and -- for a correctly installed
+    \filename{src}~subdirectory of the source distribution and -- for a correctly installed
     package -- in directory \filename{\val*{val:DOCDIR}\slash examples\slash enfuse}.
   \end{sloppypar}
 
 \item
-  At least override method~\code{weight}.
+  At least override member function~\code{weight}.
 
   \begin{itemize}
   \item
@@ -243,8 +241,8 @@
 
   Technically, the functors which the user-defined weight functions are part of are
   copy-constructed for each \acronym{OpenMP} worker thread.  Thus, there is no contention within
-  the \code{ExposureWeight} sub-classes.  Although, if \code{normalize} or \code{weight} access
-  a shared resource these accesses must be protected by serialization instructions.  One
+  the derived classes of \code{ExposureWeight}.  Although, if \code{normalize} or \code{weight}
+  access a shared resource these accesses must be protected by serialization instructions.  One
   solution is to use \acronym{OpenMP} directives, like for example,
 
   \begin{cxxlisting}
@@ -255,8 +253,8 @@
   \end{cxxlisting}
 
   Experienced hackers will recognize occasions when to prefer other constructs, like, for
-  example \code{\#pragma omp atomic} or simply an atomic data-type (e.g.~\code{sig\_atomic\_t}
-  from \filename{signal.h}).
+  example \code{\#pragma omp atomic} or simply an atomic data-type (for example
+  \code{sig\_atomic\_t} from \filename{signal.h}).
 
   Remember to compile all modules that use \acronym{OpenMP} directives with the
   (compiler-specific) flags that turn on \acronym{OpenMP}.  For \command{g++} this is
@@ -268,17 +266,18 @@
   \begin{literal}
     ExposureWeight::error(const std::string\& message)
   \end{literal}
-  \App{} catches these exceptions at an enclosing scope, displays \metavar{message}, and aborts.
+  \App{} catches these exceptions at an enclosing scope, displays \metavar{message}, and
+  terminates.
 
 \item
   Define an object of the derived class.  This creates the \metavar{SYMBOL} to refer to at the
   \App{} command line.
 
   The actual signature of the constructor (default, two-argument, \dots) does not matter,
-  because \App{} \emph{always} invokes \code{initialize} before calling any other method of a
-  user-defined \code{ExposureWeight} sub-class.  Method~\code{initialize} sets (read:
-  overwrites) \metavar{optimum} and \metavar{width} and ensures they are within the required
-  parameter range.
+  because \App{} \emph{always} invokes \code{initialize} before calling any other member
+  function of a user-defined, derived class of \code{ExposureWeight}.  Member
+  function~\code{initialize} sets (read: overwrites) \metavar{optimum} and \metavar{width} and
+  ensures they are within the required parameter range.
 \end{enumerate}
 
 \exampleName~\ref{ex:simple-dynamic-exposure-weight-function} shows the C++-code of a suitable
@@ -318,9 +317,9 @@
   \caption[Simple dynamic exposure weight function]%
           {\label{ex:simple-dynamic-exposure-weight-function}%
             A dynamic exposure weight function that defines a ``roof-top''.  The natural width
-            is exactly one, so we override method~\code{initialize} to rescale \metavar{WIDTH},
-            passed in as \code{width\_parameter}, by multiplying with \code{FWHM\_GAUSSIAN} to
-            get the same width as the predefined Gaussian.}
+            is exactly one, so we override member function~\code{initialize} to rescale
+            \metavar{WIDTH}, passed in as \code{width\_parameter}, by multiplying with
+            \code{FWHM\_GAUSSIAN} to get the same width as the predefined Gaussian.}
 \end{exemplar}
 
 
@@ -435,11 +434,11 @@
   \genidx{performance considerations}%
   Performance Considerations}
 
-Exposure weighting objects are created and destroyed only $O(1)$~times.  Thus,
-method~\code{initialize} could be used to perform all kinds of computationally expensive tasks.
-In contrast, methods~\code{normalize} and \code{weight} are called for \emph{every} pixel in
-\emph{each} of the input images.  Therefore, if performance of the weight function is a problem,
-these two functions are the prime candidates for optimization.
+Exposure weighting objects are created and destroyed only $O(1)$~times.  Thus, member
+function~\code{initialize} could be used to perform all kinds of computationally expensive
+tasks.  In contrast, methods~\code{normalize} and \code{weight} are called for \emph{every}
+pixel in \emph{each} of the input images.  Therefore, if performance of the weight function is a
+problem, these two functions are the prime candidates for optimization.
 
 
 \subsubsection[Compiling, Linking, and Loading]{\label{sec:compiling-linking-loading}%
diff -r ef8470f9d682 doc/enfuse-exposure-weighting-user-opencl.tex
--- a/doc/enfuse-exposure-weighting-user-opencl.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/enfuse-exposure-weighting-user-opencl.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -50,7 +50,7 @@
 \end{literal}
 
 If \metavar{SYMBOL} is not found in \metavar{OPENCL-SOURCE} or does not define a suitable
-function, \App{} aborts with an extensive error message.  In
+function, \App{} terminates with an extensive error message.  In
 \exampleName~\ref{ex:opencl-userweight-error} we supply a wrong \metavar{SYMBOL} called
 \sample{foobar}, whereas \filename{variable\_power.cl} -- one of the supplied examples --
 actually defines \sample{weight}.
@@ -157,8 +157,8 @@
   \item[ENFUSE\_FWHM\_GAUSSIAN]\itemend
     Shorthand for the width of \App's first ever weight function, \sample{gauss} (see
     \sectionName~\ref{sec:built-in-functions}).  Use the value to rescale the width of the newly
-    written user function to make it behave like a predefined one with respect to the full-width
-    at half of the maximum.
+    written user function to make it act like a predefined one with respect to the full-width at
+    half of the maximum.
 
     The actual value, $2 \sqrt{2 \log(2)}$, is approximately 2.35482.
 
diff -r ef8470f9d682 doc/enfuse-exposure-weighting.tex
--- a/doc/enfuse-exposure-weighting.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/enfuse-exposure-weighting.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -111,7 +111,7 @@
     & \code{halfsine}, \code{half-sine} &
     \fullref*{equ:weight:halfsine} &
     \fullref*{fig:halfsine} \\
-    Full sine-wave shifted upwards by one%
+    Full sine-wave shifted upward by one%
     \genidx{exposure weight function!\code{fullsine}}%
     \genidx{exposure weight function!\code{full-sine}}%
     & \code{fullsine}, \code{full-sine} &
@@ -270,13 +270,11 @@
   \genidx{weighting!exposure!user-defined}%
   User-Defined Exposure Weighting Functions}
 
-%% -- Commented out for Stable Branch 4.2
-%% Depending on how \App{} was compiled it may support dynamically-linked exposure weighting
-%% functions, \acronym{OpenCL} exposure weighting functions, or both.
+Depending on how \App{} was compiled it may support dynamically-linked exposure weighting
+functions, \acronym{OpenCL} exposure weighting functions, or both.
 
 \input{enfuse-exposure-weighting-user-dynamic}
-%% -- Commented out for Stable Branch 4.2
-%%\input{enfuse-exposure-weighting-user-opencl}
+\input{enfuse-exposure-weighting-user-opencl}
 
 
 %%% Local Variables:
diff -r ef8470f9d682 doc/enfuse-image-requirements.tex
--- a/doc/enfuse-image-requirements.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/enfuse-image-requirements.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -14,7 +14,7 @@
   The images overlap.
 
 \item
-  The images agree on their number of bits-per-channel, i.e., their ``depth'':
+  The images agree on their number of bits-per-channel, this is their ``depth'':
   \begin{itemize}
   \item
     \code{uint8},
@@ -23,7 +23,7 @@
   \item
     \code{float},
   \item
-    etc.
+    \dots
   \end{itemize}
 
   See option~\option{--depth} below for an explanation of different (output) depths.
@@ -44,7 +44,7 @@
   \emph{same} \acronym{ICC} profile.
 
 \item
-  If the images' meta-data contains resolution information (``\acronym{DPI}''), it is the same
+  If the images' metadata contains resolution information (``\acronym{DPI}''), it is the same
   for all pictures.
 \end{itemize}
 
diff -r ef8470f9d682 doc/enfuse-local-contrast-weighting.tex
--- a/doc/enfuse-local-contrast-weighting.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/enfuse-local-contrast-weighting.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -143,7 +143,7 @@
   \propername{Laplacian}-of-\propername{Gaussian} operator,
   \uref{\hciiwrvigracommonfilters}{\code{vigra::laplacianOfGaussian}} is part of the
   package~\uref{\hciiwrvigra}{\acronym{VIGRA}} that \App{} is built upon and is used for edge
-  detection if option~\option{--contrast-edge-scale} is non-zero and
+  detection if option~\option{--contrast-edge-scale} is nonzero and
   \option{--contrast-min-curvature} equal to or less than zero.
 \end{sloppypar}
 
@@ -227,11 +227,11 @@
 \metavar{CURVATURE}, and the scaled \acronym{SDev} is used as weight.
 
 This technique merges the two edge detection methods where they are best.  The \acronym{LoG}
-excels with clear edges and cannot be fooled by strong but smooth gradients.  However, it is bad
-at detecting faint edges and it is susceptible to noise.  The \acronym{SDev} on the other hand
-shines with even the most marginal edges, and resists noise quite well.  Its weakness is that is
-is easily deceived by strong and smooth gradients.  Tuning \metavar{CURVATURE} the user can pick
-the best threshold for a given set of images.
+excels with clear edges and cannot be fooled by strong but smooth gradients.  However, it is
+inferior at detecting faint edges and it is susceptible to noise.  The \acronym{SDev} on the
+other hand shines with even the most marginal edges, and resists noise quite well.  Its weakness
+is that is is easily deceived by strong and smooth gradients.  Tuning \metavar{CURVATURE} the
+user can pick the best threshold for a given set of images.
 
 \begin{optionsummary}
 \item[--contrast-edge-scale] \sectionName~\fullref{opt:contrast-edge-scale}
diff -r ef8470f9d682 doc/enfuse-weighting-functions.tex
--- a/doc/enfuse-weighting-functions.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/enfuse-weighting-functions.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -34,7 +34,7 @@
 
 \begin{itemize}
 \item
-  each $w$ is non-negative to yield a physical intensity and
+  each $w$ is nonnegative to yield a physical intensity and
 
 \item
   the sum of all $w$ is 1 to leave the total intensity unchanged.
@@ -64,9 +64,9 @@
   \gensee{weighted average}{average, weighted}%
   Weighted Average}
 
-By default, \App{} uses a weighted average, where \emph{each} pixel contributes as much as its
+By default \App{} uses a weighted average, where \emph{each} pixel contributes as much as its
 weight demands.  Of course the weights can be extreme, favoring only a few pixels or even only
-one pixel in the input stack.  Extremes are not typical, however.
+one pixel in the input stack.  However, such extremes are not typical.
 
 Equal weights are another extreme that turns \eqnref{equ:weight} into an arithmetic average.
 This is why we sometimes speak of the ``averaging property'' of this weighting algorithm, like
@@ -104,9 +104,9 @@
   Single Criterion Fusing}
 
 \App{} allows the user to weight each pixel of an input image by up to four different criteria
-(see e.g.\ \chapterName~\fullref{sec:overview}).  However, it does not force the user to do so.
-For some applications and more often simply to gain further insight into the weighting and
-fusing process, looking at only a single criterion is the preferred way to work.
+(see for example \chapterName~\fullref{sec:overview}).  However, it does not force the user to
+do so.  For some applications and more often simply to gain further insight into the weighting
+and fusing process, looking at only a single criterion is the preferred way to work.
 
 \genidx{criteria!active}%
 \gensee{active criteria}{criteria, active}%
diff -r ef8470f9d682 doc/enfuse.tex
--- a/doc/enfuse.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/enfuse.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -29,11 +29,13 @@
 \newcommand*{\app}{enfuse}
 \newcommand*{\appcmd}{\command{enfuse}}
 \newcommand*{\appdoes}{fuse}
+\newcommand*{\appisdoing}{fusing}
 \newcommand*{\appdid}{fused}
 
 \newcommand*{\OtherApp}{\application{Enblend}}
 \newcommand*{\otherapp}{enblend}
 \newcommand*{\otherappcmd}{\command{enblend}}
+\newcommand*{\otherappdoes}{blend}
 
 
 \finishdynamicpreamble
diff -r ef8470f9d682 doc/index-use.tex
--- a/doc/index-use.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/index-use.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -6,7 +6,7 @@
 \RaggedRight
 
 \phantomsection
-\addcontentsline{toc}{chapter}{Indices}
+\addcontentsline{toc}{chapter}{Indexes}
 
 \phantomsection
 \addcontentsline{toc}{section}{\ahrefloc{sec:syncomm-index}{Syntactic Comment Index}}
@@ -46,8 +46,8 @@
   \printindex[general]%
 \else
   \printindex[general][Locations marked like \underline{12} indicate the location where a term
-    gets introduced or defined.  Tables, lists, etc.\ that summarize material are indicated like
-    \textsl{34}.\par]%
+    gets introduced or defined.  Tables, lists, and so on that summarize material are indicated
+    like \textsl{34}.\par]%
 \fi
 
 
diff -r ef8470f9d682 doc/lead-in.tex
--- a/doc/lead-in.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/lead-in.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -9,9 +9,9 @@
 \bigskip
 
 \begin{quotation}
-  \noindent Chapters or sections marked with a ``\commonpart''-sign appear in both manuals,
-  i.e.\ the \App{} manual and the \OtherApp{} manual.  The commonality extends to \emph{all}
-  sub-sections of the marked one.
+  \noindent Chapters or sections marked with a ``\commonpart''-sign appear in both manuals, this
+  is the \App{} manual and the \OtherApp{} manual.  The commonality extends to \emph{all}
+  subsections of the marked one.
 \end{quotation}
 
 \ifhevea
diff -r ef8470f9d682 doc/macros.tex
--- a/doc/macros.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/macros.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -149,7 +149,7 @@
 \newcommand*{\flexipageref}[2]{\ifhevea\ahrefloc{#2}{#1}\else #1, \pagename~\pageref{#2}\fi}
 \WithSuffix\newcommand\flexipageref*[2]{\ifhevea\ahrefloc{#2}{#1}\else #1 (\pagename~\pageref{#2})\fi}
 \newcommand*{\manpage}[2]{#1(#2)}
-\newcommand*{\semilog}[2]{\mbox{${#1}\cdot 10^{#2}$}} % \cdot or \times
+\newcommand*{\semilog}[2]{\mbox{${#1}\cdot10^{#2}$}} % \cdot or \times, but no space before 10
 \newcommand*{\slfrac}[2]% Knuth, answer to Question 11.6 rewritten with LaTeX macros
 {\ifhevea #1/#2\else
   \hspace{.1em}\raisebox{.5ex}{\scriptsize #1}\hspace{-.1em}/%
@@ -326,7 +326,7 @@
 %% Literal text as e.g. the contents of a text file.
 \newenvironment{literal}%
 {\pagebreak[1]\begin{divstyle}{literal}%
-    \begin{trivlist}{}{\ifhevea\relax\else\topsep=0pt\fi}\item\relax
+    \begin{trivlist}{}{\ifhevea\relax\else\topsep=0pt\partopsep=0pt\fi}\item\relax
       \RaggedRight\frenchspacing\ttfamily}%
 {\end{trivlist}\end{divstyle}}
 
diff -r ef8470f9d682 doc/static-preamble.tex
--- a/doc/static-preamble.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/static-preamble.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -89,7 +89,7 @@
 
 \hyphenation{%
   ba-roque
-  cat-ches chro-mi-n-ance
+  cat-ches chro-mi-n-ance col-or col-or-space
   DC-Raw
   En-blend En-fuse en-tro-py
   gray-scale
diff -r ef8470f9d682 doc/url-def.tex
--- a/doc/url-def.tex	Sun Feb 12 15:25:10 2017 +0100
+++ b/doc/url-def.tex	Mon Apr 27 19:55:56 2020 -0700
@@ -7,6 +7,7 @@
 %%     tail --follow url-state.log
 
 
+\urldef{\adobexmp}{\url}{https://www.adobe.com/products/xmp.html}
 \urldef{\awaresystemsbeextrasamples}{\url}{http://www.awaresystems.be/imaging/tiff/tifftags/extrasamples.html}
 \urldef{\brucelindbloomworkingspaceinfo}{\url}{http://www.brucelindbloom.com/index.html?WorkingSpaceInfo.html}
 \urldef{\cambridgeincolourcomunsharpmask}{\url}{http://www.cambridgeincolour.com/tutorials/unsharp-mask.htm}
@@ -19,6 +20,9 @@
 \urldef{\enblendhgcodesfnet}{\url}{http://hg.code.sf.net/p/enblend/code}
 \urldef{\enblendsourceforgenet}{\url}{http://enblend.sourceforge.net/}
 \urldef{\ericbrasseurgamma}{\url}{http://www.4p8.com/eric.brasseur/gamma.html}
+\urldef{\exiforg}{\url}{http://www.exif.org/}
+\urldef{\exiviiorgtags}{\url}{http://www.exiv2.org/tags.html}
+\urldef{\exiviiorg}{\url}{http://www.exiv2.org/}
 \urldef{\gccgnuorg}{\url}{https://gcc.gnu.org/}
 \urldef{\gimpguruorgblendingexposures}{\url}{https://www.gimp.org/tutorials/Blending_Exposures/}
 \urldef{\gimporg}{\url}{http://www.gimp.org/}
@@ -38,18 +42,22 @@
 \urldef{\imagemagickorgusagechannelstrans}{\url}{https://www.imagemagick.org/Usage/transform/}
 \urldef{\imagemagickorgusagefileshistogram}{\url}{https://www.imagemagick.org/Usage/files/#histogram}
 \urldef{\imagemagickorg}{\url}{https://www.imagemagick.org/script/index.php}
+\urldef{\iptcorg}{\url}{https://iptc.org/}
 \urldef{\kernelorgglob}{\url}{http://man7.org/linux/man-pages/man7/glob.7.html}
 \urldef{\khronosorgopencl}{\url}{https://www.khronos.org/opencl/}
 \urldef{\launchpadnet}{\url}{https://launchpad.net/}
 \urldef{\libpngorg}{\url}{http://www.libpng.org/pub/png/libpng.html}
+\urldef{\littlecmscomunboundedcmm}{\url}{http://www.littlecms.com/CIC18_UnboundedCMM.pdf}
 \urldef{\littlecmscom}{\url}{http://www.littlecms.com/}
-\urldef{\littlecmscomunboundedcmm}{\url}{http://www.littlecms.com/CIC18_UnboundedCMM.pdf}
 \urldef{\llvm}{\url}{http://llvm.org/}
 \urldef{\luminouslandscapebokeh}{\url}{https://luminous-landscape.com/bokeh/}
 \urldef{\luminouslandscapedigitalblending}{\url}{https://luminous-landscape.com/digital-blending/}
 \urldef{\luminouslandscaperawfiles}{\url}{https://luminous-landscape.com/understanding-raw-files-explained/}
 \urldef{\magiclanternfm}{\url}{http://www.magiclantern.fm/index.html}
+\urldef{\manorgfseek}{\url}{http://man7.org/linux/man-pages/man3/fseek.3.html}
 \urldef{\mercurialseleniccom}{\url}{https://www.mercurial-scm.org/}
+\urldef{\netpbmdoc}{\url}{http://netpbm.sourceforge.net/doc/}
+\urldef{\netpbm}{\url}{http://netpbm.sourceforge.net/}
 \urldef{\openexrcomfeatures}{\url}{http://www.openexr.com/about.html#features}
 \urldef{\openexrcom}{\url}{http://www.openexr.com/}
 \urldef{\openmporg}{\url}{http://openmp.org/wp/}
@@ -57,6 +65,8 @@
 \urldef{\pfstoolssourceforgenet}{\url}{http://pfstools.sourceforge.net/}
 \urldef{\rawtherapeecom}{\url}{http://www.rawtherapee.com/}
 \urldef{\remotesensingorglibtiff}{\url}{http://www.remotesensing.org/libtiff/}
+\urldef{\smartquestions}{\url}{http://www.catb.org/~esr/faqs/smart-questions.html}
+\urldef{\snophyqueensucaexiftooltagnames}{\url}{http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/}
 \urldef{\snophyqueensucaexiftool}{\url}{http://www.sno.phy.queensu.ca/~phil/exiftool/}
 \urldef{\sourceforgenet}{\url}{http://sourceforge.net/}
 \urldef{\stargatewikiathetomb}{\url}{http://stargate.wikia.com/wiki/The_Tomb}
@@ -73,6 +83,7 @@
 \urldef{\wikipediaiccprofile}{\url}{https://en.wikipedia.org/wiki/ICC_profile}
 \urldef{\wikipediainformationentropy}{\url}{https://en.wikipedia.org/wiki/Information_entropy}
 \urldef{\wikipedialabcolorspace}{\url}{https://en.wikipedia.org/wiki/Lab_color_space}
+\urldef{\wikipedianetpbmformat}{\url}{https://en.wikipedia.org/wiki/Netpbm_format}
 \urldef{\wikipediaparallax}{\url}{https://en.wikipedia.org/wiki/Parallax}
 \urldef{\wikipediasimulatedannealing}{\url}{https://en.wikipedia.org/wiki/Simulated_annealing}
 \urldef{\wikipediastandardilluminant}{\url}{https://en.wikipedia.org/wiki/Standard_illuminant}
diff -r ef8470f9d682 m4/ax_boost_base.m4
--- a/m4/ax_boost_base.m4	Sun Feb 12 15:25:10 2017 +0100
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,272 +0,0 @@
-# ===========================================================================
-#       http://www.gnu.org/software/autoconf-archive/ax_boost_base.html
-# ===========================================================================
-#
-# SYNOPSIS
-#
-#   AX_BOOST_BASE([MINIMUM-VERSION], [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])
-#
-# DESCRIPTION
-#
-#   Test for the Boost C++ libraries of a particular version (or newer)
-#
-#   If no path to the installed boost library is given the macro searchs
-#   under /usr, /usr/local, /opt and /opt/local and evaluates the
-#   $BOOST_ROOT environment variable. Further documentation is available at
-#   <http://randspringer.de/boost/index.html>.
-#
-#   This macro calls:
-#
-#     AC_SUBST(BOOST_CPPFLAGS) / AC_SUBST(BOOST_LDFLAGS)
-#
-#   And sets:
-#
-#     HAVE_BOOST
-#
-# LICENSE
-#
-#   Copyright (c) 2008 Thomas Porschberg <thomas@randspringer.de>
-#   Copyright (c) 2009 Peter Adolphs
-#
-#   Copying and distribution of this file, with or without modification, are
-#   permitted in any medium without royalty provided the copyright notice
-#   and this notice are preserved. This file is offered as-is, without any
-#   warranty.
-
-#serial 23
-
-AC_DEFUN([AX_BOOST_BASE],
-[
-AC_ARG_WITH([boost],
-  [AS_HELP_STRING([--with-boost@<:@=ARG@:>@],
-    [use Boost library from a standard location (ARG=yes),
-     from the specified location (ARG=<path>),
-     or disable it (ARG=no)
-     @<:@ARG=yes@:>@ ])],
-    [
-    if test "$withval" = "no"; then
-        want_boost="no"
-    elif test "$withval" = "yes"; then
-        want_boost="yes"
-        ac_boost_path=""
-    else
-        want_boost="yes"
-        ac_boost_path="$withval"
-    fi
-    ],
-    [want_boost="yes"])
-
-
-AC_ARG_WITH([boost-libdir],
-        AS_HELP_STRING([--with-boost-libdir=LIB_DIR],
-        [Force given directory for boost libraries. Note that this will override library path detection, so use this parameter only if default library detection fails and you know exactly where your boost libraries are located.]),
-        [
-        if test -d "$withval"
-        then
-                ac_boost_lib_path="$withval"
-        else
-                AC_MSG_ERROR(--with-boost-libdir expected directory name)
-        fi
-        ],
-        [ac_boost_lib_path=""]
-)
-
-if test "x$want_boost" = "xyes"; then
-    boost_lib_version_req=ifelse([$1], ,1.20.0,$1)
-    boost_lib_version_req_shorten=`expr $boost_lib_version_req : '\([[0-9]]*\.[[0-9]]*\)'`
-    boost_lib_version_req_major=`expr $boost_lib_version_req : '\([[0-9]]*\)'`
-    boost_lib_version_req_minor=`expr $boost_lib_version_req : '[[0-9]]*\.\([[0-9]]*\)'`
-    boost_lib_version_req_sub_minor=`expr $boost_lib_version_req : '[[0-9]]*\.[[0-9]]*\.\([[0-9]]*\)'`
-    if test "x$boost_lib_version_req_sub_minor" = "x" ; then
-        boost_lib_version_req_sub_minor="0"
-        fi
-    WANT_BOOST_VERSION=`expr $boost_lib_version_req_major \* 100000 \+  $boost_lib_version_req_minor \* 100 \+ $boost_lib_version_req_sub_minor`
-    AC_MSG_CHECKING(for boostlib >= $boost_lib_version_req)
-    succeeded=no
-
-    dnl On 64-bit systems check for system libraries in both lib64 and lib.
-    dnl The former is specified by FHS, but e.g. Debian does not adhere to
-    dnl this (as it rises problems for generic multi-arch support).
-    dnl The last entry in the list is chosen by default when no libraries
-    dnl are found, e.g. when only header-only libraries are installed!
-    libsubdirs="lib"
-    ax_arch=`uname -m`
-    case $ax_arch in
-      x86_64|ppc64|s390x|sparc64|aarch64)
-        libsubdirs="lib64 lib lib64"
-        ;;
-    esac
-
-    dnl allow for real multi-arch paths e.g. /usr/lib/x86_64-linux-gnu. Give
-    dnl them priority over the other paths since, if libs are found there, they
-    dnl are almost assuredly the ones desired.
-    AC_REQUIRE([AC_CANONICAL_HOST])
-    libsubdirs="lib/${host_cpu}-${host_os} $libsubdirs"
-
-    case ${host_cpu} in
-      i?86)
-        libsubdirs="lib/i386-${host_os} $libsubdirs"
-        ;;
-    esac
-
-    dnl first we check the system location for boost libraries
-    dnl this location ist chosen if boost libraries are installed with the --layout=system option
-    dnl or if you install boost with RPM
-    if test "$ac_boost_path" != ""; then
-        BOOST_CPPFLAGS="-I$ac_boost_path/include"
-        for ac_boost_path_tmp in $libsubdirs; do
-                if test -d "$ac_boost_path"/"$ac_boost_path_tmp" ; then
-                        BOOST_LDFLAGS="-L$ac_boost_path/$ac_boost_path_tmp"
-                        break
-                fi
-        done
-    elif test "$cross_compiling" != yes; then
-        for ac_boost_path_tmp in /usr /usr/local /opt /opt/local ; do
-            if test -d "$ac_boost_path_tmp/include/boost" && test -r "$ac_boost_path_tmp/include/boost"; then
-                for libsubdir in $libsubdirs ; do
-                    if ls "$ac_boost_path_tmp/$libsubdir/libboost_"* >/dev/null 2>&1 ; then break; fi
-                done
-                BOOST_LDFLAGS="-L$ac_boost_path_tmp/$libsubdir"
-                BOOST_CPPFLAGS="-I$ac_boost_path_tmp/include"
-                break;
-            fi
-        done
-    fi
-
-    dnl overwrite ld flags if we have required special directory with
-    dnl --with-boost-libdir parameter
-    if test "$ac_boost_lib_path" != ""; then
-       BOOST_LDFLAGS="-L$ac_boost_lib_path"
-    fi
-
-    CPPFLAGS_SAVED="$CPPFLAGS"
-    CPPFLAGS="$CPPFLAGS $BOOST_CPPFLAGS"
-    export CPPFLAGS
-
-    LDFLAGS_SAVED="$LDFLAGS"
-    LDFLAGS="$LDFLAGS $BOOST_LDFLAGS"
-    export LDFLAGS
-
-    AC_REQUIRE([AC_PROG_CXX])
-    AC_LANG_PUSH(C++)
-        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-    @%:@include <boost/version.hpp>
-    ]], [[
-    #if BOOST_VERSION >= $WANT_BOOST_VERSION
-    // Everything is okay
-    #else
-    #  error Boost version is too old
-    #endif
-    ]])],[
-        AC_MSG_RESULT(yes)
-    succeeded=yes
-    found_system=yes
-        ],[
-        ])
-    AC_LANG_POP([C++])
-
-
-
-    dnl if we found no boost with system layout we search for boost libraries
-    dnl built and installed without the --layout=system option or for a staged(not installed) version
-    if test "x$succeeded" != "xyes"; then
-        _version=0
-        if test "$ac_boost_path" != ""; then
-            if test -d "$ac_boost_path" && test -r "$ac_boost_path"; then
-                for i in `ls -d $ac_boost_path/include/boost-* 2>/dev/null`; do
-                    _version_tmp=`echo $i | sed "s#$ac_boost_path##" | sed 's/\/include\/boost-//' | sed 's/_/./'`
-                    V_CHECK=`expr $_version_tmp \> $_version`
-                    if test "$V_CHECK" = "1" ; then
-                        _version=$_version_tmp
-                    fi
-                    VERSION_UNDERSCORE=`echo $_version | sed 's/\./_/'`
-                    BOOST_CPPFLAGS="-I$ac_boost_path/include/boost-$VERSION_UNDERSCORE"
-                done
-            fi
-        else
-            if test "$cross_compiling" != yes; then
-                for ac_boost_path in /usr /usr/local /opt /opt/local ; do
-                    if test -d "$ac_boost_path" && test -r "$ac_boost_path"; then
-                        for i in `ls -d $ac_boost_path/include/boost-* 2>/dev/null`; do
-                            _version_tmp=`echo $i | sed "s#$ac_boost_path##" | sed 's/\/include\/boost-//' | sed 's/_/./'`
-                            V_CHECK=`expr $_version_tmp \> $_version`
-                            if test "$V_CHECK" = "1" ; then
-                                _version=$_version_tmp
-                                best_path=$ac_boost_path
-                            fi
-                        done
-                    fi
-                done
-
-                VERSION_UNDERSCORE=`echo $_version | sed 's/\./_/'`
-                BOOST_CPPFLAGS="-I$best_path/include/boost-$VERSION_UNDERSCORE"
-                if test "$ac_boost_lib_path" = ""; then
-                    for libsubdir in $libsubdirs ; do
-                        if ls "$best_path/$libsubdir/libboost_"* >/dev/null 2>&1 ; then break; fi
-                    done
-                    BOOST_LDFLAGS="-L$best_path/$libsubdir"
-                fi
-            fi
-
-            if test "x$BOOST_ROOT" != "x"; then
-                for libsubdir in $libsubdirs ; do
-                    if ls "$BOOST_ROOT/stage/$libsubdir/libboost_"* >/dev/null 2>&1 ; then break; fi
-                done
-                if test -d "$BOOST_ROOT" && test -r "$BOOST_ROOT" && test -d "$BOOST_ROOT/stage/$libsubdir" && test -r "$BOOST_ROOT/stage/$libsubdir"; then
-                    version_dir=`expr //$BOOST_ROOT : '.*/\(.*\)'`
-                    stage_version=`echo $version_dir | sed 's/boost_//' | sed 's/_/./g'`
-                        stage_version_shorten=`expr $stage_version : '\([[0-9]]*\.[[0-9]]*\)'`
-                    V_CHECK=`expr $stage_version_shorten \>\= $_version`
-                    if test "$V_CHECK" = "1" -a "$ac_boost_lib_path" = "" ; then
-                        AC_MSG_NOTICE(We will use a staged boost library from $BOOST_ROOT)
-                        BOOST_CPPFLAGS="-I$BOOST_ROOT"
-                        BOOST_LDFLAGS="-L$BOOST_ROOT/stage/$libsubdir"
-                    fi
-                fi
-            fi
-        fi
-
-        CPPFLAGS="$CPPFLAGS $BOOST_CPPFLAGS"
-        export CPPFLAGS
-        LDFLAGS="$LDFLAGS $BOOST_LDFLAGS"
-        export LDFLAGS
-
-        AC_LANG_PUSH(C++)
-            AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-        @%:@include <boost/version.hpp>
-        ]], [[
-        #if BOOST_VERSION >= $WANT_BOOST_VERSION
-        // Everything is okay
-        #else
-        #  error Boost version is too old
-        #endif
-        ]])],[
-            AC_MSG_RESULT(yes)
-        succeeded=yes
-        found_system=yes
-            ],[
-            ])
-        AC_LANG_POP([C++])
-    fi
-
-    if test "$succeeded" != "yes" ; then
-        if test "$_version" = "0" ; then
-            AC_MSG_NOTICE([[We could not detect the boost libraries (version $boost_lib_version_req_shorten or higher). If you have a staged boost library (still not installed) please specify \$BOOST_ROOT in your environment and do not give a PATH to --with-boost option.  If you are sure you have boost installed, then check your version number looking in <boost/version.hpp>. See http://randspringer.de/boost for more documentation.]])
-        else
-            AC_MSG_NOTICE([Your boost libraries seems to old (version $_version).])
-        fi
-        # execute ACTION-IF-NOT-FOUND (if present):
-        ifelse([$3], , :, [$3])
-    else
-        AC_SUBST(BOOST_CPPFLAGS)
-        AC_SUBST(BOOST_LDFLAGS)
-        AC_DEFINE(HAVE_BOOST,,[define if the Boost library is available])
-        # execute ACTION-IF-FOUND (if present):
-        ifelse([$2], , :, [$2])
-    fi
-
-    CPPFLAGS="$CPPFLAGS_SAVED"
-    LDFLAGS="$LDFLAGS_SAVED"
-fi
-
-])
diff -r ef8470f9d682 m4/ax_boost_system.m4
--- a/m4/ax_boost_system.m4	Sun Feb 12 15:25:10 2017 +0100
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,120 +0,0 @@
-# ===========================================================================
-#      http://www.gnu.org/software/autoconf-archive/ax_boost_system.html
-# ===========================================================================
-#
-# SYNOPSIS
-#
-#   AX_BOOST_SYSTEM
-#
-# DESCRIPTION
-#
-#   Test for System library from the Boost C++ libraries. The macro requires
-#   a preceding call to AX_BOOST_BASE. Further documentation is available at
-#   <http://randspringer.de/boost/index.html>.
-#
-#   This macro calls:
-#
-#     AC_SUBST(BOOST_SYSTEM_LIB)
-#
-#   And sets:
-#
-#     HAVE_BOOST_SYSTEM
-#
-# LICENSE
-#
-#   Copyright (c) 2008 Thomas Porschberg <thomas@randspringer.de>
-#   Copyright (c) 2008 Michael Tindal
-#   Copyright (c) 2008 Daniel Casimiro <dan.casimiro@gmail.com>
-#
-#   Copying and distribution of this file, with or without modification, are
-#   permitted in any medium without royalty provided the copyright notice
-#   and this notice are preserved. This file is offered as-is, without any
-#   warranty.
-
-#serial 17
-
-AC_DEFUN([AX_BOOST_SYSTEM],
-[
-        AC_ARG_WITH([boost-system],
-        AS_HELP_STRING([--with-boost-system@<:@=special-lib@:>@],
-                   [use the System library from boost - it is possible to specify a certain library for the linker
-                        e.g. --with-boost-system=boost_system-gcc-mt ]),
-        [
-        if test "$withval" = "no"; then
-                        want_boost="no"
-        elif test "$withval" = "yes"; then
-            want_boost="yes"
-            ax_boost_user_system_lib=""
-        else
-                    want_boost="yes"
-                ax_boost_user_system_lib="$withval"
-                fi
-        ],
-        [want_boost="yes"]
-        )
-
-        if test "x$want_boost" = "xyes"; then
-        AC_REQUIRE([AC_PROG_CC])
-        AC_REQUIRE([AC_CANONICAL_BUILD])
-                CPPFLAGS_SAVED="$CPPFLAGS"
-                CPPFLAGS="$CPPFLAGS $BOOST_CPPFLAGS"
-                export CPPFLAGS
-
-                LDFLAGS_SAVED="$LDFLAGS"
-                LDFLAGS="$LDFLAGS $BOOST_LDFLAGS"
-                export LDFLAGS
-
-        AC_CACHE_CHECK(whether the Boost::System library is available,
-                                           ax_cv_boost_system,
-        [AC_LANG_PUSH([C++])
-                         CXXFLAGS_SAVE=$CXXFLAGS
-
-                         AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[@%:@include <boost/system/error_code.hpp>]],
-                                   [[boost::system::system_category]])],
-                   ax_cv_boost_system=yes, ax_cv_boost_system=no)
-                         CXXFLAGS=$CXXFLAGS_SAVE
-             AC_LANG_POP([C++])
-                ])
-                if test "x$ax_cv_boost_system" = "xyes"; then
-                        AC_SUBST(BOOST_CPPFLAGS)
-
-                        AC_DEFINE(HAVE_BOOST_SYSTEM,,[define if the Boost::System library is available])
-            BOOSTLIBDIR=`echo $BOOST_LDFLAGS | sed -e 's/@<:@^\/@:>@*//'`
-
-                        LDFLAGS_SAVE=$LDFLAGS
-            if test "x$ax_boost_user_system_lib" = "x"; then
-                for libextension in `ls -r $BOOSTLIBDIR/libboost_system* 2>/dev/null | sed 's,.*/lib,,' | sed 's,\..*,,'` ; do
-                     ax_lib=${libextension}
-                                    AC_CHECK_LIB($ax_lib, exit,
-                                 [BOOST_SYSTEM_LIB="-l$ax_lib"; AC_SUBST(BOOST_SYSTEM_LIB) link_system="yes"; break],
-                                 [link_system="no"])
-                                done
-                if test "x$link_system" != "xyes"; then
-                for libextension in `ls -r $BOOSTLIBDIR/boost_system* 2>/dev/null | sed 's,.*/,,' | sed -e 's,\..*,,'` ; do
-                     ax_lib=${libextension}
-                                    AC_CHECK_LIB($ax_lib, exit,
-                                 [BOOST_SYSTEM_LIB="-l$ax_lib"; AC_SUBST(BOOST_SYSTEM_LIB) link_system="yes"; break],
-                                 [link_system="no"])
-                                done
-                fi
-
-            else
-               for ax_lib in $ax_boost_user_system_lib boost_system-$ax_boost_user_system_lib; do
-                                      AC_CHECK_LIB($ax_lib, exit,
-                                   [BOOST_SYSTEM_LIB="-l$ax_lib"; AC_SUBST(BOOST_SYSTEM_LIB) link_system="yes"; break],
-                                   [link_system="no"])
-                  done
-
-            fi
-            if test "x$ax_lib" = "x"; then
-                AC_MSG_ERROR(Could not find a version of the library!)
-            fi
-                        if test "x$link_system" = "xno"; then
-                                AC_MSG_ERROR(Could not link against $ax_lib !)
-                        fi
-                fi
-
-                CPPFLAGS="$CPPFLAGS_SAVED"
-        LDFLAGS="$LDFLAGS_SAVED"
-        fi
-])
diff -r ef8470f9d682 m4/ax_cxx_as_const.m4
--- a/m4/ax_cxx_as_const.m4	Sun Feb 12 15:25:10 2017 +0100
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,41 +0,0 @@
-# SYNOPSIS
-#
-#   AX_CXX_AS_CONST
-#
-# DESCRIPTION
-#
-#   If the C++ compiler supports std::as_const(), define HAVE_AS_CONST.
-#
-# LICENSE
-#
-#   Copyright (c) 2015 Christoph L. Spiel <cspiel@users.sourceforge.net>
-#
-#   Copying and distribution of this file, with or without modification, are
-#   permitted in any medium without royalty provided the copyright notice
-#   and this notice are preserved. This file is offered as-is, without any
-#   warranty.
-
-#serial 1
-
-AU_ALIAS([AC_CXX_AS_CONST], [AX_CXX_AS_CONST])
-AC_DEFUN([AX_CXX_AS_CONST],
-[dnl
-  AC_CACHE_CHECK([whether the compiler supports as_const()], ax_cv_cxx_as_const,
-  [dnl
-    AC_LANG_PUSH([C++])
-    AC_COMPILE_IFELSE([dnl
-      AC_LANG_PROGRAM(dnl
-        [
-#include <string>
-#include <type_traits>
-#include <utility>
-        ],
-        [std::string s("foo");
-const std::string& const_s = std::as_const(s)])],
-      ax_cv_cxx_as_const=yes,
-      ax_cv_cxx_as_const=no)
-    AC_LANG_POP([C++])
-  ])
-  AS_IF([test "X$ax_cv_cxx_as_const" = Xyes],
-    [AC_DEFINE(HAVE_AS_CONST,,[define if the compiler supports as_const()])])
-])
diff -r ef8470f9d682 m4/ax_cxx_compile_stdcxx.m4
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/m4/ax_cxx_compile_stdcxx.m4	Mon Apr 27 19:55:56 2020 -0700
@@ -0,0 +1,981 @@
+# ===========================================================================
+#  https://www.gnu.org/software/autoconf-archive/ax_cxx_compile_stdcxx.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_CXX_COMPILE_STDCXX(VERSION, [ext|noext], [mandatory|optional])
+#
+# DESCRIPTION
+#
+#   Check for baseline language coverage in the compiler for the specified
+#   version of the C++ standard.  If necessary, add switches to CXX and
+#   CXXCPP to enable support.  VERSION may be '11' (for the C++11 standard)
+#   or '14' (for the C++14 standard).
+#
+#   The second argument, if specified, indicates whether you insist on an
+#   extended mode (e.g. -std=gnu++11) or a strict conformance mode (e.g.
+#   -std=c++11).  If neither is specified, you get whatever works, with
+#   preference for an extended mode.
+#
+#   The third argument, if specified 'mandatory' or if left unspecified,
+#   indicates that baseline support for the specified C++ standard is
+#   required and that the macro should error out if no mode with that
+#   support is found.  If specified 'optional', then configuration proceeds
+#   regardless, after defining HAVE_CXX${VERSION} if and only if a
+#   supporting mode is found.
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Benjamin Kosnik <bkoz@redhat.com>
+#   Copyright (c) 2012 Zack Weinberg <zackw@panix.com>
+#   Copyright (c) 2013 Roy Stogner <roystgnr@ices.utexas.edu>
+#   Copyright (c) 2014, 2015 Google Inc.; contributed by Alexey Sokolov <sokolov@google.com>
+#   Copyright (c) 2015 Paul Norman <penorman@mac.com>
+#   Copyright (c) 2015 Moritz Klammler <moritz@klammler.eu>
+#   Copyright (c) 2016 Krzesimir Nowak <qdlacz@gmail.com>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved.  This file is offered as-is, without any
+#   warranty.
+
+#serial 7
+
+dnl  This macro is based on the code from the AX_CXX_COMPILE_STDCXX_11 macro
+dnl  (serial version number 13).
+
+AX_REQUIRE_DEFINED([AC_MSG_WARN])
+AC_DEFUN([AX_CXX_COMPILE_STDCXX], [dnl
+  m4_if([$1], [11], [ax_cxx_compile_alternatives="11 0x"],
+        [$1], [14], [ax_cxx_compile_alternatives="14 1y"],
+        [$1], [17], [ax_cxx_compile_alternatives="17 1z"],
+        [m4_fatal([invalid first argument `$1' to AX_CXX_COMPILE_STDCXX])])dnl
+  m4_if([$2], [], [],
+        [$2], [ext], [],
+        [$2], [noext], [],
+        [m4_fatal([invalid second argument `$2' to AX_CXX_COMPILE_STDCXX])])dnl
+  m4_if([$3], [], [ax_cxx_compile_cxx$1_required=true],
+        [$3], [mandatory], [ax_cxx_compile_cxx$1_required=true],
+        [$3], [optional], [ax_cxx_compile_cxx$1_required=false],
+        [m4_fatal([invalid third argument `$3' to AX_CXX_COMPILE_STDCXX])])
+  AC_LANG_PUSH([C++])dnl
+  ac_success=no
+  AC_CACHE_CHECK(whether $CXX supports C++$1 features by default,
+  ax_cv_cxx_compile_cxx$1,
+  [AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],
+    [ax_cv_cxx_compile_cxx$1=yes],
+    [ax_cv_cxx_compile_cxx$1=no])])
+  if test x$ax_cv_cxx_compile_cxx$1 = xyes; then
+    ac_success=yes
+  fi
+
+  m4_if([$2], [noext], [], [dnl
+  if test x$ac_success = xno; then
+    for alternative in ${ax_cxx_compile_alternatives}; do
+      switch="-std=gnu++${alternative}"
+      cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx$1_$switch])
+      AC_CACHE_CHECK(whether $CXX supports C++$1 features with $switch,
+                     $cachevar,
+        [ac_save_CXX="$CXX"
+         CXX="$CXX $switch"
+         AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],
+          [eval $cachevar=yes],
+          [eval $cachevar=no])
+         CXX="$ac_save_CXX"])
+      if eval test x\$$cachevar = xyes; then
+        CXX="$CXX $switch"
+        if test -n "$CXXCPP" ; then
+          CXXCPP="$CXXCPP $switch"
+        fi
+        ac_success=yes
+        break
+      fi
+    done
+  fi])
+
+  m4_if([$2], [ext], [], [dnl
+  if test x$ac_success = xno; then
+    dnl HP's aCC needs +std=c++11 according to:
+    dnl http://h21007.www2.hp.com/portal/download/files/unprot/aCxx/PDF_Release_Notes/769149-001.pdf
+    dnl Cray's crayCC needs "-h std=c++11"
+    for alternative in ${ax_cxx_compile_alternatives}; do
+      for switch in -std=c++${alternative} +std=c++${alternative} "-h std=c++${alternative}"; do
+        cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx$1_$switch])
+        AC_CACHE_CHECK(whether $CXX supports C++$1 features with $switch,
+                       $cachevar,
+          [ac_save_CXX="$CXX"
+           CXX="$CXX $switch"
+           AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],
+            [eval $cachevar=yes],
+            [eval $cachevar=no])
+           CXX="$ac_save_CXX"])
+        if eval test x\$$cachevar = xyes; then
+          CXX="$CXX $switch"
+          if test -n "$CXXCPP" ; then
+            CXXCPP="$CXXCPP $switch"
+          fi
+          ac_success=yes
+          break
+        fi
+      done
+      if test x$ac_success = xyes; then
+        break
+      fi
+    done
+  fi])
+  AC_LANG_POP([C++])
+  if test x$ax_cxx_compile_cxx$1_required = xtrue; then
+    if test x$ac_success = xno; then
+      AC_MSG_ERROR([*** A compiler with support for C++$1 language features is required.])
+    fi
+  fi
+  if test x$ac_success = xno; then
+    HAVE_CXX$1=0
+    AC_MSG_NOTICE([No compiler with C++$1 support was found])
+  else
+    HAVE_CXX$1=1
+    AC_DEFINE(HAVE_CXX$1,1,
+              [define if the compiler supports basic C++$1 syntax])
+  fi
+  AC_SUBST(HAVE_CXX$1)
+])
+
+
+dnl  Test body for checking C++11 support
+
+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_11],
+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_11
+)
+
+
+dnl  Test body for checking C++14 support
+
+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_14],
+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_11
+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_14
+)
+
+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_17],
+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_11
+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_14
+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_17
+)
+
+dnl  Tests for new features in C++11
+
+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_new_in_11], [[
+
+// If the compiler admits that it is not ready for C++11, why torture it?
+// Hopefully, this will speed up the test.
+
+#ifndef __cplusplus
+
+#error "This is not a C++ compiler"
+
+#elif __cplusplus < 201103L
+
+#error "This is not a C++11 compiler"
+
+#else
+
+namespace cxx11
+{
+
+  namespace test_static_assert
+  {
+
+    template <typename T>
+    struct check
+    {
+      static_assert(sizeof(int) <= sizeof(T), "not big enough");
+    };
+
+  }
+
+  namespace test_final_override
+  {
+
+    struct Base
+    {
+      virtual void f() {}
+    };
+
+    struct Derived : public Base
+    {
+      virtual void f() override {}
+    };
+
+  }
+
+  namespace test_double_right_angle_brackets
+  {
+
+    template < typename T >
+    struct check {};
+
+    typedef check<void> single_type;
+    typedef check<check<void>> double_type;
+    typedef check<check<check<void>>> triple_type;
+    typedef check<check<check<check<void>>>> quadruple_type;
+
+  }
+
+  namespace test_decltype
+  {
+
+    int
+    f()
+    {
+      int a = 1;
+      decltype(a) b = 2;
+      return a + b;
+    }
+
+  }
+
+  namespace test_type_deduction
+  {
+
+    template < typename T1, typename T2 >
+    struct is_same
+    {
+      static const bool value = false;
+    };
+
+    template < typename T >
+    struct is_same<T, T>
+    {
+      static const bool value = true;
+    };
+
+    template < typename T1, typename T2 >
+    auto
+    add(T1 a1, T2 a2) -> decltype(a1 + a2)
+    {
+      return a1 + a2;
+    }
+
+    int
+    test(const int c, volatile int v)
+    {
+      static_assert(is_same<int, decltype(0)>::value == true, "");
+      static_assert(is_same<int, decltype(c)>::value == false, "");
+      static_assert(is_same<int, decltype(v)>::value == false, "");
+      auto ac = c;
+      auto av = v;
+      auto sumi = ac + av + 'x';
+      auto sumf = ac + av + 1.0;
+      static_assert(is_same<int, decltype(ac)>::value == true, "");
+      static_assert(is_same<int, decltype(av)>::value == true, "");
+      static_assert(is_same<int, decltype(sumi)>::value == true, "");
+      static_assert(is_same<int, decltype(sumf)>::value == false, "");
+      static_assert(is_same<int, decltype(add(c, v))>::value == true, "");
+      return (sumf > 0.0) ? sumi : add(c, v);
+    }
+
+  }
+
+  namespace test_noexcept
+  {
+
+    int f() { return 0; }
+    int g() noexcept { return 0; }
+
+    static_assert(noexcept(f()) == false, "");
+    static_assert(noexcept(g()) == true, "");
+
+  }
+
+  namespace test_constexpr
+  {
+
+    template < typename CharT >
+    unsigned long constexpr
+    strlen_c_r(const CharT *const s, const unsigned long acc) noexcept
+    {
+      return *s ? strlen_c_r(s + 1, acc + 1) : acc;
+    }
+
+    template < typename CharT >
+    unsigned long constexpr
+    strlen_c(const CharT *const s) noexcept
+    {
+      return strlen_c_r(s, 0UL);
+    }
+
+    static_assert(strlen_c("") == 0UL, "");
+    static_assert(strlen_c("1") == 1UL, "");
+    static_assert(strlen_c("example") == 7UL, "");
+    static_assert(strlen_c("another\0example") == 7UL, "");
+
+  }
+
+  namespace test_rvalue_references
+  {
+
+    template < int N >
+    struct answer
+    {
+      static constexpr int value = N;
+    };
+
+    answer<1> f(int&)       { return answer<1>(); }
+    answer<2> f(const int&) { return answer<2>(); }
+    answer<3> f(int&&)      { return answer<3>(); }
+
+    void
+    test()
+    {
+      int i = 0;
+      const int c = 0;
+      static_assert(decltype(f(i))::value == 1, "");
+      static_assert(decltype(f(c))::value == 2, "");
+      static_assert(decltype(f(0))::value == 3, "");
+    }
+
+  }
+
+  namespace test_uniform_initialization
+  {
+
+    struct test
+    {
+      static const int zero {};
+      static const int one {1};
+    };
+
+    static_assert(test::zero == 0, "");
+    static_assert(test::one == 1, "");
+
+  }
+
+  namespace test_lambdas
+  {
+
+    void
+    test1()
+    {
+      auto lambda1 = [](){};
+      auto lambda2 = lambda1;
+      lambda1();
+      lambda2();
+    }
+
+    int
+    test2()
+    {
+      auto a = [](int i, int j){ return i + j; }(1, 2);
+      auto b = []() -> int { return '0'; }();
+      auto c = [=](){ return a + b; }();
+      auto d = [&](){ return c; }();
+      auto e = [a, &b](int x) mutable {
+        const auto identity = [](int y){ return y; };
+        for (auto i = 0; i < a; ++i)
+          a += b--;
+        return x + identity(a + b);
+      }(0);
+      return a + b + c + d + e;
+    }
+
+    int
+    test3()
+    {
+      const auto nullary = [](){ return 0; };
+      const auto unary = [](int x){ return x; };
+      using nullary_t = decltype(nullary);
+      using unary_t = decltype(unary);
+      const auto higher1st = [](nullary_t f){ return f(); };
+      const auto higher2nd = [unary](nullary_t f1){
+        return [unary, f1](unary_t f2){ return f2(unary(f1())); };
+      };
+      return higher1st(nullary) + higher2nd(nullary)(unary);
+    }
+
+  }
+
+  namespace test_variadic_templates
+  {
+
+    template <int...>
+    struct sum;
+
+    template <int N0, int... N1toN>
+    struct sum<N0, N1toN...>
+    {
+      static constexpr auto value = N0 + sum<N1toN...>::value;
+    };
+
+    template <>
+    struct sum<>
+    {
+      static constexpr auto value = 0;
+    };
+
+    static_assert(sum<>::value == 0, "");
+    static_assert(sum<1>::value == 1, "");
+    static_assert(sum<23>::value == 23, "");
+    static_assert(sum<1, 2>::value == 3, "");
+    static_assert(sum<5, 5, 11>::value == 21, "");
+    static_assert(sum<2, 3, 5, 7, 11, 13>::value == 41, "");
+
+  }
+
+  // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae
+  // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function
+  // because of this.
+  namespace test_template_alias_sfinae
+  {
+
+    struct foo {};
+
+    template<typename T>
+    using member = typename T::member_type;
+
+    template<typename T>
+    void func(...) {}
+
+    template<typename T>
+    void func(member<T>*) {}
+
+    void test();
+
+    void test() { func<foo>(0); }
+
+  }
+
+}  // namespace cxx11
+
+#endif  // __cplusplus >= 201103L
+
+]])
+
+
+dnl  Tests for new features in C++14
+
+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_new_in_14], [[
+
+// If the compiler admits that it is not ready for C++14, why torture it?
+// Hopefully, this will speed up the test.
+
+#ifndef __cplusplus
+
+#error "This is not a C++ compiler"
+
+#elif __cplusplus < 201402L
+
+#error "This is not a C++14 compiler"
+
+#else
+
+namespace cxx14
+{
+
+  namespace test_polymorphic_lambdas
+  {
+
+    int
+    test()
+    {
+      const auto lambda = [](auto&&... args){
+        const auto istiny = [](auto x){
+          return (sizeof(x) == 1UL) ? 1 : 0;
+        };
+        const int aretiny[] = { istiny(args)... };
+        return aretiny[0];
+      };
+      return lambda(1, 1L, 1.0f, '1');
+    }
+
+  }
+
+  namespace test_binary_literals
+  {
+
+    constexpr auto ivii = 0b0000000000101010;
+    static_assert(ivii == 42, "wrong value");
+
+  }
+
+  namespace test_generalized_constexpr
+  {
+
+    template < typename CharT >
+    constexpr unsigned long
+    strlen_c(const CharT *const s) noexcept
+    {
+      auto length = 0UL;
+      for (auto p = s; *p; ++p)
+        ++length;
+      return length;
+    }
+
+    static_assert(strlen_c("") == 0UL, "");
+    static_assert(strlen_c("x") == 1UL, "");
+    static_assert(strlen_c("test") == 4UL, "");
+    static_assert(strlen_c("another\0test") == 7UL, "");
+
+  }
+
+  namespace test_lambda_init_capture
+  {
+
+    int
+    test()
+    {
+      auto x = 0;
+      const auto lambda1 = [a = x](int b){ return a + b; };
+      const auto lambda2 = [a = lambda1(x)](){ return a; };
+      return lambda2();
+    }
+
+  }
+
+  namespace test_digit_separators
+  {
+
+    constexpr auto ten_million = 100'000'000;
+    static_assert(ten_million == 100000000, "");
+
+  }
+
+  namespace test_return_type_deduction
+  {
+
+    auto f(int& x) { return x; }
+    decltype(auto) g(int& x) { return x; }
+
+    template < typename T1, typename T2 >
+    struct is_same
+    {
+      static constexpr auto value = false;
+    };
+
+    template < typename T >
+    struct is_same<T, T>
+    {
+      static constexpr auto value = true;
+    };
+
+    int
+    test()
+    {
+      auto x = 0;
+      static_assert(is_same<int, decltype(f(x))>::value, "");
+      static_assert(is_same<int&, decltype(g(x))>::value, "");
+      return x;
+    }
+
+  }
+
+}  // namespace cxx14
+
+#endif  // __cplusplus >= 201402L
+
+]])
+
+
+dnl  Tests for new features in C++17
+
+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_new_in_17], [[
+
+// If the compiler admits that it is not ready for C++17, why torture it?
+// Hopefully, this will speed up the test.
+
+#ifndef __cplusplus
+
+#error "This is not a C++ compiler"
+
+#elif __cplusplus <= 201402L
+
+#error "This is not a C++17 compiler"
+
+#else
+
+#if defined(__clang__)
+  #define REALLY_CLANG
+#else
+  #if defined(__GNUC__)
+    #define REALLY_GCC
+  #endif
+#endif
+
+#include <initializer_list>
+#include <utility>
+#include <type_traits>
+
+namespace cxx17
+{
+
+#if !defined(REALLY_CLANG)
+  namespace test_constexpr_lambdas
+  {
+
+    // TODO: test it with clang++ from git
+
+    constexpr int foo = [](){return 42;}();
+
+  }
+#endif // !defined(REALLY_CLANG)
+
+  namespace test::nested_namespace::definitions
+  {
+
+  }
+
+  namespace test_fold_expression
+  {
+
+    template<typename... Args>
+    int multiply(Args... args)
+    {
+      return (args * ... * 1);
+    }
+
+    template<typename... Args>
+    bool all(Args... args)
+    {
+      return (args && ...);
+    }
+
+  }
+
+  namespace test_extended_static_assert
+  {
+
+    static_assert (true);
+
+  }
+
+  namespace test_auto_brace_init_list
+  {
+
+    auto foo = {5};
+    auto bar {5};
+
+    static_assert(std::is_same<std::initializer_list<int>, decltype(foo)>::value);
+    static_assert(std::is_same<int, decltype(bar)>::value);
+  }
+
+  namespace test_typename_in_template_template_parameter
+  {
+
+    template<template<typename> typename X> struct D;
+
+  }
+
+  namespace test_fallthrough_nodiscard_maybe_unused_attributes
+  {
+
+    int f1()
+    {
+      return 42;
+    }
+
+    [[nodiscard]] int f2()
+    {
+      [[maybe_unused]] auto unused = f1();
+
+      switch (f1())
+      {
+      case 17:
+        f1();
+        [[fallthrough]];
+      case 42:
+        f1();
+      }
+      return f1();
+    }
+
+  }
+
+  namespace test_extended_aggregate_initialization
+  {
+
+    struct base1
+    {
+      int b1, b2 = 42;
+    };
+
+    struct base2
+    {
+      base2() {
+        b3 = 42;
+      }
+      int b3;
+    };
+
+    struct derived : base1, base2
+    {
+        int d;
+    };
+
+    derived d1 {{1, 2}, {}, 4};  // full initialization
+    derived d2 {{}, {}, 4};      // value-initialized bases
+
+  }
+
+  namespace test_general_range_based_for_loop
+  {
+
+    struct iter
+    {
+      int i;
+
+      int& operator* ()
+      {
+        return i;
+      }
+
+      const int& operator* () const
+      {
+        return i;
+      }
+
+      iter& operator++()
+      {
+        ++i;
+        return *this;
+      }
+    };
+
+    struct sentinel
+    {
+      int i;
+    };
+
+    bool operator== (const iter& i, const sentinel& s)
+    {
+      return i.i == s.i;
+    }
+
+    bool operator!= (const iter& i, const sentinel& s)
+    {
+      return !(i == s);
+    }
+
+    struct range
+    {
+      iter begin() const
+      {
+        return {0};
+      }
+
+      sentinel end() const
+      {
+        return {5};
+      }
+    };
+
+    void f()
+    {
+      range r {};
+
+      for (auto i : r)
+      {
+        [[maybe_unused]] auto v = i;
+      }
+    }
+
+  }
+
+  namespace test_lambda_capture_asterisk_this_by_value
+  {
+
+    struct t
+    {
+      int i;
+      int foo()
+      {
+        return [*this]()
+        {
+          return i;
+        }();
+      }
+    };
+
+  }
+
+  namespace test_enum_class_construction
+  {
+
+    enum class byte : unsigned char
+    {};
+
+    byte foo {42};
+
+  }
+
+  namespace test_constexpr_if
+  {
+
+    template <bool cond>
+    int f ()
+    {
+      if constexpr(cond)
+      {
+        return 13;
+      }
+      else
+      {
+        return 42;
+      }
+    }
+
+  }
+
+  namespace test_selection_statement_with_initializer
+  {
+
+    int f()
+    {
+      return 13;
+    }
+
+    int f2()
+    {
+      if (auto i = f(); i > 0)
+      {
+        return 3;
+      }
+
+      switch (auto i = f(); i + 4)
+      {
+      case 17:
+        return 2;
+
+      default:
+        return 1;
+      }
+    }
+
+  }
+
+#if !defined(REALLY_CLANG)
+  namespace test_template_argument_deduction_for_class_templates
+  {
+
+    // TODO: test it with clang++ from git
+
+    template <typename T1, typename T2>
+    struct pair
+    {
+      pair (T1 p1, T2 p2)
+        : m1 {p1},
+          m2 {p2}
+      {}
+
+      T1 m1;
+      T2 m2;
+    };
+
+    void f()
+    {
+      [[maybe_unused]] auto p = pair{13, 42u};
+    }
+
+  }
+#endif // !defined(REALLY_CLANG)
+
+  namespace test_non_type_auto_template_parameters
+  {
+
+    template <auto n>
+    struct B
+    {};
+
+    B<5> b1;
+    B<'a'> b2;
+
+  }
+
+#if !defined(REALLY_CLANG)
+  namespace test_structured_bindings
+  {
+
+    // TODO: test it with clang++ from git
+
+    int arr[2] = { 1, 2 };
+    std::pair<int, int> pr = { 1, 2 };
+
+    auto f1() -> int(&)[2]
+    {
+      return arr;
+    }
+
+    auto f2() -> std::pair<int, int>&
+    {
+      return pr;
+    }
+
+    struct S
+    {
+      int x1 : 2;
+      volatile double y1;
+    };
+
+    S f3()
+    {
+      return {};
+    }
+
+    auto [ x1, y1 ] = f1();
+    auto& [ xr1, yr1 ] = f1();
+    auto [ x2, y2 ] = f2();
+    auto& [ xr2, yr2 ] = f2();
+    const auto [ x3, y3 ] = f3();
+
+  }
+#endif // !defined(REALLY_CLANG)
+
+#if !defined(REALLY_CLANG)
+  namespace test_exception_spec_type_system
+  {
+
+    // TODO: test it with clang++ from git
+
+    struct Good {};
+    struct Bad {};
+
+    void g1() noexcept;
+    void g2();
+
+    template<typename T>
+    Bad
+    f(T*, T*);
+
+    template<typename T1, typename T2>
+    Good
+    f(T1*, T2*);
+
+    static_assert (std::is_same_v<Good, decltype(f(g1, g2))>);
+
+  }
+#endif // !defined(REALLY_CLANG)
+
+  namespace test_inline_variables
+  {
+
+    template<class T> void f(T)
+    {}
+
+    template<class T> inline T g(T)
+    {
+      return T{};
+    }
+
+    template<> inline void f<>(int)
+    {}
+
+    template<> int g<>(int)
+    {
+      return 5;
+    }
+
+  }
+
+}  // namespace cxx17
+
+#endif  // __cplusplus <= 201402L
+
+]])
diff -r ef8470f9d682 m4/ax_cxx_compile_stdcxx_11.m4
--- a/m4/ax_cxx_compile_stdcxx_11.m4	Sun Feb 12 15:25:10 2017 +0100
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,129 +0,0 @@
-# SYNOPSIS
-#
-#   AX_CXX_COMPILE_STDCXX_11([ext|noext],[mandatory|optional])
-#
-# DESCRIPTION
-#
-#   Check for baseline language coverage in the compiler for the C++11
-#   standard; if necessary, add switches to CXXFLAGS to enable support.
-#
-#   The first argument, if specified, indicates whether you insist on an
-#   extended mode (e.g. -std=gnu++11) or a strict conformance mode (e.g.
-#   -std=c++11).  If neither is specified, you get whatever works, with
-#   preference for an extended mode.
-#
-#   The second argument, if specified 'mandatory' or if left unspecified,
-#   indicates that baseline C++11 support is required and that the macro
-#   should error out if no mode with that support is found.  If specified
-#   'optional', then configuration proceeds regardless, after defining
-#   HAVE_CXX11 if and only if a supporting mode is found.
-#
-# LICENSE
-#
-#   Copyright (c) 2008 Benjamin Kosnik <bkoz@redhat.com>
-#   Copyright (c) 2012 Zack Weinberg <zackw@panix.com>
-#   Copyright (c) 2013 Roy Stogner <roystgnr@ices.utexas.edu>
-#
-#   Copying and distribution of this file, with or without modification, are
-#   permitted in any medium without royalty provided the copyright notice
-#   and this notice are preserved. This file is offered as-is, without any
-#   warranty.
-
-#serial 3
-
-m4_define([_AX_CXX_COMPILE_STDCXX_11_testbody], [
-  template <typename T>
-    struct check
-    {
-      static_assert(sizeof(int) <= sizeof(T), "not big enough");
-    };
-
-    typedef check<check<bool>> right_angle_brackets;
-
-    int a;
-    decltype(a) b;
-
-    typedef check<int> check_type;
-    check_type c;
-    check_type&& cr = static_cast<check_type&&>(c);
-
-    auto d = a;
-])
-
-AC_DEFUN([AX_CXX_COMPILE_STDCXX_11], [dnl
-  m4_if([$1], [], [],
-        [$1], [ext], [],
-        [$1], [noext], [],
-        [m4_fatal([invalid argument `$1' to AX_CXX_COMPILE_STDCXX_11])])dnl
-  m4_if([$2], [], [ax_cxx_compile_cxx11_required=true],
-        [$2], [mandatory], [ax_cxx_compile_cxx11_required=true],
-        [$2], [optional], [ax_cxx_compile_cxx11_required=false],
-        [m4_fatal([invalid second argument `$2' to AX_CXX_COMPILE_STDCXX_11])])dnl
-  AC_LANG_PUSH([C++])dnl
-  ac_success=no
-  AC_CACHE_CHECK(whether $CXX supports C++11 features by default,
-  ax_cv_cxx_compile_cxx11,
-  [AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_11_testbody])],
-    [ax_cv_cxx_compile_cxx11=yes],
-    [ax_cv_cxx_compile_cxx11=no])])
-  if test x$ax_cv_cxx_compile_cxx11 = xyes; then
-    ac_success=yes
-  fi
-
-  m4_if([$1], [noext], [], [dnl
-  if test x$ac_success = xno; then
-    for switch in -std=gnu++11 -std=gnu++0x; do
-      cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx11_$switch])
-      AC_CACHE_CHECK(whether $CXX supports C++11 features with $switch,
-                     $cachevar,
-        [ac_save_CXXFLAGS="$CXXFLAGS"
-         CXXFLAGS="$CXXFLAGS $switch"
-         AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_11_testbody])],
-          [eval $cachevar=yes],
-          [eval $cachevar=no])
-         CXXFLAGS="$ac_save_CXXFLAGS"])
-      if eval test x\$$cachevar = xyes; then
-        CXXFLAGS="$CXXFLAGS $switch"
-        ac_success=yes
-        break
-      fi
-    done
-  fi])
-
-  m4_if([$1], [ext], [], [dnl
-  if test x$ac_success = xno; then
-    for switch in -std=c++11 -std=c++0x; do
-      cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx11_$switch])
-      AC_CACHE_CHECK(whether $CXX supports C++11 features with $switch,
-                     $cachevar,
-        [ac_save_CXXFLAGS="$CXXFLAGS"
-         CXXFLAGS="$CXXFLAGS $switch"
-         AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_11_testbody])],
-          [eval $cachevar=yes],
-          [eval $cachevar=no])
-         CXXFLAGS="$ac_save_CXXFLAGS"])
-      if eval test x\$$cachevar = xyes; then
-        CXXFLAGS="$CXXFLAGS $switch"
-        ac_success=yes
-        break
-      fi
-    done
-  fi])
-  AC_LANG_POP([C++])
-  if test x$ax_cxx_compile_cxx11_required = xtrue; then
-    if test x$ac_success = xno; then
-      AC_MSG_ERROR([*** A compiler with support for C++11 language features is required.])
-    fi
-  else
-    if test x$ac_success = xno; then
-      HAVE_CXX11=0
-      AC_MSG_NOTICE([No compiler with C++11 support was found])
-    else
-      HAVE_CXX11=1
-      AC_DEFINE(HAVE_CXX11,1,
-                [define if the compiler supports basic C++11 syntax])
-    fi
-
-    AC_SUBST(HAVE_CXX11)
-  fi
-])
diff -r ef8470f9d682 m4/ax_cxx_compile_stdcxx_17.m4
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/m4/ax_cxx_compile_stdcxx_17.m4	Mon Apr 27 19:55:56 2020 -0700
@@ -0,0 +1,35 @@
+# =============================================================================
+#  https://www.gnu.org/software/autoconf-archive/ax_cxx_compile_stdcxx_17.html
+# =============================================================================
+#
+# SYNOPSIS
+#
+#   AX_CXX_COMPILE_STDCXX_17([ext|noext], [mandatory|optional])
+#
+# DESCRIPTION
+#
+#   Check for baseline language coverage in the compiler for the C++17
+#   standard; if necessary, add switches to CXX and CXXCPP to enable
+#   support.
+#
+#   This macro is a convenience alias for calling the AX_CXX_COMPILE_STDCXX
+#   macro with the version set to C++17.  The two optional arguments are
+#   forwarded literally as the second and third argument respectively.
+#   Please see the documentation for the AX_CXX_COMPILE_STDCXX macro for
+#   more information.  If you want to use this macro, you also need to
+#   download the ax_cxx_compile_stdcxx.m4 file.
+#
+# LICENSE
+#
+#   Copyright (c) 2015 Moritz Klammler <moritz@klammler.eu>
+#   Copyright (c) 2016 Krzesimir Nowak <qdlacz@gmail.com>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved. This file is offered as-is, without any
+#   warranty.
+
+#serial 2
+
+AX_REQUIRE_DEFINED([AX_CXX_COMPILE_STDCXX])
+AC_DEFUN([AX_CXX_COMPILE_STDCXX_17], [AX_CXX_COMPILE_STDCXX([17], [$1], [$2])])
diff -r ef8470f9d682 src/CMakeLists.txt
--- a/src/CMakeLists.txt	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/CMakeLists.txt	Mon Apr 27 19:55:56 2020 -0700
@@ -17,9 +17,41 @@
   )
 add_custom_target(signature DEPENDS "${CMAKE_CURRENT_BINARY_DIR}/signature.h")
 
+IF(ENABLE_OPENCL)
+  # prepare all OpenCL sources
+  SET(OPENCL_SOURCES)
+  FILE(GLOB opencl_sources ${TOP_SRC_DIR}/src/*.cl)
+  IF(PREFER_SEPARATE_OPENCL_SOURCE)
+    INSTALL(FILES ${opencl_sources} DESTINATION ${CMAKE_INSTALL_PREFIX}/share/enblend/kernels)
+  ELSE()
+    FILE(MAKE_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/kernels")
+    FOREACH(_cl_source ${opencl_sources})
+      GET_FILENAME_COMPONENT(_cl_filename "${_cl_source}" NAME)
+
+      STRING(REGEX REPLACE "[.]cl$" ".icl" _icl_source "${_cl_filename}")
+      SET(_icl_source "${CMAKE_CURRENT_BINARY_DIR}/kernels/${_icl_source}")
+      STRING(REGEX REPLACE "[.]cl$" "_source_code" _cl_label "${_cl_filename}")
+
+      ADD_CUSTOM_COMMAND(
+        OUTPUT "${_icl_source}"
+        COMMAND ${PERL_EXECUTABLE} "${TOP_SRC_DIR}/src/embrace"
+          "--format=c++" "--label=${_cl_label}" "${_cl_source}" ">" "${_icl_source}"
+        DEPENDS "${_cl_source}"
+        COMMENT "Generating ${_icl_source}"
+      )
+      SET_SOURCE_FILES_PROPERTIES("${_icl_source}" GENERATED)
+      LIST(APPEND OPENCL_SOURCES "${_icl_source}")
+    ENDFOREACH()
+
+    ADD_CUSTOM_TARGET(cl_sources ALL DEPENDS ${OPENCL_SOURCES})
+    INCLUDE_DIRECTORIES("${CMAKE_CURRENT_BINARY_DIR}/kernels")
+  ENDIF()
+ENDIF()
+
 include_directories(${TOP_SRC_DIR}/src)
 set(ENBLEND_SOURCES 
-    fillpolygon.hxx functoraccessor.hxx rect2d.hxx stride.hxx 
+    fillpolygon.hxx functoraccessor.hxx rect2d.hxx stride.hxx
+    allocate.h 
     anneal.h assemble.h blend.h bounds.h
     common.h enblend.h enblend.cc fixmath.h
     global.h graphcut.h
@@ -34,6 +66,7 @@
     filespec.h filespec.cc
     introspection.h introspection.cc
     mersenne.h mersenne.cc
+    metadata.h metadata.cc
     parameter.h parameter.cc
     self_test.h self_test.cc
     tiff_message.h tiff_message.cc
@@ -43,6 +76,7 @@
 )
 set(ENFUSE_SOURCES 
     functoraccessor.hxx rect2d.hxx stride.hxx
+    allocate.h
     assemble.h blend.h bounds.h common.h
     exposure_weight_base.h
     exposure_weight.h exposure_weight.cc
@@ -58,6 +92,7 @@
     filespec.h filespec.cc
     introspection.h introspection.cc
     mersenne.h mersenne.cc
+    metadata.h metadata.cc
     parameter.h parameter.cc
     self_test.h self_test.cc
     tiff_message.h tiff_message.cc
@@ -85,7 +120,6 @@
 
 include_directories(${CMAKE_CURRENT_BINARY_DIR})
 
-message(STATUS "Boost_FOUND = ${Boost_FOUND}")
 message(STATUS "OpenMP_CXX_FLAGS = ${OpenMP_CXX_FLAGS}")
 
 add_executable(enblend ${ENBLEND_SOURCES})
@@ -102,8 +136,18 @@
 endif(OpenMP_CXX_FLAGS AND NOT MSVC)
 target_link_libraries(enblend ${common_libs} ${additional_libs})
 target_link_libraries(enfuse ${common_libs} ${additional_libs})
+if(ENABLE_OPENCL AND MSVC)
+  # provide delay loading of opencl.dll
+  set_target_properties(enblend PROPERTIES LINK_FLAGS "/DELAYLOAD:opencl.dll")
+  set_target_properties(enfuse PROPERTIES LINK_FLAGS "/DELAYLOAD:opencl.dll")
+endif()
 install(TARGETS enblend enfuse DESTINATION bin CONFIGURATIONS Release RelWithDebInfo MinSizeRel)
 
+IF(ENABLE_OPENCL AND NOT ${PREFER_SEPARATE_OPENCL_SOURCE})
+    add_dependencies(enblend cl_sources)
+    add_dependencies(enfuse cl_sources)
+ENDIF()
+
 if(NOT WIN32)
     # create enblend.1 and enfuse.1
     if(NOT MANDIR AND NOT $ENV{MANDIR} STREQUAL "")
diff -r ef8470f9d682 src/DefaultSig.pm
--- a/src/DefaultSig.pm	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/DefaultSig.pm	Mon Apr 27 19:55:56 2020 -0700
@@ -109,9 +109,10 @@
 sub update_date_and_time {
     my $self = shift;
 
+    my $now = $ENV{SOURCE_DATE_EPOCH} || time;
     my ($second, $minute, $hour,
         $day_of_month, $month, $year,
-        $day_of_week) = $self->is_using_gmt() ? gmtime : localtime;
+        $day_of_week) = $self->is_using_gmt() ? gmtime($now) : localtime($now);
 
     $self->{DATE} = $self->format_date($day_of_month, $month, $year + 1900, $day_of_week,
                                        $self->weekdays->[$day_of_week],
diff -r ef8470f9d682 src/Makefile.am
--- a/src/Makefile.am	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/Makefile.am	Mon Apr 27 19:55:56 2020 -0700
@@ -9,6 +9,7 @@
 
 enblend_SOURCES = fillpolygon.hxx functoraccessor.hxx rect2d.hxx stride.hxx \
                   \
+                  allocate.h \
                   anneal.h assemble.h blend.h bounds.h \
                   common.h enblend.h enblend.cc fixmath.h \
                   global.h graphcut.h \
@@ -23,6 +24,7 @@
                   filespec.h filespec.cc \
                   introspection.h introspection.cc \
                   mersenne.h mersenne.cc \
+                  metadata.h metadata.cc \
                   parameter.h parameter.cc \
                   self_test.h self_test.cc \
                   tiff_message.h tiff_message.cc \
@@ -31,7 +33,8 @@
                   muopt.h
 enblend_LDFLAGS = $(AM_LDFLAGS)
 enblend_LDADD = layer_selection/liblayersel.a \
-                $(GSL_LIBS) @EXTRA_LIBS@
+                $(GSL_LIBS) $(STATIC_LIBS) \
+                @EXTRA_LIBS@
 enblend_CXXFLAGS = -DENBLEND_SOURCE $(AM_CXXFLAGS) $(GSL_CFLAGS) \
                    -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 \
                    -I$(top_srcdir)/src/dynamic_loader \
@@ -39,6 +42,7 @@
 
 enfuse_SOURCES = functoraccessor.hxx rect2d.hxx stride.hxx \
                  \
+                 allocate.h \
                  assemble.h blend.h bounds.h common.h \
                  exposure_weight_base.h \
                  exposure_weight.h exposure_weight.cc \
@@ -54,6 +58,7 @@
                  filespec.h filespec.cc \
                  introspection.h introspection.cc \
                  mersenne.h mersenne.cc \
+                 metadata.h metadata.cc \
                  parameter.h parameter.cc \
                  self_test.h self_test.cc \
                  tiff_message.h tiff_message.cc \
@@ -63,7 +68,8 @@
 enfuse_LDFLAGS = $(AM_LDFLAGS)
 enfuse_LDADD = dynamic_loader/libdynamic_loader.a \
                layer_selection/liblayersel.a \
-               $(GSL_LIBS) @EXTRA_LIBS@
+               $(GSL_LIBS) $(STATIC_LIBS) \
+               @EXTRA_LIBS@
 enfuse_CXXFLAGS = -DENFUSE_SOURCE $(AM_CXXFLAGS) $(GSL_CFLAGS) \
                   -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 \
                   -I$(top_srcdir)/src/dynamic_loader \
diff -r ef8470f9d682 src/allocate.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/allocate.h	Mon Apr 27 19:55:56 2020 -0700
@@ -0,0 +1,244 @@
+/*
+ * Copyright (C) 2016, 2017 Dr. Christoph L. Spiel
+ *
+ * This file is part of Enblend.
+ *
+ * Enblend is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * Enblend is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Enblend; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef ALLOCATE_H_INLCUDED
+#define ALLOCATE_H_INLCUDED
+
+
+#include <iterator>
+#include <stdexcept>
+#include <string>
+#include <vector>
+
+
+namespace allocate
+{
+    namespace detail
+    {
+        class positional_hint
+        {
+        public:
+            positional_hint() = delete;
+            positional_hint(const char* a_message, std::size_t a_position) :
+                position_ {a_position}
+            {
+                message_.append(a_message);
+                message_.append(" at position ");
+                message_.append(std::to_string(position()));
+            }
+
+            const char* message() const {return message_.c_str();}
+
+            std::size_t position() const {return position_;}
+
+        private:
+            std::string message_;
+            const std::size_t position_;
+        }; // class positional_hint
+    } // namespace detail
+
+
+    class not_initialized : public std::exception, private detail::positional_hint
+    {
+    public:
+        not_initialized() = delete;
+        explicit not_initialized(std::size_t an_uninitialized_position) :
+            detail::positional_hint {"uninitialized array element", an_uninitialized_position}
+        {}
+
+        virtual const char* what() const noexcept {return detail::positional_hint::message();}
+
+        std::size_t position() const {return detail::positional_hint::position();}
+    }; // class not_initialized
+
+
+    class already_initialized : public std::exception, private detail::positional_hint
+    {
+    public:
+        already_initialized() = delete;
+        explicit already_initialized(std::size_t an_uninitialized_position) :
+            detail::positional_hint {"array element already initialized", an_uninitialized_position}
+        {}
+
+        virtual const char* what() const noexcept {return detail::positional_hint::message();}
+
+        std::size_t position() const {return detail::positional_hint::position();}
+    }; // class already_initialized
+
+
+    class out_of_range : public std::exception, private detail::positional_hint
+    {
+    public:
+        out_of_range() = delete;
+        out_of_range(std::size_t an_out_of_range_position, std::size_t a_size) :
+            detail::positional_hint {"out of range access", an_out_of_range_position},
+            array_size_ {a_size}
+        {}
+
+        virtual const char* what() const noexcept {return detail::positional_hint::message();}
+
+        std::size_t position() const {return detail::positional_hint::position();}
+        std::size_t array_size() const {return array_size_;}
+
+    private:
+        const std::size_t array_size_;
+    }; // class out_of_range
+
+
+    template <typename t>
+    struct default_deallocator
+    {
+        typedef t value_type;
+
+        default_deallocator() {}
+        void operator()(value_type*) const {}
+    }; // template struct default_deallocator
+
+
+    template <typename t, typename deallocator = default_deallocator<t>>
+    class array
+    {
+    public:
+        typedef t value_type;
+        typedef deallocator deallocator_type;
+
+        typedef std::size_t size_type;
+        typedef std::ptrdiff_t difference_type;
+
+        typedef value_type& reference;
+        typedef const value_type& const_reference;
+        typedef value_type* pointer;
+        typedef const value_type* const_pointer;
+
+        typedef t* iterator;
+        typedef const t* const_iterator;
+        typedef std::reverse_iterator<iterator> reverse_iterator;
+        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
+
+        array() = delete;
+        array(const array&) = delete;
+        array& operator=(const array&) = delete;
+
+        explicit array(size_t an_object_count) :
+            size_(an_object_count),
+            base_(::operator new[](an_object_count * sizeof(t))),
+            initialized_(an_object_count)
+        {
+            initialization_order_.reserve(an_object_count);
+        }
+
+        ~array()
+        {
+            finalize();
+            ::operator delete[](base_);
+        }
+
+        // Not implemented yet:
+        //     reference operator[](size_type a_position) {...}
+
+        const_reference operator[](size_type a_position) const
+        {
+            if (is_initialized(a_position))
+            {
+                return *(begin() + a_position);
+            }
+            else
+            {
+                throw not_initialized(a_position);
+            }
+        }
+
+        // Not implemented yet:
+        //     reference at(size_type a_position) {...}
+
+        const_reference at(size_type a_position) const
+        {
+            if (a_position >= size_)
+            {
+                throw out_of_range(a_position, size());
+            }
+            else
+            {
+                return operator[](a_position);
+            }
+        }
+
+        bool empty() const {return size_ == size_type();}
+        size_type size() const {return size_;}
+
+        iterator begin() {return iterator(base_);}
+        iterator end() {return begin() + size_;}
+        const_iterator begin() const {return iterator(base_);}
+        const_iterator end() const {return begin() + size_;}
+
+        reverse_iterator rbegin() {return reverse_iterator(end());}
+        reverse_iterator rend() {return reverse_iterator(begin());}
+        const_reverse_iterator rbegin() const {return const_reverse_iterator(end());}
+        const_reverse_iterator rend() const {return const_reverse_iterator(begin());}
+
+        void mark_as_initialized(size_type a_position)
+        {
+            if (is_initialized(a_position))
+            {
+                throw already_initialized(a_position);
+            }
+            else
+            {
+                initialized_.at(a_position) = true;
+                initialization_order_.push_back(a_position);
+            }
+        }
+
+        void mark_as_initialized(iterator an_iterator) {mark_as_initialized(an_iterator - begin());}
+
+        bool is_initialized(size_type a_position) const {return initialized_.at(a_position);}
+        bool is_initialized(iterator an_iterator) const {return is_initialized(an_iterator - begin());}
+
+    private:
+        void finalize()
+        {
+            deallocator_type deallocate;
+
+            // Implementation Note: We apply the destructors in the
+            // reverse order of construction.  This is the sole reason
+            // why we have `initialization_order_'.
+            for (auto position = initialization_order_.rbegin();
+                 position != initialization_order_.rend();
+                 ++position)
+            {
+                const iterator value(begin() + *position);
+                value->~t();
+                deallocate(value);
+            }
+        }
+
+        const size_type size_;
+        void* const base_;
+        std::vector<bool> initialized_;
+        std::vector<size_type> initialization_order_;
+    }; // template class array
+} // namespace allocate
+
+
+#endif // ALLOCATE_H_INLCUDED
+
+// Local Variables:
+// mode: c++
+// End:
diff -r ef8470f9d682 src/anneal.h
--- a/src/anneal.h	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/anneal.h	Mon Apr 27 19:55:56 2020 -0700
@@ -55,48 +55,6 @@
 #endif
 
 
-// Nicol N. Schraudolph
-// "A Fast, Compact Approximation of the Exponential Function"
-// Neural Computation, vol. 11, pages 853--862, 1999.
-#define SCHRAUDOLPH_EXPONENT_A (1048576.0 / M_LN2)
-#define SCHRAUDOLPH_EXPONENT_A_INT 1512775
-
-inline static double
-schraudolph_exp(double x)
-{
-    if (EXPECT_RESULT(x > 709.0, false)) // log(std::numeric_limits<double>::max()) = 709.783
-    {
-        return std::numeric_limits<double>::infinity();
-    }
-    else if (EXPECT_RESULT(x < -708.0, false)) // log(std::numeric_limits<double>::min()) = -708.396
-    {
-        return double();
-    }
-    else
-    {
-        union schraudolph
-        {
-            double floating_point_value;
-            struct
-            {
-#if __BYTE_ORDER == __LITTLE_ENDIAN
-                unsigned least_significant_part;
-                int most_significant_part;
-#else
-                int most_significant_part;
-                unsigned least_significant_part;
-#endif
-            } integral_decomposition;
-        } s;
-
-        s.integral_decomposition.least_significant_part = 0U;
-        s.integral_decomposition.most_significant_part = SCHRAUDOLPH_EXPONENT_A * x + (0x3ff00000 - 60801);
-
-        return s.floating_point_value;
-    }
-}
-
-
 namespace enblend {
 
 inline static vigra::Diff2D
@@ -422,7 +380,7 @@
                     const double ej = E[j];
                     for (unsigned i = j + 1U; i < localK; ++i) {
                         const double piT = (*stateProbabilities)[i] + piTj;
-                        double piTAn = piT / (1.0 + schraudolph_exp(ej - E[i]));
+                        double piTAn = piT / (1.0 + std::exp(ej - E[i]));
                         if (EXPECT_RESULT(std::isnan(piTAn), false)) {
                             // exp term is infinity or zero.
                             piTAn = ej > E[i] ? 0.0 : piT;
@@ -654,7 +612,7 @@
     // Weight factors for the distance of a point from the initial
     // seam line and the total mismatch accumulated along the seam
     // line segment.
-    double distanceWeight;;
+    double distanceWeight;
     double mismatchWeight;
 
     omp::lock cerrLock;
diff -r ef8470f9d682 src/assemble.h
--- a/src/assemble.h	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/assemble.h	Mon Apr 27 19:55:56 2020 -0700
@@ -66,17 +66,62 @@
                                const AlphaAccessor& mask_accessor,
                                const vigra::ImageExportInfo& outputImageInfo)
 {
-    try {
+    try
+    {
         vigra::exportImageAlpha(srcImageRange(*image),
                                 srcIter(mask->upperLeft(), mask_accessor),
                                 outputImageInfo);
-    } catch (std::exception& e) {
-        std::cerr << command << ": warning: must fall back to export image without alpha channel" << std::endl;
+    }
+    catch (std::exception& e)
+    {
+        std::cerr <<
+            command << ": warning: must fall back to export image without alpha channel\n" <<
+            command << ": note: output image type (" << enblend::getFileType(OutputFileName) <<
+            ") does not support an alpha channel" << std::endl;
+        if (!OutputMaskFileName)
+        {
+            std::cerr <<
+                command << ": note: use option \"--output-mask\" to save a mask file of the alpha channel" <<
+                std::endl;
+        }
 #ifdef DEBUG
-        std::cerr << "+ exportImagePreferablyWithAlpha: exception description follows..." << e.what();
+        {
+            std::cerr << "+ exportImagePreferablyWithAlpha: exception description follows...\n";
+            const std::vector<std::string> lines {enblend::split_string(e.what(), '\n', true)};
+            for (auto line : lines)
+            {
+                std::cerr << "+ exportImagePreferablyWithAlpha: " << line << "\n";
+            }
+        }
 #endif
-        exportImage(srcImageRange(*image), outputImageInfo);
+        vigra::exportImage(srcImageRange(*image), outputImageInfo);
     }
+
+    if (OutputMaskFileName)
+    {
+        const std::string mask_filename(OutputMaskFileName.value());
+        vigra::ImageExportInfo mask_info(mask_filename.c_str());
+
+        if (!enblend::has_known_image_extension(mask_filename)) {
+            std::string fallback_file_type {parameter::as_string("fallback-output-mask-file-type",
+                                                                 DEFAULT_FALLBACK_OUTPUT_MASK_FILE_TYPE)};
+            if (mask_filename == "-")
+            {
+                mask_info.setFileName("/dev/stdout");
+            }
+            else
+            {
+                std::cerr <<
+                    command << ": warning: unknown filetype of mask output file \"" << mask_filename << "\"\n" <<
+                    command << ": note: will fall back to type \"" << fallback_file_type << "\"\n";
+            }
+            enblend::to_upper(fallback_file_type);
+            mask_info.setFileType(fallback_file_type.c_str());
+        }
+
+        vigra::exportImage(srcImageRange(*mask), mask_info);
+    }
+
     OutputIsValid = true;
 }
 
@@ -98,7 +143,7 @@
     AlphaType* mask = p.second;
 
     vigra_ext::ReadFunctorAccessor<vigra::Threshold<AlphaPixelType, ImagePixelComponentType>, AlphaAccessor>
-        ata(vigra::Threshold<AlphaPixelType, ImagePixelComponentType>
+        threshing_alpha_accessor(vigra::Threshold<AlphaPixelType, ImagePixelComponentType>
             (AlphaTraits<AlphaPixelType>::zero(),
              AlphaTraits<AlphaPixelType>::zero(),
              AlphaTraits<ImagePixelComponentType>::max(),
@@ -132,7 +177,7 @@
 #ifdef DEBUG
             std::cerr << "+ checkpoint: leaving channel width alone" << std::endl;
 #endif
-            exportImagePreferablyWithAlpha(image, mask, ata, outputImageInfo);
+            exportImagePreferablyWithAlpha(image, mask, threshing_alpha_accessor, outputImageInfo);
         } else {
             const std::string pixel_type(enblend::to_lower_copy(std::string(outputImageInfo.getPixelType())));
             std::cerr << command
@@ -146,7 +191,7 @@
                                                                  ImagePixelType(inputMax),
                                                                  ImagePixelType(outputRange.first),
                                                                  ImagePixelType(outputRange.second)));
-            exportImagePreferablyWithAlpha(&lowDepthImage, mask, ata, outputImageInfo);
+            exportImagePreferablyWithAlpha(&lowDepthImage, mask, threshing_alpha_accessor, outputImageInfo);
         }
     } else {
         const std::string pixel_type(enblend::to_lower_copy(std::string(outputImageInfo.getPixelType())));
@@ -161,7 +206,7 @@
         IMAGETYPE<IntegralPixelType> integralImage(image->width(), image->height());
 
         vigra_ext::ReadFunctorAccessor<vigra::Threshold<AlphaPixelType, IntegralPixelComponentType>, AlphaAccessor>
-            ata(vigra::Threshold<AlphaPixelType, IntegralPixelComponentType>
+            threshing_alpha_accessor(vigra::Threshold<AlphaPixelType, IntegralPixelComponentType>
                 (AlphaTraits<AlphaPixelType>::zero(),
                  AlphaTraits<AlphaPixelType>::zero(),
                  AlphaTraits<IntegralPixelComponentType>::max(),
@@ -174,7 +219,7 @@
                                                              ImagePixelType(inputMax),
                                                              IntegralPixelType(outputRange.first),
                                                              IntegralPixelType(outputRange.second)));
-        exportImagePreferablyWithAlpha(&integralImage, mask, ata, outputImageInfo);
+        exportImagePreferablyWithAlpha(&integralImage, mask, threshing_alpha_accessor, outputImageInfo);
     }
 }
 
@@ -187,31 +232,42 @@
        const std::pair<AlphaIterator, AlphaAccessor>& alpha)
 {
     typedef typename DestIterator::PixelType ImagePixelType;
-    typedef typename EnblendNumericTraits<ImagePixelType>::ImagePixelComponentType
-        ImagePixelComponentType;
+    typedef typename EnblendNumericTraits<ImagePixelType>::ImagePixelComponentType ImagePixelComponentType;
     typedef typename AlphaIterator::PixelType AlphaPixelType;
 
-    const vigra::Diff2D extent = vigra::Diff2D(info.width(), info.height());
-    const std::string pixelType = info.getPixelType();
-    const range_t inputRange = enblend::rangeOfPixelType(pixelType);
+    const vigra::Diff2D extent(info.width(), info.height());
+    const std::string pixelType {info.getPixelType()};
+    const range_t inputRange {enblend::rangeOfPixelType(pixelType)};
 
-    if (info.numExtraBands() > 0) {
+    if (info.numExtraBands() >= 1) {
         // Threshold the alpha mask so that all pixels are either
         // contributing or not contributing.
         vigra_ext::WriteFunctorAccessor<vigra::Threshold<ImagePixelComponentType, AlphaPixelType>, AlphaAccessor>
-            ata(vigra::Threshold<ImagePixelComponentType, AlphaPixelType>
-                (inputRange.second / 2,
-                 inputRange.second,
+            threshing_alpha_accessor(vigra::Threshold<ImagePixelComponentType, AlphaPixelType>
+                (static_cast<ImagePixelComponentType>(parameter::as_double("import-alpha-lower-threshold",
+                                                                           inputRange.second / 2.0)),
+                 static_cast<ImagePixelComponentType>(parameter::as_double("import-alpha-upper-threshold",
+                                                                           inputRange.second)),
                  AlphaTraits<AlphaPixelType>::zero(),
                  AlphaTraits<AlphaPixelType>::max()),
                 alpha.second);
 
-        vigra::importImageAlpha(info, image, vigra::destIter(alpha.first, ata));
+        vigra::importImageAlpha(info, image, vigra::destIter(alpha.first, threshing_alpha_accessor));
+
+        if (parameter::as_boolean("import-alpha-save-threshed", false)) {
+            static unsigned index {0};
+            std::ostringstream mask_image_name;
+
+            mask_image_name << "threshed-import-alpha-" << index << ".tif";
+            vigra::exportImage(vigra::srcIterRange(alpha.first, alpha.first + extent, alpha.second),
+                               vigra::ImageExportInfo(mask_image_name.str().c_str()).setPixelType(pixelType.c_str()));
+            ++index;
+        }
     } else {
         // Import image without alpha.  Initialize the alpha image to 100%.
-        importImage(info, image.first, image.second);
-        initImage(srcIterRange(alpha.first, alpha.first + extent, alpha.second),
-                  AlphaTraits<AlphaPixelType>::max());
+        vigra::importImage(info, image.first, image.second);
+        vigra::initImage(vigra::srcIterRange(alpha.first, alpha.first + extent, alpha.second),
+                         AlphaTraits<AlphaPixelType>::max());
     }
 
     // Performance Optimization: Transform only if ranges do not
diff -r ef8470f9d682 src/bounds.h
--- a/src/bounds.h	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/bounds.h	Mon Apr 27 19:55:56 2020 -0700
@@ -75,7 +75,7 @@
         return NoOverlap;
     }
 
-};
+}
 
 // Argument object factory version.
 template <typename SrcImageIterator, typename SrcAccessor>
@@ -85,7 +85,7 @@
 {
     return inspectOverlap(src1.first, src1.second, src1.third,
                           src2.first, src2.second);
-};
+}
 
 /** Determine the region-of-interest and number of blending levels to use,
  *  given the current mask-bounding-box and intersection-bounding-box.
diff -r ef8470f9d682 src/common.h
--- a/src/common.h	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/common.h	Mon Apr 27 19:55:56 2020 -0700
@@ -41,9 +41,11 @@
 #include "error_message.h"
 #include "filenameparse.h"
 
-#define NUMERIC_OPTION_DELIMITERS ";:/"    //< numeric-option-delimiters ;:/
-#define PATH_OPTION_DELIMITERS ",;:"       //< path-option-delimiters ,;:
-#define ASSIGNMENT_CHARACTERS "="          //< assignment-characters =
+
+#define NUMERIC_OPTION_DELIMITERS ";:/"            //< numeric-option-delimiters ;:/
+#define NUMERIC_OPTION_DELIMITERS_REGEX "[;:/]"
+#define PATH_OPTION_DELIMITERS_REGEX "[,;:]"       //< path-option-delimiters ,;:
+#define ASSIGNMENT_CHARACTERS "="                  //< assignment-characters =
 
 #define MASK_COMPRESSION "DEFLATE"
 
@@ -141,7 +143,7 @@
 // to XYZ space (and for CIECAM then on to JCh).  The following two
 // #defines control the color transformation from and to XYZ space.
 #define RENDERING_INTENT_FOR_BLENDING INTENT_PERCEPTUAL
-#define TRANSFORMATION_FLAGS_FOR_BLENDING cmsFLAGS_NOCACHE
+#define TRANSFORMATION_FLAGS_FOR_BLENDING (cmsFLAGS_NOCACHE | cmsFLAGS_HIGHRESPRECALC)
 
 
 #define IMAGETYPE vigra::BasicImage
@@ -227,6 +229,25 @@
 }
 
 
+inline std::vector<std::string>
+split_string(const std::string& a_string, char a_delimiter, bool keep_empty_tokens)
+{
+    std::stringstream s(a_string);
+    std::vector<std::string> tokens;
+    std::string t;
+
+    while (std::getline(s, t, a_delimiter))
+    {
+        if (keep_empty_tokens || !t.empty())
+        {
+            tokens.push_back(t);
+        }
+    }
+
+    return tokens;
+}
+
+
 /** Answer the string representation of the boolean b. */
 std::string
 stringOfBool(bool b)
@@ -736,7 +757,7 @@
                     case 'n':
                         ++aNumber;
                         ++aNumberOfImages;
-                        BOOST_FALLTHROUGH;
+                        [[fallthrough]];
                     case 'i':
                     {
                         std::ostringstream oss;
@@ -884,6 +905,16 @@
     assert(number_of_channels == 1U || number_of_channels == 3U);
     return number_of_channels;
 }
+
+
+inline bool
+has_known_image_extension(const std::string an_image_filename)
+{
+    const std::string actual_extension {an_image_filename.substr(an_image_filename.rfind(".") + 1U)};
+    std::vector<std::string> known_extensions {split_string(vigra::impexListExtensions(), ' ', false)};
+    return std::find(known_extensions.begin(), known_extensions.end(), actual_extension) != known_extensions.end();
+}
+
 } // namespace enblend
 
 
@@ -927,7 +958,8 @@
         return nullptr;
     }
 }
-#endif
+#endif // !HAVE_STRTOK_R
+
 
 #endif /* __COMMON_H__ */
 
diff -r ef8470f9d682 src/dynamic_loader/win32_implementation.h
--- a/src/dynamic_loader/win32_implementation.h	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/dynamic_loader/win32_implementation.h	Mon Apr 27 19:55:56 2020 -0700
@@ -27,7 +27,7 @@
 
 #define NOMINMAX
 
-#include <Windows.h>
+#include <windows.h>
 
 #include "dynamic_loader_implementation.h"
 
diff -r ef8470f9d682 src/enblend.1
--- a/src/enblend.1	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/enblend.1	Mon Apr 27 19:55:56 2020 -0700
@@ -1,7 +1,7 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.46.4.
-.TH ENBLEND "1" "March 2016" "enblend 4.2" "User Commands"
+.TH ENBLEND "1" "May 2016" "enblend 4.3-8efb4525a0bb" "User Commands"
 .SH NAME
-enblend \- manual page for enblend 4.2
+enblend \- manual page for enblend 4.3-8efb4525a0bb
 .SH SYNOPSIS
 .B enblend
 [\fI\,options\/\fR] [\fI\,--output=IMAGE\/\fR] \fI\,INPUT\/\fR...
@@ -31,6 +31,10 @@
 "deflate", "jpeg", "lzw", "none", "packbits", for TIFF files and
 0 to 100, or "jpeg", "jpeg\-arith" for JPEG files,
 where "jpeg" and "jpeg\-arith" accept a compression level
+.TP
+\fB\-\-gpu\fR
+employ GPU in addition to CPU for selected computations; negate
+with "\-\-no\-gpu"
 .SS "Advanced options:"
 .TP
 \fB\-\-blend\-colorspace\fR=\fI\,COLORSPACE\/\fR
@@ -40,11 +44,6 @@
 other available blend color spaces are "CIELAB" and
 "CIECAM"
 .TP
-\fB\-c\fR, \fB\-\-ciecam\fR
-use CIECAM02 to blend colors; disable with "\-\-no\-ciecam";
-note that this option will be withdrawn in favor of
-"\-\-blend\-colorspace"
-.TP
 \fB\-d\fR, \fB\-\-depth\fR=\fI\,DEPTH\/\fR
 set the number of bits per channel of the output
 image, where DEPTH is "8", "16", "32", "r32", or "r64"
@@ -58,6 +57,10 @@
 associated\-alpha hack for Gimp (before version 2)
 and Cinepaint
 .TP
+\fB\-\-output\-mask\fR[=\fI\,FILE\/\fR]
+write output mask to FILE if the output format does not
+support alpha\-channels; default: "a.mask.tif"
+.TP
 \fB\-w\fR, \fB\-\-wrap\fR[=\fI\,MODE\/\fR]
 wrap around image boundary, where MODE is "none",
 "horizontal", "vertical", or "both"; default: none;
@@ -110,6 +113,12 @@
 "largest\-layer": select largest layer in each (multi\-)layer image;
 "no\-layer": do not select any layer from any image;
 .TP
+\fB\-\-prefer\-gpu\fR=\fI\,DEVICE\/\fR
+select DEVICE on auto\-detected platform as GPU
+.TP
+\fB\-\-prefer\-gpu\fR=\fI\,PLATFORM\/\fR:DEVICE
+select DEVICE on PLATFORM as GPU
+.TP
 \fB\-\-parameter\fR=\fI\,KEY1[=VALUE1][\/\fR:KEY2[=VALUE2][:...]]
 set one or more KEY\-VALUE pairs
 .SS "Expert mask generation options:"
@@ -152,6 +161,10 @@
 \fB\-\-show\-globbing\-algorithms\fR
 show all globbing algorithms
 .TP
+\fB\-\-show\-gpu\-info\fR
+list all available GPUs according to their platform and device;
+inform on current preferences
+.TP
 \fB\-\-show\-image\-formats\fR
 show all recognized image formats and their filename
 extensions
@@ -164,6 +177,11 @@
 .PP
 Enblend accepts arguments to any option in uppercase as
 well as in lowercase letters.
+.SH ENVIRONMENT
+.TP
+ENBLEND_OPENCL_PATH
+The ENBLEND_OPENCL_PATH environment variable sets the search
+path for OpenCL source files.
 .SH AUTHOR
 Written by Andrew Mihal, Christoph Spiel and others.
 .SH "REPORTING BUGS"
diff -r ef8470f9d682 src/enblend.cc
--- a/src/enblend.cc	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/enblend.cc	Mon Apr 27 19:55:56 2020 -0700
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2004-2009 Andrew Mihal
- * Copyright (C) 2009-2017 Christoph Spiel
+ * Copyright (C) 2009-2019 Christoph Spiel
  *
  * This file is part of Enblend.
  *
@@ -41,13 +41,13 @@
 
 #ifdef __GW32C__
 #undef malloc
-#define BOOST_NO_STDC_NAMESPACE 1
 #endif
 
 #include <algorithm>
 #include <iostream>
 #include <list>
 #include <memory>               // std::unique_ptr
+#include <optional>
 #include <set>
 #include <vector>
 
@@ -68,7 +68,11 @@
 #include <io.h>
 #endif
 
-#include <boost/tokenizer.hpp>
+#include <regex>
+
+#ifdef HAVE_EXIV2
+#include <exiv2/image.hpp>
+#endif
 
 #include <lcms2.h>
 #if !defined(LCMS_VERSION) || LCMS_VERSION < 2050
@@ -110,7 +114,8 @@
 
 // Global values from command line parameters.
 std::string OutputFileName(DEFAULT_OUTPUT_FILENAME);
-int Verbose = 1;                //< default-verbosity-level 1
+std::optional<std::string> OutputMaskFileName;
+int Verbose = 0;                //< default-verbosity-level 0
 int ExactLevels = 0;            // 0 means: automatically calculate maximum
 bool OneAtATime = true;
 boundary_t WrapAround = OpenBoundaries;
@@ -137,8 +142,8 @@
 std::string VisualizeTemplate("vis-%n.tif"); //< default-visualize-template vis-%n.tif
 bool VisualizeSeam = false;
 std::pair<double, double> OptimizerWeights =
-    std::make_pair(8.0,      //< default-optimizer-weight-distance 8.0
-                   1.0);     //< default-optimizer-weight-mismatch 1.0
+    std::make_pair(12.0,        //< default-optimizer-weight-distance 12.0
+                   1.0);        //< default-optimizer-weight-mismatch 1.0
 anneal_para_t AnnealPara = {
     32,                         //< default-anneal-kmax 32
     0.75,                       //< default-anneal-tau 0.75
@@ -208,7 +213,7 @@
 
 
 difference_functor_t
-differenceFunctorOfString(const char* aDifferenceFunctorName)
+differenceFunctorOfString(const std::string& aDifferenceFunctorName)
 {
     std::string name(aDifferenceFunctorName);
 
@@ -226,14 +231,13 @@
 }
 
 
-#define DUMP_GLOBAL_VARIABLES(...) dump_global_variables(__FILE__, __LINE__, ##__VA_ARGS__)
-void dump_global_variables(const char* file, unsigned line,
-                           std::ostream& out = std::cout)
+void dump_global_variables(std::ostream& out = std::cout)
 {
     out <<
-        "+ " << file << ":" << line << ": state of global variables\n" <<
+        "+ State of global variables\n" <<
         "+ Verbose = " << Verbose << ", option \"--verbose\"\n" <<
         "+ OutputFileName = <" << OutputFileName << ">\n" <<
+        "+ OutputMaskFileName = <" << OutputMaskFileName.value_or("<not defined>") << ">\n" <<
         "+ ExactLevels = " << ExactLevels << "\n" <<
         "+ UseGPU = " << UseGPU << "\n" <<
         "+ OneAtATime = " << enblend::stringOfBool(OneAtATime) << ", option \"-a\"\n" <<
@@ -321,9 +325,6 @@
         "                         those without and also for all floating-point images;\n" <<
         "                         other available blend color spaces are \"CIELAB\" and\n" <<
         "                         \"CIECAM\"\n" <<
-        "  -c, --ciecam           use CIECAM02 to blend colors; disable with \"--no-ciecam\";\n" <<
-        "                         note that this option will be withdrawn in favor of\n" <<
-        "                         \"--blend-colorspace\"\n" <<
         "  -d, --depth=DEPTH      set the number of bits per channel of the output\n" <<
         "                         image, where DEPTH is \"8\", \"16\", \"32\", \"r32\", or \"r64\"\n" <<
         "  -f WIDTHxHEIGHT[+xXOFFSET+yYOFFSET]\n" <<
@@ -332,6 +333,8 @@
         "                         TIFF images, such as those produced by Nona\n" <<
         "  -g                     associated-alpha hack for Gimp (before version 2)\n" <<
         "                         and Cinepaint\n" <<
+        "  --output-mask[=FILE]   write output mask to FILE if the output format does not\n" <<
+        "                         support alpha-channels; default: \"" << DEFAULT_OUTPUT_MASK_FILENAME << "\"\n" <<
         "  -w, --wrap[=MODE]      wrap around image boundary, where MODE is \"none\",\n" <<
         "                         \"horizontal\", \"vertical\", or \"both\"; default: " <<
         enblend::stringOfWraparound(WrapAround) << ";\n" <<
@@ -486,9 +489,9 @@
 
 enum AllPossibleOptions {
     VersionOption, PreAssembleOption /* -a */, NoPreAssembleOption, HelpOption, LevelsOption,
-    OutputOption, VerboseOption, WrapAroundOption /* -w */,
+    OutputOption, OutputMaskOption, VerboseOption, WrapAroundOption /* -w */,
     CheckpointOption /* -x */, CompressionOption, LZWCompressionOption,
-    BlendColorspaceOption, CIECAM02Option, NoCIECAM02Option, FallbackProfileOption,
+    BlendColorspaceOption, FallbackProfileOption,
     DepthOption, AssociatedAlphaOption /* -g */,
     GPUOption, NoGPUOption, PreferredGPUOption,
     SizeAndPositionOption /* -f */,
@@ -778,12 +781,11 @@
         VersionId,
         DepthId,
         OutputId,
+        OutputMaskId,
         WrapAroundId,
         OptimizerWeightsId,
         LevelsId,
         BlendColorspaceId,
-        CiecamId,
-        NoCiecamId,
         FallbackProfileId,
         LayerSelectorId,
         MainAlgoId,
@@ -801,7 +803,7 @@
         {"gpu", no_argument, 0, UseGpuId},
         {"no-gpu", no_argument, 0, NoUseGpuId},
         {"prefer-gpu", required_argument, 0, PreferGpuId},
-        {"preferred-gpu", required_argument, 0, PreferGpuId}, // gramatically close alternative form
+        {"preferred-gpu", required_argument, 0, PreferGpuId}, // grammatically close alternative form
         {"pre-assemble", no_argument, 0, PreAssembleId},
         {"preassemble", no_argument, 0, PreAssembleId}, // dash-less form: not documented, not deprecated
         {"no-pre-assemble", no_argument, 0, NoPreAssembleId},
@@ -824,13 +826,12 @@
         {"version", no_argument, 0, VersionId},
         {"depth", required_argument, 0, DepthId},
         {"output", required_argument, 0, OutputId},
+        {"output-mask", optional_argument, 0, OutputMaskId},
         {"wrap", optional_argument, 0, WrapAroundId},
         {"optimizer-weights", required_argument, 0, OptimizerWeightsId},
         {"levels", required_argument, 0, LevelsId},
         {"blend-colorspace", required_argument, 0, BlendColorspaceId},
         {"blend-color-space", required_argument, 0, BlendColorspaceId}, // dash form: not documented, not deprecated
-        {"ciecam", no_argument, 0, CiecamId},
-        {"no-ciecam", no_argument, 0, NoCiecamId},
         {"fallback-profile", required_argument, 0, FallbackProfileId},
         {"layer-selector", required_argument, 0, LayerSelectorId},
         {"primary-seam-generator", required_argument, 0, MainAlgoId},
@@ -922,13 +923,15 @@
             optionSet.insert(NoOptimizeOption);
             break;
 
-        case 'h': BOOST_FALLTHROUGH;
+        case 'h':
+            [[fallthrough]];
         case HelpId:
             print_only_task = USAGE_ONLY;
             optionSet.insert(HelpOption);
             break;
 
-        case 'V': BOOST_FALLTHROUGH;
+        case 'V':
+            [[fallthrough]];
         case VersionId:
             print_only_task = VERSION_ONLY;
             optionSet.insert(VersionOption);
@@ -959,7 +962,8 @@
             optionSet.insert(ShowGPUInfoOption);
             break;
 
-        case 'w': BOOST_FALLTHROUGH;
+        case 'w':
+            [[fallthrough]];
         case WrapAroundId:
             if (optarg != nullptr && *optarg != 0) {
                 WrapAround = enblend::wraparoundOfString(optarg);
@@ -1002,9 +1006,7 @@
             if (optarg != nullptr && *optarg != 0) {
                 std::string upper_opt(optarg);
                 enblend::to_upper(upper_opt);
-                if (upper_opt == "NONE") {
-                    ;           // stick with default
-                } else if (upper_opt == "DEFLATE" || upper_opt == "LZW" || upper_opt == "PACKBITS") {
+                if (upper_opt == "NONE" || upper_opt == "DEFLATE" || upper_opt == "LZW" || upper_opt == "PACKBITS") {
                     OutputCompression = upper_opt;
                 } else if (upper_opt.find_first_not_of("0123456789") == std::string::npos) {
                     OutputCompression = "JPEG QUALITY=" + upper_opt;
@@ -1044,7 +1046,8 @@
             optionSet.insert(CompressionOption);
             break;
 
-        case 'd': BOOST_FALLTHROUGH;
+        case 'd':
+            [[fallthrough]];
         case DepthId:
             if (optarg != nullptr && *optarg != 0) {
                 OutputPixelType = enblend::outputPixelTypeOfString(optarg);
@@ -1055,7 +1058,8 @@
             optionSet.insert(DepthOption);
             break;
 
-        case 'o': BOOST_FALLTHROUGH;
+        case 'o':
+            [[fallthrough]];
         case OutputId:
             if (contains(optionSet, OutputOption)) {
                 std::cerr << command
@@ -1071,73 +1075,74 @@
             optionSet.insert(OutputOption);
             break;
 
+        case OutputMaskId:
+            OutputMaskFileName = std::string(optarg ? optarg : DEFAULT_OUTPUT_MASK_FILENAME);
+            optionSet.insert(OutputMaskOption);
+            break;
+
         case ImageDifferenceId: {
-            char* tail;
-            boost::char_separator<char> separator(NUMERIC_OPTION_DELIMITERS, "", boost::keep_empty_tokens);
+            std::string::size_type tail;
+            const std::regex delimiterRegex(NUMERIC_OPTION_DELIMITERS_REGEX);
             const std::string arg(optarg);
-            boost::tokenizer<boost::char_separator<char> > tokenizer(arg, separator);
-            boost::tokenizer<boost::char_separator<char> >::iterator token = tokenizer.begin();
+            const std::sregex_token_iterator endOfSequence;
+            std::sregex_token_iterator token(arg.begin(), arg.end(), delimiterRegex, -1);
 
-            if (token == tokenizer.end()) {
+            if (token == endOfSequence) {
                 std::cerr << command << ": option \"--image-difference\" requires an argument" << std::endl;
                 failed = true;
             } else {
-                PixelDifferenceFunctor = differenceFunctorOfString(token->c_str());
+                PixelDifferenceFunctor = differenceFunctorOfString(token->str());
                 if (PixelDifferenceFunctor == UnknownDifference) {
                     std::cerr << command
-                              << ": unknown image difference algorithm \"" << *token << "\"" << std::endl;
+                              << ": unknown image difference algorithm \"" << token->str() << "\"" << std::endl;
                     failed = true;
                 }
                 ++token;
             }
 
-            if (token != tokenizer.end()) {
-                errno = 0;
-                LuminanceDifferenceWeight = strtod(token->c_str(), &tail);
-                if (errno == 0) {
-                    if (*tail != 0) {
+            if (token != endOfSequence) {
+                try {
+                    LuminanceDifferenceWeight = std::stod(token->str(), &tail);
+                    if (tail != token->str().length()) {
                         std::cerr << command << ": unrecognized luminance weight \""
-                                  << tail << "\" in \"" << *token << "\"" << std::endl;
+                                  << token->str().substr(tail) << "\" in \"" << token->str() << "\"" << std::endl;
                         failed = true;
                     }
                     if (LuminanceDifferenceWeight < 0.0) {
                         std::cerr << command << ": luminance weight must be non-negative" << std::endl;
                         failed = true;
                     }
-                } else {
+                } catch (std::invalid_argument&) {
                     std::cerr << command << ": illegal numeric format \""
-                              << *token << "\" of luminance weight: "
-                              << enblend::errorMessage(errno) << std::endl;
+                              << token->str() << "\" of luminance weight" << std::endl;
                     failed = true;
                 }
                 ++token;
             }
 
-            if (token != tokenizer.end()) {
-                errno = 0;
-                ChrominanceDifferenceWeight = strtod(token->c_str(), &tail);
-                if (errno == 0) {
-                    if (*tail != 0) {
+            if (token != endOfSequence) {
+                try {
+                    ChrominanceDifferenceWeight = std::stod(token->str(), &tail);
+                    if (tail != token->str().length()) {
                         std::cerr << command << ": unrecognized chrominance weight \""
-                                  << tail << "\" in \"" << *token << "\"" << std::endl;
+                                  << token->str().substr(tail) << "\" in \"" << token->str() << "\"" << std::endl;
                         failed = true;
                     }
                     if (ChrominanceDifferenceWeight < 0.0) {
                         std::cerr << command << ": chrominance weight must be non-negative" << std::endl;
                         failed = true;
                     }
-                } else {
+                } catch (std::invalid_argument&) {
                     std::cerr << command << ": illegal numeric format \""
-                              << *token << "\" of chrominance weight: "
-                              << enblend::errorMessage(errno) << std::endl;
+                              << token->str() << "\" of chrominance weight" << std::endl;
                     failed = true;
                 }
                 ++token;
             }
 
-            if (token != tokenizer.end()) {
+            if (token != endOfSequence) {
                 std::cerr << command << ": warning: ignoring trailing garbage \""
-                          << *token << "\" in argument to \"--image-difference\"" << std::endl;
+                          << token->str() << "\" in argument to \"--image-difference\"" << std::endl;
             }
 
             if (LuminanceDifferenceWeight + ChrominanceDifferenceWeight == 0.0) {
@@ -1150,33 +1155,33 @@
         }
 
         case AnnealId: {
-            char* tail;
-            boost::char_separator<char> separator(NUMERIC_OPTION_DELIMITERS, "", boost::keep_empty_tokens);
+            std::string::size_type tail;
+            const std::regex delimiterRegex(NUMERIC_OPTION_DELIMITERS_REGEX);
             const std::string arg(optarg);
-            boost::tokenizer<boost::char_separator<char> > tokenizer(arg, separator);
-            boost::tokenizer<boost::char_separator<char> >::iterator token = tokenizer.begin();
+            const std::sregex_token_iterator endOfSequence;
+            std::sregex_token_iterator token(arg.begin(), arg.end(), delimiterRegex, -1);
 
-            if (token != tokenizer.end()) {
-                errno = 0;
-                double tau = strtod(token->c_str(), &tail);
-                if (errno != 0) {
+            if (token != endOfSequence) {
+                double tau = 0;
+                try {
+                    tau = std::stod(token->str(), &tail);
+                    if (tail < token->str().length()) {
+                        if (token->str().substr(tail, 1) == "%") {
+                            tau /= 100.0;
+                        } else {
+                            std::cerr << command
+                                << ": --anneal: trailing garbage \""
+                                << token->str().substr(tail) << "\" in tau: \"" << token->str() << "\""
+                                << std::endl;
+                            failed = true;
+                        }
+                    }
+                } catch (std::invalid_argument&) {
                     std::cerr << command
-                              << ": option \"--anneal\": illegal numeric format \""
-                              << *token << "\" of tau: " << enblend::errorMessage(errno)
-                              << std::endl;
+                        << ": option \"--anneal\": illegal numeric format \""
+                        << token->str() << "\" of tau" << std::endl;
                     failed = true;
                 }
-                if (*tail != 0) {
-                    if (*tail == '%') {
-                        tau /= 100.0;
-                    } else {
-                        std::cerr << command
-                                  << ": --anneal: trailing garbage \""
-                                  << tail << "\" in tau: \"" << *token << "\""
-                                  << std::endl;
-                        failed = true;
-                    }
-                }
                 //< minimum-anneal-tau 0
                 if (tau <= 0.0) {
                     std::cerr << command
@@ -1195,20 +1200,19 @@
                 ++token;
             }
 
-            if (token != tokenizer.end()) {
-                errno = 0;
-                AnnealPara.deltaEMax = strtod(token->c_str(), &tail);
-                if (errno != 0) {
+            if (token != endOfSequence) {
+                try {
+                    AnnealPara.deltaEMax = std::stod(token->str(), &tail);
+                    if (tail != token->str().length()) {
+                        std::cerr << command
+                            << ": option \"--anneal\": trailing garbage \""
+                            << token->str().substr(tail) << "\" in deltaE_max: \""
+                            << token->str() << "\"" << std::endl;
+                        failed = true;
+                    }
+                } catch (std::invalid_argument&) {
                     std::cerr << command << ": option \"--anneal\": illegal numeric format \""
-                              << *token << "\" of deltaE_max: " << enblend::errorMessage(errno)
-                              << std::endl;
-                    failed = true;
-                }
-                if (*tail != 0) {
-                    std::cerr << command
-                              << ": option \"--anneal\": trailing garbage \""
-                              << tail << "\" in deltaE_max: \""
-                              << *token << "\"" << std::endl;
+                              << token->str() << "\" of deltaE_max" << std::endl;
                     failed = true;
                 }
                 //< minimum-anneal-deltae-max 0
@@ -1221,21 +1225,20 @@
                 ++token;
             }
 
-            if (token != tokenizer.end()) {
-                errno = 0;
-                AnnealPara.deltaEMin = strtod(token->c_str(), &tail);
-                if (errno != 0) {
+            if (token != endOfSequence) {
+                try {
+                    AnnealPara.deltaEMin = std::stod(token->str(), &tail);
+                    if (tail != token->str().length()) {
+                        std::cerr << command
+                            << ": option \"--anneal\": trailing garbage \""
+                            << token->str().substr(tail) << "\" in deltaE_min: \""
+                            << token->str() << "\"" << std::endl;
+                        failed = true;
+                    }
+                } catch (std::invalid_argument&) {
                     std::cerr << command
                               << ": option \"--anneal\": illegal numeric format \""
-                              << *token << "\" of deltaE_min: " << enblend::errorMessage(errno)
-                              << std::endl;
-                    failed = true;
-                }
-                if (*tail != 0) {
-                    std::cerr << command
-                              << ": option \"--anneal\": trailing garbage \""
-                              << tail << "\" in deltaE_min: \""
-                              << *token << "\"" << std::endl;
+                              << token->str() << "\" of deltaE_min" << std::endl;
                     failed = true;
                 }
                 //< minimum-anneal-deltae-min 0
@@ -1254,21 +1257,22 @@
                 failed = true;
             }
 
-            if (token != tokenizer.end()) {
-                errno = 0;
-                const long int kmax = strtol(token->c_str(), &tail, 10);
-                if (errno != 0) {
+            if (token != endOfSequence) {
+                long int kmax = 0;
+                try {
+                    kmax = std::stol(token->str(), &tail, 10);
+                    if (tail != token->str().length()) {
+                        std::cerr << command
+                            << ": option \"--anneal\": trailing garbage \""
+                            << token->str().substr(tail) << "\" in k_max: \""
+                            << token->str() << "\"" << std::endl;
+                        failed = true;
+                    }
+
+                } catch (std::invalid_argument&) {
                     std::cerr << command
                               << ": option \"--anneal\": illegal numeric format \""
-                              << *token << "\" of k_max: " << enblend::errorMessage(errno)
-                              << std::endl;
-                    failed = true;
-                }
-                if (*tail != 0) {
-                    std::cerr << command
-                              << ": option \"--anneal\": trailing garbage \""
-                              << tail << "\" in k_max: \""
-                              << *token << "\"" << std::endl;
+                              << token->str() << "\" of k_max" << std::endl;
                     failed = true;
                 }
                 //< minimum-anneal-kmax 3
@@ -1319,20 +1323,20 @@
         }
 
         case OptimizerWeightsId: {
-            boost::char_separator<char> separator(NUMERIC_OPTION_DELIMITERS, "", boost::keep_empty_tokens);
+            const std::regex delimiterRegex(NUMERIC_OPTION_DELIMITERS_REGEX);
             const std::string arg(optarg);
-            boost::tokenizer<boost::char_separator<char> > tokenizer(arg, separator);
-            boost::tokenizer<boost::char_separator<char> >::iterator token = tokenizer.begin();
+            const std::sregex_token_iterator endOfSequence;
+            std::sregex_token_iterator token(arg.begin(), arg.end(), delimiterRegex, -1);
 
             OptimizerWeights.first =
-                enblend::numberOfString(*token,
+                enblend::numberOfString(token->str(),
                                         [](double x) {return x >= 0.0;},
                                         "negative optimizer weight; will use 0.0",
                                         0.0);
             ++token;
-            if (token != tokenizer.end()) {
+            if (token != endOfSequence) {
                 OptimizerWeights.second =
-                    enblend::numberOfString(*token,
+                    enblend::numberOfString(token->str(),
                                             [](double x) {return x >= 0.0;},
                                             "negative optimizer weight; will use 0.0",
                                             0.0);
@@ -1346,7 +1350,8 @@
             break;
         }
 
-        case 'v': BOOST_FALLTHROUGH;
+        case 'v':
+            [[fallthrough]];
         case VerboseId:
             if (optarg != nullptr && *optarg != 0) {
                 Verbose = enblend::numberOfString(optarg,
@@ -1380,7 +1385,8 @@
             optionSet.insert(DijkstraRadiusOption);
             break;
 
-        case 'a': BOOST_FALLTHROUGH;
+        case 'a':
+            [[fallthrough]];
         case PreAssembleId:
             OneAtATime = false;
             optionSet.insert(PreAssembleOption);
@@ -1416,23 +1422,6 @@
             optionSet.insert(BlendColorspaceOption);
             break;
 
-        case 'c': BOOST_FALLTHROUGH;
-        case CiecamId:
-            std::cerr <<
-                command << ": info: option \"--ciecam\" will be withdrawn in the next release\n" <<
-                command << ": note: prefer option \"--blend-colorspace\" to \"--ciecam\"" << std::endl;
-            BlendColorspace = CIECAM;
-            optionSet.insert(CIECAM02Option);
-            break;
-
-        case NoCiecamId:
-            std::cerr <<
-                command << ": info: option \"--no-ciecam\" will be withdrawn in the next release\n" <<
-                command << ": note: prefer option \"--blend-colorspace\" to \"--no-ciecam\"" << std::endl;
-            BlendColorspace = IdentitySpace;
-            optionSet.insert(NoCIECAM02Option);
-            break;
-
         case FallbackProfileId:
             if (enblend::can_open_file(optarg)) {
                 FallbackProfile = cmsOpenProfileFromFile(optarg, "r");
@@ -1501,7 +1490,8 @@
             optionSet.insert(AssociatedAlphaOption);
             break;
 
-        case 'l': BOOST_FALLTHROUGH;
+        case 'l':
+            [[fallthrough]];
         case LevelsId:
             if (optarg != nullptr && *optarg != 0) {
                 std::string levels(optarg);
@@ -1533,13 +1523,6 @@
             optionSet.insert(LevelsOption);
             break;
 
-        case 's':
-            // Deprecated sequential blending flag.
-            OneAtATime = true;
-            std::cerr << command << ": warning: flag \"-s\" is deprecated." << std::endl;
-            optionSet.insert(SequentialBlendingOption);
-            break;
-
         case 'x':
             Checkpoint = true;
             optionSet.insert(CheckpointOption);
@@ -1558,22 +1541,22 @@
         }
 
         case ParameterId: {
-            boost::char_separator<char> separator(NUMERIC_OPTION_DELIMITERS, "", boost::keep_empty_tokens);
+            const std::regex delimiterRegex(NUMERIC_OPTION_DELIMITERS_REGEX);
             const std::string arg(optarg);
-            boost::tokenizer<boost::char_separator<char> > tokenizer(arg, separator);
-            boost::tokenizer<boost::char_separator<char> >::iterator token = tokenizer.begin();
+            const std::sregex_token_iterator endOfSequence;
+            std::sregex_token_iterator token(arg.begin(), arg.end(), delimiterRegex, -1);
 
-            for (auto token = tokenizer.begin(); token != tokenizer.end(); ++token) {
+            for (; token != endOfSequence; ++token) {
                 std::string key;
                 std::string value;
-                size_t delimiter = token->find_first_of(ASSIGNMENT_CHARACTERS);
+                size_t delimiter = token->str().find_first_of(ASSIGNMENT_CHARACTERS);
 
                 if (delimiter == std::string::npos) {
-                    key = *token;
+                    key = token->str();
                     value.assign("1");
                 } else {
-                    key = token->substr(0, delimiter);
-                    value = token->substr(delimiter + 1);
+                    key = token->str().substr(0, delimiter);
+                    value = token->str().substr(delimiter + 1);
                     if (value.empty()) {
                         std::cerr <<
                             command << ": parameter key \"" << key << "\" lacks a value;\n" <<
@@ -1596,13 +1579,13 @@
         }
 
         case NoParameterId: {
-            boost::char_separator<char> separator(NUMERIC_OPTION_DELIMITERS, "", boost::keep_empty_tokens);
+            const std::regex delimiterRegex(NUMERIC_OPTION_DELIMITERS_REGEX);
             const std::string arg(optarg);
-            boost::tokenizer<boost::char_separator<char> > tokenizer(arg, separator);
-            boost::tokenizer<boost::char_separator<char> >::iterator token = tokenizer.begin();
+            const std::sregex_token_iterator endOfSequence;
+            std::sregex_token_iterator token(arg.begin(), arg.end(), delimiterRegex, -1);
 
-            for (auto token = tokenizer.begin(); token != tokenizer.end(); ++token) {
-                std::string key(*token);
+            for (; token != endOfSequence; ++token) {
+                std::string key(token->str());
                 enblend::trim(key);
 
                 if (key == "*") {
@@ -1820,7 +1803,7 @@
     }
 
     if (parameter::as_boolean("dump-global-variables", false)) {
-        DUMP_GLOBAL_VARIABLES();
+        dump_global_variables();
     }
 
     sig.check();
@@ -2052,12 +2035,7 @@
                 }
             }
 
-            if (inputInfo->width() < minDim) {
-                minDim = inputInfo->width();
-            }
-            if (inputInfo->height() < minDim) {
-                minDim = inputInfo->height();
-            }
+            minDim = std::min(minDim, std::min(inputInfo->width(), inputInfo->height()));
         }
 
         ++layer;
@@ -2111,13 +2089,13 @@
 
     // Switch to fine mask, if the smallest coarse mask would be less
     // than 64 pixels wide or high.
-    if (minDim / 8 < 64 && CoarseMask) {
+    if (minDim / CoarsenessFactor < parameter::as_unsigned("smallest-coarse-mask-size", 64) && CoarseMask) {
         std::cerr << command
                   << ": warning: input images too small for coarse mask\n"
                   << command << ": note: switching to fine mask"
                   << std::endl;
         CoarseMask = false;
-        if (MainAlgorithm == GraphCut) {
+        if (MainAlgorithm == GraphCut && OptimizeMask) {
             std::cerr << command
                       << ": warning: fine mask combined with graphcut incompatible with mask optimization\n"
                       << command << ": note: defaulting to no optimization"
@@ -2133,12 +2111,26 @@
     }
 
     // Create the Info for the output file.
-    vigra::ImageExportInfo outputImageInfo(OutputFileName.c_str());
+    vigra::ImageExportInfo outputImageInfo(OutputFileName.c_str(), parameter::as_boolean("export-bigtiff", false) ? "w8" : "w");
+
+    if (!enblend::has_known_image_extension(OutputFileName)) {
+        std::string fallback_output_file_type {parameter::as_string("fallback-output-file-type",
+                                                                    DEFAULT_FALLBACK_OUTPUT_FILE_TYPE)};
+        if (OutputFileName == "-") {
+            outputImageInfo.setFileName("/dev/stdout");
+        } else {
+            std::cerr <<
+                command << ": warning: unknown filetype of output file \"" << OutputFileName << "\"\n" <<
+                command << ": note: will fallback to type \"" << fallback_output_file_type << "\"\n";
+        }
+        enblend::to_upper(fallback_output_file_type);
+        outputImageInfo.setFileType(fallback_output_file_type.c_str());
+    }
 
     if (!StopAfterMaskGeneration) {
         OutputIsValid = false;
 
-        // Make sure that inputUnion is at least as big as given by the -f paramater.
+        // Make sure that inputUnion is at least as big as given by the -f parameter.
         if (OutputSizeGiven) {
             inputUnion |= vigra::Rect2D(OutputOffsetXCmdLine,
                                         OutputOffsetYCmdLine,
@@ -2400,7 +2392,7 @@
         exit(1);
     } catch (vigra::StdException& e) {
         std::cerr << std::endl
-                  << command << ": an exception occured\n"
+                  << command << ": an exception occurred\n"
                   << command << ": " << e.what()
                   << std::endl;
         exit(1);
diff -r ef8470f9d682 src/enblend.h
--- a/src/enblend.h	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/enblend.h	Mon Apr 27 19:55:56 2020 -0700
@@ -34,10 +34,12 @@
 
 #include "rect2d.hxx"
 
+#include "allocate.h"
 #include "common.h"
 #include "opencl.h"
 #include "openmp_def.h"
 #include "openmp_vigra.h"
+#include "metadata.h"
 #include "numerictraits.h"
 #include "fixmath.h"
 #include "assemble.h"
@@ -94,9 +96,33 @@
 
     const unsigned numberOfImages = imageInfoList.size();
 
-    // Main blending loop.
     unsigned m = 0;
     FileNameList::const_iterator inputFileNameIterator(anInputFileNameList.begin());
+
+#ifdef HAVE_EXIV2
+    typedef allocate::array<Exiv2::Image::UniquePtr> metadata_array;
+    metadata_array input_metadata(anInputFileNameList.size());
+    {
+        FileNameList::const_iterator filename(anInputFileNameList.begin());
+        metadata_array::pointer metadata {input_metadata.begin()};
+
+        while (filename != anInputFileNameList.end()) {
+            try {
+                new (metadata) metadata_array::value_type(metadata::read(*filename));
+                input_metadata.mark_as_initialized(metadata - input_metadata.begin());
+            }
+            catch (Exiv2::Error& e) {
+                std::cerr <<
+                    command << ": warning: could not read metadata of input image \"" <<
+                    *inputFileNameIterator << "\"\n" <<
+                    command << ": note: " << e.what() << "\n";
+            }
+            ++filename;
+            ++metadata;
+        }
+    }
+#endif
+
     while (!imageInfoList.empty()) {
         // Create the white image.
         vigra::Rect2D whiteBB;
@@ -520,6 +546,51 @@
 
     delete blackPair.first;
     delete blackPair.second;
+
+#ifdef HAVE_EXIV2
+    if (OutputIsValid && parameter::as_boolean("metadata-pass-through", true)) {
+        const size_t metadata_source_image_index =
+            std::min(static_cast<size_t>(parameter::as_unsigned("metadata-source-image-index", 0)),
+                     input_metadata.size() - 1);
+
+        metadata::named_meta_array valid_named_metadata;
+
+        FileNameList::const_iterator filename(anInputFileNameList.begin());
+        for (size_t i = 0; i != input_metadata.size(); ++i) {
+            if (input_metadata.is_initialized(i) && input_metadata[i].get() && input_metadata[i]->good()) {
+                valid_named_metadata.push_back(metadata::Named(*filename,
+                                                               input_metadata[i].get(),
+                                                               i == metadata_source_image_index));
+            }
+            ++filename;
+        }
+
+        if (valid_named_metadata.empty()) {
+            std::cerr << command << ": warning: none of the input images contained valid metadata";
+        } else {
+            try {
+                metadata::named_meta_array::const_iterator
+                    input_meta(metadata::write(OutputFileName,
+                                               valid_named_metadata.begin(),
+                                               valid_named_metadata.end()));
+                if (Verbose >= VERBOSE_METADATA) {
+                    std::cerr <<
+                        command << ": info: attach metadata of input image \"" <<
+                        input_meta->filename() << "\" to output image \"" << OutputFileName << "\"\n";
+                }
+            }
+            catch (Exiv2::Error& e) {
+                std::cerr <<
+                    command << ": warning: could not write metadata to output image \"" <<
+                    OutputFileName << "\"\n" <<
+                    command << ": note: " << e.what() << "\n";
+            }
+            catch (metadata::Warning& w) {
+                std::cerr << command << ": warning: " << w.what() << "\n";
+            }
+        }
+    }
+#endif
 }
 
 } // namespace enblend
diff -r ef8470f9d682 src/enfuse.1
--- a/src/enfuse.1	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/enfuse.1	Mon Apr 27 19:55:56 2020 -0700
@@ -1,7 +1,7 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.46.4.
-.TH ENFUSE "1" "March 2016" "enfuse 4.2" "User Commands"
+.TH ENFUSE "1" "May 2016" "enfuse 4.3-8efb4525a0bb" "User Commands"
 .SH NAME
-enfuse \- manual page for enfuse 4.2
+enfuse \- manual page for enfuse 4.3-8efb4525a0bb
 .SH SYNOPSIS
 .B enfuse
 [\fI\,options\/\fR] [\fI\,--output=IMAGE\/\fR] \fI\,INPUT\/\fR...
@@ -31,6 +31,10 @@
 "deflate", "jpeg", "lzw", "none", "packbits", for TIFF files and
 0 to 100, or "jpeg", "jpeg\-arith" for JPEG files,
 where "jpeg" and "jpeg\-arith" accept a compression level
+.TP
+\fB\-\-gpu\fR
+employ GPU in addition to CPU for selected computations; negate
+with "\-\-no\-gpu"
 .SS "Advanced options:"
 .TP
 \fB\-\-blend\-colorspace\fR=\fI\,COLORSPACE\/\fR
@@ -40,11 +44,6 @@
 other available blend color spaces are "CIELAB" and
 "CIECAM"
 .TP
-\fB\-c\fR, \fB\-\-ciecam\fR
-use CIECAM02 to blend colors; disable with "\-\-no\-ciecam";
-note that this option will be withdrawn in favor of
-"\-\-blend\-colorspace"
-.TP
 \fB\-d\fR, \fB\-\-depth\fR=\fI\,DEPTH\/\fR
 set the number of bits per channel of the output
 image, where DEPTH is "8", "16", "32", "r32", or "r64"
@@ -58,6 +57,10 @@
 associated\-alpha hack for Gimp (before version 2)
 and Cinepaint
 .TP
+\fB\-\-output\-mask\fR[=\fI\,FILE\/\fR]
+write output mask to FILE if the output format does not
+support alpha\-channels; default: "a.mask.tif"
+.TP
 \fB\-w\fR, \fB\-\-wrap\fR[=\fI\,MODE\/\fR]
 wrap around image boundary, where MODE is "none",
 "horizontal", "vertical", or "both"; default: none;
@@ -125,6 +128,12 @@
 "largest\-layer": select largest layer in each (multi\-)layer image;
 "no\-layer": do not select any layer from any image;
 .TP
+\fB\-\-prefer\-gpu\fR=\fI\,DEVICE\/\fR
+select DEVICE on auto\-detected platform as GPU
+.TP
+\fB\-\-prefer\-gpu\fR=\fI\,PLATFORM\/\fR:DEVICE
+select DEVICE on PLATFORM as GPU
+.TP
 \fB\-\-parameter\fR=\fI\,KEY1[=VALUE1][\/\fR:KEY2[=VALUE2][:...]]
 set one or more KEY\-VALUE pairs
 .SS "Expert fusion options:"
@@ -191,6 +200,10 @@
 \fB\-\-show\-globbing\-algorithms\fR
 show all globbing algorithms
 .TP
+\fB\-\-show\-gpu\-info\fR
+list all available GPUs according to their platform and device;
+inform on current preferences
+.TP
 \fB\-\-show\-image\-formats\fR
 show all recognized image formats and their filename
 extensions
@@ -203,6 +216,12 @@
 .PP
 Enfuse accepts arguments to any option in uppercase as
 well as in lowercase letters.
+.SH ENVIRONMENT
+.TP
+ENBLEND_OPENCL_PATH
+The ENBLEND_OPENCL_PATH environment variable sets the search
+path for OpenCL source files.  Note that the variable name is
+ENBLEND_OPENCL_PATH for Enfuse, too.
 .SH AUTHOR
 Written by Andrew Mihal, Christoph Spiel and others.
 .SH "REPORTING BUGS"
diff -r ef8470f9d682 src/enfuse.cc
--- a/src/enfuse.cc	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/enfuse.cc	Mon Apr 27 19:55:56 2020 -0700
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2004-2009 Andrew Mihal
- * Copyright (C) 2009-2017 Christoph Spiel
+ * Copyright (C) 2009-2019 Christoph Spiel
  *
  * This file is part of Enblend.
  *
@@ -41,13 +41,13 @@
 
 #ifdef __GW32C__
 #undef malloc
-#define BOOST_NO_STDC_NAMESPACE 1
 #endif
 
 #include <algorithm>
 #include <iostream>
 #include <list>
 #include <memory>               // std::unique_ptr
+#include <optional>
 #include <set>
 #include <vector>
 
@@ -68,7 +68,11 @@
 #include <io.h>
 #endif
 
-#include <boost/tokenizer.hpp>
+#include <regex>
+
+#ifdef HAVE_EXIV2
+#include <exiv2/image.hpp>
+#endif
 
 #include <gsl/gsl_version.h>    // GSL_VERSION
 
@@ -96,7 +100,8 @@
 
 // Global values from command line parameters.
 std::string OutputFileName(DEFAULT_OUTPUT_FILENAME);
-int Verbose = 1;                //< default-verbosity-level 1
+std::optional<std::string> OutputMaskFileName;
+int Verbose = 0;                //< default-verbosity-level 0
 int ExactLevels = 0;            // 0 means: automatically calculate maximum
 bool OneAtATime = true;
 boundary_t WrapAround = OpenBoundaries;
@@ -120,7 +125,7 @@
 std::string ExposureLowerCutoffGrayscaleProjector("anti-value"); //< default-exposure-lower-cutoff-projector anti-value
 std::string ExposureUpperCutoffGrayscaleProjector("value"); //< default-exposure-upper-cutoff-projector value
 double WContrast = 0.0;         //< default-weight-contrast 0.0
-double WSaturation = 0.2;       //< default-weight-saturation 0.2
+double WSaturation = 0.0;       //< default-weight-saturation 0.0
 double WEntropy = 0.0;          //< default-weight-entropy 0.0
 bool WSaturationIsDefault = true;
 int ContrastWindowSize = 5;     //< default-contrast-window-size 5
@@ -199,14 +204,13 @@
 double* enblend::Histogram<InputPixelType, ResultPixelType>::precomputedEntropy = nullptr;
 
 
-#define DUMP_GLOBAL_VARIABLES(...) dump_global_variables(__FILE__, __LINE__, ##__VA_ARGS__)
-void dump_global_variables(const char* file, unsigned line,
-                           std::ostream& out = std::cout)
+void dump_global_variables(std::ostream& out = std::cout)
 {
     out <<
-        "+ " << file << ":" << line << ": state of global variables\n" <<
+        "+ State of global variables\n" <<
         "+ Verbose = " << Verbose << ", option \"--verbose\"\n" <<
         "+ OutputFileName = <" << OutputFileName << ">\n" <<
+        "+ OutputMaskFileName = <" << OutputMaskFileName.value_or("<not defined>") << ">\n" <<
         "+ ExactLevels = " << ExactLevels << "\n" <<
         "+ UseGPU = " << UseGPU << "\n" <<
         "+ OneAtATime = " << enblend::stringOfBool(OneAtATime) << ", option \"-a\"\n" <<
@@ -317,9 +321,6 @@
         "                         those without and also for all floating-point images;\n" <<
         "                         other available blend color spaces are \"CIELAB\" and\n" <<
         "                         \"CIECAM\"\n" <<
-        "  -c, --ciecam           use CIECAM02 to blend colors; disable with \"--no-ciecam\";\n" <<
-        "                         note that this option will be withdrawn in favor of\n" <<
-        "                         \"--blend-colorspace\"\n" <<
         "  -d, --depth=DEPTH      set the number of bits per channel of the output\n" <<
         "                         image, where DEPTH is \"8\", \"16\", \"32\", \"r32\", or \"r64\"\n" <<
         "  -f WIDTHxHEIGHT[+xXOFFSET+yYOFFSET]\n" <<
@@ -328,6 +329,8 @@
         "                         TIFF images, such as those produced by Nona\n" <<
         "  -g                     associated-alpha hack for Gimp (before version 2)\n" <<
         "                         and Cinepaint\n" <<
+        "  --output-mask[=FILE]   write output mask to FILE if the output format does not\n" <<
+        "                         support alpha-channels; default: \"" << DEFAULT_OUTPUT_MASK_FILENAME << "\"\n" <<
         "  -w, --wrap[=MODE]      wrap around image boundary, where MODE is \"none\",\n" <<
         "                         \"horizontal\", \"vertical\", or \"both\"; default: " <<
         enblend::stringOfWraparound(WrapAround) << ";\n" <<
@@ -522,9 +525,9 @@
 
 
 enum AllPossibleOptions {
-    VersionOption, HelpOption, LevelsOption, OutputOption, VerboseOption,
+    VersionOption, HelpOption, LevelsOption, OutputOption, OutputMaskOption, VerboseOption,
     WrapAroundOption /* -w */, CompressionOption, LZWCompressionOption,
-    BlendColorspaceOption, CIECAM02Option, NoCIECAM02Option, FallbackProfileOption,
+    BlendColorspaceOption, FallbackProfileOption,
     DepthOption, AssociatedAlphaOption /* -g */,
     GPUOption, NoGPUOption, PreferredGPUOption,
     SizeAndPositionOption /* -f */,
@@ -769,19 +772,18 @@
                     const std::string& an_option_name)
 {
     if (an_option_argument != nullptr && *an_option_argument != 0) {
-        boost::char_separator<char> separator(PATH_OPTION_DELIMITERS, "", boost::keep_empty_tokens);
-        const std::string arg(an_option_argument);
-        boost::tokenizer<boost::char_separator<char> > tokenizer(arg, separator);
-        boost::tokenizer<boost::char_separator<char> >::iterator token = tokenizer.begin();
+        const std::regex delimiterRegex(PATH_OPTION_DELIMITERS_REGEX);
+        const std::sregex_token_iterator endOfSequence;
+        std::sregex_token_iterator token(an_option_name.begin(), an_option_name.end(), delimiterRegex, -1);
 
-        a_soft_mask_template = *token;
+        a_soft_mask_template = token->str();
         ++token;
-        if (token != tokenizer.end()) {
-            a_hard_mask_template = *token;
+        if (token != endOfSequence) {
+            a_hard_mask_template = token->str();
         }
 
         ++token;
-        if (token != tokenizer.end()) {
+        if (token != endOfSequence) {
             std::cerr << command
                       << ": warning: ignoring trailing garbage in \"" << an_option_name << "\"" << std::endl;
         }
@@ -891,8 +893,8 @@
         WeightExposureId,
         WeightContrastId,
         WeightSaturationId,
-        ExposureOptimumId, ObsoleteExposureOptimumId,
-        ExposureWidthId, ObsoleteExposureWidthId,
+        ExposureOptimumId,
+        ExposureWidthId,
         ExposureWeightFunctionId,
         MinCurvatureId,
         EdgeScaleId,
@@ -908,12 +910,11 @@
         VersionId,
         DepthId,
         OutputId,
+        OutputMaskId,
         SaveMasksId,
         WrapAroundId,
         LevelsId,
         BlendColorspaceId,
-        CiecamId,
-        NoCiecamId,
         FallbackProfileId,
         ExposureCutoffId,
         LoadMasksId,
@@ -931,14 +932,12 @@
         {"gpu", no_argument, 0, UseGpuId},
         {"no-gpu", no_argument, 0, NoUseGpuId},
         {"prefer-gpu", required_argument, 0, PreferGpuId},
-        {"preferred-gpu", required_argument, 0, PreferGpuId}, // gramatically close alternative form
+        {"preferred-gpu", required_argument, 0, PreferGpuId}, // grammatically close alternative form
         {"compression", required_argument, 0, CompressionId},
         {"exposure-weight", required_argument, 0, WeightExposureId},
         {"contrast-weight", required_argument, 0, WeightContrastId},
         {"saturation-weight", required_argument, 0, WeightSaturationId},
-        {"exposure-mu", required_argument, 0, ObsoleteExposureOptimumId},
         {"exposure-optimum", required_argument, 0, ExposureOptimumId},
-        {"exposure-sigma", required_argument, 0, ObsoleteExposureWidthId},
         {"exposure-width", required_argument, 0, ExposureWidthId},
         {"exposure-weight-function", required_argument, 0, ExposureWeightFunctionId},
         {"contrast-min-curvature", required_argument, 0, MinCurvatureId},
@@ -955,14 +954,13 @@
         {"version", no_argument, 0, VersionId},
         {"depth", required_argument, 0, DepthId},
         {"output", required_argument, 0, OutputId},
+        {"output-mask", optional_argument, 0, OutputMaskId},
         {"save-mask", optional_argument, 0, SaveMasksId}, // singular form: not documented, not deprecated
         {"save-masks", optional_argument, 0, SaveMasksId},
         {"wrap", optional_argument, 0, WrapAroundId},
         {"blend-colorspace", required_argument, 0, BlendColorspaceId},
         {"blend-color-space", required_argument, 0, BlendColorspaceId}, // dash form: not documented, not deprecated
         {"levels", required_argument, 0, LevelsId},
-        {"ciecam", no_argument, 0, CiecamId},
-        {"no-ciecam", no_argument, 0, NoCiecamId},
         {"fallback-profile", required_argument, 0, FallbackProfileId},
         {"exposure-cutoff", required_argument, 0, ExposureCutoffId},
         {"load-mask", optional_argument, 0, LoadMasksId}, // singular form: not documented, not deprecated
@@ -1051,13 +1049,15 @@
             optionSet.insert(SoftMaskOption);
             break;
 
-        case 'h': BOOST_FALLTHROUGH;
+        case 'h':
+            [[fallthrough]];
         case HelpId:
             print_only_task = USAGE_ONLY;
             optionSet.insert(HelpOption);
             break;
 
-        case 'V': BOOST_FALLTHROUGH;
+        case 'V':
+            [[fallthrough]];
         case VersionId:
             print_only_task = VERSION_ONLY;
             optionSet.insert(VersionOption);
@@ -1088,7 +1088,8 @@
             optionSet.insert(ShowGPUInfoOption);
             break;
 
-        case 'w': BOOST_FALLTHROUGH;
+        case 'w':
+            [[fallthrough]];
         case WrapAroundId:
             if (optarg != nullptr && *optarg != 0) {
                 WrapAround = enblend::wraparoundOfString(optarg);
@@ -1128,80 +1129,78 @@
         }
 
         case EdgeScaleId: {
-            char* tail;
-            boost::char_separator<char> separator(NUMERIC_OPTION_DELIMITERS, "", boost::keep_empty_tokens);
+            std::string::size_type tail;
+            const std::regex delimiterRegex(NUMERIC_OPTION_DELIMITERS_REGEX);
             const std::string arg(optarg);
-            boost::tokenizer<boost::char_separator<char> > tokenizer(arg, separator);
-            boost::tokenizer<boost::char_separator<char> >::iterator token = tokenizer.begin();
+            const std::sregex_token_iterator endOfSequence;
+            std::sregex_token_iterator token(arg.begin(), arg.end(), delimiterRegex, -1);
 
-            if (token == tokenizer.end()) {
+            if (token == endOfSequence) {
                 std::cerr << command << ": no scale given to \"--contrast-edge-scale\".  "
                           << "scale is required." << std::endl;
                 failed = true;
             } else {
-                errno = 0;
-                FilterConfig.edgeScale = strtod(token->c_str(), &tail);
-                if (errno == 0) {
-                    if (*tail != 0) {
-                        std::cerr << command << ": could not decode \"" << tail
+                try {
+                    FilterConfig.edgeScale = std::stod(token->str(), &tail);
+                    if (tail != token->str().length()) {
+                        std::cerr << command << ": could not decode \"" << token->str().substr(tail)
                                   << "\" in edge scale specification \""
-                                  << *token << "\" for edge scale." << std::endl;
+                                  << token->str() << "\" for edge scale." << std::endl;
                         failed = true;
                     }
-                } else {
+                } catch (std::invalid_argument&) {
                     std::cerr << command << ": illegal numeric format \""
-                              << *token << "\" for edge scale: "
-                              << enblend::errorMessage(errno) << std::endl;
-                    failed = true;
-                }
-		++token;
-            }
-
-            if (token != tokenizer.end()) {
-                errno = 0;
-                FilterConfig.lceScale = strtod(token->c_str(), &tail);
-                if (errno == 0) {
-                    if (strcmp(tail, "%") == 0) {
-                        FilterConfig.lceScale *= FilterConfig.edgeScale / 100.0;
-                    } else if (*tail != 0) {
-                        std::cerr << command << ": could not decode \"" << tail
-                                  << "\" in specification \"" << *token
-                                  << "\" for LCE-scale." << std::endl;
-                        failed = true;
-                    }
-                } else {
-                    std::cerr << command << ": illegal numeric format \""
-                              << *token << "\" for LCE-Scale: "
-                              << enblend::errorMessage(errno) << std::endl;
+                              << token->str() << "\" for edge scale" << std::endl;
                     failed = true;
                 }
                 ++token;
             }
 
-            if (token != tokenizer.end()) {
-                errno = 0;
-                FilterConfig.lceFactor = strtod(token->c_str(), &tail);
-                if (errno == 0) {
-                    if (strcmp(tail, "%") == 0) {
-                        FilterConfig.lceFactor /= 100.0;
-                    } else if (*tail != 0) {
-                        std::cerr << command << ": could not decode \"" << tail
-                                  << "\" in specification \"" << *token
-                                  << "\" for LCE-factor." << std::endl;
-                        failed = true;
+            if (token != endOfSequence) {
+                try {
+                    FilterConfig.lceScale = std::stod(token->str(), &tail);
+                    if (tail < token->str().length()) {
+                        if (token->str().substr(tail, 1) == "%") {
+                            FilterConfig.lceScale *= FilterConfig.edgeScale / 100.0;
+                        } else {
+                            std::cerr << command << ": could not decode \"" << token->str().substr(tail)
+                                << "\" in specification \"" << token->str()
+                                << "\" for LCE-scale." << std::endl;
+                            failed = true;
+                        }
                     }
-                } else {
+                } catch (std::invalid_argument&) {
                     std::cerr << command << ": illegal numeric format \""
-                              << *token << "\" for LCE-factor: "
-                              << enblend::errorMessage(errno) << std::endl;
+                              << token->str() << "\" for LCE-Scale" << std::endl;
                     failed = true;
                 }
                 ++token;
             }
 
-            if (token != tokenizer.end()) {
+            if (token != endOfSequence) {
+                try {
+                    FilterConfig.lceFactor = std::stod(token->str(), &tail);
+                    if (tail < token->str().length()) {
+                        if(token->str().substr(tail,1) == "%") {
+                            FilterConfig.lceFactor /= 100.0;
+                        } else  {
+                            std::cerr << command << ": could not decode \"" << token->str().substr(tail)
+                                      << "\" in specification \"" << token->str()
+                                      << "\" for LCE-factor." << std::endl;
+                            failed = true;
+                        }
+                    }
+                } catch (std::invalid_argument&) {
+                    std::cerr << command << ": illegal numeric format \""
+                              << token->str() << "\" for LCE-factor" << std::endl;
+                    failed = true;
+                }
+                ++token;
+            }
+
+            if (token != endOfSequence) {
                 std::cerr << command << ": warning: ignoring trailing garbage \""
-                          << *token << "\" in argument to \"--contrast-edge-scale\"" << std::endl;
+                          << token->str() << "\" in argument to \"--contrast-edge-scale\"" << std::endl;
             }
 
             optionSet.insert(EdgeScaleOption);
@@ -1209,62 +1208,58 @@
         }
 
         case EntropyCutoffId: {
-            char* tail;
-            boost::char_separator<char> separator(NUMERIC_OPTION_DELIMITERS, "", boost::keep_empty_tokens);
+            std::string::size_type tail;
+            const std::regex delimiterRegex(NUMERIC_OPTION_DELIMITERS_REGEX);
             const std::string arg(optarg);
-            boost::tokenizer<boost::char_separator<char> > tokenizer(arg, separator);
-            boost::tokenizer<boost::char_separator<char> >::iterator token = tokenizer.begin();
+            const std::sregex_token_iterator endOfSequence;
+            std::sregex_token_iterator token(arg.begin(), arg.end(), delimiterRegex, -1);
 
-            if (token == tokenizer.end()) {
+            if (token == endOfSequence) {
                 std::cerr << command << ": no scale given to \"--entropy-cutoff\".  "
                           << "lower cutoff is required." << std::endl;
                 failed = true;
             } else {
-                errno = 0;
-                EntropyLowerCutoff.set_value(strtod(token->c_str(), &tail));
-                if (errno == 0) {
-                    if (*tail == 0) {
+                try {
+                    EntropyLowerCutoff.set_value(std::stod(token->str(), &tail));
+                    if (tail == token->str().length()) {
                         EntropyLowerCutoff.set_percentage(false);
-                    } else if (strcmp(tail, "%") == 0) {
+                    } else if (token->str().substr(tail, 1) == "%") {
                         EntropyLowerCutoff.set_percentage(true);
                     } else {
                         std::cerr << command << ": unrecognized entropy's lower cutoff \""
-                                  << tail << "\" in \"" << *token << "\"" << std::endl;
+                                  << token->str().substr(tail) << "\" in \"" << token->str() << "\"" << std::endl;
                         failed = true;
                     }
-                } else {
+                } catch (std::invalid_argument&) {
                     std::cerr << command << ": illegal numeric format \""
-                              << *token << "\" of entropy's lower cutoff: "
-                              << enblend::errorMessage(errno) << std::endl;
+                              << token->str() << "\" of entropy's lower cutoff" << std::endl;
                     failed = true;
                 }
                 ++token;
             }
 
-            if (token != tokenizer.end()) {
-                errno = 0;
-                EntropyUpperCutoff.set_value(strtod(token->c_str(), &tail));
-                if (errno == 0) {
-                    if (*tail == 0) {
+            if (token != endOfSequence) {
+                try {
+                    EntropyUpperCutoff.set_value(std::stod(token->str(), &tail));
+                    if (tail == token->str().length()) {
                         EntropyUpperCutoff.set_percentage(false);
-                    } else if (strcmp(tail, "%") == 0) {
+                    } else if (token->str().substr(tail, 1) == "%") {
                         EntropyUpperCutoff.set_percentage(true);
                     } else {
                         std::cerr << command << ": unrecognized entropy's upper cutoff \""
-                                  << tail << "\" in \"" << *token << "\"" << std::endl;
+                                  << token->str().substr(tail) << "\" in \"" << token->str() << "\"" << std::endl;
                         failed = true;
                     }
-                } else {
+                } catch (std::invalid_argument&) {
                     std::cerr << command << ": illegal numeric format \""
-                              << *token << "\" of entropy's upper cutoff: "
-                              << enblend::errorMessage(errno) << std::endl;
+                              << token->str() << "\" of entropy's upper cutoff" << std::endl;
                     failed = true;
                 }
             }
 
-            if (token != tokenizer.end()) {
+            if (token != endOfSequence) {
                 std::cerr << command << ": warning: ignoring trailing garbage \""
-                          << *token << "\" in argument to \"--entropy-cutoff\"" << std::endl;
+                          << token->str() << "\" in argument to \"--entropy-cutoff\"" << std::endl;
             }
 
             optionSet.insert(EntropyCutoffOption);
@@ -1272,73 +1267,69 @@
         }
 
         case ExposureCutoffId: {
-            char* tail;
-            boost::char_separator<char> separator(NUMERIC_OPTION_DELIMITERS, "", boost::keep_empty_tokens);
+            std::string::size_type tail;
+            const std::regex delimiterRegex(NUMERIC_OPTION_DELIMITERS_REGEX);
             const std::string arg(optarg);
-            boost::tokenizer<boost::char_separator<char> > tokenizer(arg, separator);
-            boost::tokenizer<boost::char_separator<char> >::iterator token = tokenizer.begin();
+            const std::sregex_token_iterator endOfSequence;
+            std::sregex_token_iterator token(arg.begin(), arg.end(), delimiterRegex, -1);
 
-            if (token == tokenizer.end()) {
+            if (token == endOfSequence) {
                 std::cerr << command << ": no value given to \"--exposure-cutoff\";  "
                           << "lower cutoff is required." << std::endl;
                 failed = true;
             } else {
-                errno = 0;
-                ExposureLowerCutoff.set_value(strtod(token->c_str(), &tail));
-                if (errno == 0) {
-                    if (*tail == 0) {
+                try {
+                    ExposureLowerCutoff.set_value(std::stod(token->str(), &tail));
+                    if (tail == token->str().length()) {
                         ExposureLowerCutoff.set_percentage(false);
-                    } else if (strcmp(tail, "%") == 0) {
+                    } else if (token->str().substr(tail, 1) == "%") {
                         ExposureLowerCutoff.set_percentage(true);
                     } else {
                         std::cerr << command << ": unrecognized exposure's lower cutoff \""
-                                  << tail << "\" in \"" << *token << "\"" << std::endl;
+                                  << token->str().substr(tail) << "\" in \"" << token->str() << "\"" << std::endl;
                         failed = true;
                     }
-                } else {
+                } catch (std::invalid_argument&) {
                     std::cerr << command << ": illegal numeric format \""
-                              << *token << "\" of exposure's lower cutoff: "
-                              << enblend::errorMessage(errno) << std::endl;
+                              << token->str() << "\" of exposure's lower cutoff" << std::endl;
                     failed = true;
                 }
                 ++token;
             }
 
-            if (token != tokenizer.end()) {
-                errno = 0;
-                ExposureUpperCutoff.set_value(strtod(token->c_str(), &tail));
-                if (errno == 0) {
-                    if (*tail == 0) {
+            if (token != endOfSequence) {
+                try {
+                    ExposureUpperCutoff.set_value(std::stod(token->str(), &tail));
+                    if (tail == token->str().length()) {
                         ExposureUpperCutoff.set_percentage(false);
-                    } else if (strcmp(tail, "%") == 0) {
+                    } else if (token->str().substr(tail, 1) == "%") {
                         ExposureUpperCutoff.set_percentage(true);
                     } else {
                         std::cerr << command << ": unrecognized exposure's upper cutoff \""
-                                  << tail << "\" in \"" << *token << "\"" << std::endl;
+                                  << token->str().substr(tail) << "\" in \"" << token->str() << "\"" << std::endl;
                         failed = true;
                     }
-                } else {
+                } catch (std::invalid_argument&) {
                     std::cerr << command << ": illegal numeric format \""
-                              << *token << "\" of exposure's upper cutoff: "
-                              << enblend::errorMessage(errno) << std::endl;
+                              << token->str() << "\" of exposure's upper cutoff" << std::endl;
                     failed = true;
                 }
                 ++token;
             }
 
-            if (token != tokenizer.end()) {
-                ExposureLowerCutoffGrayscaleProjector = *token;
+            if (token != endOfSequence) {
+                ExposureLowerCutoffGrayscaleProjector = token->str();
                 ++token;
             }
 
-            if (token != tokenizer.end()) {
-                ExposureUpperCutoffGrayscaleProjector = *token;
+            if (token != endOfSequence) {
+                ExposureUpperCutoffGrayscaleProjector = token->str();
                 ++token;
             }
 
-            if (token != tokenizer.end()) {
+            if (token != endOfSequence) {
                 std::cerr << command << ": warning: ignoring trailing garbage \""
-                          << *token << "\" in argument to \"--exposure-cutoff\"" << std::endl;
+                          << token->str() << "\" in argument to \"--exposure-cutoff\"" << std::endl;
             }
 
             optionSet.insert(ExposureCutoffOption);
@@ -1349,9 +1340,7 @@
             if (optarg != nullptr && *optarg != 0) {
                 std::string upper_opt(optarg);
                 enblend::to_upper(upper_opt);
-                if (upper_opt == "NONE") {
-                    ;           // stick with default
-                } else if (upper_opt == "DEFLATE" || upper_opt == "LZW" || upper_opt == "PACKBITS") {
+                if (upper_opt == "NONE" || upper_opt == "DEFLATE" || upper_opt == "LZW" || upper_opt == "PACKBITS") {
                     OutputCompression = upper_opt;
                 } else if (upper_opt.find_first_not_of("0123456789") == std::string::npos) {
                     OutputCompression = "JPEG QUALITY=" + upper_opt;
@@ -1401,7 +1390,8 @@
             optionSet.insert(GrayProjectorOption);
             break;
 
-        case 'd': BOOST_FALLTHROUGH;
+        case 'd':
+            [[fallthrough]];
         case DepthId:
             if (optarg != nullptr && *optarg != 0) {
                 OutputPixelType = enblend::outputPixelTypeOfString(optarg);
@@ -1412,7 +1402,8 @@
             optionSet.insert(DepthOption);
             break;
 
-        case 'o': BOOST_FALLTHROUGH;
+        case 'o':
+            [[fallthrough]];
         case OutputId:
             if (contains(optionSet, OutputOption)) {
                 std::cerr << command
@@ -1428,6 +1419,11 @@
             optionSet.insert(OutputOption);
             break;
 
+        case OutputMaskId:
+            OutputMaskFileName = std::string(optarg ? optarg : DEFAULT_OUTPUT_MASK_FILENAME);
+            optionSet.insert(OutputMaskOption);
+            break;
+
         case LoadMasksId:
             fill_mask_templates(optarg, SoftMaskTemplate, HardMaskTemplate, "--load-masks");
             LoadMasks = true;
@@ -1491,9 +1487,6 @@
             optionSet.insert(SaturationWeightOption);
             break;
 
-        case ObsoleteExposureOptimumId:
-            std::cerr << command << ": info: option \"--exposure-mu\" is obsolete, prefer \"--exposure-optimum\"" << std::endl;
-            BOOST_FALLTHROUGH;
         case ExposureOptimumId:
             if (optarg != nullptr && *optarg != 0) {
                 ExposureOptimum =
@@ -1511,10 +1504,6 @@
             optionSet.insert(ExposureOptimumOption);
             break;
 
-
-        case ObsoleteExposureWidthId:
-            std::cerr << command << ": info: option \"--exposure-sigma\" is obsolete, prefer \"--exposure-width\"" << std::endl;
-            BOOST_FALLTHROUGH;
         case ExposureWidthId:
             if (optarg != nullptr && *optarg != 0) {
                 ExposureWidth =
@@ -1530,31 +1519,31 @@
             break;
 
         case ExposureWeightFunctionId: {
+            const std::regex delimiterRegex(PATH_OPTION_DELIMITERS_REGEX);
             const std::string arg(optarg);
-            boost::char_separator<char> separator(PATH_OPTION_DELIMITERS);
-            boost::tokenizer<boost::char_separator<char> > tokenizer(arg, separator);
-            boost::tokenizer<boost::char_separator<char> >::iterator token = tokenizer.begin();
+            const std::sregex_token_iterator endOfSequence;
+            std::sregex_token_iterator token(arg.begin(), arg.end(), delimiterRegex, -1);
 
-            if (token == tokenizer.end()) {
+            if (token == endOfSequence) {
                 std::cerr << command
                           << ": option \"--exposure-weight-function\" requires an argument" << std::endl;
                 failed = true;
             } else {
-                ExposureWeightFunctionName = *token;
+                ExposureWeightFunctionName = token->str();
                 ++token;
 #ifdef _WIN32
                 // special handling of absolute filenames on Windows
-                if (ExposureWeightFunctionName.length() == 1U && arg.length() > 2U && arg[1] == ':' && token != tokenizer.end())
+                if (ExposureWeightFunctionName.length() == 1U && arg.length() > 2U && arg[1] == ':' && token != endOfSequence)
                 {
                     ExposureWeightFunctionName.append(":");
-                    ExposureWeightFunctionName.append(*token);
+                    ExposureWeightFunctionName.append(token->str());
                     ++token;
                 }
 #endif
             }
 
-            for (; token != tokenizer.end(); ++token) {
-                ExposureWeightFunctionArguments.push_back(*token);
+            for (; token != endOfSequence; ++token) {
+                ExposureWeightFunctionArguments.push_back(token->str());
             }
 
             optionSet.insert(ExposureWeightFunctionOption);
@@ -1578,7 +1567,8 @@
             optionSet.insert(EntropyWeightOption);
             break;
 
-        case 'v': BOOST_FALLTHROUGH;
+        case 'v':
+            [[fallthrough]];
         case VerboseId:
             if (optarg != nullptr && *optarg != 0) {
                 Verbose =
@@ -1657,23 +1647,6 @@
             optionSet.insert(BlendColorspaceOption);
             break;
 
-        case 'c': BOOST_FALLTHROUGH;
-        case CiecamId:
-            std::cerr <<
-                command << ": info: option \"--ciecam\" will be withdrawn in the next release\n" <<
-                command << ": note: prefer option \"--blend-colorspace\" to \"--ciecam\"" << std::endl;
-            BlendColorspace = CIECAM;
-            optionSet.insert(CIECAM02Option);
-            break;
-
-        case NoCiecamId:
-            std::cerr <<
-                command << ": info: option \"--no-ciecam\" will be withdrawn in the next release\n" <<
-                command << ": note: prefer option \"--blend-colorspace\" to \"--no-ciecam\"" << std::endl;
-            BlendColorspace = IdentitySpace;
-            optionSet.insert(NoCIECAM02Option);
-            break;
-
         case FallbackProfileId:
             if (enblend::can_open_file(optarg)) {
                 FallbackProfile = cmsOpenProfileFromFile(optarg, "r");
@@ -1715,7 +1688,8 @@
             optionSet.insert(AssociatedAlphaOption);
             break;
 
-        case 'l': BOOST_FALLTHROUGH;
+        case 'l':
+            [[fallthrough]];
         case LevelsId:
             if (optarg != nullptr && *optarg != 0) {
                 std::string levels(optarg);
@@ -1760,22 +1734,22 @@
         }
 
         case ParameterId: {
-            boost::char_separator<char> separator(NUMERIC_OPTION_DELIMITERS, "", boost::keep_empty_tokens);
+            const std::regex delimiterRegex(NUMERIC_OPTION_DELIMITERS_REGEX);
             const std::string arg(optarg);
-            boost::tokenizer<boost::char_separator<char> > tokenizer(arg, separator);
-            boost::tokenizer<boost::char_separator<char> >::iterator token = tokenizer.begin();
+            const std::sregex_token_iterator endOfSequence;
+            std::sregex_token_iterator token(arg.begin(), arg.end(), delimiterRegex, -1);
 
-            for (auto token = tokenizer.begin(); token != tokenizer.end(); ++token) {
+            for (; token != endOfSequence; ++token) {
                 std::string key;
                 std::string value;
-                size_t delimiter = token->find_first_of(ASSIGNMENT_CHARACTERS);
+                size_t delimiter = token->str().find_first_of(ASSIGNMENT_CHARACTERS);
 
                 if (delimiter == std::string::npos) {
-                    key = *token;
+                    key = token->str();
                     value.assign("1");
                 } else {
-                    key = token->substr(0, delimiter);
-                    value = token->substr(delimiter + 1);
+                    key = token->str().substr(0, delimiter);
+                    value = token->str().substr(delimiter + 1);
                     if (value.empty()) {
                         std::cerr <<
                             command << ": parameter key \"" << key << "\" lacks a value;\n" <<
@@ -1798,13 +1772,13 @@
         }
 
         case NoParameterId: {
-            boost::char_separator<char> separator(NUMERIC_OPTION_DELIMITERS, "", boost::keep_empty_tokens);
+            const std::regex delimiterRegex(NUMERIC_OPTION_DELIMITERS_REGEX);
             const std::string arg(optarg);
-            boost::tokenizer<boost::char_separator<char> > tokenizer(arg, separator);
-            boost::tokenizer<boost::char_separator<char> >::iterator token = tokenizer.begin();
+            const std::sregex_token_iterator endOfSequence;
+            std::sregex_token_iterator token(arg.begin(), arg.end(), delimiterRegex, -1);
 
-            for (auto token = tokenizer.begin(); token != tokenizer.end(); ++token) {
-                std::string key(*token);
+            for (; token != endOfSequence; ++token) {
+                std::string key(token->str());
                 enblend::trim(key);
 
                 if (key == "*") {
@@ -2053,7 +2027,7 @@
     }
 
     if (parameter::as_boolean("dump-global-variables", false)) {
-        DUMP_GLOBAL_VARIABLES();
+        dump_global_variables();
     }
 
     sig.check();
@@ -2337,12 +2311,26 @@
     }
 
     // Create the Info for the output file.
-    vigra::ImageExportInfo outputImageInfo(OutputFileName.c_str());
+    vigra::ImageExportInfo outputImageInfo(OutputFileName.c_str(), parameter::as_boolean("export-bigtiff", false) ? "w8" : "w");
+
+    if (!enblend::has_known_image_extension(OutputFileName)) {
+        std::string fallback_output_file_type {parameter::as_string("fallback-output-file-type",
+                                                                    DEFAULT_FALLBACK_OUTPUT_FILE_TYPE)};
+        if (OutputFileName == "-") {
+            outputImageInfo.setFileName("/dev/stdout");
+        } else {
+            std::cerr <<
+                command << ": warning: unknown filetype of output file \"" << OutputFileName << "\"\n" <<
+                command << ": note: will fallback to type \"" << fallback_output_file_type << "\"\n";
+        }
+        enblend::to_upper(fallback_output_file_type);
+        outputImageInfo.setFileType(fallback_output_file_type.c_str());
+    }
 
     if (!StopAfterMaskGeneration) {
         OutputIsValid = false;
 
-        // Make sure that inputUnion is at least as big as given by the -f paramater.
+        // Make sure that inputUnion is at least as big as given by the -f parameter.
         if (OutputSizeGiven) {
             inputUnion |= vigra::Rect2D(OutputOffsetXCmdLine,
                                         OutputOffsetYCmdLine,
@@ -2612,7 +2600,7 @@
         exit(1);
     } catch (vigra::StdException& e) {
         std::cerr << std::endl
-                  << command << ": an exception occured\n"
+                  << command << ": an exception occurred\n"
                   << command << ": " << e.what()
                   << std::endl;
         exit(1);
diff -r ef8470f9d682 src/enfuse.h
--- a/src/enfuse.h	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/enfuse.h	Mon Apr 27 19:55:56 2020 -0700
@@ -39,11 +39,13 @@
 #include <vigra/stdimage.hxx>
 #include <vigra/transformimage.hxx>
 
+#include "allocate.h"
 #include "common.h"
 #include "filespec.h"
 #include "opencl.h"
 #include "openmp_def.h"
 #include "openmp_vigra.h"
+#include "metadata.h"
 #include "numerictraits.h"
 #include "fixmath.h"
 #include "assemble.h"
@@ -178,7 +180,7 @@
                 break;
             }
 
-            // Compute auxilliary values of next column
+            // Compute auxiliary values of next column
             SrcSumType sumInit = vigra::NumericTraits<SrcSumType>::zero();
             SrcSumType sumSqrInit = vigra::NumericTraits<SrcSumType>::zero();
             size_t nInit = 0;
@@ -1207,7 +1209,7 @@
                                        [&ef](PixelType x, const MaskValueType& y) {return ef(x) + y;});
 #endif
     }
-};
+}
 
 
 /** Enfuse's main blending loop. Templatized to handle different image types.
@@ -1251,6 +1253,31 @@
 
     unsigned m = 0;
     FileNameList::const_iterator inputFileNameIterator(anInputFileNameList.begin());
+
+#ifdef HAVE_EXIV2
+    typedef allocate::array<Exiv2::Image::UniquePtr> metadata_array;
+    metadata_array input_metadata(anInputFileNameList.size());
+    {
+        FileNameList::const_iterator filename(anInputFileNameList.begin());
+        metadata_array::pointer metadata {input_metadata.begin()};
+
+        while (filename != anInputFileNameList.end()) {
+            try {
+                new (metadata) metadata_array::value_type(metadata::read(*filename));
+                input_metadata.mark_as_initialized(metadata - input_metadata.begin());
+            }
+            catch (Exiv2::Error& e) {
+                std::cerr <<
+                    command << ": warning: could not read metadata of input image \"" <<
+                    *inputFileNameIterator << "\"\n" <<
+                    command << ": note: " << e.what() << "\n";
+            }
+            ++filename;
+            ++metadata;
+        }
+    }
+#endif
+
     while (!imageInfoList.empty()) {
         vigra::Rect2D imageBB;
         std::pair<ImageType*, AlphaType*> imagePair =
@@ -1591,6 +1618,51 @@
 
     delete outputPair.first;
     delete outputPair.second;
+
+#ifdef HAVE_EXIV2
+    if (OutputIsValid && parameter::as_boolean("metadata-pass-through", true)) {
+        const size_t metadata_source_image_index =
+            std::min(static_cast<size_t>(parameter::as_unsigned("metadata-source-image-index", 0)),
+                     input_metadata.size() - 1);
+
+        metadata::named_meta_array valid_named_metadata;
+
+        FileNameList::const_iterator filename(anInputFileNameList.begin());
+        for (size_t i = 0; i != input_metadata.size(); ++i) {
+            if (input_metadata.is_initialized(i) && input_metadata[i].get() && input_metadata[i]->good()) {
+                valid_named_metadata.push_back(metadata::Named(*filename,
+                                                               input_metadata[i].get(),
+                                                               i == metadata_source_image_index));
+            }
+            ++filename;
+        }
+
+        if (valid_named_metadata.empty()) {
+            std::cerr << command << ": warning: none of the input images contained valid metadata";
+        } else {
+            try {
+                metadata::named_meta_array::const_iterator
+                    input_meta(metadata::write(OutputFileName,
+                                               valid_named_metadata.begin(),
+                                               valid_named_metadata.end()));
+                if (Verbose >= VERBOSE_METADATA) {
+                    std::cerr <<
+                        command << ": info: attach metadata of input image \"" <<
+                        input_meta->filename() << "\" to output image \"" << OutputFileName << "\"\n";
+                }
+            }
+            catch (Exiv2::Error& e) {
+                std::cerr <<
+                    command << ": warning: could not write metadata to output image \"" <<
+                    OutputFileName << "\"\n" <<
+                    command << ": note: " << e.what() << "\n";
+            }
+            catch (metadata::Warning& w) {
+                std::cerr << command << ": warning: " << w.what() << "\n";
+            }
+        }
+    }
+#endif
 }
 
 } // namespace enblend
diff -r ef8470f9d682 src/filenameparse.cc
--- a/src/filenameparse.cc	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/filenameparse.cc	Mon Apr 27 19:55:56 2020 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2017 Dr. Christoph L. Spiel
+ * Copyright (C) 2009-2019 Dr. Christoph L. Spiel
  *
  * This file is part of Enblend.
  *
@@ -22,12 +22,11 @@
 // Life is tough and then you die.  -- Jack Dempsey
 
 
-#include <list>
+#include <filesystem>
+#include <numeric>
 #include <string>
+#include <vector>
 
-#if _WIN32
-#include <ctype.h>              // isalpha
-#endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
@@ -35,328 +34,138 @@
 
 #include "filenameparse.h"
 
-#if defined(_MSC_VER) || defined(HAVE_WINDOWS_H)
-#define PATH_SEPARATOR "\\"
-#else
-#define PATH_SEPARATOR "/"
-#endif
+
+#define CURRENT_DIRECTORY "."
+#define PARENT_DIRECTORY ".."
 
-#define DOT "."
-#define DOTDOT ".."
 
-#ifdef HAVE_STD_FILESYSTEM
-#include <filesystem>
-typedef std::tr2::sys::path basic_path;
-#endif
+typedef std::filesystem::path basic_path;
+
 
 namespace enblend {
 
 bool
 isRelativePath(const std::string& aFilename)
 {
-#if defined HAVE_STD_FILESYSTEM || defined HAVE_BOOST_FILESYSTEM
-    const basic_path path(aFilename);
-    return !path.has_root_directory();
-#else
-    const std::string::size_type separator = aFilename.find(PATH_SEPARATOR);
-#if defined(_MSC_VER) || defined(HAVE_WINDOWS_H)
-    return !(aFilename.size() >= 3 &&
-             isalpha(aFilename[0]) &&
-             aFilename[1] == ':' &&
-             separator == 2);
-#else
-    return separator != 0;
-#endif
-#endif
+    const basic_path path {aFilename};
+
+    return path.is_relative();
 }
 
 
 std::string
 extractDirname(const std::string& aFilename)
 {
-#if defined(HAVE_STD_FILESYSTEM)
-    const basic_path path(aFilename);
-    const std::string directory(path.parent_path().string());
-    return directory.empty() ? DOT : directory;
-#else
-    const std::string::size_type separator = aFilename.rfind(PATH_SEPARATOR);
-    return (separator == std::string::npos) ? DOT : aFilename.substr(0, separator);
-#endif
+    const basic_path path {aFilename};
+    const std::string directory {path.parent_path().string()};
+
+    return directory.empty() ? CURRENT_DIRECTORY : directory;
 }
 
 
 std::string
 extractBasename(const std::string& aFilename)
 {
-#if defined(HAVE_STD_FILESYSTEM)
-    const basic_path path(aFilename);
+    const basic_path path {aFilename};
+
     return path.filename().string();
-#else
-    const std::string::size_type separator = aFilename.rfind(PATH_SEPARATOR);
-    return
-        (separator == std::string::npos) ?
-        aFilename :
-        aFilename.substr(separator + 1, aFilename.length() - separator - 1);
-#endif
 }
 
 
 std::string
 extractFilename(const std::string& aFilename)
 {
-#if defined(HAVE_STD_FILESYSTEM)
-    const basic_path path(aFilename);
+    const basic_path path {aFilename};
+
     return path.stem().string();
-#else
-    const std::string::size_type separator = aFilename.rfind(PATH_SEPARATOR);
-    const std::string::size_type dot = aFilename.rfind(DOT);
-    if (separator == std::string::npos)
-    {
-        return (dot == std::string::npos) ? aFilename : aFilename.substr(0, dot);
-    }
-    else
-    {
-        return
-            (dot == std::string::npos) ?
-            aFilename.substr(separator + 1, aFilename.length() - separator - 1) :
-            aFilename.substr(separator + 1, dot - separator - 1);
-    }
-#endif
 }
 
 
 std::string
 extractExtension(const std::string& aFilename)
 {
-#if defined(HAVE_STD_FILESYSTEM)
-    const basic_path path(aFilename);
+    const basic_path path {aFilename};
+
     return path.extension().string();
-#else
-    const std::string::size_type dot = aFilename.rfind(DOT);
-    return
-        (dot == std::string::npos) ?
-        "" :
-        aFilename.substr(dot, aFilename.length() - dot);
-#endif
 }
 
 
-typedef std::list<std::string> list_t;
-
-
-#if defined(HAVE_STD_FILESYSTEM)
-
-inline basic_path
-removeDotsBoost(const basic_path& aPath)
+static
+basic_path
+removeDotsInPath(const basic_path& aPath)
 {
     basic_path result;
-    for (basic_path::const_iterator p = aPath.begin(); p != aPath.end(); ++p)
+
+    for (const auto& p : aPath)
     {
-        if (*p != DOT)
+        if (p != CURRENT_DIRECTORY)
         {
-            result /= *p;
+            result /= p;
         }
     }
+
     return result;
 }
 
 
-inline basic_path
-removeDotDotsBoost(const basic_path& aPath)
+static
+basic_path
+removeDotDotsInPath(const basic_path& aPath)
 {
-    list_t directories;
-    for (basic_path::const_iterator p = aPath.begin(); p != aPath.end(); ++p)
+    std::vector<std::string> directories;
+
+    for (const auto& p : aPath)
     {
-        if (*p == DOTDOT &&
-            !directories.empty() && directories.back() != DOTDOT)
+        if (p == PARENT_DIRECTORY &&
+            !directories.empty() && directories.back() != PARENT_DIRECTORY)
         {
             directories.pop_back();
         }
         else
         {
-            directories.push_back(p->string());
-        }
-    }
-    basic_path result;
-    for (list_t::const_iterator p = directories.begin(); p != directories.end(); ++p)
-    {
-        result /= *p;
-    }
-    return result;
-}
-
-#else
-
-inline
-std::string
-removeDotsCxx(const std::string& aPathname)
-{
-    std::string path(aPathname);
-    std::string::size_type predecessor = std::string::npos;
-    std::string::size_type separator = path.find(PATH_SEPARATOR);
-    while (separator != std::string::npos)
-    {
-        const std::string::size_type begin =
-            predecessor == std::string::npos ? 0 : predecessor + 1;
-        const std::string component =
-            path.substr(begin, separator - predecessor - 1);
-        if (component == DOT)
-        {
-            path.erase(begin, 2);
-        }
-        else
-        {
-            predecessor = separator;
-        }
-        separator = path.find(PATH_SEPARATOR, predecessor + 1);
-    }
-    if (predecessor == std::string::npos)
-    {
-        if (path == DOT)
-        {
-            path.clear();
-        }
-    }
-    else
-    {
-        const std::string component = path.substr(predecessor + 1);
-        if (component == DOT)
-        {
-            path.erase(predecessor);
+            directories.push_back(p.string());
         }
     }
-    return path;
+
+    return std::accumulate(directories.begin(), directories.end(),
+                           basic_path {},
+                           [](const basic_path& parent, const basic_path& leaf)
+                           {
+                               return basic_path {parent} /= leaf;
+                           });
 }
 
 
-inline std::string
-removeDotDotsCxx(const std::string& aPathname)
-{
-    std::string path(aPathname);
-    list_t directories;
-    std::string::size_type predecessor = std::string::npos;
-    std::string::size_type separator = path.find(PATH_SEPARATOR);
-    while (separator != std::string::npos)
-    {
-        const std::string::size_type begin =
-            predecessor == std::string::npos ? 0 : predecessor + 1;
-        const std::string component =
-            path.substr(begin, separator - predecessor - 1);
-        if (component == DOTDOT &&
-            !directories.empty() && directories.back() != DOTDOT)
-        {
-            directories.pop_back();
-        }
-        else
-        {
-            directories.push_back(component);
-        }
-
-        predecessor = separator;
-        separator = path.find(PATH_SEPARATOR, predecessor + 1);
-    }
-    if (predecessor == std::string::npos)
-    {
-        directories.push_back(path);
-    }
-    else
-    {
-        const std::string component = path.substr(predecessor + 1);
-        if (component == DOTDOT &&
-            !directories.empty() && directories.back() != DOTDOT)
-        {
-            directories.pop_back();
-        }
-        else
-        {
-            directories.push_back(component);
-        }
-    }
-    std::string result;
-    for (list_t::const_iterator p = directories.begin(); p != directories.end(); ++p)
-    {
-        if (p != directories.begin())
-        {
-            result.append(PATH_SEPARATOR);
-        }
-        result.append(*p);
-    }
-    return result;
-}
-#endif
-
-
 std::string
 canonicalizePath(const std::string& aPathname, bool keepDot)
 {
-#if defined(HAVE_STD_FILESYSTEM)
-    const basic_path result = removeDotDotsBoost(removeDotsBoost(basic_path(aPathname)));
+    const basic_path result {removeDotDotsInPath(removeDotsInPath(basic_path(aPathname)))};
+
     if (keepDot && result.empty())
     {
-        return std::string(DOT);
+        return CURRENT_DIRECTORY;
     }
     else
     {
         return result.string();
     }
-#else
-    std::string result = removeDotDotsCxx(removeDotsCxx(aPathname));
-
-    // For compatability with the Boost implementation: Remove a
-    // trailing PATH_SEPARATOR unless we reference the root directory.
-    const size_t size = result.size();
-    if (size >= 2 && result.substr(size - 1, 1) == PATH_SEPARATOR)
-    {
-        result.erase(size - 1, 1);
-    }
-    if (keepDot && result.empty())
-    {
-        return std::string(DOT);
-    }
-    else
-    {
-        return result;
-    }
-#endif
 }
 
 
 std::string
 concatPath(const std::string& aPathname, const std::string& anotherPathname)
 {
-#if defined(HAVE_STD_FILESYSTEM)
-    basic_path path(aPathname);
-    basic_path leaf(anotherPathname);
+    basic_path path {aPathname};
+    basic_path leaf {anotherPathname};
+
     path /= leaf;
+
     return path.string();
-#else
-    if (aPathname.empty())
-    {
-        return anotherPathname;
-    }
-    else if (anotherPathname.empty())
-    {
-        return aPathname;
-    }
-    else
-    {
-        const std::string::size_type end = aPathname.find_last_not_of(PATH_SEPARATOR);
-        const std::string path =
-            (end == std::string::npos) ?
-            aPathname :
-            aPathname.substr(0, end + 1);
-        const std::string::size_type begin = anotherPathname.find_first_not_of(PATH_SEPARATOR);
-        const std::string leaf =
-            (begin == std::string::npos) ?
-            anotherPathname :
-            anotherPathname.substr(begin);
-        return path + PATH_SEPARATOR + leaf;
-    }
-#endif
 }
 
 } // namespace enblend
 
+
 // Local Variables:
 // mode: c++
 // End:
diff -r ef8470f9d682 src/fillpolygon.hxx
--- a/src/fillpolygon.hxx	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/fillpolygon.hxx	Mon Apr 27 19:55:56 2020 -0700
@@ -252,7 +252,7 @@
                 {
                 case TOUCHING:
                     *result++ = i->first;
-                    BOOST_FALLTHROUGH;
+                    [[fallthrough]];
 
                 case CROSSING:
                     *result++ = i->first;
diff -r ef8470f9d682 src/fixmath.h
--- a/src/fixmath.h	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/fixmath.h	Mon Apr 27 19:55:56 2020 -0700
@@ -42,10 +42,23 @@
 #include "parameter.h"
 
 
+// ANTICIPATED CHANGE: Remove this define after Lab/Luv optimization
+// has gotten enough testing.
+#define LOG_COLORSPACE_OPTIMIZATION
+
+
 #define XYZ_SCALE 100.0
 
 
-namespace enblend {
+#ifdef LOG_COLORSPACE_CONVERSION_DETAIL
+#ifndef LOG_COLORSPACE_CONVERSION
+#define LOG_COLORSPACE_CONVERSION
+#endif
+#endif // LOG_COLORSPACE_CONVERSION_DETAIL
+
+
+namespace enblend
+{
 
 static inline double
 wrap_cyclically(double x, double modulus)
@@ -71,6 +84,13 @@
 }
 
 
+static inline double
+calculate_delta_e(const cmsCIELab* lab1, const cmsCIELab* lab2)
+{
+    return cmsCMCdeltaE(lab1, lab2, 2.0, 1.0);
+}
+
+
 static inline void
 jch_to_rgb(const cmsJCh* jch, double* rgb)
 {
@@ -106,15 +126,15 @@
     ConvertScalarToPyramidFunctor() :
         pyramid_scale(double(1U << PyramidFractionBits))
     {
-#ifdef DEBUG_COLORSPACE_STATISTICS
+#ifdef LOG_COLORSPACE_CONVERSION
 #ifdef OPENMP
 #pragma omp critical
 #endif
         std::cout <<
             "+ ConvertScalarToPyramidFunctor::ConvertScalarToPyramidFunctor: " <<
             (SrcIsIntegral().value ? "integral" : "floating-point") << " source  =>  " <<
-            (PyramidIsIntegral().value? "integral" : "floating-point") << " pyramid\n";
-#endif
+            (PyramidIsIntegral().value? "integral" : "floating-point") << " pyramid" << std::endl;
+#endif // LOG_COLORSPACE_CONVERSION
     }
 
     PyramidPixelType operator()(const SrcPixelType& v) const
@@ -310,7 +330,7 @@
 
     // Dithering is used to fool the eye into seeing gradients that are finer
     // than the precision of the pixel type.
-    // This prevents the occurence of cleanly-bordered regions in the output where
+    // This prevents the occurrence of cleanly-bordered regions in the output where
     // the pixel values suddenly change from N to N+1.
     // Such regions are especially objectionable in the green channel of 8-bit images.
     double dither(const double& v) const
@@ -452,15 +472,15 @@
         static_assert(PyramidIntegerBits >= PYRAMID_HEADROOM_BITS,
                       "not enough PyramidIntegerBits to calculate `pyramid_scale' from shift");
 
-#ifdef DEBUG_COLORSPACE_STATISTICS
+#ifdef LOG_COLORSPACE_CONVERSION
 #ifdef OPENMP
 #pragma omp critical
 #endif
         std::cout <<
             "+ PyramidScale::PyramidScale: PyramidIntegerBits = " << PyramidIntegerBits <<
             ", PyramidFractionBits = " << PyramidFractionBits << "  =>  pyramid-scale = " << pyramid_scale <<
-            "\n";
-#endif // DEBUG_COLORSPACE_STATISTICS
+            std::endl;
+#endif // LOG_COLORSPACE_CONVERSION
     }
 
     double scale_lightness_for_pyramid(double a_lightness) const
@@ -468,7 +488,7 @@
         const double scaled_lightness = pyramid_scale * a_lightness / static_cast<double>(MAXIMUM_LIGHTNESS);
         const double result = std::round(scaled_lightness);
 
-#ifdef DEBUG_COLORSPACE_STATISTICS
+#ifdef LOG_COLORSPACE_CONVERSION_DETAIL
         // Note: For we rescale color channels with respect to
         // `color_limit' and color channels as well as luminance ends
         // up in the same pyramid, we can check for overflow with the
@@ -480,9 +500,9 @@
 #endif
             std::cout <<
                 "+ PyramidScale::scale_lightness_for_pyramid: out-of-range L = " <<
-                a_lightness << ", scaled = " << scaled_lightness << ", rounded = " << result << "\n";
+                a_lightness << ", scaled = " << scaled_lightness << ", rounded = " << result << std::endl;
         }
-#endif // DEBUG_COLORSPACE_STATISTICS
+#endif // LOG_COLORSPACE_CONVERSION_DETAIL
 
         assert(result >= 0.0);
         return result;
@@ -494,7 +514,7 @@
             pyramid_scale * (color_limit + a_color_difference) / (2.0 * color_limit);
         const double result = std::round(scaled_color_difference);
 
-#ifdef DEBUG_COLORSPACE_STATISTICS
+#ifdef LOG_COLORSPACE_CONVERSION_DETAIL
         if (std::abs(result) > color_limit)
         {
 #ifdef OPENMP
@@ -503,9 +523,9 @@
             std::cout <<
                 "+ PyramidScale::scale_color_difference_for_pyramid: out-of-range a,b|u,v = " <<
                 a_color_difference << ", scaled = " << scaled_color_difference << ", rounded = " << result <<
-                "\n";
+                std::endl;
         }
-#endif // DEBUG_COLORSPACE_STATISTICS
+#endif // LOG_COLORSPACE_CONVERSION_DETAIL
 
         assert(result >= -color_limit);
         return result;
@@ -527,7 +547,7 @@
 };
 
 
-#ifdef DEBUG_COLORSPACE_STATISTICS
+#ifdef LOG_COLORSPACE_CONVERSION
 class TriplePeakHold
 {
     enum {n = 3};
@@ -591,7 +611,7 @@
     std::array<std::string, n> labels_;
     std::array<std::pair<double, double>, n> peaks_;
 };
-#endif // DEBUG_COLORSPACE_STATISTICS
+#endif // LOG_COLORSPACE_CONVERSION
 
 
 //
@@ -613,25 +633,25 @@
     ConvertVectorToLabPyramidFunctor() :
         converter(),
         rgb_source_scale(1.0 / SrcTraits::toRealPromote(SrcTraits::max()))
-#ifdef DEBUG_COLORSPACE_STATISTICS
+#ifdef LOG_COLORSPACE_CONVERSION
         , range("L", "a", "b")
-#endif // DEBUG_COLORSPACE_STATISTICS
+#endif // LOG_COLORSPACE_CONVERSION
     {
-#ifdef DEBUG_COLORSPACE_STATISTICS
+#ifdef LOG_COLORSPACE_CONVERSION
 #ifdef OPENMP
 #pragma omp critical
 #endif
         std::cout <<
-            "+ ConvertVectorToLabPyramidFunctor::ConvertVectorToLabPyramidFunctor source range [" <<
+            "+ ConvertVectorToLabPyramidFunctor::ConvertVectorToLabPyramidFunctor: source range [" <<
             static_cast<double>(SrcTraits::min()) << ", " <<
             static_cast<double>(SrcTraits::max()) << "]\n" <<
             "+ ConvertVectorToLabPyramidFunctor::ConvertVectorToLabPyramidFunctor: pyramid range [" <<
             static_cast<double>(vigra::NumericTraits<PyramidComponentType>::min()) << ", " <<
-            static_cast<double>(vigra::NumericTraits<PyramidComponentType>::max()) << "]\n";
-#endif // DEBUG_COLORSPACE_STATISTICS
+            static_cast<double>(vigra::NumericTraits<PyramidComponentType>::max()) << "]" << std::endl;
+#endif // LOG_COLORSPACE_CONVERSION
     }
 
-#ifdef DEBUG_COLORSPACE_STATISTICS
+#ifdef LOG_COLORSPACE_CONVERSION
     ~ConvertVectorToLabPyramidFunctor()
     {
 #ifdef OPENMP
@@ -641,7 +661,7 @@
             range.as_string("+ ConvertVectorToLabPyramidFunctor::~ConvertVectorToLabPyramidFunctor: ") <<
             std::endl;
     }
-#endif // DEBUG_COLORSPACE_STATISTICS
+#endif // LOG_COLORSPACE_CONVERSION
 
     PyramidVectorType operator()(const SrcVectorType& v) const
     {
@@ -653,9 +673,9 @@
         cmsCIELab lab;
 
         cmsDoTransform(InputToLabTransform, rgb, &lab, 1U);
-#ifdef DEBUG_COLORSPACE_STATISTICS
+#ifdef LOG_COLORSPACE_CONVERSION
         range.update(lab.L, lab.a, lab.b);
-#endif // DEBUG_COLORSPACE_STATISTICS
+#endif // LOG_COLORSPACE_CONVERSION
 
         return PyramidVectorType(converter(Scale::scale_lightness_for_pyramid(lab.L)),
                                  converter(Scale::scale_color_difference_for_pyramid(lab.a)),
@@ -665,9 +685,9 @@
 protected:
     ConvertFunctorType converter;
     const double rgb_source_scale;
-#ifdef DEBUG_COLORSPACE_STATISTICS
+#ifdef LOG_COLORSPACE_CONVERSION
     mutable TriplePeakHold range;
-#endif // DEBUG_COLORSPACE_STATISTICS
+#endif // LOG_COLORSPACE_CONVERSION
 };
 
 
@@ -675,9 +695,360 @@
 // Fixed point converter that uses ICC profile transformation and L*a*b* color space
 //
 
+
+// cylindrical representation: CIELCh
+// see: https://en.wikipedia.org/wiki/Lab_color_space#Cylindrical_representation:_CIELCh_or_CIEHLC
+
+inline static double
+chroma_of_cartesian_lab(const cmsCIELab& lab)
+{
+    return std::hypot(lab.a, lab.b);
+}
+
+
+inline static double
+hue_of_cartesian_lab(const cmsCIELab& lab)
+{
+    return std::atan2(lab.b, lab.a);
+}
+
+
+namespace detail
+{
+    static inline double
+    uniform_random(unsigned* seed)
+    {
+        return static_cast<double>(enblend::rand_r(seed)) / static_cast<double>(RAND_MAX);
+    }
+
+
+    static inline bool
+    bracket_minimum(const gsl_function& cost,
+                    double& x_initial, double x_lower, double x_upper,
+                    unsigned maximum_tries)
+    {
+        const double y_minimum_bound =
+            std::min(cost.function(x_lower, cost.params), cost.function(x_upper, cost.params));
+        double y_initial = cost.function(x_initial, cost.params);
+
+        if (y_initial < y_minimum_bound)
+        {
+            return true;
+        }
+
+        unsigned i = 0U;
+        const double lower = std::max(0.001, 1.001 * x_lower);
+        const double upper = 0.999 * x_upper;
+        unsigned seed = 1000003U; // fixed seed for reproducibility
+
+        while (y_initial >= y_minimum_bound && i < maximum_tries)
+        {
+            x_initial = uniform_random(&seed) * (upper - lower) + lower;
+            y_initial = cost.function(x_initial, cost.params);
+            ++i;
+        }
+
+        return i < maximum_tries;
+    }
+
+
+    template <typename forward_iterator>
+    static inline void
+    limit_sequence(forward_iterator first, forward_iterator last, double lower_limit, double upper_limit)
+    {
+        while (first != last)
+        {
+            *first = limit(*first, lower_limit, upper_limit);
+            ++first;
+        }
+    }
+
+
+    static inline int
+    alternating_power_spacing(int i, int n,
+                              double a, double b, double c,
+                              double p)
+    {
+        const bool is_even_n = n % 2 == 0;
+        const double left_unit_stride = 1.0 / static_cast<double>(n - (is_even_n ? 1 : 2));
+        const double right_unit_stride = 1.0 / static_cast<double>(n - (is_even_n ? 2 : 1));
+        const double left_width = c - a;
+        const double right_width = b - c;
+
+        const double x = static_cast<double>(i);
+        double y = c;
+
+        if (i % 2 == 1)         // 1, 3, 5, ...
+        {
+            y -= left_width * std::pow(x * left_unit_stride, 1.0 / p);
+        }
+        else                    // 0, 2, 4, 6, ...
+        {
+            y += right_width * std::pow(x * right_unit_stride, p);
+        }
+
+        return y;
+    }
+} // namespace detail
+
+
+namespace lab_detail
+{
+    struct extra_minimizer_parameter
+    {
+        explicit extra_minimizer_parameter(const cmsCIELab& an_lab_value) :
+            lab(an_lab_value),
+            hue_cos(std::cos(hue_of_cartesian_lab(an_lab_value))),
+            hue_sin(std::sin(hue_of_cartesian_lab(an_lab_value)))
+        {}
+
+        cmsCIELab lab;
+        double hue_cos;
+        double hue_sin;
+    };
+
+
+    inline static double
+    delta_e_cost(const cmsCIELab* lab, const extra_minimizer_parameter* parameter)
+    {
+        double rgb[3];
+        cmsDoTransform(LabToInputTransform, lab, rgb, 1);
+
+        cmsCIELab backwards_lab;
+        cmsDoTransform(InputToLabTransform, rgb, &backwards_lab, 1);
+
+        return calculate_delta_e(&parameter->lab, &backwards_lab);
+    }
+
+
+    double
+    delta_e_min_cost(double chroma, void* data)
+    {
+        const extra_minimizer_parameter* parameter {static_cast<const extra_minimizer_parameter*>(data)};
+        const cmsCIELab lab {parameter->lab.L, chroma * parameter->hue_cos, chroma * parameter->hue_sin};
+
+        return delta_e_cost(&lab, parameter);
+    }
+} // namespace lab_detail
+
+
+class OptimizableLuminanceSpace
+{
+public:
+    OptimizableLuminanceSpace() :
+        shadow_rgb_threshold(parameter::as_double("lum-shadow-rgb-threshold", 0.0)),
+        maximum_bracket_tries(parameter::as_unsigned("lum-bracket-maximum-tries", 500U)),
+        suspicious_delta_e(parameter::as_double("lum-suspicious-delta-e", 1.0)),
+        optimizer_error(parameter::as_double("lum-optimizer-error", 0.5 / 256.0)),
+        optimizer_goal(parameter::as_double("lum-optimizer-deltae-goal", 0.5)),
+        maximum_iterations(parameter::as_unsigned("lum-maximum-iterations", 50U)),
+        max_chroma_factor(parameter::as_double("lum-max-chroma-factor", 20.0))
+#ifdef LOG_COLORSPACE_OPTIMIZATION
+        , polish_tally(0U), polish_false_positive_tally(0U),
+        total_delta_e(0.0), total_iterations(0U)
+#endif // LOG_COLORSPACE_OPTIMIZATION
+    {}
+
+    virtual ~OptimizableLuminanceSpace()
+    {
+#ifdef LOG_COLORSPACE_OPTIMIZATION
+        if (polish_tally)
+        {
+#ifdef OPENMP
+#pragma omp critical
+#endif
+            std::cout <<
+                "+ OptimizableLuminanceSpace: polish_rgb() called " << polish_tally << " times with " <<
+                100.0 * static_cast<double>(polish_false_positive_tally) / static_cast<double>(polish_tally) <<
+                "% false positives\n" <<
+                "+ OptimizableLuminanceSpace: polish_rgb() total residual deltaE " << total_delta_e << " (" <<
+                (polish_tally == polish_false_positive_tally ?
+                 total_delta_e :
+                 total_delta_e / static_cast<double>(polish_tally - polish_false_positive_tally)) <<
+                " average) after " << total_iterations << " iterations\n" << std::endl;
+        }
+        else
+        {
+#ifdef OPENMP
+#pragma omp critical
+#endif
+            std::cout << "+ OptimizableLuminanceSpace: polish_rgb() not called\n" << std::endl;
+        }
+#endif // LOG_COLORSPACE_OPTIMIZATION
+    }
+
+    bool is_below_threshold(const double* rgb) const
+    {
+        return (rgb[0] <= shadow_rgb_threshold ||
+                rgb[1] <= shadow_rgb_threshold ||
+                rgb[2] <= shadow_rgb_threshold);
+    }
+
+    void polish_rgb(const cmsCIELab* lab, double* rgb) const
+    {
+#ifdef LOG_COLORSPACE_OPTIMIZATION
+#ifdef OPENMP
+#pragma omp atomic
+#endif
+        ++polish_tally;
+#endif // LOG_COLORSPACE_OPTIMIZATION
+
+        if (EXPECT_RESULT(std::isnan(lab->a) || std::isnan(lab->b), false))
+        {
+            if (parameter::as_boolean("mark-freaky-color-conversions", false))
+            {
+                // magenta
+                rgb[0] = 1.0;
+                rgb[1] = 0.0;
+                rgb[2] = 1.0;
+            }
+            else
+            {
+                const cmsCIELab sane_lab {lab->L, 0.0, 0.0};
+                cmsDoTransform(LabToInputTransform, &sane_lab, rgb, 1);
+            }
+            return;
+        }
+
+        {
+            cmsCIELab backwards_lab;
+            cmsDoTransform(InputToLabTransform, rgb, &backwards_lab, 1);
+            const double delta_e {calculate_delta_e(lab, &backwards_lab)};
+
+            if (EXPECT_RESULT(delta_e < suspicious_delta_e, true))
+            {
+#ifdef LOG_COLORSPACE_OPTIMIZATION
+#ifdef OPENMP
+#pragma omp atomic
+#endif
+                ++polish_false_positive_tally;
+#endif // LOG_COLORSPACE_OPTIMIZATION
+                return;
+            }
+
+#ifdef LOG_COLORSPACE_OPTIMIZATION
+#ifdef OPENMP
+#pragma omp critical
+#endif
+            std::cout << "+ polish_rgb: triggering deltaE = " << delta_e << std::endl;
+#endif // LOG_COLORSPACE_OPTIMIZATION
+        }
+
+        const double initial_chroma {chroma_of_cartesian_lab(*lab)};
+
+        lab_detail::extra_minimizer_parameter extra(*lab);
+        gsl_function cost = {lab_detail::delta_e_min_cost, &extra};
+        double initial_chroma0 = initial_chroma;
+        const double max_chroma = max_chroma_factor * initial_chroma;
+        cmsCIELab final_lab;
+
+#ifdef LOG_COLORSPACE_OPTIMIZATION
+#ifdef OPENMP
+#pragma omp critical
+#endif
+        std::cout <<
+            "+ polish_rgb: initial Lab = (" <<
+            lab->L << ", " << lab->a  << ", " << lab->b << "), RGB = (" <<
+            rgb[0] << ", " << rgb[1] << ", " << rgb[2] << ")\n" <<
+            "              initial chroma = " << initial_chroma <<
+            ", initial deltaE = " << lab_detail::delta_e_cost(lab, &extra) << std::endl;
+#endif // LOG_COLORSPACE_OPTIMIZATION
+
+        if (detail::bracket_minimum(cost, initial_chroma0, 0.0, max_chroma, maximum_bracket_tries))
+        {
+            BrentMinimizer1D optimizer(cost, initial_chroma0, 0.0, max_chroma);
+
+            optimizer.set_absolute_error(optimizer_error)->
+                set_goal(optimizer_goal)->
+                set_maximum_number_of_iterations(maximum_iterations);
+            optimizer.run();
+#ifdef LOG_COLORSPACE_OPTIMIZATION
+#ifdef OPENMP
+#pragma omp atomic
+#endif
+            total_delta_e += optimizer.f_minimum();
+#ifdef OPENMP
+#pragma omp atomic
+#endif
+            total_iterations += optimizer.number_of_iterations();
+#endif // LOG_COLORSPACE_OPTIMIZATION
+
+            const double initial_hue {hue_of_cartesian_lab(*lab)};
+            final_lab.L = lab->L;
+            final_lab.a = optimizer.x_minimum() * std::cos(initial_hue);
+            final_lab.b = optimizer.x_minimum() * std::sin(initial_hue);
+
+            cmsDoTransform(LabToInputTransform, &final_lab, rgb, 1);
+
+#ifdef LOG_COLORSPACE_OPTIMIZATION
+#ifdef OPENMP
+#pragma omp critical
+#endif
+            std::cout <<
+                "+ polish_rgb: final Lab = (" <<
+                final_lab.L << ", " << final_lab.a  << ", " << final_lab.b << "), RGB = (" <<
+                rgb[0] << ", " << rgb[1] << ", " << rgb[2] << ")\n" <<
+                "              final chroma = " << optimizer.x_minimum() <<
+                ", final deltaE = " << optimizer.f_minimum() <<
+                " after " << optimizer.number_of_iterations() << " iterations\n" << std::endl;
+#endif // LOG_COLORSPACE_OPTIMIZATION
+        }
+        else
+        {
+            // ANTICIPATED CHANGE: It could be worthwhile to study
+            // what we gain if we fire up a 2d optimizer that
+            // simultaneously minimizes luminance (`L') and chroma.
+
+            final_lab.L = lab->L;
+            final_lab.a = 0.0;
+            final_lab.b = 0.0;
+
+            cmsDoTransform(LabToInputTransform, &final_lab, rgb, 1);
+
+#ifdef LOG_COLORSPACE_OPTIMIZATION
+#ifdef OPENMP
+#pragma omp critical
+#endif
+            std::cout << "+ polish_rgb: failed to bracket minimum\n" <<
+                "              final Lab = (" <<
+                final_lab.L << ", " << final_lab.a  << ", " << final_lab.b << "), RGB = (" <<
+                rgb[0] << ", " << rgb[1] << ", " << rgb[2] << ")\n" <<
+                "              final chroma = " << initial_chroma0 <<
+                ", final deltaE = " << calculate_delta_e(lab, &final_lab) << "\n" << std::endl;
+#endif // LOG_COLORSPACE_OPTIMIZATION
+
+            if (parameter::as_boolean("mark-freaky-color-conversions", false))
+            {
+                // yellow
+                rgb[0] = 1.0;
+                rgb[1] = 1.0;
+                rgb[2] = 0.0;
+            }
+        }
+    }
+
+private:
+    const double shadow_rgb_threshold;
+    const unsigned maximum_bracket_tries;
+    const double suspicious_delta_e;
+    const double optimizer_error;
+    const double optimizer_goal;
+    const unsigned maximum_iterations;
+    const double max_chroma_factor;
+
+#ifdef LOG_COLORSPACE_OPTIMIZATION
+    mutable unsigned polish_tally;
+    mutable unsigned polish_false_positive_tally;
+    mutable double total_delta_e;
+    mutable unsigned total_iterations;
+#endif // LOG_COLORSPACE_OPTIMIZATION
+};  // class OptimizableLuminanceSpace
+
+
 template <typename DestVectorType, typename PyramidVectorType, int PyramidIntegerBits, int PyramidFractionBits>
 class ConvertLabPyramidToVectorFunctor :
-    private PyramidScale<PyramidIntegerBits, PyramidFractionBits>
+    private PyramidScale<PyramidIntegerBits, PyramidFractionBits>,
+    private OptimizableLuminanceSpace
 {
     typedef PyramidScale<PyramidIntegerBits, PyramidFractionBits> Scale;
     typedef typename DestVectorType::value_type DestComponentType;
@@ -690,11 +1061,11 @@
     ConvertLabPyramidToVectorFunctor() :
         converter(),
         rgb_dest_scale(DestTraits::toRealPromote(DestTraits::max()))
-#ifdef DEBUG_COLORSPACE_STATISTICS
+#ifdef LOG_COLORSPACE_CONVERSION
         , range("L", "a", "b")
-#endif // DEBUG_COLORSPACE_STATISTICS
+#endif // LOG_COLORSPACE_CONVERSION
     {
-#ifdef DEBUG_COLORSPACE_STATISTICS
+#ifdef LOG_COLORSPACE_CONVERSION
 #ifdef OPENMP
 #pragma omp critical
 #endif
@@ -704,11 +1075,11 @@
             static_cast<double>(DestTraits::max()) << "]\n" <<
             "+ ConvertLabPyramidToVectorFunctor::ConvertLabPyramidToVectorFunctor: pyramid range [" <<
             static_cast<double>(vigra::NumericTraits<PyramidComponentType>::min()) << ", " <<
-            static_cast<double>(vigra::NumericTraits<PyramidComponentType>::max()) << "]\n";
-#endif // DEBUG_COLORSPACE_STATISTICS
+            static_cast<double>(vigra::NumericTraits<PyramidComponentType>::max()) << "]" << std::endl;
+#endif // LOG_COLORSPACE_CONVERSION
     }
 
-#ifdef DEBUG_COLORSPACE_STATISTICS
+#ifdef LOG_COLORSPACE_CONVERSION
     ~ConvertLabPyramidToVectorFunctor()
     {
 #ifdef OPENMP
@@ -718,7 +1089,7 @@
             range.as_string("+ ConvertLabPyramidToVectorFunctor::~ConvertLabPyramidToVectorFunctor: ") <<
             std::endl;
     }
-#endif // DEBUG_COLORSPACE_STATISTICS
+#endif // LOG_COLORSPACE_CONVERSION
 
     DestVectorType operator()(const PyramidVectorType& v) const
     {
@@ -729,11 +1100,18 @@
         };
         double rgb[3];
 
-#ifdef DEBUG_COLORSPACE_STATISTICS
+#ifdef LOG_COLORSPACE_CONVERSION
         range.update(lab.L, lab.a, lab.b);
-#endif // DEBUG_COLORSPACE_STATISTICS
+#endif // LOG_COLORSPACE_CONVERSION
+
+        assert(lab.L >= 0.0);
         cmsDoTransform(LabToInputTransform, &lab, rgb, 1U);
 
+        if (EXPECT_RESULT(is_below_threshold(rgb), false))
+        {
+            polish_rgb(&lab, rgb);
+        }
+
         return DestVectorType(DestTraits::fromRealPromote(rgb_dest_scale * rgb[0]),
                               DestTraits::fromRealPromote(rgb_dest_scale * rgb[1]),
                               DestTraits::fromRealPromote(rgb_dest_scale * rgb[2]));
@@ -742,9 +1120,9 @@
 protected:
     ConvertFunctorType converter;
     const double rgb_dest_scale;
-#ifdef DEBUG_COLORSPACE_STATISTICS
+#ifdef LOG_COLORSPACE_CONVERSION
     mutable TriplePeakHold range;
-#endif // DEBUG_COLORSPACE_STATISTICS
+#endif // LOG_COLORSPACE_CONVERSION
 };
 
 
@@ -768,25 +1146,25 @@
     ConvertVectorToLuvPyramidFunctor() :
         converter(),
         rgb_source_scale(1.0 / SrcTraits::toRealPromote(SrcTraits::max()))
-#ifdef DEBUG_COLORSPACE_STATISTICS
+#ifdef LOG_COLORSPACE_CONVERSION
         , range("L", "u", "v")
-#endif // DEBUG_COLORSPACE_STATISTICS
+#endif // LOG_COLORSPACE_CONVERSION
     {
-#ifdef DEBUG_COLORSPACE_STATISTICS
+#ifdef LOG_COLORSPACE_CONVERSION
 #ifdef OPENMP
 #pragma omp critical
 #endif
         std::cout <<
-            "+ ConvertVectorToLuvPyramidFunctor::ConvertVectorToLuvPyramidFunctor source range [" <<
+            "+ ConvertVectorToLuvPyramidFunctor::ConvertVectorToLuvPyramidFunctor: source range [" <<
             static_cast<double>(SrcTraits::min()) << ", " <<
             static_cast<double>(SrcTraits::max()) << "]\n" <<
             "+ ConvertVectorToLuvPyramidFunctor::ConvertVectorToLuvPyramidFunctor: pyramid range [" <<
             static_cast<double>(vigra::NumericTraits<PyramidComponentType>::min()) << ", " <<
-            static_cast<double>(vigra::NumericTraits<PyramidComponentType>::max()) << "]\n";
-#endif // DEBUG_COLORSPACE_STATISTICS
+            static_cast<double>(vigra::NumericTraits<PyramidComponentType>::max()) << "]" << std::endl;
+#endif // LOG_COLORSPACE_CONVERSION
     }
 
-#ifdef DEBUG_COLORSPACE_STATISTICS
+#ifdef LOG_COLORSPACE_CONVERSION
     ~ConvertVectorToLuvPyramidFunctor()
     {
 #ifdef OPENMP
@@ -796,7 +1174,7 @@
             range.as_string("+ ConvertVectorToLuvPyramidFunctor::~ConvertVectorToLuvPyramidFunctor: ") <<
             std::endl;
     }
-#endif // DEBUG_COLORSPACE_STATISTICS
+#endif // LOG_COLORSPACE_CONVERSION
 
     PyramidVectorType operator()(const SrcVectorType& v) const
     {
@@ -809,9 +1187,9 @@
 
         cmsDoTransform(InputToXYZTransform, rgb, &xyz[0], 1U);
         const XYZ2LuvFunctor::result_type luv {xyz2luv(xyz)};
-#ifdef DEBUG_COLORSPACE_STATISTICS
+#ifdef LOG_COLORSPACE_CONVERSION
         range.update(luv[0], luv[1], luv[2]);
-#endif // DEBUG_COLORSPACE_STATISTICS
+#endif // LOG_COLORSPACE_CONVERSION
 
         return PyramidVectorType(converter(Scale::scale_lightness_for_pyramid(luv[0])),
                                  converter(Scale::scale_color_difference_for_pyramid(luv[1])),
@@ -822,9 +1200,9 @@
     XYZ2LuvFunctor xyz2luv;
     ConvertFunctorType converter;
     const double rgb_source_scale;
-#ifdef DEBUG_COLORSPACE_STATISTICS
+#ifdef LOG_COLORSPACE_CONVERSION
     mutable TriplePeakHold range;
-#endif // DEBUG_COLORSPACE_STATISTICS
+#endif // LOG_COLORSPACE_CONVERSION
 };
 
 
@@ -834,7 +1212,8 @@
 
 template <typename DestVectorType, typename PyramidVectorType, int PyramidIntegerBits, int PyramidFractionBits>
 class ConvertLuvPyramidToVectorFunctor :
-    private PyramidScale<PyramidIntegerBits, PyramidFractionBits>
+    private PyramidScale<PyramidIntegerBits, PyramidFractionBits>,
+    private OptimizableLuminanceSpace
 {
     typedef PyramidScale<PyramidIntegerBits, PyramidFractionBits> Scale;
     typedef typename DestVectorType::value_type DestComponentType;
@@ -843,16 +1222,17 @@
     typedef ConvertPyramidToScalarFunctor<DestComponentType, PyramidComponentType,
                                           PyramidIntegerBits, PyramidFractionBits> ConvertFunctorType;
     typedef vigra::Luv2XYZFunctor<double> Luv2XYZFunctor;
+    typedef vigra::XYZ2LabFunctor<double> XYZ2LabFunctor;
 
 public:
     ConvertLuvPyramidToVectorFunctor() :
         converter(),
         rgb_dest_scale(DestTraits::toRealPromote(DestTraits::max()))
-#ifdef DEBUG_COLORSPACE_STATISTICS
+#ifdef LOG_COLORSPACE_CONVERSION
         , range("L", "u", "v")
-#endif // DEBUG_COLORSPACE_STATISTICS
+#endif // LOG_COLORSPACE_CONVERSION
     {
-#ifdef DEBUG_COLORSPACE_STATISTICS
+#ifdef LOG_COLORSPACE_CONVERSION
 #ifdef OPENMP
 #pragma omp critical
 #endif
@@ -862,11 +1242,11 @@
             static_cast<double>(DestTraits::max()) << "]\n" <<
             "+ ConvertLuvPyramidToVectorFunctor::ConvertLuvPyramidToVectorFunctor: pyramid range [" <<
             static_cast<double>(vigra::NumericTraits<PyramidComponentType>::min()) << ", " <<
-            static_cast<double>(vigra::NumericTraits<PyramidComponentType>::max()) << "]\n";
-#endif // DEBUG_COLORSPACE_STATISTICS
+            static_cast<double>(vigra::NumericTraits<PyramidComponentType>::max()) << "]" << std::endl;
+#endif // LOG_COLORSPACE_CONVERSION
     }
 
-#ifdef DEBUG_COLORSPACE_STATISTICS
+#ifdef LOG_COLORSPACE_CONVERSION
     ~ConvertLuvPyramidToVectorFunctor()
     {
 #ifdef OPENMP
@@ -876,7 +1256,7 @@
             range.as_string("+ ConvertLuvPyramidToVectorFunctor::~ConvertLuvPyramidToVectorFunctor: ") <<
             std::endl;
     }
-#endif // DEBUG_COLORSPACE_STATISTICS
+#endif // LOG_COLORSPACE_CONVERSION
 
     DestVectorType operator()(const PyramidVectorType& v) const
     {
@@ -885,14 +1265,57 @@
             Scale::scale_color_difference_of_pyramid(converter(v.green())),
             Scale::scale_color_difference_of_pyramid(converter(v.blue()))
         };
-#ifdef DEBUG_COLORSPACE_STATISTICS
+#ifdef LOG_COLORSPACE_CONVERSION
         range.update(luv[0], luv[1], luv[2]);
-#endif // DEBUG_COLORSPACE_STATISTICS
-        const Luv2XYZFunctor::result_type xyz {luv2xyz(luv)};
+#endif // LOG_COLORSPACE_CONVERSION
+
+        assert(!std::isnan(luv[0]) && luv[0] >= 0.0);
+        Luv2XYZFunctor::result_type xyz {luv2xyz(luv)};
         double rgb[3];
 
         cmsDoTransform(XYZToInputTransform, &xyz[0], rgb, 1U);
 
+        if (EXPECT_RESULT(is_below_threshold(rgb), false))
+        {
+            XYZ2LabFunctor::result_type lab_vector {xyz2lab(xyz)};
+            cmsCIELab lab {lab_vector[0], lab_vector[1], lab_vector[2]};
+
+            if (EXPECT_RESULT(std::isnan(lab.a) || std::isnan(lab.b), false))
+            {
+#ifdef LOG_COLORSPACE_OPTIMIZATION
+#ifdef OPENMP
+#pragma omp critical
+#endif // LOG_COLORSPACE_CONVERSION
+                std::cout <<
+                    "+ ConvertLuvPyramidToVectorFunctor::operator(): initial XYZ = " << xyz << "\n"
+                    "              Lab = (" << lab.L << ", " << lab.a << ", " << lab.b << "), "
+                    "RGB = (" << rgb[0] << ", " << rgb[1] << ", " << rgb[2] << ")\n";
+#endif
+                xyz[0] = std::max(xyz[0], 0.0);
+                xyz[1] = std::max(xyz[1], 0.0);
+                xyz[2] = std::max(xyz[2], 0.0);
+
+                cmsDoTransform(XYZToInputTransform, &xyz[0], rgb, 1U);
+                lab_vector = xyz2lab(xyz);
+
+                lab.L = lab_vector[0];
+                lab.a = lab_vector[1];
+                lab.b = lab_vector[2];
+
+#ifdef LOG_COLORSPACE_OPTIMIZATION
+#ifdef OPENMP
+#pragma omp critical
+#endif
+                std::cout <<
+                    "+ ConvertLuvPyramidToVectorFunctor::operator(): fixed XYZ = " << xyz << "\n"
+                    "              Lab = (" << lab.L << ", " << lab.a << ", " << lab.b << "), "
+                    "RGB = (" << rgb[0] << ", " << rgb[1] << ", " << rgb[2] << ")\n";
+#endif // LOG_COLORSPACE_CONVERSION
+            }
+
+            polish_rgb(&lab, rgb);
+        }
+
         return DestVectorType(DestTraits::fromRealPromote(rgb_dest_scale * rgb[0]),
                               DestTraits::fromRealPromote(rgb_dest_scale * rgb[1]),
                               DestTraits::fromRealPromote(rgb_dest_scale * rgb[2]));
@@ -900,11 +1323,12 @@
 
 protected:
     Luv2XYZFunctor luv2xyz;
+    XYZ2LabFunctor xyz2lab;
     ConvertFunctorType converter;
     const double rgb_dest_scale;
-#ifdef DEBUG_COLORSPACE_STATISTICS
+#ifdef LOG_COLORSPACE_CONVERSION
     mutable TriplePeakHold range;
-#endif // DEBUG_COLORSPACE_STATISTICS
+#endif // LOG_COLORSPACE_CONVERSION
 };
 
 
@@ -925,15 +1349,15 @@
         static_assert(PyramidIntegerBits >= 8,
                       "not enough PyramidIntegerBits to get `pyramid_scale' from shift");
 
-#ifdef DEBUG_COLORSPACE_STATISTICS
+#ifdef LOG_COLORSPACE_CONVERSION
 #ifdef OPENMP
 #pragma omp critical
 #endif
         std::cout <<
             "+ PyramidScaleJCh::PyramidScaleJCh: PyramidIntegerBits = " << PyramidIntegerBits <<
             ", PyramidFractionBits = " << PyramidFractionBits << "  =>  pyramid-scale = " << pyramid_scale <<
-            "\n";
-#endif // DEBUG_COLORSPACE_STATISTICS
+            std::endl;
+#endif // LOG_COLORSPACE_CONVERSION
     }
 
     double scale_lightness_for_pyramid(double a_lightness) const
@@ -1041,82 +1465,6 @@
 
 namespace ciecam_detail
 {
-    template <typename forward_iterator>
-    static inline void
-    limit_sequence(forward_iterator first, forward_iterator last, double lower_limit, double upper_limit)
-    {
-        while (first != last)
-        {
-            *first = limit(*first, lower_limit, upper_limit);
-            ++first;
-        }
-    }
-
-
-    static inline double
-    uniform_random(unsigned* seed)
-    {
-        return static_cast<double>(enblend::rand_r(seed)) / static_cast<double>(RAND_MAX);
-    }
-
-
-    static inline bool
-    bracket_minimum(const gsl_function& cost,
-                    double& x_initial, double x_lower, double x_upper,
-                    unsigned maximum_tries)
-    {
-        const double y_minimum_bound =
-            std::min(cost.function(x_lower, cost.params), cost.function(x_upper, cost.params));
-        double y_initial = cost.function(x_initial, cost.params);
-
-        if (y_initial < y_minimum_bound)
-        {
-            return true;
-        }
-
-        unsigned i = 0U;
-        const double lower = std::max(0.001, 1.001 * x_lower);
-        const double upper = 0.999 * x_upper;
-        unsigned seed = 1000003U; // fixed seed for reproducibility
-
-        while (y_initial >= y_minimum_bound && i < maximum_tries)
-        {
-            x_initial = uniform_random(&seed) * (upper - lower) + lower;
-            y_initial = cost.function(x_initial, cost.params);
-            ++i;
-        }
-
-        return i < maximum_tries;
-    }
-
-
-    static inline int
-    alternating_power_spacing(int i, int n,
-                              double a, double b, double c,
-                              double p)
-    {
-        const bool is_even_n = n % 2 == 0;
-        const double left_unit_stride = 1.0 / static_cast<double>(n - (is_even_n ? 1 : 2));
-        const double right_unit_stride = 1.0 / static_cast<double>(n - (is_even_n ? 2 : 1));
-        const double left_width = c - a;
-        const double right_width = b - c;
-
-        const double x = static_cast<double>(i);
-        double y = c;
-
-        if (i % 2 == 1)         // 1, 3, 5, ...
-        {
-            y -= left_width * std::pow(x * left_unit_stride, 1.0 / p);
-        }
-        else                    // 0, 2, 4, 6, ...
-        {
-            y += right_width * std::pow(x * right_unit_stride, p);
-        }
-
-        return y;
-    }
-
-
     struct extra_minimizer_parameter
     {
         explicit extra_minimizer_parameter(const cmsJCh& out_of_box_jch) : jch(out_of_box_jch)
@@ -1139,7 +1487,7 @@
 
         cmsDoTransform(InputToLabTransform, rgb, &lab_of_rgb, 1);
 
-        return cmsCMCdeltaE(lab, &lab_of_rgb, 2.0, 1.0);
+        return calculate_delta_e(lab, &lab_of_rgb);
     }
 
 
@@ -1231,40 +1579,40 @@
         rgb_dest_scale(DestTraits::toRealPromote(DestTraits::max())),
 
         // Parameters for highlight optimizer only
-        highlight_lightness_guess_1d_factor(limit(parameter::as_double("highlight-recovery-lightness-guess-factor", 0.975),
+        highlight_lightness_guess_1d_factor(limit(parameter::as_double("ciecam-highlight-recovery-lightness-guess-factor", 0.975),
                                                   0.25, 4.0)),
-        highlight_lightness_guess_1d_offset(parameter::as_double("highlight-recovery-lightness-guess-offset", 0.0)),
+        highlight_lightness_guess_1d_offset(parameter::as_double("ciecam-highlight-recovery-lightness-guess-offset", 0.0)),
 
-        maximum_highlight_iterations(limit(parameter::as_unsigned("highlight-recovery-maximum-iterations", 100U),
+        maximum_highlight_iterations(limit(parameter::as_unsigned("ciecam-highlight-recovery-maximum-iterations", 100U),
                                            10U, 1000U)),
-        maximum_highlight_bracket_tries(limit(parameter::as_unsigned("highlight-recovery-bracket-maximum-tries", 1000U),
+        maximum_highlight_bracket_tries(limit(parameter::as_unsigned("ciecam-highlight-recovery-bracket-maximum-tries", 1000U),
                                               10U, 1000000U)),
-        highlight_simplex_lightness_step_length(limit(parameter::as_double("highlight-recovery-lightness-step-length", 12.5),
+        highlight_simplex_lightness_step_length(limit(parameter::as_double("ciecam-highlight-recovery-lightness-step-length", 12.5),
                                                       1.0 / 65536.0, 100.0)),
-        highlight_simplex_chroma_step_length(limit(parameter::as_double("highlight-recovery-chroma-step-length", 6.25),
+        highlight_simplex_chroma_step_length(limit(parameter::as_double("ciecam-highlight-recovery-chroma-step-length", 6.25),
                                                    1.0 / 65536.0, 120.0)),
-        highlight_iterations_per_leg(limit(parameter::as_unsigned("highlight-recovery-iterations-per-leg", 50U),
+        highlight_iterations_per_leg(limit(parameter::as_unsigned("ciecam-highlight-recovery-iterations-per-leg", 50U),
                                            5U, 500U)),
-        maximum_highlight_leg(limit(parameter::as_unsigned("highlight-recovery-maximum-legs", 10U), 1U, 100U)),
-        shadow_disguised_as_highlight_j(limit(parameter::as_double("shadow-disguised-as-highlight-lightness", 1.0),
+        maximum_highlight_leg(limit(parameter::as_unsigned("ciecam-highlight-recovery-maximum-legs", 10U), 1U, 100U)),
+        shadow_disguised_as_highlight_j(limit(parameter::as_double("ciecam-shadow-disguised-as-highlight-lightness", 1.0),
                                               0.0001, 10.0)),
 
         // Parameters for shadow optimizer only
-        shadow_lightness_lightness_guess_factor(parameter::as_double("shadow-recovery-lightness-lightness-guess-factor", 1.24)),
-        shadow_lightness_chroma_guess_factor(parameter::as_double("shadow-recovery-lightness-chroma-guess-factor", -0.136)),
-        shadow_lightness_guess_offset(parameter::as_double("shadow-recovery-lightness-guess-offset", 0.0)),
-        shadow_chroma_lightness_guess_factor(parameter::as_double("shadow-recovery-chroma-lightness-guess-factor", -0.604)),
-        shadow_chroma_chroma_guess_factor(parameter::as_double("shadow-recovery-chroma-chroma-guess-factor", 1.33)),
-        shadow_chroma_guess_offset(parameter::as_double("shadow-recovery-chroma-guess-offset", 0.0)),
+        shadow_lightness_lightness_guess_factor(parameter::as_double("ciecam-shadow-recovery-lightness-lightness-guess-factor", 1.24)),
+        shadow_lightness_chroma_guess_factor(parameter::as_double("ciecam-shadow-recovery-lightness-chroma-guess-factor", -0.136)),
+        shadow_lightness_guess_offset(parameter::as_double("ciecam-shadow-recovery-lightness-guess-offset", 0.0)),
+        shadow_chroma_lightness_guess_factor(parameter::as_double("ciecam-shadow-recovery-chroma-lightness-guess-factor", -0.604)),
+        shadow_chroma_chroma_guess_factor(parameter::as_double("ciecam-shadow-recovery-chroma-chroma-guess-factor", 1.33)),
+        shadow_chroma_guess_offset(parameter::as_double("ciecam-shadow-recovery-chroma-guess-offset", 0.0)),
 
-        shadow_simplex_lightness_step_length(limit(parameter::as_double("shadow-recovery-lightness-step-length", 0.625),
+        shadow_simplex_lightness_step_length(limit(parameter::as_double("ciecam-shadow-recovery-lightness-step-length", 0.625),
                                                    1.0 / 65536.0, 100.0)),
-        shadow_simplex_chroma_step_length(limit(parameter::as_double("shadow-recovery-chroma-step-length", 1.25),
+        shadow_simplex_chroma_step_length(limit(parameter::as_double("ciecam-shadow-recovery-chroma-step-length", 1.25),
                                                 1.0 / 65536.0, 120.0)),
-        shadow_iterations_per_leg(limit(parameter::as_unsigned("shadow-recovery-iterations-per-leg", 40U),
+        shadow_iterations_per_leg(limit(parameter::as_unsigned("ciecam-shadow-recovery-iterations-per-leg", 40U),
                                         4U, 400U)),
-        maximum_shadow_leg(limit(parameter::as_unsigned("shadow-recovery-maximum-legs", 5U), 1U, 50U)),
-        maximum_multistart_tries(limit(parameter::as_unsigned("shadow-recovery-maximum_tries", 20U), 1U, 500U)),
+        maximum_shadow_leg(limit(parameter::as_unsigned("ciecam-shadow-recovery-maximum-legs", 5U), 1U, 50U)),
+        maximum_multistart_tries(limit(parameter::as_unsigned("ciecam-shadow-recovery-maximum-tries", 20U), 1U, 500U)),
 
         // Parameters for both optimizers
         // Desired error limits: LoFi: 0.5/2^8, HiFi: 0.5/2^16, Super-HiFi: 0.5/2^24
@@ -1308,9 +1656,9 @@
     }
 
     double optimize_1d(cmsJCh initial_jch,
-                              double initial_lightness,
-                              unsigned maximum_iterations,
-                              cmsJCh& final_jch) const
+                       double initial_lightness,
+                       unsigned maximum_iterations,
+                       cmsJCh& final_jch) const
     {
         ciecam_detail::extra_minimizer_parameter extra(initial_jch);
         gsl_function cost = {ciecam_detail::delta_e_min_cost, &extra};
@@ -1326,7 +1674,7 @@
 
         final_jch.J = optimizer.x_minimum();
 
-#ifdef DEBUG_OPTIMIZE_1D_STATISTICS
+#ifdef LOG_COLORSPACE_OPTIMIZATION
 #ifdef OPENMP
 #pragma omp critical
 #endif
@@ -1337,7 +1685,7 @@
                 "+ optimize_1d: delta-E = " << optimizer.f_minimum() << "\n";
             ciecam_detail::show_jch_rgb("+ optimize_1d: final", &final_jch);
         }
-#endif
+#endif // LOG_COLORSPACE_OPTIMIZATION
 
         return optimizer.f_minimum();
     }
@@ -1396,9 +1744,9 @@
             cmsJCh jch;
             const double opt_deltae =
                 optimize_2d(*initial_jch,
-                            ciecam_detail::alternating_power_spacing(n, maximum_multistart_tries,
-                                                                     0.0, Scale::MAXIMUM_LIGHTNESS, guessed_j,
-                                                                     2.0),
+                            detail::alternating_power_spacing(n, maximum_multistart_tries,
+                                                              0.0, Scale::MAXIMUM_LIGHTNESS, guessed_j,
+                                                              2.0),
                             guessed_c,
                             shadow_simplex_lightness_step_length, shadow_simplex_chroma_step_length,
                             maximum_shadow_leg, shadow_iterations_per_leg,
@@ -1420,7 +1768,7 @@
 
         jch_to_rgb(&best_jch, rgb);
 
-#ifdef DEBUG_SHADOW_HIGHLIGHT_STATISTICS
+#ifdef LOG_COLORSPACE_OPTIMIZATION
         if (best_deltae > optimizer_goal)
         {
 #ifdef OPENMP
@@ -1433,7 +1781,7 @@
             ciecam_detail::show_jch_rgb("+ multistart_optimize_2d: initial", initial_jch);
             ciecam_detail::show_jch_rgb("+ multistart_optimize_2d: final", &best_jch);
         }
-#endif
+#endif // LOG_COLORSPACE_OPTIMIZATION
     }
 
     void flexible_optimize_1d_2d(const cmsJCh* jch, double* rgb) const
@@ -1445,15 +1793,15 @@
         double delta_e_1d = 0.0;
         double delta_e_2d __attribute__((unused)) = 0.0;
 
-        if (EXPECT_RESULT(ciecam_detail::bracket_minimum(cost, guessed_j,
-                                                         0.0, std::max(static_cast<double>(Scale::MAXIMUM_LIGHTNESS), jch->J),
-                                                         maximum_highlight_bracket_tries),
+        if (EXPECT_RESULT(detail::bracket_minimum(cost, guessed_j,
+                                                  0.0, std::max(static_cast<double>(Scale::MAXIMUM_LIGHTNESS), jch->J),
+                                                  maximum_highlight_bracket_tries),
                           true))
         {
             delta_e_1d = optimize_1d(*jch, guessed_j, maximum_highlight_iterations, opt_jch);
             if (delta_e_1d > optimizer_goal)
             {
-#ifdef DEBUG_HIGHLIGHT_FALLBACK_STATISTICS
+#ifdef LOG_COLORSPACE_OPTIMIZATION
 #ifdef OPENMP
 #pragma omp critical
 #endif
@@ -1462,7 +1810,8 @@
                     jch->J << ", {C = " << jch->C << ", h = " << jch->h << "}\n" <<
                     "+          1d opt J = " << opt_jch.J << " and 1d delta-E = " << delta_e_1d <<
                     std::endl;
-#endif
+#endif // LOG_COLORSPACE_OPTIMIZATION
+
                 delta_e_2d =
                     optimize_2d(opt_jch,
                                 highlight_lightness_guess_2d(opt_jch), highlight_chroma_guess_2d(opt_jch),
@@ -1483,7 +1832,7 @@
 
         jch_to_rgb(&opt_jch, rgb);
 
-#ifdef DEBUG_SHADOW_HIGHLIGHT_STATISTICS
+#ifdef LOG_COLORSPACE_OPTIMIZATION
         if (delta_e_1d > optimizer_goal && delta_e_2d > optimizer_goal)
         {
 #ifdef OPENMP
@@ -1493,13 +1842,13 @@
                 std::cout <<
                     "\n" <<
                     "+ flexible_optimize_1d_2d: failed to reach optimizer goal " <<
-                    optimizer_goal << " -- only achived deltaE{1d} = " << delta_e_1d <<
+                    optimizer_goal << " -- only achieved deltaE{1d} = " << delta_e_1d <<
                     ", deltaE{2d} = " << delta_e_2d << "\n";
                 ciecam_detail::show_jch_rgb("+ flexible_optimize_1d_2d: initial", jch);
                 ciecam_detail::show_jch_rgb("+ flexible_optimize_1d_2d: final", &opt_jch);
             }
         }
-#endif
+#endif // LOG_COLORSPACE_OPTIMIZATION
     }
 
     DestVectorType operator()(const PyramidVectorType& v) const
@@ -1513,10 +1862,13 @@
             Scale::scale_hue_of_pyramid(ch_x, ch_y)
         };
 
-        if (jch.J <= 0.0)
+        if (EXPECT_RESULT(jch.J <= 0.0, false))
         {
             // Lasciate ogne speranza, voi ch'intrate.
-            return DestVectorType(0, 0, 0);
+            return
+                parameter::as_boolean("mark-freaky-color-conversions", false) ?
+                DestVectorType(DestTraits::max(), DestTraits::max(), 0) : // yellow
+                DestVectorType(0, 0, 0);
         }
 
         double rgb[3];
@@ -1524,7 +1876,7 @@
 
         // Implementation Notes
         //
-        //         New LittleCMS versions use "open color space" arithmetics, which means color
+        //         New LittleCMS versions use "open color space" arithmetic, which means color
         // coordinates can end up outside their domains, e.g. JCh cylinder or RGB cube.  We just
         // let LittleCMS chug along freewheeling as long as possible.  Right here, we must take
         // care of out-of-cube RGB values, because the array `rgb[3]' ends up as pixel in the
@@ -1579,7 +1931,7 @@
             }
         }
 
-#ifdef DEBUG_STUBBORN_SHADOW_HIGHLIGHT
+#ifdef LOG_COLORSPACE_OPTIMIZATION
         if (rgb[0] > 1.0 || rgb[1] > 1.0 || rgb[2] > 1.0)
         {
 #ifdef OPENMP
@@ -1589,6 +1941,13 @@
                 std::cout << "\n";
                 ciecam_detail::show_jch_rgb("+ stubborn highlight:", &jch);
             }
+            if (parameter::as_boolean("mark-freaky-color-conversions", false))
+            {
+                // navy blue
+                rgb[0] = 0.0;
+                rgb[1] = 0.0;
+                rgb[2] = 0.5;
+            }
         }
 
         if (rgb[0] < 0.0 || rgb[1] < 0.0 || rgb[2] < 0.0)
@@ -1600,10 +1959,17 @@
                 std::cout << "\n";
                 ciecam_detail::show_jch_rgb("+ stubborn shadow:", &jch);
             }
+            if (parameter::as_boolean("mark-freaky-color-conversions", false))
+            {
+                // yellow
+                rgb[0] = 1.0;
+                rgb[1] = 1.0;
+                rgb[2] = 0.0;
+            }
         }
-#endif
+#endif // LOG_COLORSPACE_OPTIMIZATION
 
-        ciecam_detail::limit_sequence(rgb, rgb + 3U, 0.0, 1.0);
+        detail::limit_sequence(rgb, rgb + 3U, 0.0, 1.0);
 
         return DestVectorType(DestTraits::fromRealPromote(rgb_dest_scale * rgb[0]),
                               DestTraits::fromRealPromote(rgb_dest_scale * rgb[1]),
diff -r ef8470f9d682 src/functoraccessor.hxx
--- a/src/functoraccessor.hxx	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/functoraccessor.hxx	Mon Apr 27 19:55:56 2020 -0700
@@ -405,7 +405,7 @@
 /** An accessor to encapsulate write access to a multiband image,
     and move divide it into two images.
 
-    This is particulary useful, if a multiband image should be splitted
+    This is particularly useful, if a multiband image should be split
     into separate images during import operations. Then one doesn't
     need to create a temporary image.
 
@@ -424,7 +424,7 @@
       - vector -> scalar, scalar
       - vector -> vector, scalar
 
-    This accessor is quite slow. It checks the vector indicies on
+    This accessor is quite slow. It checks the vector indices on
     every access.
 
     @bug This is not a complete accessor, only write operations are supported.
diff -r ef8470f9d682 src/global.h
--- a/src/global.h	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/global.h	Mon Apr 27 19:55:56 2020 -0700
@@ -43,39 +43,50 @@
 
 // Defines to control how many -v flags are required for each type
 // of message to be produced on stdout.
-#define VERBOSE_ASSEMBLE_MESSAGES           1
-#define VERBOSE_CHECKPOINTING_MESSAGES      1
-#define VERBOSE_OPENCL_MESSAGES             1 // ANTICIPATED CHANGE: raise level when we are done with debugging
+#define VERBOSE_ASSEMBLE_MESSAGES           1 //< verbosity-level-assemble 1
+#define VERBOSE_CHECKPOINTING_MESSAGES      1 //< verbosity-level-checkpoint 1
+// ANTICIPATED CHANGE: Raise VERBOSE_OPENCL_MESSAGES level when we are done with debugging.
+#define VERBOSE_OPENCL_MESSAGES             1 //< verbosity-level-opencl 1
 
-#define VERBOSE_BLEND_MESSAGES              2
-#define VERBOSE_MASK_MESSAGES               2
-#define VERBOSE_NFT_MESSAGES                2
-#define VERBOSE_PYRAMID_MESSAGES            2
-#define VERBOSE_SIGNATURE_REPORTING         2
-#define VERBOSE_TIFF_MESSAGES               2
-#define VERBOSE_VERSION_REPORTING           2
+#define VERBOSE_BLEND_MESSAGES              2 //< verbosity-level-blend 2
+#define VERBOSE_MASK_MESSAGES               2 //< verbosity-level-mask 2
+#define VERBOSE_NFT_MESSAGES                2 //< verbosity-level-nft 2
+#define VERBOSE_PYRAMID_MESSAGES            2 //< verbosity-level-pyramid 2
+#define VERBOSE_SIGNATURE_REPORTING         2 //< verbosity-level-signature 2
+#define VERBOSE_TIFF_MESSAGES               2 //< verbosity-level-tiff 2
+#define VERBOSE_VERSION_REPORTING           2 //< verbosity-level-version-report 2
 
-#define VERBOSE_COLOR_CONVERSION_MESSAGES   3
-#define VERBOSE_DIFFERENCE_STATISTICS       3
-#define VERBOSE_LAYER_SELECTION             3
-#define VERBOSE_RESPONSE_FILES              3
+#define VERBOSE_COLOR_CONVERSION_MESSAGES   3 //< verbosity-level-color-conversion 3
+#define VERBOSE_DIFFERENCE_STATISTICS       3 //< verbosity-level-difference-statistics 3
+#define VERBOSE_LAYER_SELECTION             3 //< verbosity-level-layer-selection 3
+#define VERBOSE_METADATA                    3 //< verbosity-level-metadata 3
+#define VERBOSE_RESPONSE_FILES              3 //< verbosity-level-response-files 3
 
-#define VERBOSE_ABB_MESSAGES                4
-#define VERBOSE_IBB_MESSAGES                4
-#define VERBOSE_INPUT_IMAGE_INFO_MESSAGES   4
-#define VERBOSE_INPUT_UNION_SIZE_MESSAGES   4
-#define VERBOSE_ROIBB_SIZE_MESSAGES         4
-#define VERBOSE_UBB_MESSAGES                4
+#define VERBOSE_ABB_MESSAGES                4 //< verbosity-level-abb 4
+#define VERBOSE_IBB_MESSAGES                4 //< verbosity-level-ibb 4
+#define VERBOSE_INPUT_IMAGE_INFO_MESSAGES   4 //< verbosity-level-input-image-info 4
+#define VERBOSE_INPUT_UNION_SIZE_MESSAGES   4 //< verbosity-level-input-union-size 4
+#define VERBOSE_ROIBB_SIZE_MESSAGES         4 //< verbosity-level-roibb-size 4
+#define VERBOSE_UBB_MESSAGES                4 //< verbosity-level-ubb 4
 
-#define VERBOSE_CFI_MESSAGES                5
-#define VERBOSE_GDA_MESSAGES                5
+#define VERBOSE_CFI_MESSAGES                5 //< verbosity-level-cfi 5
+#define VERBOSE_GDA_MESSAGES                5 //< verbosity-level-gda 5
 
-#define VERBOSE_MEMORY_ESTIMATION_MESSAGES  6
+#define VERBOSE_MEMORY_ESTIMATION_MESSAGES  6 //< verbosity-level-memory-estimate 6
 
 
 //< default-output-filename a.tif
 #define DEFAULT_OUTPUT_FILENAME "a.tif"
 
+//< default-fallback-output-file-type pnm
+#define DEFAULT_FALLBACK_OUTPUT_FILE_TYPE "pnm"
+
+//< default-output-mask-filename a.mask.tif
+#define DEFAULT_OUTPUT_MASK_FILENAME "a.mask.tif"
+
+//< default-fallback-output-mask-file-type pbm
+#define DEFAULT_FALLBACK_OUTPUT_MASK_FILE_TYPE "pbm"
+
 
 namespace enblend
 {
diff -r ef8470f9d682 src/graphcut.h
--- a/src/graphcut.h	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/graphcut.h	Mon Apr 27 19:55:56 2020 -0700
@@ -74,11 +74,11 @@
 
 namespace enblend
 {
-    template <class T>
-    inline void hash_combine(std::size_t & seed, const T & value)
-    {
-        std::hash<T> hasher;
-        seed ^= hasher(value) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
+    template <class T>
+    inline void hash_combine(std::size_t & seed, const T & value)
+    {
+        std::hash<T> hasher;
+        seed ^= hasher(value) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
     }
 
     struct pointHash
@@ -311,35 +311,6 @@
         return interPointList;
     }
 
-
-    template <typename ImageType>
-    class CostComparer
-    {
-    public:
-        CostComparer(const ImageType* image) : img(image) {}
-
-        bool operator()(const vigra::Point2D& a, const vigra::Point2D& b) const
-        {
-            if (a == vigra::Point2D(-20, -20)) {
-                return totalScore > (*img)[b];
-            } else if (b == vigra::Point2D(-20, -20)) {
-                return (*img)[a] > totalScore;
-            }
-
-            return (*img)[a] > (*img)[b];
-        }
-
-        void setTotalScore(long s)
-        {
-            totalScore = s;
-        }
-
-    protected:
-        const ImageType* img;
-        long totalScore;
-    };
-
-
     template<class MaskPixelType>
     struct OutputLabelingFunctor
     {
@@ -576,11 +547,20 @@
            vigra::Diff2D bounds, CheckpointPixels* srcDestPoints, std::unordered_set<vigra::Point2D, pointHash>* visited)
     {
         MaskPixelType zeroVal = vigra::NumericTraits<MaskPixelType>::zero();
-        typedef std::priority_queue<vigra::Point2D, std::vector<vigra::Point2D>, CostComparer<ImageType> > Queue;
-        CostComparer<ImageType> costcomp(img);
-        Queue* openset = new Queue(costcomp);
         long score = 0;
         long totalScore = 0;
+        auto costcomparer = [&img, &totalScore](const vigra::Point2D& a, const vigra::Point2D& b)->bool {
+            if (a == vigra::Point2D(-20, -20)) {
+                return totalScore > (*img)[b];
+            } else {
+                if (b == vigra::Point2D(-20, -20)) {
+                    return (*img)[a] > totalScore;
+                };
+            };
+            return (*img)[a] > (*img)[b];
+        };
+        typedef std::priority_queue<vigra::Point2D, std::vector<vigra::Point2D>, decltype(costcomparer)> Queue;
+        Queue * openset = new Queue(costcomparer);
         long iterCount = 0;
         int gradientA;
         int gradientB;
@@ -668,7 +648,6 @@
                             if (neighbour == vigra::Point2D(-20, -20)) {
                                 totalScore = score;
                                 destNeighbour = current;
-                                costcomp.setTotalScore(totalScore);
                             } else {
                                 (*img)[neighbour(1, 1)] &= BIT_MASK_OPEN;
                                 (*img)[neighbour(1, 1)] += i;
@@ -743,7 +722,7 @@
              ++currentDual) {
 
             current = convertFromDual(*currentDual);
-            
+
             if (nextDual != cut->end()) {
                 next = convertFromDual(*nextDual);
             }
@@ -1340,7 +1319,6 @@
         IMAGETYPE<GradientPixelType> gradientY(size);
         IMAGETYPE<GraphPixelType> graphImg(size + size + vigra::Diff2D(1, 1));
 
-        std::vector<vigra::Point2D>* dualPath = nullptr;
         std::vector<vigra::Point2D> totalDualPath;
         vigra::Point2D intermediatePoint;
         CheckpointPixels srcDestPoints;
@@ -1460,7 +1438,7 @@
             std::cout << "Running graph-cut: " << intermediatePoint << ":" << *i << std::endl;
 #endif
 
-            dualPath = A_star<IMAGETYPE<GraphPixelType>, IMAGETYPE<GradientPixelType>, BasePixelType>
+            std::vector<vigra::Point2D>* dualPath = A_star<IMAGETYPE<GraphPixelType>, IMAGETYPE<GradientPixelType>, BasePixelType>
                 (vigra::Point2D(-10, -10), vigra::Point2D(-20, -20), &intermediateGraphImg, &gradientX,
                  &gradientY, graphsize - vigra::Diff2D(1, 1), &srcDestPoints, &visited);
 
@@ -1471,6 +1449,7 @@
                     totalDualPath.push_back(*j);
                 }
             }
+            delete dualPath;
 
             vigra::copyImage(srcImageRange(graphImg), destImage(intermediateGraphImg));
             intermediatePoint = *i;
@@ -1481,7 +1460,6 @@
              dest_upperleft, da, totalDualPath, iBB);
 
         delete intermediatePointList;
-        delete dualPath;
     }
 } /* namespace enblend */
 
diff -r ef8470f9d682 src/introspection.cc
--- a/src/introspection.cc	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/introspection.cc	Mon Apr 27 19:55:56 2020 -0700
@@ -31,6 +31,10 @@
 #include <config.h>
 #endif
 
+#ifdef HAVE_EXIV2
+#include <exiv2/exiv2.hpp>
+#endif
+
 #include "filespec.h"
 #include "global.h"
 #include "signature.h"
@@ -56,7 +60,7 @@
     {
         std::cout << command << " " << VERSION << "\n\n";
 
-        if (Verbose >= VERBOSE_VERSION_REPORTING)
+        if (Verbose)
         {
 #ifdef ENFUSE_SOURCE
             {
@@ -108,6 +112,14 @@
 #else
             std::cout << "Extra feature: OpenCL: no\n";
 #endif
+
+            std::cout << "Extra feature: metadata (EXIF, IPTC, XMP) transfer: ";
+#ifdef HAVE_EXIV2
+            std::cout << "yes\n";
+#else
+            std::cout << "no\n";
+#endif
+
             std::cout << "\n";
         }
 
@@ -251,6 +263,9 @@
 #endif // OPENCL
 
         std::cout << "Libraries\n" <<
+#ifdef HAVE_EXIV2
+            "  Exif2:      " << EXIV2_MAJOR_VERSION << '.' << EXIV2_MINOR_VERSION << '.' << EXIV2_PATCH_VERSION << "\n" <<
+#endif
             "  GSL:        " << GSL_VERSION << "\n" <<
             //"  JPEG:       " << "\n" <<
             "  Little CMS: " << LCMS_VERSION / 1000 << '.' << (LCMS_VERSION / 10) % 100 << '.' << LCMS_VERSION % 10 << "\n" <<
diff -r ef8470f9d682 src/layer_selection/selector.cc
--- a/src/layer_selection/selector.cc	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/layer_selection/selector.cc	Mon Apr 27 19:55:56 2020 -0700
@@ -24,7 +24,7 @@
 #include <iostream>             // WHILE DEBUGGING
 #include <memory>               // std::unique_ptr
 
-#include <boost/tokenizer.hpp>
+#include <regex>
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
@@ -33,7 +33,7 @@
 #include "selector.h"
 
 
-#define NUMERIC_OPTION_DELIMITERS ";:/" // FIXME: Already defined on "common.h".
+#define NUMERIC_NUMERIC_OPTION_DELIMITERS_REGEX "[;:/]" // FIXME: Already defined on "common.h".
 extern const std::string command;
 
 
@@ -425,12 +425,6 @@
         return result;
     }
 
-
-    // http://www.boost.org/doc/libs/1_58_0/libs/tokenizer/
-    typedef boost::char_separator<char> separator_t;
-    typedef boost::tokenizer<separator_t> tokenizer_t;
-
-
     inline static
     bool
     is_whitespace_or_empty(const std::string& a_string)
@@ -487,11 +481,11 @@
                     "\" after integer " << n << "\n";
             }
         }
-        catch (std::invalid_argument)
+        catch (std::invalid_argument&)
         {
             std::cerr << command << ": invalid integer \"" << a_token << "\"\n";
         }
-        catch (std::out_of_range)
+        catch (std::out_of_range&)
         {
             std::cerr << command << ": number " << a_token << " is outside of the range of integers\n";
         }
@@ -502,21 +496,22 @@
 
     LayerSpecification::LayerSpecification(const std::string& a_layer_specification)
     {
-        static const separator_t separator(NUMERIC_OPTION_DELIMITERS, "");
-        tokenizer_t tokenizer(a_layer_specification, separator);
+        static const std::regex separator(NUMERIC_NUMERIC_OPTION_DELIMITERS_REGEX);
+        std::sregex_token_iterator token(a_layer_specification.begin(), a_layer_specification.end(), separator, -1);
+        std::sregex_token_iterator tokenEnd;
         int token_number = 1;
 
-        for (tokenizer_t::iterator token = tokenizer.begin(); token != tokenizer.end(); ++token)
+        for (; token != tokenEnd; ++token)
         {
-            const std::string::size_type range_separator_position = token->find(range_separator);
+            const std::string::size_type range_separator_position = token->str().find(range_separator);
             std::pair<std::string::const_iterator, std::string::const_iterator> prefix_count =
-                std::mismatch(token->begin(), token->end(), reverse_keyword.begin(),
+                std::mismatch(token->str().begin(), token->str().end(), reverse_keyword.begin(),
                               [](std::string::value_type v1, std::string::value_type v2)
                               {return tolower(v1) == tolower(v2);});
 
             if (range_separator_position == std::string::npos)
             {
-                if (prefix_count.first > token->begin())
+                if (prefix_count.first > token->str().begin())
                 {
                     std::cerr <<
                         command << ": layer index, #" << token_number <<
@@ -525,7 +520,7 @@
                     exit(1);
                 }
 
-                SingletonIndex* possible_index(parse_singleton(*token));
+                SingletonIndex* possible_index(parse_singleton(token->str()));
                 if (possible_index == nullptr)
                 {
                     std::cerr <<
@@ -540,12 +535,12 @@
             }
             else
             {
-                const size_t prefix_length = prefix_count.first - token->begin();
-                const bool forward_range = prefix_count.first == token->begin();
+                const size_t prefix_length = prefix_count.first - token->str().begin();
+                const bool forward_range = prefix_count.first == token->str().begin();
 #ifdef DEBUG_FILESPEC
                 std::cout <<
                     "+ LayerSpecification::LayerSpecification(const std::string&): " <<
-                    " token = <" << *token << ">, reverse_keyword = <" << reverse_keyword << ">\n" <<
+                    " token = <" << token->str() << ">, reverse_keyword = <" << reverse_keyword << ">\n" <<
                     "+ LayerSpecification::LayerSpecification(const std::string&): " <<
                     "prefix_length = " << prefix_length <<
                     ", 1st = <" << token->substr(prefix_length, range_separator_position - prefix_length) <<
@@ -553,10 +548,10 @@
 #endif
 
                 std::unique_ptr<SingletonIndex>
-                    first_index(parse_singleton(token->substr(prefix_length,
+                    first_index(parse_singleton(token->str().substr(prefix_length,
                                                               range_separator_position - prefix_length)));
                 std::unique_ptr<SingletonIndex>
-                    second_index(parse_singleton(token->substr(range_separator_position +
+                    second_index(parse_singleton(token->str().substr(range_separator_position +
                                                                range_separator.length())));
 
                 if (first_index.get() == nullptr)
diff -r ef8470f9d682 src/mask.h
--- a/src/mask.h	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/mask.h	Mon Apr 27 19:55:56 2020 -0700
@@ -1139,20 +1139,19 @@
 
     search_for_isolated_points(blackAlpha);
 
-#ifdef DEBUG_NEAREST_FEATURE_TRANSFORM
-    {
-        typedef std::pair<const char*, const MaskType*> ImagePair;
+    if (parameter::as_boolean("dump-nft-images", false)) {
+        typedef std::pair<const char*, const MaskType*> image_pair_t;
 
-        const std::array<ImagePair, 3> nft {
+        const std::array<image_pair_t, 3> nft {
             std::make_pair("blackmask", blackAlpha),
             std::make_pair("whitemask", whiteAlpha),
             std::make_pair("nft-output", mainOutputImage)
         };
 
         for (const auto& x : nft) {
-            const std::string nftMaskTemplate(command + "-" + x.first + "-%n.tif");
-            const std::string nftMaskFilename =
-                enblend::expandFilenameTemplate(nftMaskTemplate,
+            const std::string nft_mask_template(command + "-" + x.first + "-%n.tif");
+            const std::string nft_mask_filename =
+                enblend::expandFilenameTemplate(nft_mask_template,
                                                 numberOfImages,
                                                 *inputFileNameIterator,
                                                 OutputFileName,
@@ -1160,14 +1159,14 @@
             if (Verbose >= VERBOSE_NFT_MESSAGES) {
                 std::cerr << command <<
                     ": info: saving nearest-feature-transform image \"" <<
-                    nftMaskFilename << "\"" << std::endl;
+                    nft_mask_filename << "\"" << std::endl;
             }
-            vigra::ImageExportInfo nftMaskInfo(nftMaskFilename.c_str());
-            nftMaskInfo.setCompression(MASK_COMPRESSION);
-            vigra::exportImage(srcImageRange(*x.second), nftMaskInfo);
+
+            vigra::ImageExportInfo nft_mask_info(nft_mask_filename.c_str());
+            nft_mask_info.setCompression(MASK_COMPRESSION);
+            vigra::exportImage(srcImageRange(*x.second), nft_mask_info);
         }
     }
-#endif
 
     // mem usage before: CoarseMask: 2/8 * uBB * MaskType
     //                   !CoarseMask: 2 * uBB * MaskType
diff -r ef8470f9d682 src/metadata.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/metadata.cc	Mon Apr 27 19:55:56 2020 -0700
@@ -0,0 +1,235 @@
+/*
+ * Copyright (C) 2016, 2017 Christoph L. Spiel
+ *
+ * This file is part of Enblend.
+ *
+ * Enblend is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * Enblend is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Enblend; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+#include <algorithm>
+#include <array>
+#include <cassert>
+#include <memory>
+#include <regex>
+#include <sstream>
+#include <vector>
+
+#include "parameter.h"
+
+#include "metadata.h"
+
+
+namespace metadata
+{
+#ifdef HAVE_EXIV2
+    static void
+    copy_exif(Exiv2::ExifData& output_exif, const Exiv2::ExifData& input_exif)
+    {
+        for (auto x : input_exif)
+        {
+            if (output_exif.findKey(Exiv2::ExifKey(x.key())) == output_exif.end())
+            {
+                output_exif.add(x);
+            }
+        }
+    }
+
+
+    static void
+    copy_iptc(Exiv2::IptcData& output_iptc, const Exiv2::IptcData& input_iptc)
+    {
+        for (auto x : input_iptc)
+        {
+            if (output_iptc.findKey(Exiv2::IptcKey(x.key())) == output_iptc.end())
+            {
+                output_iptc.add(x);
+            }
+        }
+    }
+
+
+    static void
+    copy_xmp(Exiv2::XmpData& output_xmp, const Exiv2::XmpData& input_xmp)
+    {
+        for (auto x : input_xmp)
+        {
+            if (output_xmp.findKey(Exiv2::XmpKey(x.key())) == output_xmp.end())
+            {
+                output_xmp.add(x);
+            }
+        }
+    }
+
+
+    static void
+    copy(Exiv2::Image* some_output_metadata, const Exiv2::Image* some_input_metadata)
+    {
+        copy_exif(some_output_metadata->exifData(), some_input_metadata->exifData());
+        copy_iptc(some_output_metadata->iptcData(), some_input_metadata->iptcData());
+        copy_xmp(some_output_metadata->xmpData(), some_input_metadata->xmpData());
+    }
+
+
+#if defined(ENBLEND_SOURCE)
+#define PROCESSING_SOFTWARE "enblend"
+#elif defined(ENFUSE_SOURCE)
+#define PROCESSING_SOFTWARE "enfuse"
+#else
+#error "Neither ENBLEND_SOURCE nor ENFUSE_SOURCE are defined."
+#endif
+
+
+    static void
+    augment(Exiv2::Image* some_output_metadata)
+    {
+        Exiv2::ExifData& output_exif {some_output_metadata->exifData()};
+
+        std::unique_ptr<Exiv2::AsciiValue>
+            processing_software {new Exiv2::AsciiValue(PROCESSING_SOFTWARE " " VERSION)};
+
+        output_exif.add(Exiv2::ExifKey("Exif.Image.ProcessingSoftware"), processing_software.get());
+    }
+
+
+    static const std::array<const char*, 3> static_blacklist_keys
+    {
+        R"(Exif\.Image\.[XY]Resolution)",
+        R"(Exif\.Image\.0x011[ef])",   // [XY]Position
+        R"(Exif\.Image\.0x821[45])"    // Image Full Width and Height
+    };
+
+
+    using regexp_list = std::vector<std::regex>;
+
+
+    static void
+    compile_blacklist(std::back_insert_iterator<regexp_list> a_blacklist)
+    {
+        const std::regex::flag_type regex_flags {std::regex::icase | std::regex::nosubs};
+
+        // Static part.
+        for (auto x : static_blacklist_keys)
+        {
+            *a_blacklist++ = std::regex(x, regex_flags);
+        }
+
+        // Dynamic part.
+        const std::regex delimiter {R"(\s*[,;:]\s*)"};
+        const std::string dynamic_keys {parameter::as_string("blacklist-exif-keys", "")};
+        std::sregex_token_iterator
+            dynamic_key_iterator(dynamic_keys.begin(), dynamic_keys.end(), delimiter, -1);
+        while (dynamic_key_iterator != std::sregex_token_iterator())
+        {
+            const std::string key {dynamic_key_iterator->str()};
+            if (!key.empty())
+            {
+                *a_blacklist++ = std::regex(key, regex_flags);
+            }
+            ++dynamic_key_iterator;
+        }
+    }
+
+
+    static void
+    enforce_blacklist(Exiv2::Image* some_output_metadata,
+                      regexp_list::const_iterator a_blacklist_begin,
+                      regexp_list::const_iterator a_blacklist_end)
+    {
+        Exiv2::ExifData& output_exif {some_output_metadata->exifData()};
+
+        for (auto x = a_blacklist_begin; x != a_blacklist_end; ++x)
+        {
+            auto exif_datum = output_exif.begin();
+            while (exif_datum != output_exif.end())
+            {
+                if (std::regex_match(exif_datum->key(), *x))
+                {
+#ifdef DEBUG_METADATA
+                    std::cout << "+ EXIF key `" << exif_datum->key() << "' is blacklisted -- not copied\n";
+#endif
+                    exif_datum = output_exif.erase(exif_datum);
+                }
+                else
+                {
+                    ++exif_datum;
+                }
+            }
+        }
+    }
+
+
+    Exiv2::Image::UniquePtr
+    read(const std::string& an_image_filename)
+    {
+        Exiv2::Image::UniquePtr meta {Exiv2::ImageFactory::open(an_image_filename)};
+
+        if (meta.get() && meta->good())
+        {
+            meta->readMetadata();
+            return meta;
+        }
+        else
+        {
+            return Exiv2::Image::UniquePtr(nullptr);
+        }
+    }
+
+
+    named_meta_array::const_iterator
+    write(const std::string& an_image_filename,
+          named_meta_array::const_iterator some_named_meta_begin,
+          named_meta_array::const_iterator some_named_meta_end)
+    {
+        Exiv2::Image::UniquePtr output_meta {Exiv2::ImageFactory::open(an_image_filename)};
+
+        if (output_meta.get() && output_meta->good())
+        {
+            assert(some_named_meta_begin != some_named_meta_end);
+
+            named_meta_array::const_iterator
+                desired_meta(std::find_if(some_named_meta_begin, some_named_meta_end,
+                                          [](const Named& named){return named.is_desired();}));
+            named_meta_array::const_iterator safe_meta(desired_meta == some_named_meta_end ?
+                                                       some_named_meta_begin :
+                                                       desired_meta);
+
+            copy(output_meta.get(), safe_meta->meta());
+            augment(output_meta.get());
+            {
+                regexp_list blacklist;
+                compile_blacklist(std::back_inserter(blacklist));
+                enforce_blacklist(output_meta.get(), blacklist.begin(), blacklist.end());
+            }
+            output_meta->writeMetadata();
+
+            if (desired_meta == some_named_meta_end)
+            {
+                std::stringstream message;
+                message <<
+                    "could not use metadata of selected image \"" << desired_meta->filename() <<
+                    "\" - have used \"" << safe_meta->filename() << "\" instead";
+                throw Warning(message.str());
+            }
+
+            return safe_meta;
+        }
+        else
+        {
+            throw Warning("initial output metadata is not valid");
+        }
+    }
+#endif // HAVE_EXIV2
+} // namespace metadata
diff -r ef8470f9d682 src/metadata.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/metadata.h	Mon Apr 27 19:55:56 2020 -0700
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2016, 2017 Dr. Christoph L. Spiel
+ *
+ * This file is part of Enblend.
+ *
+ * Enblend is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * Enblend is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Enblend; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef METADATA_H_INCLUDED
+#define METADATA_H_INCLUDED
+
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+
+#include <stdexcept>
+#include <string>
+#include <vector>
+
+
+#ifdef HAVE_EXIV2
+#include <exiv2/exiv2.hpp>
+#endif
+
+
+namespace metadata
+{
+#ifdef HAVE_EXIV2
+    struct Warning : public std::runtime_error
+    {
+        Warning() = delete;
+        explicit Warning(const char* a_message) : std::runtime_error(a_message) {}
+        explicit Warning(const std::string& a_message) : std::runtime_error(a_message) {}
+    }; // struct Warning
+
+
+    class Named
+    {
+        typedef Exiv2::Image::UniquePtr::element_type* meta_pointer;
+
+    public:
+        Named() = delete;
+        Named(const std::string& a_filename, const meta_pointer a_meta, bool is_desired) :
+            filename_(a_filename), meta_(a_meta), is_desired_(is_desired) {}
+
+        const std::string& filename() const {return filename_;}
+        meta_pointer meta() const {return meta_;}
+        bool is_desired() const {return is_desired_;}
+
+    private:
+        const std::string& filename_;
+        const meta_pointer meta_;
+        bool is_desired_;
+    }; // class Named
+
+
+    typedef std::vector<Named> named_meta_array;
+
+
+    Exiv2::Image::UniquePtr read(const std::string& an_image_filename);
+
+    named_meta_array::const_iterator write(const std::string& an_image_filename,
+                                           named_meta_array::const_iterator some_named_meta_begin,
+                                           named_meta_array::const_iterator some_named_meta_end);
+#endif
+} // namespace metadata
+
+
+#endif // METADATA_H_INCLUDED
+
+// Local Variables:
+// mode: c++
+// End:
diff -r ef8470f9d682 src/minimizer.cc
--- a/src/minimizer.cc	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/minimizer.cc	Mon Apr 27 19:55:56 2020 -0700
@@ -18,6 +18,10 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+#include <cassert>
+#include <limits>
+#include <algorithm>  // std::max
+
 #include <gsl/gsl_errno.h>
 
 #include "minimizer.h"
@@ -26,7 +30,7 @@
 Minimizer::Minimizer(size_t a_dimension) :
     dimension_(a_dimension),
     maximum_iteration_(ITERATIONS_PER_DIMENSION * a_dimension), iteration_(0U),
-    f_goal_(boost::none), absolute_error_(sqrt(std::numeric_limits<double>::epsilon()))
+    f_goal_(std::nullopt), absolute_error_(sqrt(std::numeric_limits<double>::epsilon()))
 {}
 
 
@@ -64,7 +68,7 @@
 Minimizer*
 Minimizer::unset_maximum_number_of_iterations()
 {
-    maximum_iteration_ = boost::none;
+    maximum_iteration_ = std::nullopt;
     return this;
 }
 
@@ -80,7 +84,7 @@
 Minimizer*
 Minimizer::unset_goal()
 {
-    f_goal_ = boost::none;
+    f_goal_ = std::nullopt;
     return this;
 }
 
@@ -103,7 +107,7 @@
 Minimizer*
 Minimizer::unset_absolute_error()
 {
-    absolute_error_ = boost::none;
+    absolute_error_ = std::nullopt;
     return this;
 }
 
@@ -191,7 +195,8 @@
 
     if (status == GSL_EINVAL)
     {
-        throw minimum_not_bracketed("Minimizer1D::set_bracket: minimum not bracketed");
+        throw minimum_not_bracketed("Minimizer1D::set_bracket: minimum not bracketed",
+                                    x_minimum, x_lower, x_upper);
     }
     else if (status != GSL_SUCCESS)
     {
@@ -218,7 +223,7 @@
 Minimizer1D*
 Minimizer1D::unset_relative_error()
 {
-    relative_error_ = boost::none;
+    relative_error_ = std::nullopt;
     return this;
 }
 
diff -r ef8470f9d682 src/minimizer.h
--- a/src/minimizer.h	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/minimizer.h	Mon Apr 27 19:55:56 2020 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2017 Dr. Christoph L. Spiel
+ * Copyright (C) 2012-2019 Dr. Christoph L. Spiel
  *
  * This file is part of Enblend.
  *
@@ -26,12 +26,11 @@
 #include <config.h>
 #endif
 
+#include <optional>
 #include <string>
 #include <stdexcept>
 #include <vector>
 
-#include <boost/optional.hpp>
-
 #include <gsl/gsl_min.h>
 #include <gsl/gsl_multimin.h>
 #include <gsl/gsl_vector.h>
@@ -71,7 +70,22 @@
 
     struct minimum_not_bracketed : public std::runtime_error
     {
-        minimum_not_bracketed(const std::string& a_message) : std::runtime_error(a_message) {}
+        double minimum;
+        double lower;
+        double upper;
+
+        explicit minimum_not_bracketed(const std::string& a_message) :
+            std::runtime_error(a_message),
+            minimum(0.0), lower(0.0), upper(0.0)
+        {}
+
+        minimum_not_bracketed(const std::string& a_message, double x_minimum, double x_lower, double x_upper) :
+            std::runtime_error(a_message + " [(" +
+                               std::to_string(x_lower) + " | " +
+                               std::to_string(x_minimum) + " | " +
+                               std::to_string(x_upper) + ")]"),
+            minimum(x_minimum), lower(x_lower), upper(x_upper)
+        {}
     };
 
 protected:
@@ -79,10 +93,10 @@
 
 private:
     size_t dimension_;
-    boost::optional<unsigned> maximum_iteration_;
+    std::optional<unsigned> maximum_iteration_;
     unsigned iteration_;
-    boost::optional<double> f_goal_;
-    boost::optional<double> absolute_error_;
+    std::optional<double> f_goal_;
+    std::optional<double> absolute_error_;
 };
 
 
@@ -126,7 +140,7 @@
     double x_lower_;
     double x_upper_;
 
-    boost::optional<double> relative_error_;
+    std::optional<double> relative_error_;
 };
 
 
diff -r ef8470f9d682 src/opencl.cc
--- a/src/opencl.cc	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/opencl.cc	Mon Apr 27 19:55:56 2020 -0700
@@ -477,7 +477,7 @@
     construct_search_path()
     {
         // We _always_ search a_filename along of some explicit, given
-        // path, never implicitly through CWD or the direcory of the
+        // path, never implicitly through CWD or the directory of the
         // binary.
         std::vector<std::string> paths;
 
diff -r ef8470f9d682 src/opencl.h
--- a/src/opencl.h	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/opencl.h	Mon Apr 27 19:55:56 2020 -0700
@@ -63,36 +63,6 @@
 #define UNUSEDVAR __attribute__((unused))
 #endif
 
-
-#ifndef HAVE_AS_CONST
-namespace std
-{
-    // Available in C++17
-    // See for example: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0007r0.html
-
-    template <typename t>
-    inline static
-    const t&
-    as_const(const t& x) noexcept
-    {
-        return x;
-    }
-
-    template <typename t>
-    inline static
-    const t
-#if (defined _MSC_VER) && (_MSC_VER <= 1800)
-    as_const(t&& x)
-#else
-    as_const(t&& x) noexcept(noexcept(t(x)))
-#endif
-    {
-        return x;
-    }
-}
-#endif
-
-
 namespace cl
 {
     // forward declarations
@@ -408,7 +378,7 @@
         template <typename t>
         typename std::add_const<t>::type get() const
         {
-            return std::as_const(static_cast<t>(super::base_address()));
+            return std::add_const_t<typename std::add_const<t>::type>(static_cast<t>(super::base_address()));
         }
     }; // class ScopedReadMap
 
diff -r ef8470f9d682 src/parameter.h
--- a/src/parameter.h	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/parameter.h	Mon Apr 27 19:55:56 2020 -0700
@@ -69,7 +69,7 @@
     //         std::string s = parameter::as_string("foobar");
     //         int i = parameter::as_integer("foobar");
     //         unsigned u = parameter::as_unsigned("foobar");
-    //         double x = parameter::as_floating_point("foobar");
+    //         double x = parameter::as_double("foobar");
     //         bool b = parameter::as_boolean("foobar");
     //
     // (3) Substitute parameter value if it exists; otherwise go with
@@ -77,7 +77,7 @@
     //         std::string s = parameter::as_string("foobar", "baz");
     //         int i = parameter::as_integer("foobar", 123);
     //         unsigned u = parameter::as_unsigned("foobar", 42U);
-    //         double x = parameter::as_floating_point("foobar", 0.577215665);
+    //         double x = parameter::as_double("foobar", 0.577215665);
     //         bool b = parameter::as_boolean("foobar", true);
     //
     // (4) React on parameter with a non-local change of control flow
diff -r ef8470f9d682 src/pyramid.h
--- a/src/pyramid.h	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/pyramid.h	Mon Apr 27 19:55:56 2020 -0700
@@ -160,7 +160,7 @@
  *  sr1 <= sr0 + srp
  *  scp[x] <= 4*(sr1 + 6*sr0 + srp + current)
  *
- *  Updates when visting (odd x, odd y) source pixel:
+ *  Updates when visiting (odd x, odd y) source pixel:
  *  srp <= 4*current
  */
 template <typename SKIPSMImagePixelType, typename SKIPSMAlphaPixelType,
@@ -591,7 +591,7 @@
                                                        mask.first, mask.second,
                                                        dest.first, dest.second, dest.third,
                                                        destMask.first, destMask.second, destMask.third);
-};
+}
 
 
 
@@ -1421,7 +1421,7 @@
 
 // Functor that adds two values and de-promotes the result.
 // Used when collapsing a laplacian pyramid.
-// Explict fromPromote necessary to avoid overflow/underflow problems.
+// Explicit fromPromote necessary to avoid overflow/underflow problems.
 template<typename T1, typename T2, typename T3>
 struct FromPromotePlusFunctorWrapper :
     public std::binary_function<T1, T2, T3>
diff -r ef8470f9d682 src/tiff_message.cc
--- a/src/tiff_message.cc	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/tiff_message.cc	Mon Apr 27 19:55:56 2020 -0700
@@ -19,6 +19,7 @@
  */
 
 
+#include <array>
 #include <cstdio>              // fflush(), vsnprintf()
 #include <cstring>
 #include <iostream>
@@ -97,12 +98,26 @@
 }
 
 
+static const std::array<std::string, 2> benign_error_messages {
+    "Deflate compression support is not configured",
+    "OJPEG encoding not supported; use new-style JPEG compression instead"
+};
+
+
 static bool
 is_benign(const char* format, va_list arguments)
 {
     const std::string message(interpolate_format(format, arguments));
 
-    return message == "OJPEG encoding not supported; use new-style JPEG compression instead";
+    for (auto benign_error_message : benign_error_messages)
+    {
+        if (message.find(benign_error_message) != std::string::npos)
+        {
+            return true;
+        }
+    }
+
+    return false;
 }
 
 
diff -r ef8470f9d682 src/timer.h
--- a/src/timer.h	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/timer.h	Mon Apr 27 19:55:56 2020 -0700
@@ -34,7 +34,7 @@
 #include <time.h>        // clock_t, clock(); timespec, clock_gettime()
 
 #ifdef WIN32
-#include <Windows.h>
+#include <windows.h>
 #endif
 
 
diff -r ef8470f9d682 src/win32helpers/delayHelper.h
--- a/src/win32helpers/delayHelper.h	Sun Feb 12 15:25:10 2017 +0100
+++ b/src/win32helpers/delayHelper.h	Mon Apr 27 19:55:56 2020 -0700
@@ -32,6 +32,9 @@
 #define VC_EXTRALEAN
 #include <windows.h>
 #undef DIFFERENCE
+// with Visual Studio 2015 Update 3 the hooks have become const
+// force currently the old non-const behaviour
+#define DELAYIMP_INSECURE_WRITABLE_HOOKS
 #include <delayimp.h>
 static char* openclLib = "opencl.dll";
 
