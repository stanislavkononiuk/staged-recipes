
{% set name = "heaptrack" %}
{% set version = "1.2.0" %}

package:
  name: {{ name|lower }}
  version: {{ version }}

source:
  url: https://github.com/KDE/heaptrack/archive/v{{ version }}.tar.gz
  sha256: f299a4846b80e607a412f439e17cddae13f0529701ffdb05eaa7ba878865717e
  folder: source
  # sha256 is the preferred checksum -- you can get it for a file with:
  #  `openssl sha256 <file name>`.
  # You may need the openssl package, available on conda-forge:
  #  `conda install openssl -c conda-forge``
  patches:
    - stdc_format.patch

build:
  number: 0
  skip: true  # [win]
  ignore_run_exports:
    - elfutils
  

requirements:
  build:
    - {{ compiler('cxx') }}
    - cmake
    - make

  host:
    - boost-cpp
    - libunwind
    - elfutils

  run:
    - boost-cpp
    - libunwind
    - elfutils

test:
  commands:
    - heaptrack_print --help

about:
  home: https://github.com/KDE/heaptrack
  # Remember to specify the license variants for BSD, Apache, GPL, and LGPL.
  # Use the SPDX identifier, e.g: GPL-2.0-only instead of GNU General Public License version 2.0
  # See https://spdx.org/licenses/
  license: LGPL-2.1-or-later
  license_family: LGPL
  license_file: source/COPYING
  summary: 'heaptrack - a heap memory profiler for Linux'
  description: |
    Heaptrack traces all memory allocations and annotates these events with stack traces. Dedicated analysis tools then allow you to interpret the heap memory profile to:
      find hotspots that need to be optimized to reduce the memory footprint of your application
      find memory leaks, i.e. locations that allocate memory which is never deallocated
      find allocation hotspots, i.e. code locations that trigger a lot of memory allocation calls
      find temporary allocations, which are allocations that are directly followed by their deallocation
  doc_url: https://userbase.kde.org/Heaptrack
  dev_url: https://github.com/KDE/heaptrack

extra:
  recipe-maintainers:
    - bcouturi
    
