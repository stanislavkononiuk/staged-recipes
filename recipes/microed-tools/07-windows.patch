Fallback implementations for Windows.  These will require config.h to
be included.
--- tvips/CMakeLists.txt.orig
+++ tvips/CMakeLists.txt
@@ -112,6 +112,7 @@ CHECK_FUNCTION_EXISTS(gmtime_r HAVE_GMTIME_R)
 CHECK_FUNCTION_EXISTS(localtime_r HAVE_LOCALTIME_R)
 CHECK_FUNCTION_EXISTS(realpath HAVE_REALPATH)
 CHECK_FUNCTION_EXISTS(setenv HAVE_SETENV)
+CHECK_FUNCTION_EXISTS(strndup HAVE_STRNDUP)
 CHECK_FUNCTION_EXISTS(unsetenv HAVE_UNSETENV)
 
 
--- tvips/compat.c.orig
+++ tvips/compat.c
@@ -256,3 +256,26 @@ unsetenv(const char *name)
     return (setenv(name, "", 0));
 }
 #endif /* !HAVE_UNSETENV */
+
+
+/* Allocate sufficient memory for a copy of @p str, do the copy, and
+ * return a pointer to it, which may subsequently be used as an
+ * argument to free(3).  strndup() copies up to @p maxlen characters
+ * from @p str and the returned string is always NULL-terminated.  If
+ * memory allocation fails, strndup() returns @c NULL.
+ */
+#ifndef HAVE_STRNDUP
+char *
+strndup(const char *str, size_t maxlen)
+{
+    char *dst;
+    size_t len;
+
+    len = strnlen(str, maxlen);
+    dst = calloc(len + 1, sizeof(char));
+    if (dst == NULL)
+        return (NULL);
+
+    return (memcpy(dst, str, len));
+}
+#endif /* !HAVE_STRNDUP */
--- tvips/config.h.in.orig
+++ tvips/config.h.in
@@ -155,6 +155,17 @@
     unsetenv(const char *name);
 #endif
 
+
+/* Declare the compatibility implementation of strndup(3).
+ */
+#cmakedefine HAVE_STRNDUP
+#if !defined(HAVE_STRNDUP)
+#    include <stdint.h>
+     char *
+     strndup(const char *str, size_t maxlen);
+#endif
+
+
 /* Define WORDS_BIGENDIAN on big-endian platforms
  */
 #cmakedefine WORDS_BIGENDIAN
--- tvips/fixpoint.c.orig
+++ tvips/fixpoint.c
@@ -635,7 +635,7 @@ main(int argc, char *argv[])
     int verbose;
 
 
-    srandom(time(NULL));
+    srand(time(NULL));
 
     verbose = 1;
 
--- tvips/img2px.c.orig
+++ tvips/img2px.c
@@ -268,7 +268,7 @@ _index_list_permute(struct _index_list *il)
     long int j;
 
     for (i = il->nmemb; i-- > 1; ) {
-        j = lrint(1.0 * i * random() / RAND_MAX);
+        j = lrint(1.0 * i * rand() / RAND_MAX);
 
         if (j < 0)
             fprintf(stderr, "SHUFFLE UNDERFLOW %ld %zd\n", j, i);
@@ -300,7 +300,7 @@ _index_list_permute(struct _index_list *il)
     for (i = 0; i < il->nmemb; i++) {
 //        fprintf(stderr, "  iteration %zd\n", i);
 
-        l = lrint(1.0 * (il->nmemb - i - 1) * random() / RAND_MAX);
+        l = lrint(1.0 * (il->nmemb - i - 1) * rand() / RAND_MAX);
         if (l < 0)
             l = 0; // XXX WARN HERE?
         else if (l + i + 1 > il->nmemb)
--- tvips/metadata.c.orig
+++ tvips/metadata.c
@@ -18,6 +18,9 @@
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#ifdef HAVE_CONFIG_H
+#    include "config.h"
+#endif
 
 #include <stdio.h>
 
--- tvips/tiff.c.orig
+++ tvips/tiff.c
@@ -36,13 +36,14 @@
 
 #ifdef _WIN32
 #    include <windows.h>
+#    include <Lmcons.h>
 #else
 #    include <sys/mman.h>
+#    include <sys/socket.h>
+#    include <sys/utsname.h>
 #endif
-#include <sys/socket.h>
 #include <sys/stat.h>
 #include <sys/types.h>
-#include <sys/utsname.h>
 
 #include <stdlib.h>
 
@@ -52,7 +53,9 @@
 #include TVIPS_TOOLS_ICONV_H
 #include <limits.h>
 #include <math.h>
-#include <netdb.h>
+#ifndef _WIN32
+#    include <netdb.h>
+#endif
 #include <pthread.h>
 #include <string.h>
 #include <time.h>
@@ -1367,9 +1370,15 @@ int
 tvips_write_tiff(const struct frame *frame, float K, float M, FILE *stream)
 {
     iconv_t cd;
+#ifdef _WIN32
+    TCHAR username[UNLEN + 1];
+    DWORD hostnamelen = 0, usernamelen = UNLEN + 1;
+#else
     struct addrinfo hints, *res;
+    struct utsname hostname;
+    const char *username;
+#endif
     struct tm tm;
-    struct utsname name;
 
     /* XXX Duplication w.r.t. frame_panel structure in frame.h
      */
@@ -1384,7 +1393,6 @@ tvips_write_tiff(const struct frame *frame, float K, float M, FILE *stream)
         void *ptr;
     } raster;
 
-    const char* login;
     struct tvips_tiff *handle;
     char *buf, *inbuf, *outbuf;
     void *p;
@@ -1594,9 +1602,14 @@ tvips_write_tiff(const struct frame *frame, float K, float M, FILE *stream)
      * TIFFTAG_ARTIST was sometimes used for that purpose) is not
      * written by this function.
      */
-    login = getlogin();
-    if (login != NULL) {
-        if (TIFFSetField(handle->tif, TIFFTAG_ARTIST, login) == 0) {
+    if (
+#ifdef _WIN32
+        GetUserName(username, &usernamelen) != 0
+#else
+        (username = getlogin()) != NULL
+#endif
+        ) {
+        if (TIFFSetField(handle->tif, TIFFTAG_ARTIST, username) == 0) {
             errno = EPROTO;
             goto exit_error;
         }
@@ -1606,30 +1619,48 @@ tvips_write_tiff(const struct frame *frame, float K, float M, FILE *stream)
     /* The canonical name registered in DNS is in the first addrinfo
      * structure returned returned by getaddrinfo().  This is assumed
      * to be ASCII-encoded.  Unlike Linux, OpenBSD has an AI_FQDN flag
-     * as well.
+     * as well.  On Windows, GetComputerNameExA() may only return the
+     * FQDN if the host is configured to use DNS names.
      */
-    if (uname(&name) >= 0) {
+#ifdef _WIN32
+    GetComputerNameExA(
+        ComputerNamePhysicalDnsFullyQualified, NULL, &hostnamelen);
+    p = realloc(buf, hostnamelen * sizeof(TCHAR));
+    if (p == NULL)
+        goto exit_error;
+    buf = p;
+
+    if (GetComputerNameExA(
+            ComputerNamePhysicalDnsFullyQualified, buf, &hostnamelen) != 0) {
+        if (TIFFSetField(handle->tif, TIFFTAG_HOSTCOMPUTER, buf) == 0) {
+            errno = EPROTO;
+            goto exit_error;
+        }
+    }
+#else
+    if (uname(&hostname) >= 0) {
         memset(&hints, 0, sizeof(struct addrinfo));
         hints.ai_family = AF_UNSPEC;
         hints.ai_flags = AI_CANONNAME;
 
-        if (getaddrinfo(name.nodename, NULL, &hints, &res) == 0) {
+        if (getaddrinfo(hostname.nodename, NULL, &hints, &res) == 0) {
             if (TIFFSetField(handle->tif, TIFFTAG_HOSTCOMPUTER,
                              res->ai_canonname != NULL
                              ? res->ai_canonname
-                             : name.nodename) == 0) {
+                             : hostname.nodename) == 0) {
                 errno = EPROTO;
                 goto exit_error;
             }
             freeaddrinfo(res);
         } else {
             if (TIFFSetField(handle->tif, TIFFTAG_HOSTCOMPUTER,
-                             name.nodename) == 0) {
+                             hostname.nodename) == 0) {
                 errno = EPROTO;
                 goto exit_error;
             }
         }
     }
+#endif
 
 
     /* UTF-8 can generally not be represented as ASCII, which is the
