diff --git a/.gitattributes b/.gitattributes
index d37816a..4433bcf 100644
--- a/.gitattributes
+++ b/.gitattributes
@@ -1,4 +1,5 @@
 * text=auto !eol
+.coin-or/projDesc.xml -text
 /AUTHORS -text
 /AUTHORS.txt -text
 /CMakeLists.txt -text
diff --git a/AUTHORS b/AUTHORS
index 925e8e7..e9ad01c 100644
--- a/AUTHORS
+++ b/AUTHORS
@@ -62,6 +62,7 @@ bugs or proposing algorithmic improvements (in alphabetical order):
     Boris Houska
     D. Kwame Minde Kufoalor
     Aude Perrin
+    Silvio Traversaro
     Milan Vukov
     Thomas Wiese
     Leonard Wirsching
diff --git a/AUTHORS.txt b/AUTHORS.txt
index 3f44c0c..012529d 100644
--- a/AUTHORS.txt
+++ b/AUTHORS.txt
@@ -62,6 +62,7 @@ bugs or proposing algorithmic improvements (in alphabetical order):
     Boris Houska
     D. Kwame Minde Kufoalor
     Aude Perrin
+    Silvio Traversaro
     Milan Vukov
     Thomas Wiese
     Leonard Wirsching
diff --git a/CMakeLists.txt b/CMakeLists.txt
index adb111f..9ef6de7 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -54,14 +54,22 @@ IF( NOT CMAKE_BUILD_TYPE )
         )
 ENDIF( NOT CMAKE_BUILD_TYPE )
 
-
+option(BUILD_SHARED_LIBS "If ON, build shared library instead of static" OFF)
 option(QPOASES_BUILD_EXAMPLES "Build examples." ON)
+option(QPOASES_AVOID_LA_NAMING_CONFLICTS "If ON, avoid to re-defined symbols that conflict with Blas/Lapack provided functions." OFF)
 
+IF(BUILD_SHARED_LIBS AND WIN32)
+    MESSAGE(FATAL_ERROR "Compiling qpOASES as a shared library in Windows is not supported.")
+ENDIF()
 
 ############################################################
 #################### compiler flags ########################
 ############################################################
 SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -D__NO_COPYRIGHT__")
+IF(QPOASES_AVOID_LA_NAMING_CONFLICTS)
+  SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -D__AVOID_LA_NAMING_CONFLICTS__")
+ENDIF()
+
 IF ( UNIX )
     SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -pedantic -Wfloat-equal -Wshadow -DLINUX")
     SET(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_DEBUG} -O3 -finline-functions")
@@ -104,7 +112,7 @@ INCLUDE_DIRECTORIES(${PROJECT_SOURCE_DIR}/include)
 FILE(GLOB SRC src/*.cpp)
 
 # library
-ADD_LIBRARY(qpOASES STATIC ${SRC})
+ADD_LIBRARY(qpOASES ${SRC})
 INSTALL(TARGETS qpOASES
   LIBRARY DESTINATION lib
   ARCHIVE DESTINATION lib
diff --git a/Makefile b/Makefile
index 9d83ab8..2a87c1a 100644
--- a/Makefile
+++ b/Makefile
@@ -12,7 +12,7 @@
 ##
 ##	qpOASES is distributed in the hope that it will be useful,
 ##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 ##	See the GNU Lesser General Public License for more details.
 ##
 ##	You should have received a copy of the GNU Lesser General Public
@@ -40,16 +40,16 @@ all: src examples
 #src_aw testing
 
 src:
-	@cd $@; ${MAKE} -s 
+	@cd $@; ${MAKE} -s
 
 #src_aw:
-#	@cd $@; ${MAKE} -s 
+#	@cd $@; ${MAKE} -s
 
 examples: src
 	@cd $@; ${MAKE} -s
 
 doc:
-	@cd $@; ${MAKE} -s 
+	@cd $@; ${MAKE} -s
 
 testing: src
 	@cd testing/cpp; ${MAKE} -s
@@ -58,7 +58,7 @@ test: testing
 	@cd testing/cpp; ${MAKE} -s runTests
 
 debugging:
-	@cd $@; ${MAKE} -s 
+	@cd $@; ${MAKE} -s
 
 clean:
 	@cd src               && ${MAKE} -s clean
diff --git a/README b/README
index ab62901..cafbbc2 100644
--- a/README
+++ b/README
@@ -52,7 +52,7 @@ GETTING STARTED
 3. The whole software package can be obtained from 
 
        http://www.qpOASES.org/ or
-	   https://projects.coin-or.org/qpOASES/
+       https://github.com/coin-or/qpOASES/
 
    On this webpage you will also find further support such as a list of 
    questions posed by other users.
diff --git a/include/qpOASES/LapackBlasReplacement.hpp b/include/qpOASES/LapackBlasReplacement.hpp
index 529c3eb..2c34c58 100644
--- a/include/qpOASES/LapackBlasReplacement.hpp
+++ b/include/qpOASES/LapackBlasReplacement.hpp
@@ -1,145 +1,128 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2017 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/LapackBlasReplacement.hpp
- *	\author Andreas Potschka, Hans Joachim Ferreau, Christian Kirches
- *	\version 3.2
- *	\date 2009-2017
- *
- *  Declarations for external LAPACK/BLAS functions.
- */
-
-
-
-#ifndef QPOASES_LAPACKBLASREPLACEMENT_HPP
-#define QPOASES_LAPACKBLASREPLACEMENT_HPP
-
-
-#ifdef __USE_SINGLE_PRECISION__
-
-	/** Macro for calling level 3 BLAS operation in single precision. */
-	#define GEMM sgemm_
-	/** Macro for calling level 3 BLAS operation in single precision. */
-	#define SYR ssyr_
-	/** Macro for calling level 3 BLAS operation in single precision. */
-	#define SYR2 ssyr2_
-	/** Macro for calling level 3 BLAS operation in single precision. */
-	#define POTRF spotrf_
-
-	/** Macro for calling level 3 BLAS operation in single precision. */
-	/* #define GEQRF sgeqrf_ */
-	/** Macro for calling level 3 BLAS operation in single precision. */
-	/* #define ORMQR sormqr_ */
-	/** Macro for calling level 3 BLAS operation in single precision. */
-	#define TRTRS strtrs_
-	/** Macro for calling level 3 BLAS operation in single precision. */
-	#define TRCON strcon_
-
-#else
-
-	/** Macro for calling level 3 BLAS operation in double precision. */
-	#define GEMM dgemm_
-	/** Macro for calling level 3 BLAS operation in double precision. */
-	#define SYR  dsyr_
-	/** Macro for calling level 3 BLAS operation in double precision. */
-	#define SYR2 dsyr2_
-	/** Macro for calling level 3 BLAS operation in double precision. */
-	#define POTRF dpotrf_
-
-	/** Macro for calling level 3 BLAS operation in double precision. */
-	/* #define GEQRF dgeqrf_ */
-	/** Macro for calling level 3 BLAS operation in double precision. */
-	/* #define ORMQR dormqr_ */
-	/** Macro for calling level 3 BLAS operation in double precision. */
-	#define TRTRS dtrtrs_
-	/** Macro for calling level 3 BLAS operation in double precision. */
-	#define TRCON dtrcon_
-
-#endif /* __USE_SINGLE_PRECISION__ */
-
-
-extern "C"
-{
-	/** Performs one of the matrix-matrix operation in double precision. */
-	void dgemm_(	const char*, const char*, const la_uint_t*, const la_uint_t*, const la_uint_t*,
-					const double*, const double*, const la_uint_t*, const double*, const la_uint_t*,
-					const double*, double*, const la_uint_t* );
-	/** Performs one of the matrix-matrix operation in single precision. */
-	void sgemm_(	const char*, const char*, const la_uint_t*, const la_uint_t*, const la_uint_t*,
-					const float*, const float*, const la_uint_t*, const float*, const la_uint_t*,
-					const float*, float*, const la_uint_t* );
-
-	/** Performs a symmetric rank 1 operation in double precision. */
-	void dsyr_(		const char*, const la_uint_t*, const double*, const double*,
-					const la_uint_t*, double*, const la_uint_t* );
-	/** Performs a symmetric rank 1 operation in single precision. */
-	void ssyr_(		const char*, const la_uint_t*, const float*, const float*,
-					const la_uint_t*, float*, const la_uint_t* );
-
-	/** Performs a symmetric rank 2 operation in double precision. */
-	void dsyr2_(	const char*, const la_uint_t*, const double*, const double*,
-					const la_uint_t*, const double*, const la_uint_t*, double*, const la_uint_t*);
-	/** Performs a symmetric rank 2 operation in single precision. */
-	void ssyr2_(	const char*, const la_uint_t*, const float*, const float*,
-					const la_uint_t*, const float*, const la_uint_t*, float*, const la_uint_t*);
-
-	/** Calculates the Cholesky factorization of a real symmetric positive definite matrix in double precision. */
-	void dpotrf_(	const char*, const la_uint_t*, double*, const la_uint_t*, la_int_t* );
-	/** Calculates the Cholesky factorization of a real symmetric positive definite matrix in single precision. */
-	void spotrf_(	const char*, const la_uint_t*, float*, const la_uint_t*, la_int_t* );
-
-
-	/** Computes a QR factorization of a real M-by-N matrix A in double precision */
-	/* void dgeqrf_(	const la_uint_t* M, const la_uint_t* N, double* A, const la_uint_t* LDA,
-						double* TAU, double* WORK, const la_uint_t* LWORK, int *INFO );*/
-	/** Computes a QR factorization of a real M-by-N matrix A in single precision */
-	/* void sgeqrf_(	const la_uint_t* M, const la_uint_t* N, float* A, const la_uint_t* LDA,
-						float* TAU, float* WORK, const la_uint_t* LWORK, int *INFO );*/
-
-	/** Multiplies C with orthogonal matrix Q**T as returned by geqrf (double precision) */
-	/* void dormqr_(	const char* SIDE, const char* TRANS, const la_uint_t* M, const la_uint_t* N, const la_uint_t* K,
-						double* A, const la_uint_t* LDA, double* TAU, double* C, const la_uint_t* LDC,
-						double* WORK, const la_uint_t* LWORK, int *INFO );*/
-	/** Multiplies C with orthogonal matrix Q**T as returned by geqrf (single precision) */
-	/* void sormqr_(	const char* SIDE, const char* TRANS, const la_uint_t* M, const la_uint_t* N, const la_uint_t* K,
-						float* A, const la_uint_t* LDA, float* TAU, float* C, const la_uint_t* LDC,
-						float* WORK, const la_uint_t* LWORK, int *INFO );*/
-
-	/** Solves a triangular system (double precision) */
-	void dtrtrs_(	const char* UPLO, const char* TRANS, const char* DIAG, const la_uint_t* N, const la_uint_t* NRHS,
-					double* A, const la_uint_t* LDA, double* B, const la_uint_t* LDB, la_int_t* INFO );
-	/** Solves a triangular system (single precision) */
-	void strtrs_(	const char* UPLO, const char* TRANS, const char* DIAG, const la_uint_t* N, const la_uint_t* NRHS,
-					float* A, const la_uint_t* LDA, float* B, const la_uint_t* LDB, la_int_t* INFO );
-
-	/** Estimate the reciprocal of the condition number of a triangular matrix in double precision */
-	void dtrcon_(	const char* NORM, const char* UPLO, const char* DIAG, const la_uint_t* N, double* A, const la_uint_t* LDA,
-					double* RCOND, double* WORK, const la_uint_t* IWORK, la_int_t* INFO );
-	/** Estimate the reciprocal of the condition number of a triangular matrix in single precision */
-	void strcon_(	const char* NORM, const char* UPLO, const char* DIAG, const la_uint_t* N, float* A, const la_uint_t* LDA,
-					float* RCOND, float* WORK, const la_uint_t* IWORK, la_int_t* INFO );
-}
-
-#endif	/* QPOASES_LAPACKBLASREPLACEMENT_HPP */
+/*
+ *	This file is part of qpOASES.
+ *
+ *	qpOASES -- An Implementation of the Online Active Set Strategy.
+ *	Copyright (C) 2007-2017 by Hans Joachim Ferreau, Andreas Potschka,
+ *	Christian Kirches et al. All rights reserved.
+ *
+ *	qpOASES is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation; either
+ *	version 2.1 of the License, or (at your option) any later version.
+ *
+ *	qpOASES is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *	See the GNU Lesser General Public License for more details.
+ *
+ *	You should have received a copy of the GNU Lesser General Public
+ *	License along with qpOASES; if not, write to the Free Software
+ *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+
+/**
+ *	\file include/qpOASES/LapackBlasReplacement.hpp
+ *	\author Andreas Potschka, Hans Joachim Ferreau, Christian Kirches
+ *	\version 3.2
+ *	\date 2009-2017
+ *
+ *  Declarations for external LAPACK/BLAS functions.
+ */
+
+
+
+#ifndef QPOASES_LAPACKBLASREPLACEMENT_HPP
+#define QPOASES_LAPACKBLASREPLACEMENT_HPP
+
+
+#ifdef __AVOID_LA_NAMING_CONFLICTS__
+
+	#define SGEMM  qpOASES_sgemm
+	#define DGEMM  qpOASES_gemm
+	#define SPOTRF qpOASES_spotrf
+	#define DPOTRF qpOASES_dpotrf
+	#define STRTRS qpOASES_strtrs
+	#define DTRTRS qpOASES_dtrtrs
+	#define STRCON qpOASES_strcon
+	#define DTRCON qpOASES_dtrcon
+
+#else
+
+	#define SGEMM  sgemm_
+	#define DGEMM  dgemm_
+	#define SPOTRF spotrf_
+	#define DPOTRF dpotrf_
+	#define STRTRS strtrs_
+	#define DTRTRS dtrtrs_
+	#define STRCON strcon_
+	#define DTRCON dtrcon_
+
+#endif
+
+
+#ifdef __USE_SINGLE_PRECISION__
+
+	/** Macro for calling level 3 BLAS operation in single precision. */
+	#define GEMM  SGEMM
+	/** Macro for calling level 3 BLAS operation in single precision. */
+	#define POTRF SPOTRF
+
+	/** Macro for calling level 3 BLAS operation in single precision. */
+	#define TRTRS STRTRS
+	/** Macro for calling level 3 BLAS operation in single precision. */
+	#define TRCON strcon_
+
+#else
+
+	/** Macro for calling level 3 BLAS operation in double precision. */
+	#define GEMM  DGEMM
+	/** Macro for calling level 3 BLAS operation in double precision. */
+	#define POTRF DPOTRF
+
+	/** Macro for calling level 3 BLAS operation in double precision. */
+	#define TRTRS DTRTRS
+	/** Macro for calling level 3 BLAS operation in double precision. */
+	#define TRCON DTRCON
+
+#endif /* __USE_SINGLE_PRECISION__ */
+
+
+extern "C"
+{
+	/** Performs one of the matrix-matrix operation in double precision. */
+	void DGEMM(		const char*, const char*, const la_uint_t*, const la_uint_t*, const la_uint_t*,
+					const double*, const double*, const la_uint_t*, const double*, const la_uint_t*,
+					const double*, double*, const la_uint_t* );
+	/** Performs one of the matrix-matrix operation in single precision. */
+	void SGEMM(		const char*, const char*, const la_uint_t*, const la_uint_t*, const la_uint_t*,
+					const float*, const float*, const la_uint_t*, const float*, const la_uint_t*,
+					const float*, float*, const la_uint_t* );
+
+	/** Calculates the Cholesky factorization of a real symmetric positive definite matrix in double precision. */
+	void DPOTRF(	const char*, const la_uint_t*, double*, const la_uint_t*, la_int_t* );
+	/** Calculates the Cholesky factorization of a real symmetric positive definite matrix in single precision. */
+	void SPOTRF(	const char*, const la_uint_t*, float*, const la_uint_t*, la_int_t* );
+
+	/** Solves a triangular system (double precision) */
+	void DTRTRS(	const char* UPLO, const char* TRANS, const char* DIAG, const la_uint_t* N, const la_uint_t* NRHS,
+					double* A, const la_uint_t* LDA, double* B, const la_uint_t* LDB, la_int_t* INFO );
+	/** Solves a triangular system (single precision) */
+	void STRTRS(	const char* UPLO, const char* TRANS, const char* DIAG, const la_uint_t* N, const la_uint_t* NRHS,
+					float* A, const la_uint_t* LDA, float* B, const la_uint_t* LDB, la_int_t* INFO );
+
+	/** Estimate the reciprocal of the condition number of a triangular matrix in double precision */
+	void DTRCON(	const char* NORM, const char* UPLO, const char* DIAG, const la_uint_t* N, double* A, const la_uint_t* LDA,
+					double* RCOND, double* WORK, const la_uint_t* IWORK, la_int_t* INFO );
+	/** Estimate the reciprocal of the condition number of a triangular matrix in single precision */
+	void STRCON(	const char* NORM, const char* UPLO, const char* DIAG, const la_uint_t* N, float* A, const la_uint_t* LDA,
+					float* RCOND, float* WORK, const la_uint_t* IWORK, la_int_t* INFO );
+}
+
+#endif	/* QPOASES_LAPACKBLASREPLACEMENT_HPP */
+
+
+/*
+ *	end of file
+ */
diff --git a/include/qpOASES/SQProblemSchur.hpp b/include/qpOASES/SQProblemSchur.hpp
index 8408ef7..309e903 100644
--- a/include/qpOASES/SQProblemSchur.hpp
+++ b/include/qpOASES/SQProblemSchur.hpp
@@ -41,7 +41,6 @@
 
 #include <qpOASES/SQProblem.hpp>
 #include <qpOASES/SparseSolver.hpp>
-#include <qpOASES/LapackBlasReplacement.hpp>
 
 
 BEGIN_NAMESPACE_QPOASES
diff --git a/interfaces/c/Makefile b/interfaces/c/Makefile
index 1f4d188..f7774a1 100644
--- a/interfaces/c/Makefile
+++ b/interfaces/c/Makefile
@@ -57,6 +57,7 @@ QPOASES_WRAPPER_OBJECTS = \
 
 QPOASES_DEPENDS = \
 	${IDIR}/qpOASES.hpp \
+	${IDIR}/qpOASES/LapackBlasReplacement.hpp \
 	${IDIR}/qpOASES/SQProblem.hpp \
 	${IDIR}/qpOASES/QProblem.hpp \
 	${IDIR}/qpOASES/Flipper.hpp \
diff --git a/interfaces/matlab/make.m b/interfaces/matlab/make.m
index 0ff4274..37c02c2 100644
--- a/interfaces/matlab/make.m
+++ b/interfaces/matlab/make.m
@@ -65,7 +65,7 @@ function [] = make( varargin )
     %DEBUGFLAGS = ' -v -g CXXDEBUGFLAGS=''$CXXDEBUGFLAGS -Wall -pedantic -Wshadow'' ';
 
     IFLAGS = [ '-I. -I',QPOASESPATH,'include',' -I',QPOASESPATH,'src',' ' ];
-    CPPFLAGS = [ IFLAGS, DEBUGFLAGS, '-largeArrayDims -D__cpluplus -D__MATLAB__ -D__SINGLE_OBJECT__',' ' ];
+    CPPFLAGS = [ IFLAGS, DEBUGFLAGS, '-largeArrayDims -D__cpluplus -D__MATLAB__ -D__AVOID_LA_NAMING_CONFLICTS__ -D__SINGLE_OBJECT__',' ' ];
     defaultFlags = '-O -D__NO_COPYRIGHT__ '; %% -D__SUPPRESSANYOUTPUT__
 
     if ( ispc() == 0 )
diff --git a/interfaces/python/README.rst b/interfaces/python/README.rst
index 64911d9..2b17d11 100644
--- a/interfaces/python/README.rst
+++ b/interfaces/python/README.rst
@@ -2,11 +2,16 @@ pyqpOASES: a Python interface to qpOASES
 
 :Author: Sebastian F. Walter, Manuel Kudruss
 
+Known to work with
+------------------
+
+* python2.7
+* qpOASES 3.2 (rev 259)
+
 
 Installation
 ------------
 
-
 Requirements:
 
   You'll need numpy and cython. Install for instance with::
@@ -66,3 +71,5 @@ The Python interface is known to work on
 
 * Windows, Python 3
 * Linux (Ubuntu 12.04) using Python 2.7.3, Python 3.2.3. NumPy 1.8, Cython 0.19
+* MacOS Mojave (10.14.3) using Python 3.7 (anaconda suite)
+
diff --git a/interfaces/python/examples/example1.py b/interfaces/python/examples/example1.py
index 93e4b57..c1a7df4 100644
--- a/interfaces/python/examples/example1.py
+++ b/interfaces/python/examples/example1.py
@@ -52,25 +52,23 @@ ubA_new = np.array([1.0])
 
 example = QProblem(2, 1)
 options = Options()
-options.printLevel = PrintLevel.NONE
+#options.printLevel = PrintLevel.NONE
 example.setOptions(options)
 
 # Solve first QP.
 nWSR = np.array([10])
 example.init(H, g, A, lb, ub, lbA, ubA, nWSR)
 
+xOpt = np.zeros(2)
+example.getPrimalSolution(xOpt)
+print("\nxOpt = [ %e, %e ];  objVal = %e\n\n"%(xOpt[0],xOpt[1],example.getObjVal()))
 
 # Solve second QP.
 nWSR = np.array([10])
-
-for i in range(100000):
-    for j in range(1, 100):
-        g_new[0] = i%j
-    example.hotstart( g_new, lb_new, ub_new, lbA_new, ubA_new, nWSR)
+example.hotstart( g_new, lb_new, ub_new, lbA_new, ubA_new, nWSR)
 
 # Get and print solution of second QP.
 
-xOpt = np.zeros(2)
 example.getPrimalSolution(xOpt)
 print("\nxOpt = [ %e, %e ];  objVal = %e\n\n"%(xOpt[0],xOpt[1],example.getObjVal()))
 example.printOptions()
diff --git a/interfaces/python/examples/example2.py b/interfaces/python/examples/example2.py
index 9bfc9d0..748b7cb 100644
--- a/interfaces/python/examples/example2.py
+++ b/interfaces/python/examples/example2.py
@@ -23,6 +23,8 @@
 ## Example adapted from examples/example2.cpp.
 ## author of this file: Sebastian F. Walter
 
+import os
+import sys
 import numpy as np
 from qpoases import PySQProblem as SQProblem
 from qpoases import PySolutionAnalysis as SolutionAnalysis
diff --git a/interfaces/python/qpoases.pxd b/interfaces/python/qpoases.pxd
index 23a0cc2..9c92cfc 100644
--- a/interfaces/python/qpoases.pxd
+++ b/interfaces/python/qpoases.pxd
@@ -30,6 +30,9 @@
 cdef extern from "qpOASES.hpp" namespace "qpOASES":
 
     ctypedef double real_t
+    # NOTE we use long type for integers to be compatible with the C/C++
+    #      interface in all cases, i.e, either __USE_LONG_INTEGERS__ is defined
+    #      or not.
     ctypedef long int_t
 
     cdef enum BooleanType:
@@ -298,6 +301,15 @@ cdef extern from "qpOASES.hpp" namespace "qpOASES":
         int_t dropEqConPriority
         int_t dropIneqConPriority
 
+
+    cdef cppclass Bounds:
+        Bounds()
+
+
+    cdef cppclass Constraints:
+        Constraints()
+
+
     cdef cppclass QProblemB:
         QProblemB()
         QProblemB(int_t, HessianType, BooleanType)
@@ -411,6 +423,22 @@ cdef extern from "qpOASES.hpp" namespace "qpOASES":
                          int_t&,
                          real_t*)
 
+        returnValue init(real_t* _H,
+                         real_t* _g,
+                         real_t* _A,
+                         real_t* _lb,
+                         real_t* _ub,
+                         real_t* _lbA,
+                         real_t* _ubA,
+                         int_t& nWSR,
+                         real_t* cputime,
+                         real_t* xOpt,
+                         real_t* yOpt,
+                         Bounds* guessedBounds,
+                         Constraints* guessedConstraints,
+                         real_t* _R)
+
+
         returnValue hotstart(real_t*,
                              real_t*,
                              real_t*,
diff --git a/interfaces/python/qpoases.pyx b/interfaces/python/qpoases.pyx
index 7afdf56..113fe10 100644
--- a/interfaces/python/qpoases.pyx
+++ b/interfaces/python/qpoases.pyx
@@ -387,7 +387,8 @@ cdef class PyQProblemB:
     cdef QProblemB *thisptr      # hold a C++ instance which we're wrapping
     def __cinit__(self, long nV):
         # FIXME: allow other HessianTypes!
-        self.thisptr = new QProblemB(nV, HST_UNKNOWN, BT_TRUE)
+        self.thisptr = new QProblemB(<int_t> nV, HST_UNKNOWN, BT_TRUE)
+
     def __dealloc__(self):
         del self.thisptr
 
@@ -419,20 +420,20 @@ cdef class PyQProblemB:
                 cput_tmp = cputime
 
             return self.thisptr.init(
-                    <double*> H.data,
-                    <double*> g.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
+                    <real_t*> H.data,
+                    <real_t*> g.data,
+                    <real_t*> lb.data,
+                    <real_t*> ub.data,
                     <int_t&>  nWSR_tmp.data[0],
-                    <double*> &cput_tmp.data[0]
+                    <real_t*> &cput_tmp.data[0]
                     )
 
         return self.thisptr.init(
-                    <double*> H.data,
-                    <double*> g.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <int_t&>  nWSR_tmp.data[0]
+                    <real_t*> H.data,
+                    <real_t*> g.data,
+                    <real_t*> lb.data,
+                    <real_t*> ub.data,
+                    <int_t&> nWSR_tmp.data[0]
                     )
 
     def hotstart(self,
@@ -462,25 +463,25 @@ cdef class PyQProblemB:
                 cput_tmp = cputime#np.asarray(cputime, dtype=float)
 
             return self.thisptr.hotstart(
-                    <double*> g.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
+                    <real_t*> g.data,
+                    <real_t*> lb.data,
+                    <real_t*> ub.data,
                     <int_t&>  nWSR_tmp.data[0],
-                    <double*> &cput_tmp.data[0]
+                    <real_t*> &cput_tmp.data[0]
                 )
 
         return self.thisptr.hotstart(
-                    <double*> g.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <int_t&>  nWSR_tmp.data[0]
+                    <real_t*> g.data,
+                    <real_t*> lb.data,
+                    <real_t*> ub.data,
+                    <int_t&>    nWSR_tmp.data[0]
             )
 
     def getPrimalSolution(self, np.ndarray[np.double_t, ndim=1] xOpt):
-        return self.thisptr.getPrimalSolution(<double*> xOpt.data)
+        return self.thisptr.getPrimalSolution(<real_t*> xOpt.data)
 
     def getDualSolution(self, np.ndarray[np.double_t, ndim=1] yOpt):
-        return self.thisptr.getDualSolution(<double*> yOpt.data)
+        return self.thisptr.getDualSolution(<real_t*> yOpt.data)
 
     def getObjVal(self):
         return self.thisptr.getObjVal()
@@ -501,8 +502,10 @@ cdef class PyQProblemB:
 
 cdef class PyQProblem:
     cdef QProblem *thisptr      # hold a C++ instance which we're wrapping
+
     def __cinit__(self, long nV, long nC):
         self.thisptr = new QProblem(nV, nC, HST_UNKNOWN, BT_TRUE)
+
     def __dealloc__(self):
         del self.thisptr
 
@@ -537,25 +540,25 @@ cdef class PyQProblem:
                 cput_tmp = cputime
 
             return self.thisptr.init(
-                    <double*> H.data,
-                    <double*> g.data,
-                    <double*> A.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <double*> lbA.data,
-                    <double*> ubA.data,
+                    <real_t*> H.data,
+                    <real_t*> g.data,
+                    <real_t*> A.data,
+                    <real_t*> lb.data,
+                    <real_t*> ub.data,
+                    <real_t*> lbA.data,
+                    <real_t*> ubA.data,
                     <int_t&>  nWSR_tmp.data[0],
-                    <double*> &cput_tmp.data[0]
+                    <real_t*> &cput_tmp.data[0]
                 )
 
         return self.thisptr.init(
-                    <double*> H.data,
-                    <double*> g.data,
-                    <double*> A.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <double*> lbA.data,
-                    <double*> ubA.data,
+                    <real_t*> H.data,
+                    <real_t*> g.data,
+                    <real_t*> A.data,
+                    <real_t*> lb.data,
+                    <real_t*> ub.data,
+                    <real_t*> lbA.data,
+                    <real_t*> ubA.data,
                     <int_t&>  nWSR_tmp.data[0]
                 )
 
@@ -568,7 +571,6 @@ cdef class PyQProblem:
              nWSR,
              cputime=0.0
         ):
-
         # FIXME: add asserts
         cdef np.ndarray nWSR_tmp
         cdef np.ndarray cput_tmp
@@ -589,29 +591,29 @@ cdef class PyQProblem:
                 cput_tmp = cputime
 
             return self.thisptr.hotstart(
-                    <double*> g.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <double*> lbA.data,
-                    <double*> ubA.data,
+                    <real_t*> g.data,
+                    <real_t*> lb.data,
+                    <real_t*> ub.data,
+                    <real_t*> lbA.data,
+                    <real_t*> ubA.data,
                     <int_t&>  nWSR_tmp.data[0],
-                    <double*> &cput_tmp.data[0]
+                    <real_t*> &cput_tmp.data[0]
                 )
 
         return self.thisptr.hotstart(
-                    <double*> g.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <double*> lbA.data,
-                    <double*> ubA.data,
+                    <real_t*> g.data,
+                    <real_t*> lb.data,
+                    <real_t*> ub.data,
+                    <real_t*> lbA.data,
+                    <real_t*> ubA.data,
                     <int_t&>  nWSR_tmp.data[0]
                 )
 
     cpdef getPrimalSolution(self, np.ndarray[np.double_t, ndim=1] xOpt):
-        return self.thisptr.getPrimalSolution(<double*> xOpt.data)
+        return self.thisptr.getPrimalSolution(<real_t*> xOpt.data)
 
     cpdef getDualSolution(self, np.ndarray[np.double_t, ndim=1] yOpt):
-        return self.thisptr.getDualSolution(<double*> yOpt.data)
+        return self.thisptr.getDualSolution(<real_t*> yOpt.data)
 
     cpdef getObjVal(self):
         return self.thisptr.getObjVal()
@@ -622,10 +624,13 @@ cdef class PyQProblem:
     cpdef setOptions(self, PyOptions options):
         self.thisptr.setOptions(deref(options.thisptr))
 
+
 cdef class PySQProblem:
     cdef SQProblem *thisptr      # hold a C++ instance which we're wrapping
+
     def __cinit__(self, long nV, long nC):
         self.thisptr = new SQProblem(nV, nC, HST_UNKNOWN, BT_TRUE)
+
     def __dealloc__(self):
         del self.thisptr
 
@@ -638,11 +643,13 @@ cdef class PySQProblem:
              np.ndarray[np.double_t, ndim=1] lbA,
              np.ndarray[np.double_t, ndim=1] ubA,
              nWSR,
-             cputime=0.0):
-
+             cputime=0.0
+    ):
         # FIXME: add asserts
-        cdef np.ndarray nWSR_tmp
-        cdef np.ndarray cput_tmp
+        cpdef np.ndarray nWSR_tmp
+        cpdef np.ndarray cput_tmp
+        # nWSR_tmp = np.zeros(1, dtype=long)
+        # cput_tmp = np.zeros(1, dtype=float)
 
         # enable nWSR as return value in argument list
         if isinstance(nWSR, long) or isinstance(nWSR, int):
@@ -658,29 +665,30 @@ cdef class PySQProblem:
                 cput_tmp = np.array([cputime], dtype=float)
             else:
                 cput_tmp = cputime
+            # print "cput_tmp: ", cput_tmp
 
             return self.thisptr.init(
-                        <double*> H.data,
-                        <double*> g.data,
-                        <double*> A.data,
-                        <double*> lb.data,
-                        <double*> ub.data,
-                        <double*> lbA.data,
-                        <double*> ubA.data,
+                        <real_t*> H.data,
+                        <real_t*> g.data,
+                        <real_t*> A.data,
+                        <real_t*> lb.data,
+                        <real_t*> ub.data,
+                        <real_t*> lbA.data,
+                        <real_t*> ubA.data,
                         <int_t&>  nWSR_tmp.data[0],
-                        <double*> &cput_tmp.data[0]
+                        <real_t*> &cput_tmp.data[0]
                 )
 
         return self.thisptr.init(
-                    <double*> H.data,
-                    <double*> g.data,
-                    <double*> A.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <double*> lbA.data,
-                    <double*> ubA.data,
+                    <real_t*> H.data,
+                    <real_t*> g.data,
+                    <real_t*> A.data,
+                    <real_t*> lb.data,
+                    <real_t*> ub.data,
+                    <real_t*> lbA.data,
+                    <real_t*> ubA.data,
                     <int_t&>  nWSR_tmp.data[0],
-        )
+                )
 
     cpdef hotstart(self,
              np.ndarray[np.double_t, ndim=2] H,
@@ -713,33 +721,33 @@ cdef class PySQProblem:
                 cput_tmp = cputime
 
             return self.thisptr.hotstart(
-                    <double*> H.data,
-                    <double*> g.data,
-                    <double*> A.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <double*> lbA.data,
-                    <double*> ubA.data,
+                    <real_t*> H.data,
+                    <real_t*> g.data,
+                    <real_t*> A.data,
+                    <real_t*> lb.data,
+                    <real_t*> ub.data,
+                    <real_t*> lbA.data,
+                    <real_t*> ubA.data,
                     <int_t&>  nWSR_tmp.data[0],
-                    <double*> &cput_tmp.data[0]
+                    <real_t*> &cput_tmp.data[0]
             )
 
         return self.thisptr.hotstart(
-                    <double*> H.data,
-                    <double*> g.data,
-                    <double*> A.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <double*> lbA.data,
-                    <double*> ubA.data,
+                    <real_t*> H.data,
+                    <real_t*> g.data,
+                    <real_t*> A.data,
+                    <real_t*> lb.data,
+                    <real_t*> ub.data,
+                    <real_t*> lbA.data,
+                    <real_t*> ubA.data,
                     <int_t&>  nWSR_tmp.data[0],
         )
 
     cpdef getPrimalSolution(self, np.ndarray[np.double_t, ndim=1] xOpt):
-        return self.thisptr.getPrimalSolution(<double*> xOpt.data)
+        return self.thisptr.getPrimalSolution(<real_t*> xOpt.data)
 
     cpdef getDualSolution(self, np.ndarray[np.double_t, ndim=1] yOpt):
-        return self.thisptr.getDualSolution(<double*> yOpt.data)
+        return self.thisptr.getDualSolution(<real_t*> yOpt.data)
 
     cpdef getObjVal(self):
         return self.thisptr.getObjVal()
@@ -838,24 +846,24 @@ cdef class PySolutionAnalysis:
                               np.ndarray[np.double_t, ndim=1] g_b_bA_VAR,
                               np.ndarray[np.double_t, ndim=1] Primal_Dual_VAR ):
         return self.thisptr.getVarianceCovariance(qp.thisptr,
-                                                  <double*> g_b_bA_VAR.data,
-                                                  <double*> Primal_Dual_VAR.data)
+                                                  <real_t*> g_b_bA_VAR.data,
+                                                  <real_t*> Primal_Dual_VAR.data)
 
     cpdef _getVarianceCovariance_QProblem(self,
                               PyQProblem qp,
                               np.ndarray[np.double_t, ndim=1] g_b_bA_VAR,
                               np.ndarray[np.double_t, ndim=1] Primal_Dual_VAR ):
         return self.thisptr.getVarianceCovariance(qp.thisptr,
-                                                  <double*> g_b_bA_VAR.data,
-                                                  <double*> Primal_Dual_VAR.data)
+                                                  <real_t*> g_b_bA_VAR.data,
+                                                  <real_t*> Primal_Dual_VAR.data)
 
     cpdef _getVarianceCovariance_SQProblem(self,
                               PySQProblem qp,
                               np.ndarray[np.double_t, ndim=1] g_b_bA_VAR,
                               np.ndarray[np.double_t, ndim=1] Primal_Dual_VAR ):
         return self.thisptr.getVarianceCovariance(qp.thisptr,
-                                                  <double*> g_b_bA_VAR.data,
-                                                  <double*> Primal_Dual_VAR.data)
+                                                  <real_t*> g_b_bA_VAR.data,
+                                                  <real_t*> Primal_Dual_VAR.data)
 
 # Wrapped some utility functions for unit testing
 cpdef py_runOqpBenchmark(path,               # Full path of the benchmark files (without trailing slash!).
@@ -874,25 +882,6 @@ cpdef py_runOqpBenchmark(path,               # Full path of the benchmark files
     maxFeasibility     = 0.0 # Output: Maximum residual of primal feasibility condition.
     maxComplementarity = 0.0 # Output: Maximum residual of complementarity condition.
 
-    maxCPUtime = maxCPUTime
-
-    p = path.encode()
-    returnValue = runOqpBenchmark(p,
-                                  isSparse,
-                                  useHotstarts,
-                                  deref(options.thisptr),
-                                  maxAllowedNWSR,
-                                  maxNWSR,
-                                  avgNWSR,
-                                  maxCPUtime,
-                                  avgCPUtime,
-                                  maxStationarity,
-                                  maxFeasibility,
-                                  maxComplementarity)
-
-    return returnValue, maxNWSR, avgNWSR, maxCPUtime, avgCPUtime, \
-           maxStationarity, maxFeasibility, maxComplementarity
-
 """
 def py_getKktViolation(long nV,                             # Number of variables.
                        long nC,                             # Number of constraints.
@@ -911,19 +900,19 @@ def py_getKktViolation(long nV,                             # Number of variable
     cmpl = 0.0 # Maximum value of complementarity residual.
     getKktViolation(nV,
                     nC,
-                    <double*> H.data,
-                    <double*> g.data,
-                    <double*> A.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <double*> lbA.data,
-                    <double*> ubA.data,
-                    <double*> x.data,
-                    <double*> y.data,
+                    <real_t*> H.data,
+                    <real_t*> g.data,
+                    <real_t*> A.data,
+                    <real_t*> lb.data,
+                    <real_t*> ub.data,
+                    <real_t*> lbA.data,
+                    <real_t*> ubA.data,
+                    <real_t*> x.data,
+                    <real_t*> y.data,
                     stat,
                     feas,
                     cmpl
                     )
     return stat, feas, cmpl
-    """
+"""
 
diff --git a/interfaces/python/setup.py b/interfaces/python/setup.py
index 017c248..913f8da 100755
--- a/interfaces/python/setup.py
+++ b/interfaces/python/setup.py
@@ -34,7 +34,7 @@ import os
 import numpy as np
 import platform
 
-from=20distutils.core import setup
+from distutils.core import setup
 from distutils.extension import Extension
 from Cython.Distutils import build_ext
 from Cython.Build import cythonize
@@ -59,10 +59,40 @@ extra_params['library_dirs'] = ['/usr/lib', os.path.join(BASEDIR, 'bin')]
 extra_params['language'] = 'c++'
 
 if platform.system() in ['Linux', 'Darwin']:
-    extra_params['extra_compile_args'] = ['-D__USE_LONG_INTEGERS__', '-D__USE_LONG_INTS__']
+    extra_params['extra_compile_args'] = ['-D__USE_LONG_INTEGERS__',
+            '-D__USE_LONG_FINTS__']
+
+if platform.system() == 'Darwin':
+    extra_params['include_dirs'].append(
+            '/Library/Developer/CommandLineTools/usr/include/c++/v1')
+    extra_params['extra_compile_args'] += ['-stdlib=libc++',
+        '-Wno-c++11-long-long']
+    extra_params['extra_link_args'] = ['-stdlib=libc++'] # override the others!
 
 if os.name == 'posix':
     extra_params['runtime_library_dirs'] = extra_params['library_dirs']
+    # NOTE the python wrapper compiles the interface from the header files
+    #      and therefore requires access to all defines made.
+    #      Therefore, we provide the CPPFLAGS from the make_linux.mk file
+    #      directly to the compile process by extra_compile_args.
+    # NOTE not all FLAGS can be added automatically, e.g. DEF_SOLVER.
+    #      Please fix this yourself in case of problems.
+    # TODO maybe add automatic make file parsing and choose from those options
+    extra_params['extra_compile_args'] += [
+        "-Wall",
+        "-pedantic",
+        "-Wshadow",
+        "-Wfloat-equal",
+        "-O3",
+        "-Wconversion",
+        "-Wsign-conversion",
+        "-finline-functions",
+        "-fPIC",
+        "-DLINUX",
+        "-D__USE_LONG_INTEGERS__",
+        "-D__USE_LONG_FINTS__",
+        "-D__NO_COPYRIGHT__",
+    ]
 
 ext_modules = [
     Extension("qpoases",  ["qpoases.pyx", "qpoases.pxd"],   **extra_params),
diff --git a/interfaces/simulink/qpOASES_QProblem.cpp b/interfaces/simulink/qpOASES_QProblem.cpp
index c294d44..1defe13 100644
--- a/interfaces/simulink/qpOASES_QProblem.cpp
+++ b/interfaces/simulink/qpOASES_QProblem.cpp
@@ -62,6 +62,7 @@ extern "C" {
 
 static void mdlInitializeSizes (SimStruct *S)   /* Init sizes array */
 {
+	int ii;
 	int nU = NCONTROLINPUTS;
 
 	/* Specify the number of continuous and discrete states */
@@ -95,11 +96,11 @@ static void mdlInitializeSizes (SimStruct *S)   /* Init sizes array */
 	ssSetOutputPortVectorDimension(S, 3, 1 );   /* iter */
 
 	/* Specify the direct feedthrough status */
-	ssSetInputPortDirectFeedThrough(S, 0, 1);
-	ssSetInputPortDirectFeedThrough(S, 1, 1);
-	ssSetInputPortDirectFeedThrough(S, 2, 1);
-	ssSetInputPortDirectFeedThrough(S, 3, 1);
-	ssSetInputPortDirectFeedThrough(S, 4, 1);
+	for( ii=0; ii<5; ++ii ) 
+	{
+		ssSetInputPortDirectFeedThrough(S, ii, 1);
+		//ssSetInputPortRequiredContiguous(S, ii, 1);
+	}
 
 	/* One sample time */
 	ssSetNumSampleTimes(S, 1);
@@ -340,7 +341,7 @@ static void mdlOutputs(SimStruct *S, int_T tid)
 {
 	USING_NAMESPACE_QPOASES
 
-	int i;
+	int ii;
 	int nV, nC;
 	returnValue status;
 
@@ -386,37 +387,37 @@ static void mdlOutputs(SimStruct *S, int_T tid)
 	if ( H != 0 )
 	{
 		/* no conversion from FORTRAN to C as Hessian is symmetric! */
-		for ( i=0; i<nV*nV; ++i )
-			H[i] = (mxGetPr(in_H))[i];
+		for ( ii=0; ii<nV*nV; ++ii )
+			H[ii] = (mxGetPr(in_H))[ii];
 	}
 
 	convertFortranToC( mxGetPr(in_A),nV,nC, A );
 
-	for ( i=0; i<nV; ++i )
-		g[i] = (*in_g)[i];
+	for ( ii=0; ii<nV; ++ii )
+		g[ii] = (*in_g)[ii];
 
 	if ( lb != 0 )
 	{
-		for ( i=0; i<nV; ++i )
-			lb[i] = (*in_lb)[i];
+		for ( ii=0; ii<nV; ++ii )
+			lb[ii] = (*in_lb)[ii];
 	}
 
 	if ( ub != 0 )
 	{
-		for ( i=0; i<nV; ++i )
-			ub[i] = (*in_ub)[i];
+		for ( ii=0; ii<nV; ++ii )
+			ub[ii] = (*in_ub)[ii];
 	}
 
 	if ( lbA != 0 )
 	{
-		for ( i=0; i<nC; ++i )
-			lbA[i] = (*in_lbA)[i];
+		for ( ii=0; ii<nC; ++ii )
+			lbA[ii] = (*in_lbA)[ii];
 	}
 
 	if ( ubA != 0 )
 	{
-		for ( i=0; i<nC; ++i )
-			ubA[i] = (*in_ubA)[i];
+		for ( ii=0; ii<nC; ++ii )
+			ubA[ii] = (*in_ubA)[ii];
 	}
 
 	xOpt = new real_t[nV];
@@ -453,8 +454,8 @@ static void mdlOutputs(SimStruct *S, int_T tid)
 	out_status = ssGetOutputPortRealSignal(S, 2);
 	out_nWSR   = ssGetOutputPortRealSignal(S, 3);
 
-	for ( i=0; i<nU; ++i )
-		out_uOpt[i] = (real_T)(xOpt[i]);
+	for ( ii=0; ii<nU; ++ii )
+		out_uOpt[ii] = (real_T)(xOpt[ii]);
 
 	out_objVal[0] = (real_T)(problem->getObjVal());
 	out_status[0] = (real_t)(getSimpleStatus( status ));
@@ -473,7 +474,7 @@ static void mdlTerminate(SimStruct *S)
 {
 	USING_NAMESPACE_QPOASES
 
-	int i;
+	int ii;
 	
 	/* reset global message handler */
 	getGlobalMessageHandler( )->reset( );
@@ -481,10 +482,10 @@ static void mdlTerminate(SimStruct *S)
 	if ( ssGetPWork(S)[0] != 0 )
 		delete ((QProblem*)(ssGetPWork(S)[0]));
 
-	for ( i=1; i<8; ++i )
+	for ( ii=1; ii<8; ++ii )
 	{
-		if ( ssGetPWork(S)[i] != 0 )
-			free( ssGetPWork(S)[i] );
+		if ( ssGetPWork(S)[ii] != 0 )
+			free( ssGetPWork(S)[ii] );
 	}
 }
 
diff --git a/interfaces/simulink/qpOASES_QProblemB.cpp b/interfaces/simulink/qpOASES_QProblemB.cpp
index 2d46440..8a0c401 100644
--- a/interfaces/simulink/qpOASES_QProblemB.cpp
+++ b/interfaces/simulink/qpOASES_QProblemB.cpp
@@ -62,6 +62,7 @@ extern "C" {
 
 static void mdlInitializeSizes (SimStruct *S)   /* Init sizes array */
 {
+	int ii;
 	int nU = NCONTROLINPUTS;
 
 	/* Specify the number of continuous and discrete states */
@@ -93,9 +94,11 @@ static void mdlInitializeSizes (SimStruct *S)   /* Init sizes array */
 	ssSetOutputPortVectorDimension(S, 3, 1 );   /* iter */
 
 	/* Specify the direct feedthrough status */
-	ssSetInputPortDirectFeedThrough(S, 0, 1);
-	ssSetInputPortDirectFeedThrough(S, 1, 1);
-	ssSetInputPortDirectFeedThrough(S, 2, 1);
+	for( ii=0; ii<3; ++ii ) 
+	{
+		ssSetInputPortDirectFeedThrough(S, ii, 1);
+		//ssSetInputPortRequiredContiguous(S, ii, 1);
+	}
 
 	/* One sample time */
 	ssSetNumSampleTimes(S, 1);
@@ -288,7 +291,7 @@ static void mdlOutputs(SimStruct *S, int_T tid)
 {
 	USING_NAMESPACE_QPOASES
 
-	int i;
+	int ii;
 	int nV;
 	returnValue status;
 
@@ -326,23 +329,23 @@ static void mdlOutputs(SimStruct *S, int_T tid)
 	if ( H != 0 )
 	{
 		/* no conversion from FORTRAN to C as Hessian is symmetric! */
-		for ( i=0; i<nV*nV; ++i )
-			H[i] = (mxGetPr(in_H))[i];
+		for ( ii=0; ii<nV*nV; ++ii )
+			H[ii] = (mxGetPr(in_H))[ii];
 	}
 
-	for ( i=0; i<nV; ++i )
-		g[i] = (*in_g)[i];
+	for ( ii=0; ii<nV; ++ii )
+		g[ii] = (*in_g)[ii];
 
 	if ( lb != 0 )
 	{
-		for ( i=0; i<nV; ++i )
-			lb[i] = (*in_lb)[i];
+		for ( ii=0; ii<nV; ++ii )
+			lb[ii] = (*in_lb)[ii];
 	}
 
 	if ( ub != 0 )
 	{
-		for ( i=0; i<nV; ++i )
-			ub[i] = (*in_ub)[i];
+		for ( ii=0; ii<nV; ++ii )
+			ub[ii] = (*in_ub)[ii];
 	}
 
 	xOpt = new real_t[nV];
@@ -378,8 +381,8 @@ static void mdlOutputs(SimStruct *S, int_T tid)
 	out_status = ssGetOutputPortRealSignal(S, 2);
 	out_nWSR   = ssGetOutputPortRealSignal(S, 3);
 
-	for ( i=0; i<nU; ++i )
-		out_uOpt[i] = (real_T)(xOpt[i]);
+	for ( ii=0; ii<nU; ++ii )
+		out_uOpt[ii] = (real_T)(xOpt[ii]);
     
     out_objVal[0] = (real_T)(problem->getObjVal());
 	out_status[0] = (real_t)(getSimpleStatus( status ));
@@ -398,7 +401,7 @@ static void mdlTerminate(SimStruct *S)
 {
 	USING_NAMESPACE_QPOASES
 
-	int i;
+	int ii;
 
 	/* reset global message handler */
 	getGlobalMessageHandler( )->reset( );
@@ -406,10 +409,10 @@ static void mdlTerminate(SimStruct *S)
 	if ( ssGetPWork(S)[0] != 0 )
 		delete ((QProblemB*)(ssGetPWork(S)[0]));
 
-	for ( i=1; i<5; ++i )
+	for ( ii=1; ii<5; ++ii )
 	{
-		if ( ssGetPWork(S)[i] != 0 )
-			free( ssGetPWork(S)[i] );
+		if ( ssGetPWork(S)[ii] != 0 )
+			free( ssGetPWork(S)[ii] );
 	}
 }
 
diff --git a/interfaces/simulink/qpOASES_SQProblem.cpp b/interfaces/simulink/qpOASES_SQProblem.cpp
index 559ed7b..8f1fd95 100644
--- a/interfaces/simulink/qpOASES_SQProblem.cpp
+++ b/interfaces/simulink/qpOASES_SQProblem.cpp
@@ -62,6 +62,7 @@ extern "C" {
 
 static void mdlInitializeSizes (SimStruct *S)   /* Init sizes array */
 {
+	int ii;
 	int nU = NCONTROLINPUTS;
 
 	/* Specify the number of continuous and discrete states */
@@ -107,13 +108,11 @@ static void mdlInitializeSizes (SimStruct *S)   /* Init sizes array */
 	ssSetOutputPortVectorDimension(S, 3, 1 );   /* iter */
 
 	/* Specify the direct feedthrough status */
-	ssSetInputPortDirectFeedThrough(S, 0, 1);
-	ssSetInputPortDirectFeedThrough(S, 1, 1);
-	ssSetInputPortDirectFeedThrough(S, 2, 1);
-	ssSetInputPortDirectFeedThrough(S, 3, 1);
-	ssSetInputPortDirectFeedThrough(S, 4, 1);
-	ssSetInputPortDirectFeedThrough(S, 5, 1);
-	ssSetInputPortDirectFeedThrough(S, 6, 1);
+	for( ii=0; ii<7; ++ii ) 
+	{
+		ssSetInputPortDirectFeedThrough(S, ii, 1);
+		//ssSetInputPortRequiredContiguous(S, ii, 1);
+	}
 
 	/* One sample time */
 	ssSetNumSampleTimes(S, 1);
@@ -310,7 +309,7 @@ static void mdlOutputs(SimStruct *S, int_T tid)
 {
 	USING_NAMESPACE_QPOASES
 
-	int i;
+	int ii;
 	int nV, nC;
 	returnValue status;
 
@@ -356,37 +355,37 @@ static void mdlOutputs(SimStruct *S, int_T tid)
 	if ( H != 0 )
 	{
 		/* no conversion from FORTRAN to C as Hessian is symmetric! */
-		for ( i=0; i<nV*nV; ++i )
-			H[i] = (*in_H)[i];
+		for ( ii=0; ii<nV*nV; ++ii )
+			H[ii] = (*in_H)[ii];
 	}
 
 	convertFortranToC( *in_A,nV,nC, A );
 
-	for ( i=0; i<nV; ++i )
-		g[i] = (*in_g)[i];
+	for ( ii=0; ii<nV; ++ii )
+		g[ii] = (*in_g)[ii];
 
 	if ( lb != 0 )
 	{
-		for ( i=0; i<nV; ++i )
-			lb[i] = (*in_lb)[i];
+		for ( ii=0; ii<nV; ++ii )
+			lb[ii] = (*in_lb)[ii];
 	}
 
 	if ( ub != 0 )
 	{
-		for ( i=0; i<nV; ++i )
-			ub[i] = (*in_ub)[i];
+		for ( ii=0; ii<nV; ++ii )
+			ub[ii] = (*in_ub)[ii];
 	}
 
 	if ( lbA != 0 )
 	{
-		for ( i=0; i<nC; ++i )
-			lbA[i] = (*in_lbA)[i];
+		for ( ii=0; ii<nC; ++ii )
+			lbA[ii] = (*in_lbA)[ii];
 	}
 
 	if ( ubA != 0 )
 	{
-		for ( i=0; i<nC; ++i )
-			ubA[i] = (*in_ubA)[i];
+		for ( ii=0; ii<nC; ++ii )
+			ubA[ii] = (*in_ubA)[ii];
 	}
 
 	xOpt = new real_t[nV];
@@ -422,8 +421,8 @@ static void mdlOutputs(SimStruct *S, int_T tid)
 	out_status = ssGetOutputPortRealSignal(S, 2);
 	out_nWSR   = ssGetOutputPortRealSignal(S, 3);
 
-	for ( i=0; i<nU; ++i )
-		out_uOpt[i] = (real_T)(xOpt[i]);
+	for ( ii=0; ii<nU; ++ii )
+		out_uOpt[ii] = (real_T)(xOpt[ii]);
 
 	out_objVal[0] = (real_T)(problem->getObjVal( ));
 	out_status[0] = (real_t)(getSimpleStatus( status ));
@@ -442,7 +441,7 @@ static void mdlTerminate(SimStruct *S)
 {
 	USING_NAMESPACE_QPOASES
 
-	int i;
+	int ii;
 
 	/* reset global message handler */
 	getGlobalMessageHandler( )->reset( );
@@ -450,10 +449,10 @@ static void mdlTerminate(SimStruct *S)
 	if ( ssGetPWork(S)[0] != 0 )
 		delete ((SQProblem*)(ssGetPWork(S)[0]));
 
-	for ( i=1; i<8; ++i )
+	for ( ii=1; ii<8; ++ii )
 	{
-		if ( ssGetPWork(S)[i] != 0 )
-			free( ssGetPWork(S)[i] );
+		if ( ssGetPWork(S)[ii] != 0 )
+			free( ssGetPWork(S)[ii] );
 	}
 }
 
diff --git a/make_linux.mk b/make_linux.mk
index 17ce467..a15b52e 100644
--- a/make_linux.mk
+++ b/make_linux.mk
@@ -106,7 +106,6 @@ else
 endif
 
 
-
 CPPFLAGS = -Wall -pedantic -Wshadow -Wfloat-equal -O3 -Wconversion -Wsign-conversion -fPIC -DLINUX -D__USE_LONG_INTEGERS__ -D__USE_LONG_FINTS__ -D${DEF_SOLVER} -D__NO_COPYRIGHT__
 #          -g -D__DEBUG__ -D__NO_COPYRIGHT__ -D__SUPPRESSANYOUTPUT__ -D__USE_SINGLE_PRECISION__
 
diff --git a/make_osx.mk b/make_osx.mk
index 87fd9c4..cca2505 100644
--- a/make_osx.mk
+++ b/make_osx.mk
@@ -38,7 +38,7 @@ SRCDIR = ${TOP}/src
 BINDIR = ${TOP}/bin
 
 # MacOSX SDK
-SYSROOT = /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk
+SYSROOT = /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk
 SDK = -isysroot ${SYSROOT} -stdlib=libc++
 
 # Matlab include directory (ADAPT TO YOUR LOCAL SETTINGS!)
@@ -46,7 +46,7 @@ MATLAB_IDIR   = /Applications/MATLAB_R2013a.app/extern/include/
 MATLAB_LIBDIR =
 
 # system or replacement BLAS/LAPACK
-REPLACE_LINALG = 1
+REPLACE_LINALG = 0
 
 ifeq ($(REPLACE_LINALG), 1)
 	LIB_BLAS =   ${SRCDIR}/BLASReplacement.o
@@ -91,7 +91,7 @@ DLLEXT = dylib
 EXE =
 MEXOCTEXT = mex
 DEF_TARGET = -o $@
-SHARED = -dynamiclib ${SDK} -lgcc_s.10.5 -ldylib1.o
+SHARED = -dynamiclib ${SDK}
 
 # 32 or 64 depending on target platform
 BITS = $(shell getconf LONG_BIT)
@@ -103,7 +103,7 @@ else
 	MEXEXT = mexa64
 endif
 
-CPPFLAGS = ${SDK} -Wall -pedantic -Wshadow -Wfloat-equal -Wconversion -Wsign-conversion -O3 -fPIC -DLINUX
+CPPFLAGS = ${SDK} -Wall -pedantic -Wshadow -Wfloat-equal -Wconversion -Wsign-conversion -O3 -fPIC -D__USE_LONG_INTEGERS__ -D__USE_LONG_FINTS__ -D__NO_COPYRIGHT__
 #          -g -D__DEBUG__ -D__NO_COPYRIGHT__ -D__SUPPRESSANYOUTPUT__ -D__USE_SINGLE_PRECISION__
 
 # libraries to link against when building qpOASES .so files
@@ -111,7 +111,7 @@ LINK_LIBRARIES = ${LIB_LAPACK} ${LIB_BLAS} -lm ${LIB_SOLVER}
 LINK_LIBRARIES_WRAPPER = -lm ${LIB_SOLVER}
 
 # how to link against the qpOASES shared library
-QPOASES_LINK = -L${BINDIR}  -lqpOASES -L${SYSROOT}/usr/lib/System -lgcc_s.10.5 -lcrt1.o
+QPOASES_LINK = -L${BINDIR}  -lqpOASES -L${SYSROOT}/usr/lib/System
 QPOASES_LINK_WRAPPER = -L${BINDIR} -lqpOASES_wrapper
 
 # link dependencies when creating executables
diff --git a/src/BLASReplacement.cpp b/src/BLASReplacement.cpp
index c372a38..b32ee98 100644
--- a/src/BLASReplacement.cpp
+++ b/src/BLASReplacement.cpp
@@ -33,9 +33,10 @@
 
 
 #include <qpOASES/Utils.hpp>
+#include <qpOASES/LapackBlasReplacement.hpp>
 
 
-extern "C" void dgemm_(	const char* TRANSA, const char* TRANSB,
+extern "C" void DGEMM(	const char* TRANSA, const char* TRANSB,
 						const la_uint_t* M, const la_uint_t* N, const la_uint_t* K,
 						const double* ALPHA, const double* A, const la_uint_t* LDA, const double* B, const la_uint_t* LDB,
 						const double* BETA, double* C, const la_uint_t* LDC
@@ -90,7 +91,7 @@ extern "C" void dgemm_(	const char* TRANSA, const char* TRANSB,
 						C[j+(*LDC)*k] += *ALPHA * A[i+(*LDA)*j] * B[i+(*LDB)*k];
 }
 
-extern "C" void sgemm_(	const char* TRANSA, const char* TRANSB,
+extern "C" void SGEMM(	const char* TRANSA, const char* TRANSB,
 						const la_uint_t* M, const la_uint_t* N, const la_uint_t* K,
 						const float* ALPHA, const float* A, const la_uint_t* LDA, const float* B, const la_uint_t* LDB,
 						const float* BETA, float* C, const la_uint_t* LDC
@@ -144,3 +145,8 @@ extern "C" void sgemm_(	const char* TRANSA, const char* TRANSB,
 					for (i = 0; i < *K; i++)
 						C[j+(*LDC)*k] += *ALPHA * A[i+(*LDA)*j] * B[i+(*LDB)*k];
 }
+
+
+/*
+ *	end of file
+ */
diff --git a/src/LAPACKReplacement.cpp b/src/LAPACKReplacement.cpp
index 016a643..16f474e 100644
--- a/src/LAPACKReplacement.cpp
+++ b/src/LAPACKReplacement.cpp
@@ -33,11 +33,12 @@
 
 
 #include <qpOASES/Utils.hpp>
+#include <qpOASES/LapackBlasReplacement.hpp>
 
 
-extern "C" void dpotrf_(	const char* uplo, const la_uint_t* _n, double* a,
-							const la_uint_t* _lda, la_int_t* info
-							)
+extern "C" void DPOTRF(	const char* uplo, const la_uint_t* _n, double* a,
+						const la_uint_t* _lda, la_int_t* info
+						)
 {
 	double sum;
 	la_int_t i, j, k;
@@ -77,9 +78,9 @@ extern "C" void dpotrf_(	const char* uplo, const la_uint_t* _n, double* a,
 }
 
 
-extern "C" void spotrf_(	const char* uplo, const la_uint_t* _n, float* a,
-							const la_uint_t* _lda, la_int_t* info
-							)
+extern "C" void SPOTRF(	const char* uplo, const la_uint_t* _n, float* a,
+						const la_uint_t* _lda, la_int_t* info
+						)
 {
 	float sum;
 	la_int_t i, j, k;
@@ -118,35 +119,41 @@ extern "C" void spotrf_(	const char* uplo, const la_uint_t* _n, float* a,
 		*info = 0;
 }
 
-extern "C" void dtrtrs_(	const char* UPLO, const char* TRANS, const char* DIAG,
-							const la_uint_t* N, const la_uint_t* NRHS,
-							double* A, const la_uint_t* LDA, double* B, const la_uint_t* LDB, la_int_t* INFO
-							)
+
+extern "C" void DTRTRS(	const char* UPLO, const char* TRANS, const char* DIAG,
+						const la_uint_t* N, const la_uint_t* NRHS,
+						double* A, const la_uint_t* LDA, double* B, const la_uint_t* LDB, la_int_t* INFO
+						)
 {
 	INFO[0] = ((la_int_t)0xDEADBEEF); /* Dummy. If SQProblemSchur is to be used, system LAPACK must be used */
 }
 
-extern "C" void strtrs_(	const char* UPLO, const char* TRANS, const char* DIAG,
-							const la_uint_t* N, const la_uint_t* NRHS,
-							float* A, const la_uint_t* LDA, float* B, const la_uint_t* LDB, la_int_t* INFO
-							)
+extern "C" void STRTRS(	const char* UPLO, const char* TRANS, const char* DIAG,
+						const la_uint_t* N, const la_uint_t* NRHS,
+						float* A, const la_uint_t* LDA, float* B, const la_uint_t* LDB, la_int_t* INFO
+						)
 {
 	INFO[0] = ((la_int_t)0xDEADBEEF); /* Dummy. If SQProblemSchur is to be used, system LAPACK must be used */
 }
 
-extern "C" void dtrcon_(	const char* NORM, const char* UPLO, const char* DIAG,
-							const la_uint_t* N, double* A, const la_uint_t*LDA,
-							double* RCOND, double* WORK, const la_uint_t* IWORK, la_int_t* INFO
-							)
+
+extern "C" void DTRCON(	const char* NORM, const char* UPLO, const char* DIAG,
+						const la_uint_t* N, double* A, const la_uint_t*LDA,
+						double* RCOND, double* WORK, const la_uint_t* IWORK, la_int_t* INFO
+						)
 {
 	INFO[0] = ((la_int_t)0xDEADBEEF); /* Dummy. If SQProblemSchur is to be used, system LAPACK must be used */
 }
 
-extern "C" void strcon_(	const char* NORM, const char* UPLO, const char* DIAG,
-							const la_uint_t* N, float* A, const la_uint_t* LDA,
-							float* RCOND, float* WORK, const la_uint_t* IWORK, la_int_t* INFO
-							)
+extern "C" void STRCON(	const char* NORM, const char* UPLO, const char* DIAG,
+						const la_uint_t* N, float* A, const la_uint_t* LDA,
+						float* RCOND, float* WORK, const la_uint_t* IWORK, la_int_t* INFO
+						)
 {
 	INFO[0] = ((la_int_t)0xDEADBEEF); /* Dummy. If SQProblemSchur is to be used, system LAPACK must be used */
 }
 
+
+/*
+ *	end of file
+ */
diff --git a/src/Makefile b/src/Makefile
index ed765bd..69b9503 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -61,6 +61,7 @@ QPOASES_EXTRAS_OBJECTS = \
 
 QPOASES_DEPENDS = \
 	${IDIR}/qpOASES.hpp \
+	${IDIR}/qpOASES/LapackBlasReplacement.hpp \
 	${IDIR}/qpOASES/SQProblem.hpp \
 	${IDIR}/qpOASES/QProblem.hpp \
 	${IDIR}/qpOASES/Flipper.hpp \
diff --git a/src/Matrices.cpp b/src/Matrices.cpp
index 60550bc..d41881f 100644
--- a/src/Matrices.cpp
+++ b/src/Matrices.cpp
@@ -850,6 +850,8 @@ returnValue SparseMatrix::getRowNorm( real_t* norm, int_t type ) const
 			break;
 		case 1:
 			for ( j=0; j < nCols; ++j ) {
+				// FIXME please add guarding or fix indent for "for loop" to
+				//       remove compile warnings
 				for (i = jc[j]; i < jc[j+1]; i++);
 				  norm[ir[i]] += getAbs( val[i] );
 			}
diff --git a/src/QProblem.cpp b/src/QProblem.cpp
index 138c712..8ea39e1 100644
--- a/src/QProblem.cpp
+++ b/src/QProblem.cpp
@@ -79,7 +79,7 @@ QProblem::QProblem( ) : QProblemB( )
 /*
  *	Q P r o b l e m
  */
-QProblem::QProblem( int_t _nV, int_t _nC, HessianType _hessianType, BooleanType allocDenseMats ) 
+QProblem::QProblem( int_t _nV, int_t _nC, HessianType _hessianType, BooleanType allocDenseMats )
 	: QProblemB( _nV,_hessianType,allocDenseMats )
 {
 	int_t i;
@@ -5507,11 +5507,12 @@ returnValue QProblem::updateFarBounds(	real_t curFarBound, int_t nRamp,
 	int_t nV = getNV( );
 	int_t nC = getNC( );
 
-    returnValue returnvalue = QProblemB::updateFarBounds(	curFarBound,nRamp,
+	returnValue returnvalue = QProblemB::updateFarBounds(	curFarBound,nRamp,
 															lb_new,lb_new_far, ub_new,ub_new_far
 															);
-    if ( returnvalue != SUCCESSFUL_RETURN )
-        return returnvalue;
+	if ( returnvalue != SUCCESSFUL_RETURN ) {
+		return returnvalue;
+	}
 
 	if ( options.enableRamping == BT_TRUE )
 	{
@@ -6256,8 +6257,6 @@ returnValue QProblem::printIteration( 	int_t iter,
 }
 
 
-inline real_t abs (real_t x) { return (x>0)?x:-x; }
-
 /*
  * d r o p I n f e a s i b l e s
  */
@@ -6392,7 +6391,7 @@ returnValue QProblem::writeQpDataIntoMatFile(	const char* const filename
 	fclose( matFile );
 
 	return SUCCESSFUL_RETURN;
-    
+
 	#else /* __SUPPRESSANYOUTPUT__ */
 
 	return RET_NOT_YET_IMPLEMENTED;
@@ -6445,7 +6444,7 @@ returnValue QProblem::writeQpWorkspaceIntoMatFile(	const char* const filename
 	fclose( matFile );
 
 	return SUCCESSFUL_RETURN;
-    
+
 	#else /* __SUPPRESSANYOUTPUT__ */
 
 	return RET_NOT_YET_IMPLEMENTED;
diff --git a/src/QProblemB.cpp b/src/QProblemB.cpp
index 2a59370..52620e0 100644
--- a/src/QProblemB.cpp
+++ b/src/QProblemB.cpp
@@ -3382,11 +3382,13 @@ returnValue QProblemB::changeActiveSet( int_t BC_idx, SubjectToStatus BC_status
 		/* Add one variable to active set. */
 		default:
 			#ifndef __SUPPRESSANYOUTPUT__
-			if ( BC_status == ST_LOWER )
+			if ( BC_status == ST_LOWER ) {
 				snprintf( messageString,MAX_STRING_LENGTH,"lower bound no. %d.",(int)BC_idx );
-			else
+			}
+			else {
 				snprintf( messageString,MAX_STRING_LENGTH,"upper bound no. %d.",(int)BC_idx );
-				getGlobalMessageHandler( )->throwInfo( RET_ADD_TO_ACTIVESET,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
+			}
+			getGlobalMessageHandler( )->throwInfo( RET_ADD_TO_ACTIVESET,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
 			#endif
 
 			if ( addBound( BC_idx,BC_status,BT_TRUE ) != SUCCESSFUL_RETURN )
diff --git a/src/SQProblem.cpp b/src/SQProblem.cpp
index 9b9cad5..95dde53 100644
--- a/src/SQProblem.cpp
+++ b/src/SQProblem.cpp
@@ -56,7 +56,7 @@ SQProblem::SQProblem( ) : QProblem( )
 /*
  *	S Q P r o b l e m
  */
-SQProblem::SQProblem( int_t _nV, int_t _nC, HessianType _hessianType, BooleanType allocDenseMats ) 
+SQProblem::SQProblem( int_t _nV, int_t _nC, HessianType _hessianType, BooleanType allocDenseMats )
 	: QProblem( _nV,_nC,_hessianType,allocDenseMats )
 {
 }
@@ -114,13 +114,15 @@ returnValue SQProblem::hotstart(	SymmetricMatrix *H_new, const real_t* const g_n
 	real_t starttime = 0.0;
 	real_t auxTime = 0.0;
 
-    if ( cputime != 0 )
-        starttime = getCPUtime( );
+	if ( cputime != 0 ) {
+		starttime = getCPUtime( );
+	}
 
 
 	/* I) UPDATE QP MATRICES AND VECTORS */
-	if ( setupNewAuxiliaryQP( H_new,A_new,lb_new,ub_new,lbA_new,ubA_new ) != SUCCESSFUL_RETURN )
+	if ( setupNewAuxiliaryQP( H_new,A_new,lb_new,ub_new,lbA_new,ubA_new ) != SUCCESSFUL_RETURN ) {
 		return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
+	}
 
 
 	/* II) PERFORM USUAL HOMOTOPY */
@@ -136,9 +138,10 @@ returnValue SQProblem::hotstart(	SymmetricMatrix *H_new, const real_t* const g_n
 													nWSR,cputime,
 													guessedBounds,guessedConstraints
 													);
-	
-	if ( cputime != 0 )
+
+	if ( cputime != 0 ) {
 		*cputime += auxTime;
+	}
 
 	return returnvalue;
 }
@@ -163,8 +166,9 @@ returnValue SQProblem::hotstart(	const real_t* const H_new, const real_t* const
 
 	/* start runtime measurement */
 	real_t starttime = 0.0;
-    if ( cputime != 0 )
-        starttime = getCPUtime( );
+	if ( cputime != 0 ) {
+		starttime = getCPUtime( );
+	}
 
 
 	/* I) UPDATE QP MATRICES AND VECTORS */
@@ -175,8 +179,9 @@ returnValue SQProblem::hotstart(	const real_t* const H_new, const real_t* const
 	/* II) PERFORM USUAL HOMOTOPY */
 
 	/* Allow only remaining CPU time for usual hotstart. */
-	if ( cputime != 0 )
+	if ( cputime != 0 ) {
 		*cputime -= getCPUtime( ) - starttime;
+	}
 
 	returnValue returnvalue = QProblem::hotstart(	g_new,lb_new,ub_new,lbA_new,ubA_new,
 													nWSR,cputime,
diff --git a/src/SQProblemSchur.cpp b/src/SQProblemSchur.cpp
index 61ecc5c..5ffca3d 100644
--- a/src/SQProblemSchur.cpp
+++ b/src/SQProblemSchur.cpp
@@ -35,6 +35,7 @@
  */
 
 #include <qpOASES/SQProblemSchur.hpp>
+#include <qpOASES/LapackBlasReplacement.hpp>
 
 
 #ifndef __MATLAB__
diff --git a/src/SparseSolver.cpp b/src/SparseSolver.cpp
index 8460904..39b30c0 100644
--- a/src/SparseSolver.cpp
+++ b/src/SparseSolver.cpp
@@ -774,7 +774,8 @@ returnValue Ma57SparseSolver::factorize( )
 	 * Call MA57AD for symbolic factorization *
 	******************************************/
 
-	fint_t lkeep_ma57 = 5*dim + numNonzeros + getMax(numNonzeros,dim) + 42;
+	fint_t max_nnz = numNonzeros > dim ? numNonzeros : dim;
+	fint_t lkeep_ma57 = 5*dim + numNonzeros + max_nnz + 42;
 	fint_t *keep_ma57 = new fint_t[lkeep_ma57];
 	fint_t *iwork_ma57 = new fint_t[5*dim];
 
@@ -806,7 +807,7 @@ returnValue Ma57SparseSolver::factorize( )
 	fact_ma57 = new double[lfact_ma57];
 
 	lifact_ma57 = (fint_t)(lfact_factor * (double)(info_ma57[9]));
-	ifact_ma57 = new int_t[lifact_ma57];
+	ifact_ma57 = new fint_t[lifact_ma57];
 
     /*******************************************
 	 * Call MA57BD for numerical factorization *
