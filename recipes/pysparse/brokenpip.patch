diff -X xcld.txt -r -N pysparse-1.3-dev/LICENSE pysparse/LICENSE
0a1,26
> Copyright (c) 2001-2010, The PySparse Project. All rights reserved.
> 
> Redistribution and use in source and binary forms, with or without
> modification, are permitted provided that the following conditions are met:
> 
>     * Redistributions of source code must retain the above copyright
>       notice, this list of conditions and the following disclaimer.
>     * Redistributions in binary form must reproduce the above
>       copyright notice, this list of conditions and the following
>       disclaimer in the documentation and/or other materials provided
>       with the distribution.
> 
> THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
> ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
> WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
> DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
> ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
> (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
> LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
> ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
> (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
> SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
> 
> The views and conclusions contained in the software and documentation are those
> of the authors and should not be interpreted as representing official policies,
> either expressed or implied, of the PySparse Project.
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/amd/License pysparse/pysparse/direct/amd/License
0a1,29
> The AMD library in this directory is a modified version of the original
> which is available at http://www.cise.ufl.edu/research/sparse/amd. The license
> for the use of AMD is available below.
> 
> AMD Version 1.0 (Apr. 30, 2003),  Copyright (c) 2003 by Timothy A.
> Davis, Patrick R. Amestoy, and Iain S. Duff.  All Rights Reserved.
> 
> AMD License:
> 
>     Your use or distribution of AMD or any modified version of
>     AMD implies that you agree to this License.
> 
>     THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
>     EXPRESSED OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.
> 
>     Permission is hereby granted to use or copy this program, provided
>     that the Copyright, this License, and the Availability of the original
>     version is retained on all copies.  User documentation of any code that
>     uses AMD or any modified version of AMD code must cite the
>     Copyright, this License, the Availability note, and "Used by permission."
>     Permission to modify the code and to distribute modified code is granted,
>     provided the Copyright, this License, and the Availability note are
>     retained, and a notice that the code was modified is included.  This
>     software was developed with support from the National Science Foundation,
>     and is provided to you free of charge.
> 
> Availability:
> 
>     http://www.cise.ufl.edu/research/sparse/amd
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/amd/include/amd.h pysparse/pysparse/direct/amd/include/amd.h
0a1,258
> /* ========================================================================== */
> /* === AMD:  approximate minimum degree ordering ============================ */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* AMD Version 1.0 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A. Davis,   */
> /* Patrick R. Amestoy, and Iain S. Duff.  See ../README for License.          */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/amd                           */
> /* -------------------------------------------------------------------------- */
> 
> /* AMD finds a symmetric ordering P of a matrix A so that the Cholesky
>  * factorization of P*A*P' has fewer nonzeros and takes less work than the
>  * Cholesky factorization of A.  If A is not symmetric, then it performs its
>  * ordering on the matrix A+A'.  Two sets of user-callable routines are
>  * provided, one for "int" integers and the other for "long" integers.
>  *
>  * The method is based on the approximate minimum degree algorithm, discussed in
>  * Amestoy, Davis, and Duff, "An approximate degree ordering algorithm", SIAM
>  * Journal of Matrix Analysis and Applications, vol. 17, no. 4, pp.  886-905,
>  * 1996.  This package can perform both the AMD ordering (with aggressive
>  * absorption), and the AMDBAR ordering (without aggressive absorption)
>  * discussed in the above paper.  This package differs from the Fortran codes
>  * discussed in the paper:
>  *
>  *	(1) it can ignore "dense" rows and columns, leading to faster run times,
>  *	(2) it computes the ordering of A+A' if A is not symmetric,
>  *	(3) it is followed by a depth-first post-ordering of the assembly tree
>  *	    (or supernodal elimination tree)
>  *
>  * For historical reasons, the Fortran versions, amd.f and amdbar.f, have
>  * been left unchanged.  They compute the identical ordering as described in
>  * the above paper.
>  */
> 
> #ifndef AMD_H
> #define AMD_H
> 
> int amd_order (		    /* returns 0 if OK, negative value if error */
>     int n,		    /* A is n-by-n.  n must be >= 0. */
>     const int Ap [ ],	    /* column pointers for A, of size n+1 */
>     const int Ai [ ],	    /* row indices of A, of size nz = Ap [n] */
>     int P [ ],		    /* output permutation, of size n */
>     double Control [ ],	    /* input Control settings, of size AMD_CONTROL */
>     double Info [ ]	    /* output Info statistics, of size AMD_INFO */
> ) ;
> 
> long amd_l_order (	    /* see above for description of arguments */
>     long n,
>     const long Ap [ ],
>     const long Ai [ ],
>     long P [ ],
>     double Control [ ],
>     double Info [ ]
> ) ;
> 
> /* Input arguments (not modified):
>  *
>  *	n: the matrix A is n-by-n.
>  *	Ap: an int/long array of size n+1, containing the column pointers of A.
>  *	Ai: an int/long array of size nz, containing the row indices of A,
>  *	    where nz = Ap [n].
>  *	Control:  a double array of size AMD_CONTROL, containing control
>  *	    parameters.  Defaults are used if Control is NULL.
>  *
>  * Output arguments (not defined on input):
>  *
>  *	P: an int/long array of size n, containing the output permutation. If
>  *	    row i is the kth pivot row, then P [k] = i.  In MATLAB notation,
>  *	    the reordered matrix is A (P,P).
>  *	Info: a double array of size AMD_INFO, containing statistical
>  *	    information.  Ignored if Info is NULL.
>  *
>  * On input, the matrix A is stored in column-oriented form.  The row indices
>  * of nonzero entries in column j are stored in Ai [Ap [j] ... Ap [j+1]-1].
>  * The row indices must appear in ascending order in each column, and there
>  * must not be any duplicate entries.  Row indices must be in the range 0 to
>  * n-1.  Ap [0] must be zero, and thus nz = Ap [n] is the number of nonzeros
>  * in A.  The array Ap is of size n+1, and the array Ai is of size nz = Ap [n].
>  * The matrix does not need to be symmetric, and the diagonal does not need to
>  * be present (if diagonal entries are present, they are ignored except for
>  * the output statistic Info [AMD_NZDIAG]).  The arrays Ai and Ap are not
>  * modified.  This form of the Ap and Ai arrays to represent the nonzero
>  * pattern of the matrix A is the same as that used internally by MATLAB.
>  * If you wish to use a more flexible input structure, please see the
>  * umfpack_*_triplet_to_col routines in the UMFPACK package, at
>  * http://www.cise.ufl.edu/research/sparse/umfpack.
>  *
>  * Restrictions:  n >= 0.  Ap [0] = 0.  Ap [j] <= Ap [j+1] for all j in the
>  *	range 0 to n-1.  nz = Ap [n] >= 0.  For all j in the range 0 to n-1,
>  *	and for all p in the range Ap [j] to Ap [j+1]-2, Ai [p] < Ai [p+1] must
>  *	hold.  Ai [0..nz-1] must be in the range 0 to n-1.  To avoid integer
>  *	overflow, (2.4*nz + 8*n) < INT_MAX / sizeof (int) for must hold for the
>  *	"int" version. (2.4*nz + 8*n) < LONG_MAX / sizeof (long) must hold
>  *	for the "long" version.  Finally, Ai, Ap, and P must not be NULL.  If
>  *	any of these restrictions are not met, AMD returns AMD_INVALID.
>  *
>  * AMD returns:
>  *
>  *	AMD_OK if the matrix is valid and sufficient memory can be allocated to
>  *	    perform the ordering.
>  *
>  *	AMD_OUT_OF_MEMORY if not enough memory can be allocated.
>  *
>  *	AMD_INVALID if the input arguments n, Ap, Ai are invalid, or if P is
>  *	    NULL.
>  *
>  * The AMD routine first forms the pattern of the matrix A+A', and then computes
>  * a fill-reducing ordering, P.  If P [k] = i, then row/column i of the original
>  * is the kth pivotal row.  In MATLAB notation, the permuted matrix is A (P,P),
>  * except that 0-based indexing is used instead of the 1-based indexing in
>  * MATLAB.
>  *
>  * The Control array is used to set various parameters for AMD.  If a NULL
>  * pointer is passed, default values are used.  The Control array is not
>  * modified.
>  *
>  *	Control [AMD_DENSE]:  controls the threshold for "dense" rows/columns.
>  *	    A dense row/column in A+A' can cause AMD to spend a lot of time in
>  *	    ordering the matrix.  If Control [AMD_DENSE] >= 0, rows/columns with
>  *	    more than Control [AMD_DENSE] * sqrt (n) entries are ignored during
>  *	    the ordering, and placed last in the output order.  The default
>  *	    value of Control [AMD_DENSE] is 10.  If negative, no rows/columns
>  *	    are treated as "dense".  Rows/columns with 16 or fewer off-diagonal
>  *	    entries are never considered "dense".
>  *
>  *	Control [AMD_AGGRESSIVE]: controls whether or not to use aggressive
>  *	    absorption, in which a prior element is absorbed into the current
>  *	    element if is a subset of the current element, even if it is not
>  *	    adjacent to the current pivot element (refer to Amestoy, Davis,
>  *	    & Duff, 1996, for more details).  The default value is nonzero,
>  *	    which means to perform aggressive absorption.  This nearly always
>  *	    leads to a better ordering (because the approximate degrees are more
>  *	    accurate) and a lower execution time.  There are cases where it can
>  *	    lead to a slightly worse ordering, however.  To turn it off, set
>  *	    Control [AMD_AGGRESSIVE] to 0.
>  *
>  *	Control [2..4] are not used in the current version, but may be used in
>  *	    future versions.
>  *
>  * The Info array provides statistics about the ordering on output.  If it is
>  * not present, the statistics are not returned.  This is not an error
>  * condition.
>  * 
>  *	Info [AMD_STATUS]:  the return value of AMD, either AMD_OK,
>  *	    AMD_OUT_OF_MEMORY, or AMD_INVALID.
>  *
>  *	Info [AMD_N]: n, the size of the input matrix
>  *
>  *	Info [AMD_NZ]: the number of nonzeros in A, nz = Ap [n]
>  *
>  *	Info [AMD_SYMMETRY]:  the symmetry of the matrix A.  It is the number
>  *	    of "matched" off-diagonal entries divided by the total number of
>  *	    off-diagonal entries.  An entry A(i,j) is matched if A(j,i) is also
>  *	    an entry, for any pair (i,j) for which i != j.  In MATLAB notation,
>  *		S = spones (A) ;
>  *		B = tril (S, -1) + triu (S, 1) ;
>  *		symmetry = nnz (B & B') / nnz (B) ;
>  *
>  *	Info [AMD_NZDIAG]: the number of entries on the diagonal of A.
>  *
>  *	Info [AMD_NZ_A_PLUS_AT]:  the number of nonzeros in A+A', excluding the
>  *	    diagonal.  If A is perfectly symmetric (Info [AMD_SYMMETRY] = 1)
>  *	    with a fully nonzero diagonal, then Info [AMD_NZ_A_PLUS_AT] = nz-n
>  *	    (the smallest possible value).  If A is perfectly unsymmetric
>  *	    (Info [AMD_SYMMETRY] = 0, for an upper triangular matrix, for
>  *	    example) with no diagonal, then Info [AMD_NZ_A_PLUS_AT] = 2*nz
>  *	    (the largest possible value).
>  *
>  *	Info [AMD_NDENSE]: the number of "dense" rows/columns of A+A' that were
>  *	    removed from A prior to ordering.  These are placed last in the
>  *	    output order P.
>  *
>  *	Info [AMD_MEMORY]: the amount of memory used by AMD, in bytes.  In the
>  *	    current version, this is 1.2 * Info  [AMD_NZ_A_PLUS_AT] + 9*n
>  *	    times the size of an integer.  This is at most 2.4nz + 9n.  This
>  *	    excludes the size of the input arguments Ai, Ap, and P, which have
>  *	    a total size of nz + 2*n + 1 integers.
>  *
>  *	Info [AMD_NCMPA]: the number of garbage collections performed.
>  *
>  *	Info [AMD_LNZ]: the number of nonzeros in L (excluding the diagonal).
>  *	    This is a slight upper bound because mass elimination is combined
>  *	    with the approximate degree update.  It is a rough upper bound if
>  *	    there are many "dense" rows/columns.  The rest of the statistics,
>  *	    below, are also slight or rough upper bounds, for the same reasons.
>  *	    The post-ordering of the assembly tree might also not exactly
>  *	    correspond to a true elimination tree postordering.
>  *
>  *	Info [AMD_NDIV]: the number of divide operations for a subsequent LDL'
>  *	    or LU factorization of the permuted matrix A (P,P).
>  *
>  *	Info [AMD_NMULTSUBS_LDL]:  the number of multiply-subtract pairs for a
>  *	    subsequent LDL' factorization of A (P,P).
>  *
>  *	Info [AMD_NMULTSUBS_LU]:  the number of multiply-subtract pairs for a
>  *	    subsequent LU factorization of A (P,P), assuming that no numerical
>  *	    pivoting is required.
>  *
>  *	Info [AMD_DMAX]:  the maximum number of nonzeros in any column of L,
>  *	    including the diagonal.
>  *
>  *	Info [14..19] are not used in the current version, but may be used in
>  *	    future versions.
>  */    
> 
> /* -------------------------------------------------------------------------- */
> /* AMD Control and Info arrays */
> /* -------------------------------------------------------------------------- */
> 
> /* amd_defaults:  sets the default control settings */
> void amd_defaults   (double Control [ ]) ;
> void amd_l_defaults (double Control [ ]) ;
> 
> /* amd_control: prints the control settings */
> void amd_control    (double Control [ ]) ;
> void amd_l_control  (double Control [ ]) ;
> 
> /* amd_info: prints the statistics */
> void amd_info       (double Info [ ]) ;
> void amd_l_info     (double Info [ ]) ;
> 
> #define AMD_CONTROL 5	    /* size of Control array */
> #define AMD_INFO 20	    /* size of Info array */
> 
> /* contents of Control */
> #define AMD_DENSE 0	    /* "dense" if degree > Control [0] * sqrt (n) */
> #define AMD_AGGRESSIVE 1    /* do aggressive absorption if Control [1] != 0 */
> 
> /* default Control settings */
> #define AMD_DEFAULT_DENSE 10.0	    /* default "dense" degree 10*sqrt(n) */
> #define AMD_DEFAULT_AGGRESSIVE 1    /* do aggressive absorption by default */
> 
> /* contents of Info */
> #define AMD_STATUS 0	    /* return value of amd_order and amd_l_order */
> #define AMD_N 1		    /* A is n-by-n */
> #define AMD_NZ 2	    /* number of nonzeros in A */ 
> #define AMD_SYMMETRY 3	    /* symmetry of pattern (1 is sym., 0 is unsym.) */
> #define AMD_NZDIAG 4	    /* # of entries on diagonal */
> #define AMD_NZ_A_PLUS_AT 5  /* nz in A+A' */
> #define AMD_NDENSE 6	    /* number of "dense" rows/columns in A */
> #define AMD_MEMORY 7	    /* amount of memory used by AMD */
> #define AMD_NCMPA 8	    /* number of garbage collections in AMD */
> #define AMD_LNZ 9	    /* approx. nz in L, excluding the diagonal */
> #define AMD_NDIV 10	    /* number of fl. point divides for LU and LDL' */
> #define AMD_NMULTSUBS_LDL 11 /* number of fl. point (*,-) pairs for LDL' */
> #define AMD_NMULTSUBS_LU 12  /* number of fl. point (*,-) pairs for LU */
> #define AMD_DMAX 13	     /* max nz. in any column of L, incl. diagonal */
> 
> /* -------------------------------------------------------------------------- */
> /* return values of AMD */
> /* -------------------------------------------------------------------------- */
> 
> #define AMD_OK 0		/* success */
> #define AMD_OUT_OF_MEMORY -1	/* malloc failed, or 2.4*nz+9*n is too large */
> #define AMD_INVALID -2		/* input arguments are not valid */
> 
> #endif
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/amd/include/amd_internal.h pysparse/pysparse/direct/amd/include/amd_internal.h
0a1,376
> /* ========================================================================== */
> /* === amd_internal.h ======================================================= */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* AMD Version 1.0 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A. Davis,   */
> /* Patrick R. Amestoy, and Iain S. Duff.  See ../README for License.          */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/amd                           */
> /* -------------------------------------------------------------------------- */
> 
> /* This file is for internal use in AMD itself, and does not normally need to
>  * be included in user code.  Use amd.h instead.
>  *
>  * The following compile-time definitions affect how AMD is compiled.
>  *
>  *	-DMATLAB_MEX_FILE
>  *
>  *	    This flag is turned on when compiling the amd mexFunction for
>  *	    use in MATLAB.
>  *
>  *	-DMATHWORKS
>  *
>  *	    This flag is turned on when compiling amd as a built-in routine
>  *	    in MATLAB.  Internal routines utMalloc, utFree, utRealloc, and
>  *	    utPrintf are used, and the MathWorks "util.h" file is included.  
>  *	    This option is intended for use by The MathWorks, Inc., only.
>  *
>  *	-DNDEBUG
>  *
>  *	    Debugging mode (if NDEBUG is not defined).  The default, of course,
>  *	    is no debugging.  Turning on debugging takes some work (see below).
>  *	    If you do not edit this file, then debugging is turned off anyway,
>  *	    regardless of whether or not -DNDEBUG is specified in your compiler
>  *	    options.
>  *
>  * You can change the memory allocator routines by editting the definitions
>  * of ALLOCATE and FREE, below, and recompilng AMD.
>  */
> 
> /* ========================================================================== */
> /* === NDEBUG =============================================================== */
> /* ========================================================================== */
> 
> /*
>     AMD will be exceedingly slow when running in debug mode.  The next three
>     lines ensure that debugging is turned off.
> */
> #ifndef NDEBUG
> #define NDEBUG
> #endif
> 
> /*
>     To enable debugging, uncomment the following line:
> #undef NDEBUG
> */
> 
> /* -------------------------------------------------------------------------- */
> /* ANSI include files */
> /* -------------------------------------------------------------------------- */
> 
> /* from stdlib.h:  malloc, free, realloc (when not compiling for MATLAB) */
> #include <stdlib.h>
> 
> /* from stdio.h:  printf, NULL.  When in debug mode:  fopen, fscanf */
> #include <stdio.h>
> 
> /* from limits.h:  INT_MAX and LONG_MAX */
> #include <limits.h>
> 
> /* from math.h: sqrt */
> #include <math.h>
> 
> /* -------------------------------------------------------------------------- */
> /* MATLAB include files */
> /* -------------------------------------------------------------------------- */
> 
> #ifdef MATHWORKS
> #include "util.h"
> #endif
> 
> #ifdef MATLAB_MEX_FILE
> #include "matrix.h"
> #include "mex.h"
> #endif
> 
> /* -------------------------------------------------------------------------- */
> /* basic definitions */
> /* -------------------------------------------------------------------------- */
> 
> #ifdef FLIP
> #undef FLIP
> #endif
> 
> #ifdef MAX
> #undef MAX
> #endif
> 
> #ifdef MIN
> #undef MIN
> #endif
> 
> #ifdef EMPTY
> #undef EMPTY
> #endif
> 
> /* FLIP is a "negation about -1", and is used to mark an integer i that is
>  * normally non-negative.  FLIP (EMPTY) is EMPTY.  FLIP of a number > EMPTY
>  * is negative, and FLIP of a number < EMTPY is positive.  FLIP (FLIP (i)) = i
>  * for all integers i.  UNFLIP (i) is >= EMPTY. */
> #define EMPTY (-1)
> #define FLIP(i) (-(i)-2)
> #define UNFLIP(i) ((i < EMPTY) ? FLIP (i) : (i))
> 
> /* for integer MAX/MIN, or for doubles when we don't care how NaN's behave: */
> #define MAX(a,b) (((a) > (b)) ? (a) : (b))
> #define MIN(a,b) (((a) < (b)) ? (a) : (b))
> 
> /* logical expression of p implies q: */
> #define IMPLIES(p,q) (!(p) || (q))
> 
> /* Note that the IBM RS 6000 xlc predefines TRUE and FALSE in <types.h>. */
> /* The Compaq Alpha also predefines TRUE and FALSE. */
> #ifdef TRUE
> #undef TRUE
> #endif
> #ifdef FALSE
> #undef FALSE
> #endif
> 
> #define TRUE (1)
> #define FALSE (0)
> #define PRIVATE static
> #define GLOBAL
> #define EMPTY (-1)
> 
> /* Note that Linux's gcc 2.96 defines NULL as ((void *) 0), but other */
> /* compilers (even gcc 2.95.2 on Solaris) define NULL as 0 or (0). */
> #ifdef NULL
> #undef NULL
> #endif
> 
> #define NULL 0
> 
> /* -------------------------------------------------------------------------- */
> /* integer type for AMD: int or long */
> /* -------------------------------------------------------------------------- */
> 
> #if defined (DLONG) || defined (ZLONG)
> 
> #define Int long
> #define ID "%ld"
> #define Int_MAX LONG_MAX
> #define Int_MIN LONG_MIN
> 
> #define AMD_order amd_l_order
> #define AMD_defaults amd_l_defaults
> #define AMD_control amd_l_control
> #define AMD_info amd_l_info
> #define AMD_1 amd_l1
> #define AMD_2 amd_l2
> #define AMD_valid amd_l_valid
> #define AMD_aat amd_l_aat
> #define AMD_postorder amd_l_postorder
> #define AMD_post_tree amd_l_post_tree
> #define AMD_dump amd_l_dump
> #define AMD_debug amd_l_debug
> #define AMD_debug_init amd_l_debug_init
> 
> #else
> 
> #define Int int
> #define ID "%d"
> #define Int_MAX INT_MAX
> #define Int_MIN INT_MIN
> 
> #define AMD_order amd_order
> #define AMD_defaults amd_defaults
> #define AMD_control amd_control
> #define AMD_info amd_info
> #define AMD_1 amd_1
> #define AMD_2 amd_2
> #define AMD_valid amd_valid
> #define AMD_aat amd_aat
> #define AMD_postorder amd_postorder
> #define AMD_post_tree amd_post_tree
> #define AMD_dump amd_dump
> #define AMD_debug amd_debug
> #define AMD_debug_init amd_debug_init
> 
> #endif
> 
> /* ========================================================================== */
> /* === Memory allocator ===================================================== */
> /* ========================================================================== */
> 
> /* The MATLAB mexFunction uses MATLAB's memory manager, while the C-callable */
> /* AMD routine uses the ANSI C malloc, free, and realloc routines. */
> 
> #ifdef MATLAB_MEX_FILE
> #define ALLOCATE mxMalloc
> #define FREE mxFree
> #else
> #ifdef MATHWORKS
> /* Compiling as a built-in routine.  Since out-of-memory conditions are checked
>  * after every allocation, we can use ut* routines here. */
> #define ALLOCATE utMalloc
> #define FREE utFree
> #else
> /* use the ANSI C memory allocation routines */
> #define ALLOCATE malloc
> #define FREE free
> #endif
> #endif
> 
> 
> /* ========================================================================== */
> /* === PRINTF macro ========================================================= */
> /* ========================================================================== */
> 
> /* All output goes through the PRINTF macro.  */
> 
> #ifdef MATLAB_MEX_FILE
> #define PRINTF(params) { (void) mexPrintf params ; }
> #else
> #ifdef MATHWORKS
> #define PRINTF(params) { (void) utPrintf params ; }
> #else
> #define PRINTF(params) { (void) printf params ; }
> #endif
> #endif
> 
> /* -------------------------------------------------------------------------- */
> /* AMD routine definitions (user-callable) */
> /* -------------------------------------------------------------------------- */
> 
> #include "amd.h"
> 
> /* -------------------------------------------------------------------------- */
> /* AMD routine definitions (not user-callable) */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL Int AMD_valid
> (
>     Int n_row,
>     Int n_col,
>     const Int Ap [ ],
>     const Int Ai [ ]
> ) ;
> 
> GLOBAL Int AMD_aat
> (
>     Int n,
>     const Int Ap [ ],
>     const Int Ai [ ],
>     Int Len [ ],
>     Int Tp [ ],	
>     double Info [ ]
> ) ;
> 
> GLOBAL void AMD_1
> (
>     Int n,
>     const Int Ap [ ],
>     const Int Ai [ ],
>     Int P [ ],
>     Int Pinv [ ],
>     Int Len [ ],
>     Int slen,
>     Int S [ ],
>     double Control [ ],
>     double Info [ ]
> ) ;
> 
> GLOBAL void AMD_2 (
>     Int n,
>     Int Pe [ ],
>     Int Iw [ ],
>     Int Len [ ],
>     Int iwlen,
>     Int pfree,
>     Int Nv [ ],
>     Int Next [ ], 
>     Int Last [ ],
>     Int Head [ ],
>     Int Elen [ ],
>     Int Degree [ ],
>     Int W [ ],
>     double Control [ ],
>     double Info [ ]
> ) ;
> 
> GLOBAL void AMD_postorder
> (
>     Int nn,
>     Int Parent [ ],
>     Int Npiv [ ],
>     Int Fsize [ ],
>     Int Order [ ],
>     Int Child [ ],
>     Int Sibling [ ],
>     Int Stack [ ]
> ) ;
> 
> GLOBAL Int AMD_post_tree
> (
>     Int root,
>     Int k,
>     Int Child [ ],
>     const Int Sibling [ ],
>     Int Order [ ],
>     Int Stack [ ]
> #ifndef NDEBUG
>     , Int nn
> #endif
> ) ;
> 
> /* -------------------------------------------------------------------------- */
> /* debugging definitions */
> /* -------------------------------------------------------------------------- */
> 
> /* from assert.h:  assert macro */
> #if !defined (MATHWORKS) && !defined (MATLAB_MEX_FILE)
> #include <assert.h>
> #endif
> 
> #ifndef NDEBUG
> 
> GLOBAL Int AMD_debug ;
> 
> GLOBAL void AMD_debug_init ( char *s ) ;
> 
> GLOBAL void AMD_dump (
>     Int n,
>     Int Pe [ ],
>     Int Iw [ ],
>     Int Len [ ],
>     Int iwlen,
>     Int pfree,
>     Int Nv [ ],
>     Int Next [ ],
>     Int Last [ ],
>     Int Head [ ],
>     Int Elen [ ],
>     Int Degree [ ],
>     Int W [ ],
>     Int nel
> ) ;
> 
> #ifdef MATLAB_MEX_FILE
> #define ASSERT(expression) (mxAssert ((expression), ""))
> #else
> #ifdef MATHWORKS
> #define ASSERT(expression) (utAssert (expression))
> #else
> #define ASSERT(expression) (assert (expression))
> #endif
> #endif /* MATLAB_MEX_FILE */
> 
> #define AMD_DEBUG0(params) { PRINTF (params) ; }
> #define AMD_DEBUG1(params) { if (AMD_debug >= 1) PRINTF (params) ; }
> #define AMD_DEBUG2(params) { if (AMD_debug >= 2) PRINTF (params) ; }
> #define AMD_DEBUG3(params) { if (AMD_debug >= 3) PRINTF (params) ; }
> #define AMD_DEBUG4(params) { if (AMD_debug >= 4) PRINTF (params) ; }
> 
> #else
> 
> #define AMD_DEBUG0(params)
> #define AMD_DEBUG1(params)
> #define AMD_DEBUG2(params)
> #define AMD_DEBUG3(params)
> #define AMD_DEBUG4(params)
> 
> #define ASSERT(expression)
> 
> #endif
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/src/superlu3module.c pysparse/pysparse/direct/src/superlu3module.c
0a1,410
> #include <stdio.h>
> #include "Python.h"
> #define PY_ARRAY_UNIQUE_SYMBOL superlu
> 
> #include "numpy/arrayobject.h"
> #include "numpy/noprefix.h"
> 
> #include "slu_ddefs.h"
> #include "slu_util.h"
> 
> #include "spmatrix.h"
> 
> /*********************************************************************** 
>  * static variable
>  */
> 
> 
> /*********************************************************************** 
>  * SuperLUObject definition
>  */
> 
> typedef struct SuperLUObject {
>   PyObject_VAR_HEAD
>   int n;
>   SuperMatrix L;
>   SuperMatrix U;
>   int *perm_r;
>   int *perm_c;
>   SuperLUStat_t stat;
>   int StatInit_done;  /* flag showing whether StatInit was already called */
>   superlu_options_t options;
> } SuperLUObject;
> 
> /*********************************************************************** 
>  * SuperLUObject methods
>  */
> 
> static char solve_doc[] = "self.solve(b, x, trans)\n\
> \n\
> solves linear system of equations with one or sereral right hand sides.\n\
> \n\
> parameters\n\
> ----------\n\
> \n\
> b        array, right hand side(s) of equation\n\
> x        array, solution vector(s)\n\
> trans    'N': solve A   * x == b\n\
>          'T': solve A^T * x == b\n\
>          (optional, default value 'N')\n\
> ";
> 
> static PyObject *SuperLU_solve(SuperLUObject *self, PyObject *args) {
>   PyArrayObject *b, *x;
>   SuperMatrix B;
>   char trans = 'N';
>   trans_t Trans;
>   int i, info = 0;
> 
>   if (!PyArg_ParseTuple(args, "O!O!|c", 
> 			&PyArray_Type, &b, 
> 			&PyArray_Type, &x,
> 			&trans))
>     return NULL;
>   
>   SPMATRIX_CHECK_ARR_DIM_SIZE(b, 1, self->n);
>   SPMATRIX_CHECK_ARR_DIM_SIZE(x, 1, self->n);
> 
>   /* solve transposed system:
>    * matrix was passed row-wise instead of column-wise */
>   if (trans == 'n' || trans == 'N')
>     Trans = TRANS; //trans = 'T';
>   else if (trans == 't' || trans == 'T')
>     Trans = NOTRANS; //trans = 'N';
>   else {
>     PyErr_SetString(PyExc_ValueError, "trans");
>     return NULL;
>   }
> 
>   /* copy b to x */
>   for (i = 0; i < self->n; i ++)
>     ((double *)x->data)[i] = ((double *)b->data)[i];
> 
>   /* Create data structure for right hand side */
>   dCreate_Dense_Matrix(&B, self->n, 1, (double *)x->data, self->n,
>                        SLU_DN, SLU_D, SLU_GE);
> 
>   /* Solve the system, overwriting vector x. */
>   dgstrs(Trans, &self->L, &self->U, self->perm_c, self->perm_r, &B,
>          &self->stat, &info);
> 
>   /* free memory */
>   Destroy_SuperMatrix_Store(&B);
> 
>   if (info) {
>     PyErr_SetString(PyExc_SystemError,
>                     "dgstrs was called with invalid arguments");
>     return NULL;
>   } else {
>     Py_INCREF(Py_None); 
>     return Py_None;
>   }
> }
> 
> /** table of object methods
>  */
> PyMethodDef SuperLU_special_methods[] = {
>   {"solve", (PyCFunction)SuperLU_solve, METH_VARARGS, solve_doc},
>   {NULL,    NULL,                       0,            NULL     }  /* sentinel */
> };
> 
> 
> /*********************************************************************** 
>  * SuperLUType methods
>  */
> 
> static void SuperLU_dealloc(SuperLUObject *self) {
>   SUPERLU_FREE(self->perm_r);
>   SUPERLU_FREE(self->perm_c);
>   Destroy_SuperNode_Matrix(&self->L);
>   Destroy_CompCol_Matrix(&self->U);
>   StatFree(&self->stat);
>   PyObject_Del(self);
> }
> 
> static PyObject *SuperLU_getattr(SuperLUObject *self, char *name) {
>   if (strcmp(name, "shape") == 0)
>     return Py_BuildValue("(i,i)", self->n, self->n);
>   if (strcmp(name, "nnz") == 0)
>     return Py_BuildValue("i", ((SCformat *)self->L.Store)->nnz + ((SCformat *)self->U.Store)->nnz);
>   if (strcmp(name, "__members__") == 0) {
>     char *members[] = {"shape", "nnz"};
>     int i;
> 
>     PyObject *list = PyList_New(sizeof(members)/sizeof(char *));
>     if (list != NULL) {
>       for (i = 0; i < sizeof(members)/sizeof(char *); i ++)
> 	PyList_SetItem(list, i, PyString_FromString(members[i]));
>       if (PyErr_Occurred()) {
> 	Py_DECREF(list);
> 	list = NULL;
>       }
>     }
>     return list;
>   }
>   return Py_FindMethod(SuperLU_special_methods, (PyObject *)self, name);
> }
> 
> 
> /***********************************************************************
>  * SuperLUType structure
>  */
> 
> PyTypeObject SuperLUType = {
>   PyObject_HEAD_INIT(NULL)
>   0,
>   "superlu_context",
>   sizeof(SuperLUObject),
>   0,
>   (destructor)SuperLU_dealloc,   /* tp_dealloc */
>   0,				/* tp_print */
>   (getattrfunc)SuperLU_getattr,  /* tp_getattr */
>   0,                           /* tp_setattr */
>   0,                           /* tp_compare */
>   0,                           /* tp_repr */
>   0,                           /* tp_as_number*/
>   0,                           /* tp_as_sequence*/
>   0,                           /* tp_as_mapping*/
>   0,                           /* tp_hash */
>   0,                           /* tp_call*/
>   0,                           /* tp_str*/
>   0,                           /* tp_getattro*/
>   0,                           /* tp_setattro*/
>   0,                           /* tp_as_buffer*/
>   Py_TPFLAGS_DEFAULT,          /* tp_flags*/
>   "SuperLU Context Object",    /* tp_doc */
> };
> 
> /*********************************************************************** 
>  * Object construction functions
>  */
> 
> /*********************************************************************** 
>  * Module functions
>  */
> 
> static PyObject *newSuperLUObject(int n, CSRMatObject *matrix, PyObject *issym,
>                                   double diag_pivot_thresh, double drop_tol,
>                                   int relax, int panel_size, int permc_spec) {
>   SuperLUObject *self;
>   SuperMatrix A;      /* A in NC format used by the factorization routine. */
>   SuperMatrix AC;     /* Matrix postmultiplied by Pc */
>   mem_usage_t mem_usage;
>   int *etree;
>   int info = 0;
> 
>   //printf("Creating new object\n");
>   
>   /* Create SuperLUObject */
>   self = PyObject_New(SuperLUObject, &SuperLUType);
>   if (self == NULL)
>     return NULL; // PyErr_NoMemory();
>   self->n = n;
>   self->perm_r = NULL;
>   self->perm_c = NULL;
>   self->StatInit_done = 0;
> 
>   //printf("Setting options (permc_spec = %d)\n", permc_spec);
> 
>   set_default_options(&self->options);
>   switch( permc_spec ) {
>   case 0:
>     self->options.ColPerm = NATURAL;
>     break;
>   case 1:
>     self->options.ColPerm = MMD_ATA;
>     break;
>   case 2:
>     self->options.ColPerm = MMD_AT_PLUS_A;
>     break;
>   case 3:
>     self->options.ColPerm = COLAMD;
>     break;
>   default:
>     //self->options.ColPerm = MY_PERMC;
>     break;
>   }
>   self->options.DiagPivotThresh = diag_pivot_thresh;
>   self->options.PrintStat = YES;
>   self->options.SymmetricMode = (issym == Py_True) ? YES : NO;
> 
>   //printf("Setting up stats\n");
> 
>   /* Make sure StatInit is only called once */
>   if(! self->StatInit_done) {
>     StatInit(&self->stat);    // StatInit(panel_size, relax);
>     self->StatInit_done = 1;
>   }
> 
>   //printf("Creating matrix structure\n");
>   /* Create matrix structure ; indicate that A is stored by rows (SLU_NR) */
>   dCreate_CompCol_Matrix(&A, n, n, matrix->nnz,
>                          matrix->val, matrix->col, matrix->ind,
>                          SLU_NR, SLU_D, (issym == Py_True) ? SLU_SYL : SLU_GE);
> 
>   //dPrint_CompCol_Matrix("A", &A);
> 
>   //printf("Allocating room for permutations\n");
>   etree = intMalloc(n);
>   self->perm_r = intMalloc(n);
>   self->perm_c = intMalloc(n);
>   if (etree == NULL || self->perm_r == NULL || self->perm_c == NULL) {
>     PyErr_NoMemory();
>     goto fail;
>   }
> 
>   //printf("Obtaining permutation\n");
>   /* Obtain and apply column permutation */
>   get_perm_c(permc_spec, &A, self->perm_c);
>   sp_preorder(&self->options, &A, self->perm_c, etree, &AC);
> 
>   //print_int_vec("\nperm_c", n, self->perm_c);
> 
>   //printf("Factorizing with drop_tol = %g\n", drop_tol);
>   /* Perform factorization (perm_c and perm_r are swapped because our matrix
>    * is stored in compressed-row format and not in compressed-column format! */
>   dgstrf(&self->options, &AC, drop_tol, relax, panel_size,
>          etree, NULL, 0, self->perm_c, self->perm_r,
>          &self->L, &self->U, &self->stat, &info);
> 
>   //dPrint_SuperNode_Matrix("L", &self->L);
>   //dPrint_CompCol_Matrix("U", &self->U);
> 
>   //printf("Freeing memory\n");
>   /* free memory */
>   SUPERLU_FREE(etree);
>   Destroy_SuperMatrix_Store(&A); /* arrays of input matrix will not be freed */
>   Destroy_CompCol_Permuted(&AC);
> 
>   if (info) {
>     if (info < 0)
>       PyErr_SetString(PyExc_SystemError,
>                       "dgstrf was called with invalid arguments");
>     else {
>       if (info <= n) 
> 	PyErr_SetString(PyExc_RuntimeError, "Factor is exactly singular");
>       else
> 	PyErr_NoMemory();
>     }
>     goto fail;
>   }
>   
>   return (PyObject *)self;
> 
>  fail:
>   PyMem_Del(self->perm_r);
>   PyMem_Del(self->perm_c);
>   StatFree(&self->stat);
>   PyObject_Del(self);
>   return NULL;
> }
> 
> static char factorize_doc[] = "factorize(A, ...)\n\
> \n\
> performs a factorization of the sparse matrix A (which is a csr_mat object) and \n\
> return a superlu_context object.\n\
> \n\
> arguments\n\
> ---------\n\
> \n\
> A    spmatrix.csr_mat object.\n\
>      Matrix to be factorized\n\
> \n\
> additional keyword arguments:\n\
> -----------------------------\n\
> \n\
> diag_pivot_thresh   threshhold for partial pivoting.\n\
>                     0.0 <= diag_pivot_thresh <= 1.0\n\
>                     0.0 corresponds to no pivoting\n\
>                     1.0 corresponds to partial pivoting\n\
>                     (default: 1.0)\n\
> \n\
> drop_tol            drop tolerance parameter\n\
>                     0.0 <= drop_tol <= 1.0\n\
>                     0.0 corresponds to exact factorization\n\
>                     CAUTION: the drop_tol is not implemented in SuperLU 2.0\n\
>                     (default: 0.0)\n\
> \n\
> relax               to control degree of relaxing supernodes\n\
>                     (default: 1)\n\
> \n\
> panel_size          a panel consist of at most panel_size consecutive columns.\n\
>                     (default: 10)\n\
> \n\
> permc_spec          specifies the matrix ordering used for the factorization\n\
>                     0: natural ordering\n\
>                     1: MMD applied to the structure of A^T * A\n\
>                     2: MMD applied to the structure of A^T + A\n\
>                     3: COLAMD, approximate minimum degree column ordering\n\
>                     (default: 2)\n\
> ";
> 
> /* ========================================================================== */
> 
> static PyObject *factorize(PyObject *self, PyObject *args, PyObject *keywds) {
>   int n;			/* dimension of matrix */
> 
>   /* default value for SuperLU parameters*/
>   double diag_pivot_thresh = 1.0;
>   double drop_tol = 0.0;
>   PyObject *symmetric = Py_False;
>   int relax = 1;
>   int panel_size = 10;
>   int permc_spec = 2;
>   
>   PyObject *matrix;
>   static char *kwlist[] = {"", "symmetric", "diag_pivot_thresh", "drop_tol",
>                            "relax", "panel_size", "permc_spec", NULL};
> 
>   int res = PyArg_ParseTupleAndKeywords(args, keywds, "O|Oddiii", kwlist, 
> 					&matrix,
>                                         &symmetric,
> 					&diag_pivot_thresh,
> 					&drop_tol,
> 					&relax,
> 					&panel_size,
> 					&permc_spec);
>   if (!res) return NULL;
> 
>   /* check shape of matrix object */
>   if (SpMatrix_GetOrder(matrix, &n)) return NULL;
> 
>   return newSuperLUObject(n, (CSRMatObject *)matrix, symmetric,
>                           diag_pivot_thresh, drop_tol, relax, panel_size,
>                           permc_spec);
> }
> 
> /* ========================================================================== */
> 
> /*
>  *          D e f i n i t i o n   o f   S u p e r L U   m e t h o d s
>  */
> 
> /* ========================================================================== */
> 
> static PyMethodDef SuperLU_methods[] = {
>   {"factorize", (PyCFunction)factorize, METH_VARARGS|METH_KEYWORDS, factorize_doc},
>   {NULL,        NULL,      0,                          NULL         }// sentinel
> };
> 
> /* ========================================================================== */
> 
> DL_EXPORT(void) initsuperlu(void) {
>   PyObject *m, *d;
>   
>   //SuperLUType.ob_type = &PyType_Type;
>   if( PyType_Ready( &SuperLUType ) < 0 ) return;
> 
>   m = Py_InitModule3("superlu", SuperLU_methods, "Python interface to SuperLU");
>   d = PyModule_GetDict(m);
>   PyDict_SetItemString(d, "SuperLUType", (PyObject *)&SuperLUType);
> 
>   import_array();     /* Initialize the NumPy module */
>   import_spmatrix();  /* Initialize PySparse module */
> 
>   /* Check for errors */
>   if (PyErr_Occurred())
>     Py_FatalError("Unable to initialize module superlu");
> 
>   return;
> }
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/superlu/include/Cnames.h pysparse/pysparse/direct/superlu/include/Cnames.h
0a1,197
> /*
>  * -- SuperLU routine (version 2.0) --
>  * Univ. of California Berkeley, Xerox Palo Alto Research Center,
>  * and Lawrence Berkeley National Lab.
>  * November 1, 1997
>  *
>  */
> #ifndef __SUPERLU_CNAMES /* allow multiple inclusions */
> #define __SUPERLU_CNAMES
> 
> /*
>  * These macros define how C routines will be called.  ADD_ assumes that
>  * they will be called by fortran, which expects C routines to have an
>  * underscore postfixed to the name (Suns, and the Intel expect this).
>  * NOCHANGE indicates that fortran will be calling, and that it expects
>  * the name called by fortran to be identical to that compiled by the C
>  * (RS6K's do this).  UPCASE says it expects C routines called by fortran
>  * to be in all upcase (CRAY wants this). 
>  */
> 
> #define ADD_       0
> #define NOCHANGE   1
> #define UPCASE     2
> #define C_CALL     3
> 
> #ifdef UpCase
> #define F77_CALL_C UPCASE
> #endif
> 
> #ifdef NoChange
> #define F77_CALL_C NOCHANGE
> #endif
> 
> #ifdef Add_
> #define F77_CALL_C ADD_
> #endif
> 
> #ifndef F77_CALL_C
> #define F77_CALL_C ADD_
> #endif
> 
> #if (F77_CALL_C == ADD_)
> /*
>  * These defines set up the naming scheme required to have a fortran 77
>  * routine call a C routine
>  * No redefinition necessary to have following Fortran to C interface:
>  *           FORTRAN CALL               C DECLARATION
>  *           call dgemm(...)           void dgemm_(...)
>  *
>  * This is the default.
>  */
> 
> #endif
> 
> #if (F77_CALL_C == UPCASE)
> /*
>  * These defines set up the naming scheme required to have a fortran 77
>  * routine call a C routine 
>  * following Fortran to C interface:
>  *           FORTRAN CALL               C DECLARATION
>  *           call dgemm(...)           void DGEMM(...)
>  */
> #define sasum_    SASUM
> #define isamax_   ISAMAX
> #define scopy_    SCOPY
> #define sscal_    SSCAL
> #define sger_     SGER
> #define snrm2_    SNRM2
> #define ssymv_    SSYMV
> #define sdot_     SDOT
> #define saxpy_    SAXPY
> #define ssyr2_    SSYR2
> #define srot_     SROT
> #define sgemv_    SGEMV
> #define strsv_    STRSV
> #define sgemm_    SGEMM
> #define strsm_    STRSM
> 
> #define dasum_    SASUM
> #define idamax_   ISAMAX
> #define dcopy_    SCOPY
> #define dscal_    SSCAL
> #define dger_     SGER
> #define dnrm2_    SNRM2
> #define dsymv_    SSYMV
> #define ddot_     SDOT
> #define daxpy_    SAXPY
> #define dsyr2_    SSYR2
> #define drot_     SROT
> #define dgemv_    SGEMV
> #define dtrsv_    STRSV
> #define dgemm_    SGEMM
> #define dtrsm_    STRSM
> 
> #define scasum_   SCASUM
> #define icamax_   ICAMAX
> #define ccopy_    CCOPY
> #define cscal_    CSCAL
> #define scnrm2_   SCNRM2
> #define caxpy_    CAXPY
> #define cgemv_    CGEMV
> #define ctrsv_    CTRSV
> #define cgemm_    CGEMM
> #define ctrsm_    CTRSM
> #define cgerc_    CGERC
> #define chemv_    CHEMV
> #define cher2_    CHER2
> 
> #define dzasum_   SCASUM
> #define izamax_   ICAMAX
> #define zcopy_    CCOPY
> #define zscal_    CSCAL
> #define dznrm2_   SCNRM2
> #define zaxpy_    CAXPY
> #define zgemv_    CGEMV
> #define ztrsv_    CTRSV
> #define zgemm_    CGEMM
> #define ztrsm_    CTRSM
> #define zgerc_    CGERC
> #define zhemv_    CHEMV
> #define zher2_    CHER2
> 
> #define c_bridge_dgssv_ C_BRIDGE_DGSSV
> #endif
> 
> #if (F77_CALL_C == NOCHANGE)
> /*
>  * These defines set up the naming scheme required to have a fortran 77
>  * routine call a C routine 
>  * for following Fortran to C interface:
>  *           FORTRAN CALL               C DECLARATION
>  *           call dgemm(...)           void dgemm(...)
>  */
> #define sasum_    sasum
> #define isamax_   isamax
> #define scopy_    scopy
> #define sscal_    sscal
> #define sger_     sger
> #define snrm2_    snrm2
> #define ssymv_    ssymv
> #define sdot_     sdot
> #define saxpy_    saxpy
> #define ssyr2_    ssyr2
> #define srot_     srot
> #define sgemv_    sgemv
> #define strsv_    strsv
> #define sgemm_    sgemm
> #define strsm_    strsm
> 
> #define dasum_    dasum
> #define idamax_   idamax
> #define dcopy_    dcopy
> #define dscal_    dscal
> #define dger_     dger
> #define dnrm2_    dnrm2
> #define dsymv_    dsymv
> #define ddot_     ddot
> #define daxpy_    daxpy
> #define dsyr2_    dsyr2
> #define drot_     drot
> #define dgemv_    dgemv
> #define dtrsv_    dtrsv
> #define dgemm_    dgemm
> #define dtrsm_    dtrsm
> 
> #define scasum_   scasum
> #define icamax_   icamax
> #define ccopy_    ccopy
> #define cscal_    cscal
> #define scnrm2_   scnrm2
> #define caxpy_    caxpy
> #define cgemv_    cgemv
> #define ctrsv_    ctrsv
> #define cgemm_    cgemm
> #define ctrsm_    ctrsm
> #define cgerc_    cgerc
> #define chemv_    chemv
> #define cher2_    cher2
> 
> #define dzasum_   dzasum
> #define izamax_   izamax
> #define zcopy_    zcopy
> #define zscal_    zscal
> #define dznrm2_   dznrm2
> #define zaxpy_    zaxpy
> #define zgemv_    zgemv
> #define ztrsv_    ztrsv
> #define zgemm_    zgemm
> #define ztrsm_    ztrsm
> #define zgerc_    zgerc
> #define zhemv_    zhemv
> #define zher2_    zher2
> 
> #define c_bridge_dgssv_ c_bridge_dgssv
> #endif
> 
> #endif /* __SUPERLU_CNAMES */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/superlu/include/colamd.h pysparse/pysparse/direct/superlu/include/colamd.h
0a1,67
> /* ========================================================================== */
> /* === colamd prototypes and definitions ==================================== */
> /* ========================================================================== */
> 
> /*
>     This is the colamd include file,
> 
> 	http://www.cise.ufl.edu/~davis/colamd/colamd.h
> 
>     for use in the colamd.c, colamdmex.c, and symamdmex.c files located at
> 
> 	http://www.cise.ufl.edu/~davis/colamd/
> 
>     See those files for a description of colamd and symamd, and for the
>     copyright notice, which also applies to this file.
> 
>     August 3, 1998.  Version 1.0.
> */
> 
> /* ========================================================================== */
> /* === Definitions ========================================================== */
> /* ========================================================================== */
> 
> /* size of the knobs [ ] array.  Only knobs [0..1] are currently used. */
> #define COLAMD_KNOBS 20
> 
> /* number of output statistics.  Only A [0..2] are currently used. */
> #define COLAMD_STATS 20
> 
> /* knobs [0] and A [0]: dense row knob and output statistic. */
> #define COLAMD_DENSE_ROW 0
> 
> /* knobs [1] and A [1]: dense column knob and output statistic. */
> #define COLAMD_DENSE_COL 1
> 
> /* A [2]: memory defragmentation count output statistic */
> #define COLAMD_DEFRAG_COUNT 2
> 
> /* A [3]: whether or not the input columns were jumbled or had duplicates */
> #define COLAMD_JUMBLED_COLS 3
> 
> /* ========================================================================== */
> /* === Prototypes of user-callable routines ================================= */
> /* ========================================================================== */
> 
> int colamd_recommended		/* returns recommended value of Alen */
> (
>     int nnz,			/* nonzeros in A */
>     int n_row,			/* number of rows in A */
>     int n_col			/* number of columns in A */
> ) ;
> 
> void colamd_set_defaults	/* sets default parameters */
> (				/* knobs argument is modified on output */
>     double knobs [COLAMD_KNOBS]	/* parameter settings for colamd */
> ) ;
> 
> int colamd			/* returns TRUE if successful, FALSE otherwise*/
> (				/* A and p arguments are modified on output */
>     int n_row,			/* number of rows in A */
>     int n_col,			/* number of columns in A */
>     int Alen,			/* size of the array A */
>     int A [],			/* row indices of A, of size Alen */
>     int p [],			/* column pointers of A, of size n_col+1 */
>     double knobs [COLAMD_KNOBS]	/* parameter settings for colamd */
> ) ;
> 
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/superlu/include/csp_defs.h pysparse/pysparse/direct/superlu/include/csp_defs.h
0a1,252
> 
> 
> /*
>  * -- SuperLU routine (version 2.0) --
>  * Univ. of California Berkeley, Xerox Palo Alto Research Center,
>  * and Lawrence Berkeley National Lab.
>  * November 15, 1997
>  *
>  */
> #ifndef __SUPERLU_cSP_DEFS /* allow multiple inclusions */
> #define __SUPERLU_cSP_DEFS
> 
> /*
>  * File name:		csp_defs.h
>  * Purpose:             Sparse matrix types and function prototypes
>  * History:
>  */
> #ifdef _CRAY
> #include <fortran.h>
> #include <string.h>
> #endif
> #include "Cnames.h"
> #include "supermatrix.h"
> #include "scomplex.h"
> 
> 
> /* No of marker arrays used in the symbolic factorization,
>    each of size n */
> #define NO_MARKER     3
> #define NUM_TEMPV(m,w,t,b)  ( SUPERLU_MAX(m, (t + b)*w) )
> 
> typedef enum {LUSUP, UCOL, LSUB, USUB} MemType;
> typedef enum {HEAD, TAIL}              stack_end_t;
> typedef enum {SYSTEM, USER}            LU_space_t;
> 
> /*
>  * Global data structures used in LU factorization -
>  * 
>  *   nsuper: #supernodes = nsuper + 1, numbered [0, nsuper].
>  *   (xsup,supno): supno[i] is the supernode no to which i belongs;
>  *	xsup(s) points to the beginning of the s-th supernode.
>  *	e.g.   supno 0 1 2 2 3 3 3 4 4 4 4 4   (n=12)
>  *	        xsup 0 1 2 4 7 12
>  *	Note: dfs will be performed on supernode rep. relative to the new 
>  *	      row pivoting ordering
>  *
>  *   (xlsub,lsub): lsub[*] contains the compressed subscript of
>  *	rectangular supernodes; xlsub[j] points to the starting
>  *	location of the j-th column in lsub[*]. Note that xlsub 
>  *	is indexed by column.
>  *	Storage: original row subscripts
>  *
>  *      During the course of sparse LU factorization, we also use
>  *	(xlsub,lsub) for the purpose of symmetric pruning. For each
>  *	supernode {s,s+1,...,t=s+r} with first column s and last
>  *	column t, the subscript set
>  *		lsub[j], j=xlsub[s], .., xlsub[s+1]-1
>  *	is the structure of column s (i.e. structure of this supernode).
>  *	It is used for the storage of numerical values.
>  *	Furthermore,
>  *		lsub[j], j=xlsub[t], .., xlsub[t+1]-1
>  *	is the structure of the last column t of this supernode.
>  *	It is for the purpose of symmetric pruning. Therefore, the
>  *	structural subscripts can be rearranged without making physical
>  *	interchanges among the numerical values.
>  *
>  *	However, if the supernode has only one column, then we
>  *	only keep one set of subscripts. For any subscript interchange
>  *	performed, similar interchange must be done on the numerical
>  *	values.
>  *
>  *	The last column structures (for pruning) will be removed
>  *	after the numercial LU factorization phase.
>  *
>  *   (xlusup,lusup): lusup[*] contains the numerical values of the
>  *	rectangular supernodes; xlusup[j] points to the starting
>  *	location of the j-th column in storage vector lusup[*]
>  *	Note: xlusup is indexed by column.
>  *	Each rectangular supernode is stored by column-major
>  *	scheme, consistent with Fortran 2-dim array storage.
>  *
>  *   (xusub,ucol,usub): ucol[*] stores the numerical values of
>  *	U-columns outside the rectangular supernodes. The row
>  *	subscript of nonzero ucol[k] is stored in usub[k].
>  *	xusub[i] points to the starting location of column i in ucol.
>  *	Storage: new row subscripts; that is subscripts of PA.
>  */
> typedef struct {
>     int     *xsup;    /* supernode and column mapping */
>     int     *supno;   
>     int     *lsub;    /* compressed L subscripts */
>     int	    *xlsub;
>     complex  *lusup;   /* L supernodes */
>     int     *xlusup;
>     complex  *ucol;    /* U columns */
>     int     *usub;
>     int	    *xusub;
>     int     nzlmax;   /* current max size of lsub */
>     int     nzumax;   /*    "    "    "      ucol */
>     int     nzlumax;  /*    "    "    "     lusup */
>     int     n;        /* number of columns in the matrix */
>     LU_space_t MemModel; /* 0 - system malloc'd; 1 - user provided */
> } GlobalLU_t;
> 
> typedef struct {
>     int panel_size;
>     int relax;
>     float diag_pivot_thresh;
>     float drop_tol;
> } factor_param_t;
> 
> typedef struct {
>     float for_lu;
>     float total_needed;
>     int   expansions;
> } mem_usage_t;
> 
> #ifdef __cplusplus
> extern "C" {
> #endif
> 
> /* Driver routines */
> extern void
> cgssv(SuperMatrix *, int *, int *, SuperMatrix *, SuperMatrix *, 
> 	SuperMatrix *, int *);
> extern void
> cgssvx(char *, char *, char *, SuperMatrix *, factor_param_t *,
>        int *, int *, int *, char *, float *, float *,
>        SuperMatrix *, SuperMatrix *, void *, int, SuperMatrix *, 
>        SuperMatrix *, float *, float *, float *,
>        float *, mem_usage_t *, int *);
> 
> /* Supernodal LU factor related */
> extern void
> cCreate_CompCol_Matrix(SuperMatrix *, int, int, int, complex *,
> 		       int *, int *, Stype_t, Dtype_t, Mtype_t);
> extern void
> cCopy_CompCol_Matrix(SuperMatrix *, SuperMatrix *);
> extern void
> cCreate_Dense_Matrix(SuperMatrix *, int, int, complex *, int,
> 		     Stype_t, Dtype_t, Mtype_t);
> extern void
> cCreate_SuperNode_Matrix(SuperMatrix *, int, int, int, complex *, 
> 		         int *, int *, int *, int *, int *,
> 			 Stype_t, Dtype_t, Mtype_t);
> extern void
> cCopy_Dense_Matrix(int, int, complex *, int, complex *, int);
> 
> extern void    Destroy_SuperMatrix_Store(SuperMatrix *);
> extern void    Destroy_CompCol_Matrix(SuperMatrix *);
> extern void    Destroy_SuperNode_Matrix(SuperMatrix *);
> extern void    Destroy_CompCol_Permuted(SuperMatrix *);
> extern void    Destroy_Dense_Matrix(SuperMatrix *);
> extern void    get_perm_c(int, SuperMatrix *, int *);
> extern void    sp_preorder (char*, SuperMatrix*, int*, int*, SuperMatrix*);
> extern void    countnz (const int, int *, int *, int *, GlobalLU_t *);
> extern void    fixupL (const int, const int *, GlobalLU_t *);
> 
> extern void    callocateA (int, int, complex **, int **, int **);
> extern void    cgstrf (char*, SuperMatrix*, float, float, int, int, int*,
> 			void *, int, int *, int *, 
>                         SuperMatrix *, SuperMatrix *, int *);
> extern int     csnode_dfs (const int, const int, const int *, const int *,
> 			     const int *, int *, int *, GlobalLU_t *);
> extern int     csnode_bmod (const int, const int, const int, complex *,
>                               complex *, GlobalLU_t *);
> extern void    cpanel_dfs (const int, const int, const int, SuperMatrix *,
> 			   int *, int *, complex *, int *, int *, int *,
> 			   int *, int *, int *, int *, GlobalLU_t *);
> extern void    cpanel_bmod (const int, const int, const int, const int,
>                            complex *, complex *, int *, int *,
> 			   GlobalLU_t *);
> extern int     ccolumn_dfs (const int, const int, int *, int *, int *, int *,
> 			   int *, int *, int *, int *, int *, GlobalLU_t *);
> extern int     ccolumn_bmod (const int, const int, complex *,
> 			   complex *, int *, int *, int, GlobalLU_t *);
> extern int     ccopy_to_ucol (int, int, int *, int *, int *,
>                               complex *, GlobalLU_t *);         
> extern int     cpivotL (const int, const float, int *, int *, 
>                               int *, int *, int *, GlobalLU_t *);
> extern void    cpruneL (const int, const int *, const int, const int,
> 			     const int *, const int *, int *, GlobalLU_t *);
> extern void    creadmt (int *, int *, int *, complex **, int **, int **);
> extern void    cGenXtrue (int, int, complex *, int);
> extern void    cFillRHS (char *, int, complex *, int, SuperMatrix *,
> 			SuperMatrix *);
> extern void    cgstrs (char *, SuperMatrix *, SuperMatrix *, int *, int *,
> 			SuperMatrix *, int *);
> 
> 
> /* Driver related */
> 
> extern void    cgsequ (SuperMatrix *, float *, float *, float *,
> 			     float *, float *, int *);
> extern void    claqgs (SuperMatrix *, float *, float *, float,
>                              float, float, char *);
> extern void    cgscon (char *, SuperMatrix *, SuperMatrix *, 
> 			float, float *, int *);
> extern float   cPivotGrowth(int, SuperMatrix *, int *, 
>                             SuperMatrix *, SuperMatrix *);
> extern void    cgsrfs (char *, SuperMatrix *, SuperMatrix *,
> 			SuperMatrix *, int *, int *, char *, float *, 
> 			float *, SuperMatrix *, SuperMatrix *, float *,
> 			float *, int *);
> 
> extern int     sp_ctrsv (char *, char *, char *, SuperMatrix *,
> 			SuperMatrix *, complex *, int *);
> extern int     sp_cgemv (char *, complex, SuperMatrix *, complex *,
> 			int, complex, complex *, int);
> 
> extern int     sp_cgemm (char *, char *, int, int, int, complex,
> 			SuperMatrix *, complex *, int, complex, 
> 			complex *, int);
> 
> /* Memory-related */
> extern int     cLUMemInit (char *, void *, int, int, int, int, int,
> 			     SuperMatrix *, SuperMatrix *,
> 			     GlobalLU_t *, int **, complex **);
> extern void    cSetRWork (int, int, complex *, complex **, complex **);
> extern void    cLUWorkFree (int *, complex *, GlobalLU_t *);
> extern int     cLUMemXpand (int, int, MemType, int *, GlobalLU_t *);
> 
> extern complex  *complexMalloc(int);
> extern complex  *complexCalloc(int);
> extern float  *floatMalloc(int);
> extern float  *floatCalloc(int);
> extern int     cmemory_usage(const int, const int, const int, const int);
> extern int     cQuerySpace (SuperMatrix *, SuperMatrix *, int,
> 				mem_usage_t *);
> 
> /* Auxiliary routines */
> extern void    creadhb(int *, int *, int *, complex **, int **, int **);
> extern void    cCompRow_to_CompCol(int, int, int, complex*, int*, int*,
> 		                   complex **, int **, int **);
> extern void    cfill (complex *, int, complex);
> extern void    cinf_norm_error (int, SuperMatrix *, complex *);
> extern void    PrintPerf (SuperMatrix *, SuperMatrix *, mem_usage_t *,
> 			 complex, complex, complex *, complex *, char *);
> 
> /* Routines for debugging */
> extern void    cPrint_CompCol_Matrix(char *, SuperMatrix *);
> extern void    cPrint_SuperNode_Matrix(char *, SuperMatrix *);
> extern void    cPrint_Dense_Matrix(char *, SuperMatrix *);
> extern void    print_lu_col(char *, int, int, int *, GlobalLU_t *);
> extern void    check_tempv(int, complex *);
> 
> #ifdef __cplusplus
>   }
> #endif
> 
> #endif /* __SUPERLU_cSP_DEFS */
> 
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/superlu/include/dcomplex.h pysparse/pysparse/direct/superlu/include/dcomplex.h
0a1,68
> 
> 
> /*
>  * -- SuperLU routine (version 2.0) --
>  * Univ. of California Berkeley, Xerox Palo Alto Research Center,
>  * and Lawrence Berkeley National Lab.
>  * November 15, 1997
>  *
>  */
> #ifndef __SUPERLU_DCOMPLEX /* allow multiple inclusions */
> #define __SUPERLU_DCOMPLEX
> 
> /* 
>  * This header file is to be included in source files z*.c
>  */
> #ifndef DCOMPLEX_INCLUDE
> #define DCOMPLEX_INCLUDE
> 
> typedef struct { double r, i; } doublecomplex;
> 
> 
> /* Macro definitions */
> 
> /* Complex Addition c = a + b */
> #define z_add(c, a, b) { (c)->r = (a)->r + (b)->r; \
> 			 (c)->i = (a)->i + (b)->i; }
> 
> /* Complex Subtraction c = a - b */
> #define z_sub(c, a, b) { (c)->r = (a)->r - (b)->r; \
> 			 (c)->i = (a)->i - (b)->i; }
> 
> /* Complex-Double Multiplication */
> #define zd_mult(c, a, b) { (c)->r = (a)->r * (b); \
>                            (c)->i = (a)->i * (b); }
> 
> /* Complex-Complex Multiplication */
> #define zz_mult(c, a, b) { \
> 	double cr, ci; \
>     	cr = (a)->r * (b)->r - (a)->i * (b)->i; \
>     	ci = (a)->i * (b)->r + (a)->r * (b)->i; \
>     	(c)->r = cr; \
>     	(c)->i = ci; \
>     }
> 
> /* Complex equality testing */
> #define z_eq(a, b)  ( (a)->r == (b)->r && (a)->i == (b)->i )
> 
> 
> #ifdef __cplusplus
> extern "C" {
> #endif
> 
> /* Prototypes for functions in dcomplex.c */
> void z_div(doublecomplex *, doublecomplex *, doublecomplex *);
> double z_abs(doublecomplex *);     /* exact */
> double z_abs1(doublecomplex *);    /* approximate */
> void z_exp(doublecomplex *, doublecomplex *);
> void d_cnjg(doublecomplex *r, doublecomplex *z);
> double d_imag(doublecomplex *);
> 
> 
> #ifdef __cplusplus
>   }
> #endif
> 
> #endif
> 
> #endif  /* __SUPERLU_DCOMPLEX */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/superlu/include/dsp_defs.h pysparse/pysparse/direct/superlu/include/dsp_defs.h
0a1,249
> 
> 
> /*
>  * -- SuperLU routine (version 2.0) --
>  * Univ. of California Berkeley, Xerox Palo Alto Research Center,
>  * and Lawrence Berkeley National Lab.
>  * November 15, 1997
>  *
>  */
> #ifndef __SUPERLU_dSP_DEFS /* allow multiple inclusions */
> #define __SUPERLU_dSP_DEFS
> 
> /*
>  * File name:		dsp_defs.h
>  * Purpose:             Sparse matrix types and function prototypes
>  * History:
>  */
> #ifdef _CRAY
> #include <fortran.h>
> #include <string.h>
> #endif
> #include "Cnames.h"
> #include "supermatrix.h"
> 
> 
> /* No of marker arrays used in the symbolic factorization,
>    each of size n */
> #define NO_MARKER     3
> #define NUM_TEMPV(m,w,t,b)  ( SUPERLU_MAX(m, (t + b)*w) )
> 
> typedef enum {LUSUP, UCOL, LSUB, USUB} MemType;
> typedef enum {HEAD, TAIL}              stack_end_t;
> typedef enum {SYSTEM, USER}            LU_space_t;
> 
> /*
>  * Global data structures used in LU factorization -
>  * 
>  *   nsuper: #supernodes = nsuper + 1, numbered [0, nsuper].
>  *   (xsup,supno): supno[i] is the supernode no to which i belongs;
>  *	xsup(s) points to the beginning of the s-th supernode.
>  *	e.g.   supno 0 1 2 2 3 3 3 4 4 4 4 4   (n=12)
>  *	        xsup 0 1 2 4 7 12
>  *	Note: dfs will be performed on supernode rep. relative to the new 
>  *	      row pivoting ordering
>  *
>  *   (xlsub,lsub): lsub[*] contains the compressed subscript of
>  *	rectangular supernodes; xlsub[j] points to the starting
>  *	location of the j-th column in lsub[*]. Note that xlsub 
>  *	is indexed by column.
>  *	Storage: original row subscripts
>  *
>  *      During the course of sparse LU factorization, we also use
>  *	(xlsub,lsub) for the purpose of symmetric pruning. For each
>  *	supernode {s,s+1,...,t=s+r} with first column s and last
>  *	column t, the subscript set
>  *		lsub[j], j=xlsub[s], .., xlsub[s+1]-1
>  *	is the structure of column s (i.e. structure of this supernode).
>  *	It is used for the storage of numerical values.
>  *	Furthermore,
>  *		lsub[j], j=xlsub[t], .., xlsub[t+1]-1
>  *	is the structure of the last column t of this supernode.
>  *	It is for the purpose of symmetric pruning. Therefore, the
>  *	structural subscripts can be rearranged without making physical
>  *	interchanges among the numerical values.
>  *
>  *	However, if the supernode has only one column, then we
>  *	only keep one set of subscripts. For any subscript interchange
>  *	performed, similar interchange must be done on the numerical
>  *	values.
>  *
>  *	The last column structures (for pruning) will be removed
>  *	after the numercial LU factorization phase.
>  *
>  *   (xlusup,lusup): lusup[*] contains the numerical values of the
>  *	rectangular supernodes; xlusup[j] points to the starting
>  *	location of the j-th column in storage vector lusup[*]
>  *	Note: xlusup is indexed by column.
>  *	Each rectangular supernode is stored by column-major
>  *	scheme, consistent with Fortran 2-dim array storage.
>  *
>  *   (xusub,ucol,usub): ucol[*] stores the numerical values of
>  *	U-columns outside the rectangular supernodes. The row
>  *	subscript of nonzero ucol[k] is stored in usub[k].
>  *	xusub[i] points to the starting location of column i in ucol.
>  *	Storage: new row subscripts; that is subscripts of PA.
>  */
> typedef struct {
>     int     *xsup;    /* supernode and column mapping */
>     int     *supno;   
>     int     *lsub;    /* compressed L subscripts */
>     int	    *xlsub;
>     double  *lusup;   /* L supernodes */
>     int     *xlusup;
>     double  *ucol;    /* U columns */
>     int     *usub;
>     int	    *xusub;
>     int     nzlmax;   /* current max size of lsub */
>     int     nzumax;   /*    "    "    "      ucol */
>     int     nzlumax;  /*    "    "    "     lusup */
>     int     n;        /* number of columns in the matrix */
>     LU_space_t MemModel; /* 0 - system malloc'd; 1 - user provided */
> } GlobalLU_t;
> 
> typedef struct {
>     int panel_size;
>     int relax;
>     double diag_pivot_thresh;
>     double drop_tol;
> } factor_param_t;
> 
> typedef struct {
>     float for_lu;
>     float total_needed;
>     int   expansions;
> } mem_usage_t;
> 
> #ifdef __cplusplus
> extern "C" {
> #endif
> 
> /* Driver routines */
> extern void
> dgssv(SuperMatrix *, int *, int *, SuperMatrix *, SuperMatrix *, 
> 	SuperMatrix *, int *);
> extern void
> dgssvx(char *, char *, char *, SuperMatrix *, factor_param_t *,
>        int *, int *, int *, char *, double *, double *,
>        SuperMatrix *, SuperMatrix *, void *, int, SuperMatrix *, 
>        SuperMatrix *, double *, double *, double *,
>        double *, mem_usage_t *, int *);
> 
> /* Supernodal LU factor related */
> extern void
> dCreate_CompCol_Matrix(SuperMatrix *, int, int, int, double *,
> 		       int *, int *, Stype_t, Dtype_t, Mtype_t);
> extern void
> dCopy_CompCol_Matrix(SuperMatrix *, SuperMatrix *);
> extern void
> dCreate_Dense_Matrix(SuperMatrix *, int, int, double *, int,
> 		     Stype_t, Dtype_t, Mtype_t);
> extern void
> dCreate_SuperNode_Matrix(SuperMatrix *, int, int, int, double *, 
> 		         int *, int *, int *, int *, int *,
> 			 Stype_t, Dtype_t, Mtype_t);
> extern void
> dCopy_Dense_Matrix(int, int, double *, int, double *, int);
> 
> extern void    Destroy_SuperMatrix_Store(SuperMatrix *);
> extern void    Destroy_CompCol_Matrix(SuperMatrix *);
> extern void    Destroy_SuperNode_Matrix(SuperMatrix *);
> extern void    Destroy_CompCol_Permuted(SuperMatrix *);
> extern void    Destroy_Dense_Matrix(SuperMatrix *);
> extern void    get_perm_c(int, SuperMatrix *, int *);
> extern void    sp_preorder (char*, SuperMatrix*, int*, int*, SuperMatrix*);
> extern void    countnz (const int, int *, int *, int *, GlobalLU_t *);
> extern void    fixupL (const int, const int *, GlobalLU_t *);
> 
> extern void    dallocateA (int, int, double **, int **, int **);
> extern void    dgstrf (char*, SuperMatrix*, double, double, int, int, int*,
> 			void *, int, int *, int *, 
>                         SuperMatrix *, SuperMatrix *, int *);
> extern int     dsnode_dfs (const int, const int, const int *, const int *,
> 			     const int *, int *, int *, GlobalLU_t *);
> extern int     dsnode_bmod (const int, const int, const int, double *,
>                               double *, GlobalLU_t *);
> extern void    dpanel_dfs (const int, const int, const int, SuperMatrix *,
> 			   int *, int *, double *, int *, int *, int *,
> 			   int *, int *, int *, int *, GlobalLU_t *);
> extern void    dpanel_bmod (const int, const int, const int, const int,
>                            double *, double *, int *, int *,
> 			   GlobalLU_t *);
> extern int     dcolumn_dfs (const int, const int, int *, int *, int *, int *,
> 			   int *, int *, int *, int *, int *, GlobalLU_t *);
> extern int     dcolumn_bmod (const int, const int, double *,
> 			   double *, int *, int *, int, GlobalLU_t *);
> extern int     dcopy_to_ucol (int, int, int *, int *, int *,
>                               double *, GlobalLU_t *);         
> extern int     dpivotL (const int, const double, int *, int *, 
>                               int *, int *, int *, GlobalLU_t *);
> extern void    dpruneL (const int, const int *, const int, const int,
> 			     const int *, const int *, int *, GlobalLU_t *);
> extern void    dreadmt (int *, int *, int *, double **, int **, int **);
> extern void    dGenXtrue (int, int, double *, int);
> extern void    dFillRHS (char *, int, double *, int, SuperMatrix *,
> 			SuperMatrix *);
> extern void    dgstrs (char *, SuperMatrix *, SuperMatrix *, int *, int *,
> 			SuperMatrix *, int *);
> 
> 
> /* Driver related */
> 
> extern void    dgsequ (SuperMatrix *, double *, double *, double *,
> 			     double *, double *, int *);
> extern void    dlaqgs (SuperMatrix *, double *, double *, double,
>                              double, double, char *);
> extern void    dgscon (char *, SuperMatrix *, SuperMatrix *,
> 			double, double *, int *);
> extern double  dPivotGrowth(int, SuperMatrix *, int *, 
>                             SuperMatrix *, SuperMatrix *);
> extern void    dgsrfs (char *, SuperMatrix *, SuperMatrix *, 
> 			SuperMatrix *, int *, int *, char *, double *,
> 			double *, SuperMatrix *, SuperMatrix *, 
> 			double *, double *, int *);
> 
> extern int     sp_dtrsv (char *, char *, char *, SuperMatrix *,
> 			SuperMatrix *, double *, int *);
> extern int     sp_dgemv (char *, double, SuperMatrix *, double *,
> 			int, double, double *, int);
> 
> extern int     sp_dgemm (char *, char *, int, int, int, double,
> 			SuperMatrix *, double *, int, double, 
> 			double *, int);
> 
> /* Memory-related */
> extern int     dLUMemInit (char *, void *, int, int, int, int, int,
> 			     SuperMatrix *, SuperMatrix *,
> 			     GlobalLU_t *, int **, double **);
> extern void    dSetRWork (int, int, double *, double **, double **);
> extern void    dLUWorkFree (int *, double *, GlobalLU_t *);
> extern int     dLUMemXpand (int, int, MemType, int *, GlobalLU_t *);
> 
> extern double  *doubleMalloc(int);
> extern double  *doubleCalloc(int);
> extern int     dmemory_usage(const int, const int, const int, const int);
> extern int     dQuerySpace (SuperMatrix *, SuperMatrix *, int,
> 				mem_usage_t *);
> 
> /* Auxiliary routines */
> extern void    dreadhb(int *, int *, int *, double **, int **, int **);
> extern void    dCompRow_to_CompCol(int, int, int, double*, int*, int*,
> 		                   double **, int **, int **);
> extern void    dfill (double *, int, double);
> extern void    dinf_norm_error (int, SuperMatrix *, double *);
> extern void    PrintPerf (SuperMatrix *, SuperMatrix *, mem_usage_t *,
> 			 double, double, double *, double *, char *);
> 
> /* Routines for debugging */
> extern void    dPrint_CompCol_Matrix(char *, SuperMatrix *);
> extern void    dPrint_SuperNode_Matrix(char *, SuperMatrix *);
> extern void    dPrint_Dense_Matrix(char *, SuperMatrix *);
> extern void    print_lu_col(char *, int, int, int *, GlobalLU_t *);
> extern void    check_tempv(int, double *);
> 
> #ifdef __cplusplus
>   }
> #endif
> 
> #endif /* __SUPERLU_dSP_DEFS */
> 
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/superlu/include/scomplex.h pysparse/pysparse/direct/superlu/include/scomplex.h
0a1,68
> 
> 
> /*
>  * -- SuperLU routine (version 2.0) --
>  * Univ. of California Berkeley, Xerox Palo Alto Research Center,
>  * and Lawrence Berkeley National Lab.
>  * November 15, 1997
>  *
>  */
> #ifndef __SUPERLU_SCOMPLEX /* allow multiple inclusions */
> #define __SUPERLU_SCOMPLEX
> 
> /* 
>  * This header file is to be included in source files c*.c
>  */
> #ifndef SCOMPLEX_INCLUDE
> #define SCOMPLEX_INCLUDE
> 
> typedef struct { float r, i; } complex;
> 
> 
> /* Macro definitions */
> 
> /* Complex Addition c = a + b */
> #define c_add(c, a, b) { (c)->r = (a)->r + (b)->r; \
> 			 (c)->i = (a)->i + (b)->i; }
> 
> /* Complex Subtraction c = a - b */
> #define c_sub(c, a, b) { (c)->r = (a)->r - (b)->r; \
> 			 (c)->i = (a)->i - (b)->i; }
> 
> /* Complex-Double Multiplication */
> #define cs_mult(c, a, b) { (c)->r = (a)->r * (b); \
>                            (c)->i = (a)->i * (b); }
> 
> /* Complex-Complex Multiplication */
> #define cc_mult(c, a, b) { \
> 	float cr, ci; \
>     	cr = (a)->r * (b)->r - (a)->i * (b)->i; \
>     	ci = (a)->i * (b)->r + (a)->r * (b)->i; \
>     	(c)->r = cr; \
>     	(c)->i = ci; \
>     }
> 
> /* Complex equality testing */
> #define c_eq(a, b)  ( (a)->r == (b)->r && (a)->i == (b)->i )
> 
> 
> #ifdef __cplusplus
> extern "C" {
> #endif
> 
> /* Prototypes for functions in scomplex.c */
> void c_div(complex *, complex *, complex *);
> double c_abs(complex *);     /* exact */
> double c_abs1(complex *);    /* approximate */
> void c_exp(complex *, complex *);
> void r_cnjg(complex *, complex *);
> double r_imag(complex *);
> 
> 
> #ifdef __cplusplus
>   }
> #endif
> 
> #endif
> 
> #endif  /* __SUPERLU_SCOMPLEX */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/superlu/include/ssp_defs.h pysparse/pysparse/direct/superlu/include/ssp_defs.h
0a1,249
> 
> 
> /*
>  * -- SuperLU routine (version 2.0) --
>  * Univ. of California Berkeley, Xerox Palo Alto Research Center,
>  * and Lawrence Berkeley National Lab.
>  * November 15, 1997
>  *
>  */
> #ifndef __SUPERLU_sSP_DEFS /* allow multiple inclusions */
> #define __SUPERLU_sSP_DEFS
> 
> /*
>  * File name:		ssp_defs.h
>  * Purpose:             Sparse matrix types and function prototypes
>  * History:
>  */
> #ifdef _CRAY
> #include <fortran.h>
> #include <string.h>
> #endif
> #include "Cnames.h"
> #include "supermatrix.h"
> 
> 
> /* No of marker arrays used in the symbolic factorization,
>    each of size n */
> #define NO_MARKER     3
> #define NUM_TEMPV(m,w,t,b)  ( SUPERLU_MAX(m, (t + b)*w) )
> 
> typedef enum {LUSUP, UCOL, LSUB, USUB} MemType;
> typedef enum {HEAD, TAIL}              stack_end_t;
> typedef enum {SYSTEM, USER}            LU_space_t;
> 
> /*
>  * Global data structures used in LU factorization -
>  * 
>  *   nsuper: #supernodes = nsuper + 1, numbered [0, nsuper].
>  *   (xsup,supno): supno[i] is the supernode no to which i belongs;
>  *	xsup(s) points to the beginning of the s-th supernode.
>  *	e.g.   supno 0 1 2 2 3 3 3 4 4 4 4 4   (n=12)
>  *	        xsup 0 1 2 4 7 12
>  *	Note: dfs will be performed on supernode rep. relative to the new 
>  *	      row pivoting ordering
>  *
>  *   (xlsub,lsub): lsub[*] contains the compressed subscript of
>  *	rectangular supernodes; xlsub[j] points to the starting
>  *	location of the j-th column in lsub[*]. Note that xlsub 
>  *	is indexed by column.
>  *	Storage: original row subscripts
>  *
>  *      During the course of sparse LU factorization, we also use
>  *	(xlsub,lsub) for the purpose of symmetric pruning. For each
>  *	supernode {s,s+1,...,t=s+r} with first column s and last
>  *	column t, the subscript set
>  *		lsub[j], j=xlsub[s], .., xlsub[s+1]-1
>  *	is the structure of column s (i.e. structure of this supernode).
>  *	It is used for the storage of numerical values.
>  *	Furthermore,
>  *		lsub[j], j=xlsub[t], .., xlsub[t+1]-1
>  *	is the structure of the last column t of this supernode.
>  *	It is for the purpose of symmetric pruning. Therefore, the
>  *	structural subscripts can be rearranged without making physical
>  *	interchanges among the numerical values.
>  *
>  *	However, if the supernode has only one column, then we
>  *	only keep one set of subscripts. For any subscript interchange
>  *	performed, similar interchange must be done on the numerical
>  *	values.
>  *
>  *	The last column structures (for pruning) will be removed
>  *	after the numercial LU factorization phase.
>  *
>  *   (xlusup,lusup): lusup[*] contains the numerical values of the
>  *	rectangular supernodes; xlusup[j] points to the starting
>  *	location of the j-th column in storage vector lusup[*]
>  *	Note: xlusup is indexed by column.
>  *	Each rectangular supernode is stored by column-major
>  *	scheme, consistent with Fortran 2-dim array storage.
>  *
>  *   (xusub,ucol,usub): ucol[*] stores the numerical values of
>  *	U-columns outside the rectangular supernodes. The row
>  *	subscript of nonzero ucol[k] is stored in usub[k].
>  *	xusub[i] points to the starting location of column i in ucol.
>  *	Storage: new row subscripts; that is subscripts of PA.
>  */
> typedef struct {
>     int     *xsup;    /* supernode and column mapping */
>     int     *supno;   
>     int     *lsub;    /* compressed L subscripts */
>     int	    *xlsub;
>     float  *lusup;   /* L supernodes */
>     int     *xlusup;
>     float  *ucol;    /* U columns */
>     int     *usub;
>     int	    *xusub;
>     int     nzlmax;   /* current max size of lsub */
>     int     nzumax;   /*    "    "    "      ucol */
>     int     nzlumax;  /*    "    "    "     lusup */
>     int     n;        /* number of columns in the matrix */
>     LU_space_t MemModel; /* 0 - system malloc'd; 1 - user provided */
> } GlobalLU_t;
> 
> typedef struct {
>     int panel_size;
>     int relax;
>     float diag_pivot_thresh;
>     float drop_tol;
> } factor_param_t;
> 
> typedef struct {
>     float for_lu;
>     float total_needed;
>     int   expansions;
> } mem_usage_t;
> 
> #ifdef __cplusplus
> extern "C" {
> #endif
> 
> /* Driver routines */
> extern void
> sgssv(SuperMatrix *, int *, int *, SuperMatrix *, SuperMatrix *, 
> 	SuperMatrix *, int *);
> extern void
> sgssvx(char *, char *, char *, SuperMatrix *, factor_param_t *,
>        int *, int *, int *, char *, float *, float *,
>        SuperMatrix *, SuperMatrix *, void *, int, SuperMatrix *, 
>        SuperMatrix *, float *, float *, float *,
>        float *, mem_usage_t *, int *);
> 
> /* Supernodal LU factor related */
> extern void
> sCreate_CompCol_Matrix(SuperMatrix *, int, int, int, float *,
> 		       int *, int *, Stype_t, Dtype_t, Mtype_t);
> extern void
> sCopy_CompCol_Matrix(SuperMatrix *, SuperMatrix *);
> extern void
> sCreate_Dense_Matrix(SuperMatrix *, int, int, float *, int,
> 		     Stype_t, Dtype_t, Mtype_t);
> extern void
> sCreate_SuperNode_Matrix(SuperMatrix *, int, int, int, float *, 
> 		         int *, int *, int *, int *, int *,
> 			 Stype_t, Dtype_t, Mtype_t);
> extern void
> sCopy_Dense_Matrix(int, int, float *, int, float *, int);
> 
> extern void    Destroy_SuperMatrix_Store(SuperMatrix *);
> extern void    Destroy_CompCol_Matrix(SuperMatrix *);
> extern void    Destroy_SuperNode_Matrix(SuperMatrix *);
> extern void    Destroy_CompCol_Permuted(SuperMatrix *);
> extern void    Destroy_Dense_Matrix(SuperMatrix *);
> extern void    get_perm_c(int, SuperMatrix *, int *);
> extern void    sp_preorder (char*, SuperMatrix*, int*, int*, SuperMatrix*);
> extern void    countnz (const int, int *, int *, int *, GlobalLU_t *);
> extern void    fixupL (const int, const int *, GlobalLU_t *);
> 
> extern void    sallocateA (int, int, float **, int **, int **);
> extern void    sgstrf (char*, SuperMatrix*, float, float, int, int, int*,
> 			void *, int, int *, int *, 
>                         SuperMatrix *, SuperMatrix *, int *);
> extern int     ssnode_dfs (const int, const int, const int *, const int *,
> 			     const int *, int *, int *, GlobalLU_t *);
> extern int     ssnode_bmod (const int, const int, const int, float *,
>                               float *, GlobalLU_t *);
> extern void    spanel_dfs (const int, const int, const int, SuperMatrix *,
> 			   int *, int *, float *, int *, int *, int *,
> 			   int *, int *, int *, int *, GlobalLU_t *);
> extern void    spanel_bmod (const int, const int, const int, const int,
>                            float *, float *, int *, int *,
> 			   GlobalLU_t *);
> extern int     scolumn_dfs (const int, const int, int *, int *, int *, int *,
> 			   int *, int *, int *, int *, int *, GlobalLU_t *);
> extern int     scolumn_bmod (const int, const int, float *,
> 			   float *, int *, int *, int, GlobalLU_t *);
> extern int     scopy_to_ucol (int, int, int *, int *, int *,
>                               float *, GlobalLU_t *);         
> extern int     spivotL (const int, const float, int *, int *, 
>                               int *, int *, int *, GlobalLU_t *);
> extern void    spruneL (const int, const int *, const int, const int,
> 			     const int *, const int *, int *, GlobalLU_t *);
> extern void    sreadmt (int *, int *, int *, float **, int **, int **);
> extern void    sGenXtrue (int, int, float *, int);
> extern void    sFillRHS (char *, int, float *, int, SuperMatrix *,
> 			SuperMatrix *);
> extern void    sgstrs (char *, SuperMatrix *, SuperMatrix *, int *, int *,
> 			SuperMatrix *, int *);
> 
> 
> /* Driver related */
> 
> extern void    sgsequ (SuperMatrix *, float *, float *, float *,
> 			     float *, float *, int *);
> extern void    slaqgs (SuperMatrix *, float *, float *, float,
>                              float, float, char *);
> extern void    sgscon (char *, SuperMatrix *, SuperMatrix *, 
> 			float, float *, int *);
> extern float   sPivotGrowth(int, SuperMatrix *, int *, 
>                             SuperMatrix *, SuperMatrix *);
> extern void    sgsrfs (char *, SuperMatrix *, SuperMatrix *,
> 			SuperMatrix *, int *, int *, char *, float *, 
> 			float *, SuperMatrix *, SuperMatrix *, float *,
> 			float *, int *);
> 
> extern int     sp_strsv (char *, char *, char *, SuperMatrix *,
> 			SuperMatrix *, float *, int *);
> extern int     sp_sgemv (char *, float, SuperMatrix *, float *,
> 			int, float, float *, int);
> 
> extern int     sp_sgemm (char *, char *, int, int, int, float,
> 			SuperMatrix *, float *, int, float, 
> 			float *, int);
> 
> /* Memory-related */
> extern int     sLUMemInit (char *, void *, int, int, int, int, int,
> 			     SuperMatrix *, SuperMatrix *,
> 			     GlobalLU_t *, int **, float **);
> extern void    sSetRWork (int, int, float *, float **, float **);
> extern void    sLUWorkFree (int *, float *, GlobalLU_t *);
> extern int     sLUMemXpand (int, int, MemType, int *, GlobalLU_t *);
> 
> extern float  *floatMalloc(int);
> extern float  *floatCalloc(int);
> extern int     smemory_usage(const int, const int, const int, const int);
> extern int     sQuerySpace (SuperMatrix *, SuperMatrix *, int,
> 				mem_usage_t *);
> 
> /* Auxiliary routines */
> extern void    sreadhb(int *, int *, int *, float **, int **, int **);
> extern void    sCompRow_to_CompCol(int, int, int, float*, int*, int*,
> 		                   float **, int **, int **);
> extern void    sfill (float *, int, float);
> extern void    sinf_norm_error (int, SuperMatrix *, float *);
> extern void    PrintPerf (SuperMatrix *, SuperMatrix *, mem_usage_t *,
> 			 float, float, float *, float *, char *);
> 
> /* Routines for debugging */
> extern void    sPrint_CompCol_Matrix(char *, SuperMatrix *);
> extern void    sPrint_SuperNode_Matrix(char *, SuperMatrix *);
> extern void    sPrint_Dense_Matrix(char *, SuperMatrix *);
> extern void    print_lu_col(char *, int, int, int *, GlobalLU_t *);
> extern void    check_tempv(int, float *);
> 
> #ifdef __cplusplus
>   }
> #endif
> 
> #endif /* __SUPERLU_sSP_DEFS */
> 
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/superlu/include/supermatrix.h pysparse/pysparse/direct/superlu/include/supermatrix.h
0a1,143
> #ifndef __SUPERLU_SUPERMATRIX /* allow multiple inclusions */
> #define __SUPERLU_SUPERMATRIX
> 
> /********************************************
>  * The matrix types are defined as follows. *
>  ********************************************/
> typedef enum {
>     NC,        /* column-wise, no supernode */
>     NR,        /* row-wize, no supernode */
>     SC,        /* column-wise, supernode */
>     SR,        /* row-wise, supernode */
>     NCP,       /* column-wise, column-permuted, no supernode 
>                   (The consecutive columns of nonzeros, after permutation,
> 		   may not be stored  contiguously.) */
>     DN         /* Fortran style column-wise storage for dense matrix */
> } Stype_t;
> 
> typedef enum {
>     S_,         /* single */
>     D_,         /* double */
>     C_,         /* single complex */
>     Z_          /* double complex */
> } Dtype_t;
> 
> typedef enum {
>     GE,        /* general */
>     TRLU,      /* lower triangular, unit diagonal */
>     TRUU,      /* upper triangular, unit diagonal */
>     TRL,       /* lower triangular */
>     TRU,       /* upper triangular */
>     SYL,       /* symmetric, store lower half */
>     SYU,       /* symmetric, store upper half */
>     HEL,       /* Hermitian, store lower half */
>     HEU        /* Hermitian, store upper half */
> } Mtype_t;
> 
> typedef struct {
> 	Stype_t Stype; /* Storage type: interprets the storage structure 
> 		   	  pointed to by *Store. */
> 	Dtype_t Dtype; /* Data type. */
> 	Mtype_t Mtype; /* Matrix type: describes the mathematical property of 
> 			  the matrix. */
> 	int  nrow;     /* number of rows */
> 	int  ncol;     /* number of columns */
> 	void *Store;   /* pointer to the actual storage of the matrix */
> } SuperMatrix;
> 
> /***********************************************
>  * The storage schemes are defined as follows. *
>  ***********************************************/
> 
> /* Stype == NC (Also known as Harwell-Boeing sparse matrix format (CCS)) */
> typedef struct {
>     int  nnz;	  /* number of nonzeros in the matrix */
>     void *nzval;  /* pointer to array of nonzero values, packed by column */
>     int  *rowind; /* pointer to array of row indices of the nonzeros */
>     int  *colptr; /* pointer to array of beginning of columns in nzval[] 
>                      and rowind[]  */
>                   /* Note:
> 		     Zero-based indexing is used;
> 		     nzval[] and rowind[] are of the same length, nnz;
> 		     colptr[] has ncol+1 entries, the last one pointing
> 		     beyond the last column, so that colptr[ncol] = nnz. */
> } NCformat;
> 
> /* Stype == NR (Also known as row compressed storage (RCS). */
> typedef struct {
>     int  nnz;	  /* number of nonzeros in the matrix */
>     void *nzval;  /* pointer to array of nonzero values, packed by row */
>     int  *colind; /* pointer to array of column indices of the nonzeros */
>     int  *rowptr; /* pointer to array of beginning of rows in nzval[] 
>                      and colind[]  */
>                   /* Note:
> 		     Zero-based indexing is used;
> 		     nzval[] and colind[] are of the same length, nnz;
> 		     rowptr[] has nrow+1 entries, the last one pointing
> 		     beyond the last column, so that rowptr[nrow] = nnz. */
> } NRformat;
> 
> /* Stype == SC */
> typedef struct {
>   int  nnz;	     /* number of nonzeros in the matrix */
>   int  nsuper;       /* number of supernodes, minus 1 */
>   void *nzval;       /* pointer to array of nonzero values, packed by column */
>   int  *nzval_colptr;/* pointer to array of beginning of columns in nzval[] */
>   int  *rowind;      /* pointer to array of compressed row indices of 
> 			rectangular supernodes */
>   int *rowind_colptr;/* pointer to array of beginning of columns in rowind[] */
>   int *col_to_sup;   /* col_to_sup[j] is the supernode number to which column 
> 			j belongs; mapping from column to supernode number. */
>   int *sup_to_col;   /* sup_to_col[s] points to the start of the s-th 
> 			supernode; mapping from supernode number to column.
> 		        e.g.: col_to_sup: 0 1 2 2 3 3 3 4 4 4 4 4 (ncol=12)
> 		              sup_to_col: 0 1 2 4 7 12            (nsuper=4) */
>                      /* Note:
> 		        Zero-based indexing is used;
> 		        nzval_colptr[], rowind_colptr[], col_to_sup[] and
> 		        sup_to_col[] have ncol+1 entries, the last one
> 		        pointing beyond the last column.
> 		        For col_to_sup[], only the first ncol entries are
> 		        defined. For sup_to_col[], only the first nsuper+2
> 		        entries are defined. */
> } SCformat;
> 
> /* Stype == NCP */
> typedef struct {
>     int nnz;	  /* number of nonzeros in the matrix */
>     void *nzval;  /* pointer to array of nonzero values, packed by column */
>     int *rowind;  /* pointer to array of row indices of the nonzeros */
> 		  /* Note: nzval[]/rowind[] always have the same length */
>     int *colbeg;  /* colbeg[j] points to the beginning of column j in nzval[] 
>                      and rowind[]  */
>     int *colend;  /* colend[j] points to one past the last element of column
> 		     j in nzval[] and rowind[]  */
> 		  /* Note:
> 		     Zero-based indexing is used;
> 		     nzval[] and rowind[] are of the same length, nnz;
> 		     colbeg[] and colend[] are of the same length, ncol;
> 		     The consecutive columns of the nonzeros may not be 
> 		     contiguous in storage, because the matrix has been 
> 		     postmultiplied by a column permutation matrix. */
> } NCPformat;
> 
> /* Stype == DN */
> typedef struct {
>     int lda;      /* leading dimension */
>     void *nzval;  /* array of size lda*ncol to represent a dense matrix */
> } DNformat;
> 
> 
> 
> /*********************************************************
>  * Macros used for easy access of sparse matrix entries. *
>  *********************************************************/
> #define L_SUB_START(col)     ( Lstore->rowind_colptr[col] )
> #define L_SUB(ptr)           ( Lstore->rowind[ptr] )
> #define L_NZ_START(col)      ( Lstore->nzval_colptr[col] )
> #define L_FST_SUPC(superno)  ( Lstore->sup_to_col[superno] )
> #define U_NZ_START(col)      ( Ustore->colptr[col] )
> #define U_SUB(ptr)           ( Ustore->rowind[ptr] )
> 
> 
> #endif  /* __SUPERLU_SUPERMATRIX */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/superlu/include/util.h pysparse/pysparse/direct/superlu/include/util.h
0a1,116
> #ifndef __SUPERLU_UTIL /* allow multiple inclusions */
> #define __SUPERLU_UTIL
> 
> #include <stdio.h>
> #include <stdlib.h>
> #include <string.h>
> #include <assert.h>
> 
> /* Macros */
> #ifndef USER_ABORT
> #define USER_ABORT(msg) superlu_abort_and_exit(msg)
> #endif
> 
> #define ABORT(err_msg) \
>  { char msg[256];\
>    sprintf(msg,"%s at line %d in file %s\n",err_msg,__LINE__, __FILE__);\
>    USER_ABORT(msg); }
> 
> 
> #ifndef USER_MALLOC
> #define USER_MALLOC(size) superlu_malloc(size)
> #endif
> 
> #define SUPERLU_MALLOC(size) USER_MALLOC(size)
> 
> #ifndef USER_FREE
> #define USER_FREE(addr) superlu_free(addr)
> #endif
> 
> #define SUPERLU_FREE(addr) USER_FREE(addr)
> 
> 
> #define SUPERLU_MAX(x, y) 	( (x) > (y) ? (x) : (y) )
> #define SUPERLU_MIN(x, y) 	( (x) < (y) ? (x) : (y) )
> 
> /* 
>  * Constants 
>  */
> #define EMPTY	(-1)
> #define NO	(-1)
> #define FALSE	0
> #define TRUE	1
> 
> /*
>  * Type definitions
>  */
> typedef float    flops_t;
> typedef unsigned char Logical;
> 
> /* 
>  * The following enumerate type is used by the statistics variable 
>  * SuperLUStat, to keep track of flop count and time spent at various stages.
>  *
>  * Note that not all of the fields are disjoint.
>  */
> typedef enum {
>     COLPERM, /* find a column ordering that minimizes fills */
>     RELAX,   /* find artificial supernodes */
>     ETREE,   /* compute column etree */
>     EQUIL,   /* equilibrate the original matrix */
>     FACT,    /* perform LU factorization */
>     RCOND,   /* estimate reciprocal condition number */
>     SOLVE,   /* forward and back solves */
>     REFINE,  /* perform iterative refinement */
>     FLOAT,   /* time spent in floating-point operations */
>     TRSV,    /* fraction of FACT spent in xTRSV */
>     GEMV,    /* fraction of FACT spent in xGEMV */
>     FERR,    /* estimate error bounds after iterative refinement */
>     NPHASES  /* total number of phases */
> } PhaseType;
> 
> typedef struct {
>     int     *panel_histo; /* histogram of panel size distribution */
>     double  *utime;       /* running time at various phases */
>     flops_t *ops;         /* operation count at various phases */
> } SuperLUStat_t;
> 
> /* Macros */
> #define FIRSTCOL_OF_SNODE(i)	(xsup[i])
> 
> 
> #ifdef __cplusplus
> extern "C" {
> #endif
> 
> extern void    superlu_abort_and_exit(char*);
> extern void    *superlu_malloc (size_t);
> extern int     *intMalloc (int);
> extern int     *intCalloc (int);
> extern void    superlu_free (void*);
> extern void    SetIWork (int, int, int, int *, int **, int **, int **,
>                          int **, int **, int **, int **);
> extern void    StatInit(int, int);
> extern void    StatFree();
> extern int     sp_coletree (int *, int *, int *, int, int, int *);
> extern void    relax_snode (const int, int *, const int, int *, int *);
> extern void    resetrep_col (const int, const int *, int *);
> extern int     spcoletree (int *, int *, int *, int, int, int *);
> extern int     *TreePostorder (int, int *);
> extern double  SuperLU_timer_ ();
> extern int     sp_ienv (int);
> extern int     lsame_ (char *, char *);
> extern int     xerbla_ (char *, int *);
> extern void    ifill (int *, int, int);
> extern void    snode_profile (int, int *);
> extern void    super_stats (int, int *);
> extern void    PrintSumm (char *, int, int, int);
> extern void    PrintStat (SuperLUStat_t *);
> extern void    print_panel_seg(int, int, int, int, int *, int *);
> extern void    check_repfnz(int, int, int, int *);
> 
> #ifdef __cplusplus
>   }
> #endif
> 
> #endif /* __SUPERLU_UTIL */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/superlu/include/zsp_defs.h pysparse/pysparse/direct/superlu/include/zsp_defs.h
0a1,252
> 
> 
> /*
>  * -- SuperLU routine (version 2.0) --
>  * Univ. of California Berkeley, Xerox Palo Alto Research Center,
>  * and Lawrence Berkeley National Lab.
>  * November 15, 1997
>  *
>  */
> #ifndef __SUPERLU_zSP_DEFS /* allow multiple inclusions */
> #define __SUPERLU_zSP_DEFS
> 
> /*
>  * File name:		zsp_defs.h
>  * Purpose:             Sparse matrix types and function prototypes
>  * History:
>  */
> #ifdef _CRAY
> #include <fortran.h>
> #include <string.h>
> #endif
> #include "Cnames.h"
> #include "supermatrix.h"
> #include "dcomplex.h"
> 
> 
> /* No of marker arrays used in the symbolic factorization,
>    each of size n */
> #define NO_MARKER     3
> #define NUM_TEMPV(m,w,t,b)  ( SUPERLU_MAX(m, (t + b)*w) )
> 
> typedef enum {LUSUP, UCOL, LSUB, USUB} MemType;
> typedef enum {HEAD, TAIL}              stack_end_t;
> typedef enum {SYSTEM, USER}            LU_space_t;
> 
> /*
>  * Global data structures used in LU factorization -
>  * 
>  *   nsuper: #supernodes = nsuper + 1, numbered [0, nsuper].
>  *   (xsup,supno): supno[i] is the supernode no to which i belongs;
>  *	xsup(s) points to the beginning of the s-th supernode.
>  *	e.g.   supno 0 1 2 2 3 3 3 4 4 4 4 4   (n=12)
>  *	        xsup 0 1 2 4 7 12
>  *	Note: dfs will be performed on supernode rep. relative to the new 
>  *	      row pivoting ordering
>  *
>  *   (xlsub,lsub): lsub[*] contains the compressed subscript of
>  *	rectangular supernodes; xlsub[j] points to the starting
>  *	location of the j-th column in lsub[*]. Note that xlsub 
>  *	is indexed by column.
>  *	Storage: original row subscripts
>  *
>  *      During the course of sparse LU factorization, we also use
>  *	(xlsub,lsub) for the purpose of symmetric pruning. For each
>  *	supernode {s,s+1,...,t=s+r} with first column s and last
>  *	column t, the subscript set
>  *		lsub[j], j=xlsub[s], .., xlsub[s+1]-1
>  *	is the structure of column s (i.e. structure of this supernode).
>  *	It is used for the storage of numerical values.
>  *	Furthermore,
>  *		lsub[j], j=xlsub[t], .., xlsub[t+1]-1
>  *	is the structure of the last column t of this supernode.
>  *	It is for the purpose of symmetric pruning. Therefore, the
>  *	structural subscripts can be rearranged without making physical
>  *	interchanges among the numerical values.
>  *
>  *	However, if the supernode has only one column, then we
>  *	only keep one set of subscripts. For any subscript interchange
>  *	performed, similar interchange must be done on the numerical
>  *	values.
>  *
>  *	The last column structures (for pruning) will be removed
>  *	after the numercial LU factorization phase.
>  *
>  *   (xlusup,lusup): lusup[*] contains the numerical values of the
>  *	rectangular supernodes; xlusup[j] points to the starting
>  *	location of the j-th column in storage vector lusup[*]
>  *	Note: xlusup is indexed by column.
>  *	Each rectangular supernode is stored by column-major
>  *	scheme, consistent with Fortran 2-dim array storage.
>  *
>  *   (xusub,ucol,usub): ucol[*] stores the numerical values of
>  *	U-columns outside the rectangular supernodes. The row
>  *	subscript of nonzero ucol[k] is stored in usub[k].
>  *	xusub[i] points to the starting location of column i in ucol.
>  *	Storage: new row subscripts; that is subscripts of PA.
>  */
> typedef struct {
>     int     *xsup;    /* supernode and column mapping */
>     int     *supno;   
>     int     *lsub;    /* compressed L subscripts */
>     int	    *xlsub;
>     doublecomplex  *lusup;   /* L supernodes */
>     int     *xlusup;
>     doublecomplex  *ucol;    /* U columns */
>     int     *usub;
>     int	    *xusub;
>     int     nzlmax;   /* current max size of lsub */
>     int     nzumax;   /*    "    "    "      ucol */
>     int     nzlumax;  /*    "    "    "     lusup */
>     int     n;        /* number of columns in the matrix */
>     LU_space_t MemModel; /* 0 - system malloc'd; 1 - user provided */
> } GlobalLU_t;
> 
> typedef struct {
>     int panel_size;
>     int relax;
>     double diag_pivot_thresh;
>     double drop_tol;
> } factor_param_t;
> 
> typedef struct {
>     float for_lu;
>     float total_needed;
>     int   expansions;
> } mem_usage_t;
> 
> #ifdef __cplusplus
> extern "C" {
> #endif
> 
> /* Driver routines */
> extern void
> zgssv(SuperMatrix *, int *, int *, SuperMatrix *, SuperMatrix *, 
> 	SuperMatrix *, int *);
> extern void
> zgssvx(char *, char *, char *, SuperMatrix *, factor_param_t *,
>        int *, int *, int *, char *, double *, double *,
>        SuperMatrix *, SuperMatrix *, void *, int, SuperMatrix *, 
>        SuperMatrix *, double *, double *, double *,
>        double *, mem_usage_t *, int *);
> 
> /* Supernodal LU factor related */
> extern void
> zCreate_CompCol_Matrix(SuperMatrix *, int, int, int, doublecomplex *,
> 		       int *, int *, Stype_t, Dtype_t, Mtype_t);
> extern void
> zCopy_CompCol_Matrix(SuperMatrix *, SuperMatrix *);
> extern void
> zCreate_Dense_Matrix(SuperMatrix *, int, int, doublecomplex *, int,
> 		     Stype_t, Dtype_t, Mtype_t);
> extern void
> zCreate_SuperNode_Matrix(SuperMatrix *, int, int, int, doublecomplex *, 
> 		         int *, int *, int *, int *, int *,
> 			 Stype_t, Dtype_t, Mtype_t);
> extern void
> zCopy_Dense_Matrix(int, int, doublecomplex *, int, doublecomplex *, int);
> 
> extern void    Destroy_SuperMatrix_Store(SuperMatrix *);
> extern void    Destroy_CompCol_Matrix(SuperMatrix *);
> extern void    Destroy_SuperNode_Matrix(SuperMatrix *);
> extern void    Destroy_CompCol_Permuted(SuperMatrix *);
> extern void    Destroy_Dense_Matrix(SuperMatrix *);
> extern void    get_perm_c(int, SuperMatrix *, int *);
> extern void    sp_preorder (char*, SuperMatrix*, int*, int*, SuperMatrix*);
> extern void    countnz (const int, int *, int *, int *, GlobalLU_t *);
> extern void    fixupL (const int, const int *, GlobalLU_t *);
> 
> extern void    zallocateA (int, int, doublecomplex **, int **, int **);
> extern void    zgstrf (char*, SuperMatrix*, double, double, int, int, int*,
> 			void *, int, int *, int *, 
>                         SuperMatrix *, SuperMatrix *, int *);
> extern int     zsnode_dfs (const int, const int, const int *, const int *,
> 			     const int *, int *, int *, GlobalLU_t *);
> extern int     zsnode_bmod (const int, const int, const int, doublecomplex *,
>                               doublecomplex *, GlobalLU_t *);
> extern void    zpanel_dfs (const int, const int, const int, SuperMatrix *,
> 			   int *, int *, doublecomplex *, int *, int *, int *,
> 			   int *, int *, int *, int *, GlobalLU_t *);
> extern void    zpanel_bmod (const int, const int, const int, const int,
>                            doublecomplex *, doublecomplex *, int *, int *,
> 			   GlobalLU_t *);
> extern int     zcolumn_dfs (const int, const int, int *, int *, int *, int *,
> 			   int *, int *, int *, int *, int *, GlobalLU_t *);
> extern int     zcolumn_bmod (const int, const int, doublecomplex *,
> 			   doublecomplex *, int *, int *, int, GlobalLU_t *);
> extern int     zcopy_to_ucol (int, int, int *, int *, int *,
>                               doublecomplex *, GlobalLU_t *);         
> extern int     zpivotL (const int, const double, int *, int *, 
>                               int *, int *, int *, GlobalLU_t *);
> extern void    zpruneL (const int, const int *, const int, const int,
> 			     const int *, const int *, int *, GlobalLU_t *);
> extern void    zreadmt (int *, int *, int *, doublecomplex **, int **, int **);
> extern void    zGenXtrue (int, int, doublecomplex *, int);
> extern void    zFillRHS (char *, int, doublecomplex *, int, SuperMatrix *,
> 			SuperMatrix *);
> extern void    zgstrs (char *, SuperMatrix *, SuperMatrix *, int *, int *,
> 			SuperMatrix *, int *);
> 
> 
> /* Driver related */
> 
> extern void    zgsequ (SuperMatrix *, double *, double *, double *,
> 			     double *, double *, int *);
> extern void    zlaqgs (SuperMatrix *, double *, double *, double,
>                              double, double, char *);
> extern void    zgscon (char *, SuperMatrix *, SuperMatrix *,
> 			double, double *, int *);
> extern double  zPivotGrowth(int, SuperMatrix *, int *, 
>                             SuperMatrix *, SuperMatrix *);
> extern void    zgsrfs (char *, SuperMatrix *, SuperMatrix *, 
> 			SuperMatrix *, int *, int *, char *, double *,
> 			double *, SuperMatrix *, SuperMatrix *, 
> 			double *, double *, int *);
> 
> extern int     sp_ztrsv (char *, char *, char *, SuperMatrix *,
> 			SuperMatrix *, doublecomplex *, int *);
> extern int     sp_zgemv (char *, doublecomplex, SuperMatrix *, doublecomplex *,
> 			int, doublecomplex, doublecomplex *, int);
> 
> extern int     sp_zgemm (char *, char *, int, int, int, doublecomplex,
> 			SuperMatrix *, doublecomplex *, int, doublecomplex, 
> 			doublecomplex *, int);
> 
> /* Memory-related */
> extern int     zLUMemInit (char *, void *, int, int, int, int, int,
> 			     SuperMatrix *, SuperMatrix *,
> 			     GlobalLU_t *, int **, doublecomplex **);
> extern void    zSetRWork (int, int, doublecomplex *, doublecomplex **, doublecomplex **);
> extern void    zLUWorkFree (int *, doublecomplex *, GlobalLU_t *);
> extern int     zLUMemXpand (int, int, MemType, int *, GlobalLU_t *);
> 
> extern doublecomplex  *doublecomplexMalloc(int);
> extern doublecomplex  *doublecomplexCalloc(int);
> extern double  *doubleMalloc(int);
> extern double  *doubleCalloc(int);
> extern int     zmemory_usage(const int, const int, const int, const int);
> extern int     zQuerySpace (SuperMatrix *, SuperMatrix *, int,
> 				mem_usage_t *);
> 
> /* Auxiliary routines */
> extern void    zreadhb(int *, int *, int *, doublecomplex **, int **, int **);
> extern void    zCompRow_to_CompCol(int, int, int, doublecomplex*, int*, int*,
> 		                   doublecomplex **, int **, int **);
> extern void    zfill (doublecomplex *, int, doublecomplex);
> extern void    zinf_norm_error (int, SuperMatrix *, doublecomplex *);
> extern void    PrintPerf (SuperMatrix *, SuperMatrix *, mem_usage_t *,
> 			 doublecomplex, doublecomplex, doublecomplex *, doublecomplex *, char *);
> 
> /* Routines for debugging */
> extern void    zPrint_CompCol_Matrix(char *, SuperMatrix *);
> extern void    zPrint_SuperNode_Matrix(char *, SuperMatrix *);
> extern void    zPrint_Dense_Matrix(char *, SuperMatrix *);
> extern void    print_lu_col(char *, int, int, int *, GlobalLU_t *);
> extern void    check_tempv(int, doublecomplex *);
> 
> #ifdef __cplusplus
>   }
> #endif
> 
> #endif /* __SUPERLU_zSP_DEFS */
> 
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/superlu/src/list.txt pysparse/pysparse/direct/superlu/src/list.txt
0a1,43
> dcolumn_bmod.c
> dcolumn_dfs.c
> dcomplex.c
> scomplex.c
> dcopy_to_ucol.c
> dgscon.c
> dgsequ.c
> dgsrfs.c
> dgssv.c
> dgssvx.c
> dgstrf.c
> dgstrs.c
> dlacon.c
> dlamch.c
> dlangs.c
> dlaqgs.c
> dmemory.c
> colamd.c
> dpanel_bmod.c
> dpanel_dfs.c
> dpivotL.c
> dpivotgrowth.c
> dpruneL.c
> dreadhb.c
> dsnode_bmod.c
> dsnode_dfs.c
> dsp_blas2.c
> dsp_blas3.c
> superlu_timer.c
> dutil.c
> dzsum1.c
> get_perm_c.c
> icmax1.c
> izmax1.c
> lsame.c
> memory.c
> mmd.c
> relax_snode.c
> sp_coletree.c
> sp_ienv.c
> sp_preorder.c
> util.c
> xerbla.c
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/License pysparse/pysparse/direct/umfpack/License
0a1,57
> The UMFPACK library in this directory is a modified version of the original
> which is available at http://www.cise.ufl.edu/research/sparse/umfpack. The license
> for the use of UMFPACK is available below.
> 
> UMFPACK Version 4.1 (Apr. 30, 2003),  Copyright (c) 2003 by Timothy A.
> Davis.  All Rights Reserved.
> 
> UMFPACK License:
> 
>     Your use or distribution of UMFPACK or any modified version of
>     UMFPACK implies that you agree to this License.
> 
>     THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
>     EXPRESSED OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.
> 
>     Permission is hereby granted to use or copy this program, provided
>     that the Copyright, this License, and the Availability of the original
>     version is retained on all copies.  User documentation of any code that
>     uses UMFPACK or any modified version of UMFPACK code must cite the
>     Copyright, this License, the Availability note, and "Used by permission."
>     Permission to modify the code and to distribute modified code is granted,
>     provided the Copyright, this License, and the Availability note are
>     retained, and a notice that the code was modified is included.  This
>     software was developed with support from the National Science Foundation,
>     and is provided to you free of charge.
> 
> Availability:
> 
>     http://www.cise.ufl.edu/research/sparse/umfpack
> 
> --------------------------------------------------------------------------------
> 
> AMD Version 1.0 (Apr. 30, 2003),  Copyright (c) 2003 by Timothy A.
> Davis, Patrick R. Amestoy, and Iain S. Duff.  All Rights Reserved.
> 
> AMD License:
> 
>     Your use or distribution of AMD or any modified version of
>     AMD implies that you agree to this License.
> 
>     THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
>     EXPRESSED OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.
> 
>     Permission is hereby granted to use or copy this program, provided
>     that the Copyright, this License, and the Availability of the original
>     version is retained on all copies.  User documentation of any code that
>     uses AMD or any modified version of AMD code must cite the
>     Copyright, this License, the Availability note, and "Used by permission."
>     Permission to modify the code and to distribute modified code is granted,
>     provided the Copyright, this License, and the Availability note are
>     retained, and a notice that the code was modified is included.  This
>     software was developed with support from the National Science Foundation,
>     and is provided to you free of charge.
> 
> Availability:
> 
>     http://www.cise.ufl.edu/research/sparse/amd
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_2by2.h pysparse/pysparse/direct/umfpack/include/umf_2by2.h
0a1,37
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL void UMF_2by2
> (
>     Int n,
>     const Int Ap [ ],
>     const Int Ai [ ],
>     const double Ax [ ],
> #ifdef COMPLEX
>     const double Az [ ],
> #endif
>     double tol,
>     Int scale,
>     Int Cperm1 [ ],
> #ifndef NDEBUG
>     Int Rperm1 [ ],
> #endif
>     Int InvRperm [ ],
>     Int n1,
>     Int nempty,
>     Int Degree [ ],
>     Int P [ ],
>     Int *p_nweak,
>     Int *p_nmatched,
>     Int Ri [ ],
>     Int Rp [ ],
>     double Rs [ ],
>     Int Head [ ],
>     Int Next [ ],
>     Int Si [ ],
>     Int Sp [ ]
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_analyze.h pysparse/pysparse/direct/umfpack/include/umf_analyze.h
0a1,24
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL Int UMF_analyze
> (
>     Int n_row,
>     Int n_col,
>     Int Ai [ ],
>     Int Ap [ ],
>     Int Up [ ],
>     Int fixQ,
>     Int Front_ncols [ ],
>     Int W [ ],
>     Int Link [ ],
>     Int Front_nrows [ ],
>     Int Front_npivcol [ ],
>     Int Front_parent [ ],
>     Int *nfr_out,
>     Int *p_ncompactions
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_apply_order.h pysparse/pysparse/direct/umfpack/include/umf_apply_order.h
0a1,15
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL void UMF_apply_order
> (
>     Int Front [ ],
>     const Int Order [ ],
>     Int Temp [ ],
>     Int n_col,
>     Int nfr
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_assemble.h pysparse/pysparse/direct/umfpack/include/umf_assemble.h
0a1,18
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL void UMF_assemble
> (
>     NumericType *Numeric,
>     WorkType *Work
> ) ;
> 
> GLOBAL void UMF_assemble_fixq
> (
>     NumericType *Numeric,
>     WorkType *Work
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_blas3_update.h pysparse/pysparse/direct/umfpack/include/umf_blas3_update.h
0a1,11
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL void UMF_blas3_update
> (
>     WorkType *Work
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_build_tuples.h pysparse/pysparse/direct/umfpack/include/umf_build_tuples.h
0a1,12
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL Int UMF_build_tuples
> (
>     NumericType *Numeric,
>     WorkType *Work
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_colamd.h pysparse/pysparse/direct/umfpack/include/umf_colamd.h
0a1,256
> /* ========================================================================== */
> /* === umf_colamd.h ========================================================= */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> /*
> 
> Authors:
> 
>     The authors of the COLAMD code itself are Stefan I. Larimore and Timothy A.
>     Davis, University of Florida.  The algorithm was developed in collaboration
>     with John Gilbert, Xerox PARC, and Esmond Ng, Oak Ridge National Laboratory.
> 
> Date:
> 
>     UMFPACK Version: see above.
>     COLAMD Version 2.0 was released on January 31, 2000.
> 
> Acknowledgements:
> 
>     This work was supported by the National Science Foundation, under
>     grants DMS-9504974 and DMS-9803599.
> 
> UMFPACK:  Copyright (c) 2003 by Timothy A. Davis.  All Rights Reserved.
> 
> See the UMFPACK README file for the License for your use of this code.
> 
> Availability:
> 
>     Both UMFPACK and the original unmodified colamd/symamd library are
>     available at http://www.cise.ufl.edu/research/sparse.
> 
> */
> 
> #ifndef COLAMD_H
> #define COLAMD_H
> 
> /* ========================================================================== */
> /* === Include files ======================================================== */
> /* ========================================================================== */
> 
> #include <stdlib.h>
> 
> /* ========================================================================== */
> /* === Knob and statistics definitions ====================================== */
> /* ========================================================================== */
> 
> /* size of the knobs [ ] array.  Only knobs [0..2] are currently used. */
> #define COLAMD_KNOBS 20
> 
> /* number of output statistics.  Only stats [0..8] are currently used. */
> #define COLAMD_STATS 20
> 
> /* knobs [0] and stats [0]: dense row knob and output statistic. */
> #define COLAMD_DENSE_ROW 0
> 
> /* knobs [1] and stats [1]: dense column knob and output statistic. */
> #define COLAMD_DENSE_COL 1
> 
> /* knobs [2]: aggressive absorption option */
> #define COLAMD_AGGRESSIVE 2
> 
> /* stats [2]: memory defragmentation count output statistic */
> #define COLAMD_DEFRAG_COUNT 2
> 
> /* stats [3]: colamd status:  zero OK, > 0 warning or notice, < 0 error */
> #define COLAMD_STATUS 3
> 
> /* stats [4..6]: error info, or info on jumbled columns */
> #define COLAMD_INFO1 4
> #define COLAMD_INFO2 5
> #define COLAMD_INFO3 6
> 
> /* ------------------ */
> /* added for UMFPACK: */
> /* stats [7]: number of originally empty rows */
> #define COLAMD_EMPTY_ROW 7
> /* stats [8]: number of originally empty cols */
> #define COLAMD_EMPTY_COL 8
> /* stats [9]: number of rows with entries only in dense cols */
> #define COLAMD_NEWLY_EMPTY_ROW 9
> /* stats [10]: number of cols with entries only in dense rows */
> #define COLAMD_NEWLY_EMPTY_COL 10
> /* ------------------ */
> 
> /* error codes returned in stats [3]: */
> #define COLAMD_OK				(0)
> #define COLAMD_ERROR_jumbled_matrix		(-11)
> #define COLAMD_ERROR_A_not_present		(-1)
> #define COLAMD_ERROR_p_not_present		(-2)
> #define COLAMD_ERROR_nrow_negative		(-3)
> #define COLAMD_ERROR_ncol_negative		(-4)
> #define COLAMD_ERROR_nnz_negative		(-5)
> #define COLAMD_ERROR_p0_nonzero			(-6)
> #define COLAMD_ERROR_A_too_small		(-7)
> #define COLAMD_ERROR_col_length_negative	(-8)
> #define COLAMD_ERROR_row_index_out_of_bounds	(-9)
> #define COLAMD_ERROR_out_of_memory		(-10)
> #define COLAMD_ERROR_internal_error		(-999)
> 
> /* ========================================================================== */
> /* === Row and Column structures ============================================ */
> /* ========================================================================== */
> 
> /* User code that makes use of the colamd/symamd routines need not directly */
> /* reference these structures.  They are used only for the COLAMD_RECOMMENDED */
> /* macro. */
> 
> typedef struct Colamd_Col_struct
> {
>     Int start ;		/* index for A of first row in this column, or DEAD */
> 			/* if column is dead */
>     Int length ;	/* number of rows in this column */
>     union
>     {
> 	Int thickness ;	/* number of original columns represented by this */
> 			/* col, if the column is alive */
> 	Int parent ;	/* parent in parent tree super-column structure, if */
> 			/* the column is dead */
>     } shared1 ;
>     union
>     {
> 	Int score ;	/* the score used to maintain heap, if col is alive */
> 	Int order ;	/* pivot ordering of this column, if col is dead */
>     } shared2 ;
>     union
>     {
> 	Int headhash ;	/* head of a hash bucket, if col is at the head of */
> 			/* a degree list */
> 	Int hash ;	/* hash value, if col is not in a degree list */
> 	Int prev ;	/* previous column in degree list, if col is in a */
> 			/* degree list (but not at the head of a degree list) */
>     } shared3 ;
>     union
>     {
> 	Int degree_next ;	/* next column, if col is in a degree list */
> 	Int hash_next ;		/* next column, if col is in a hash list */
>     } shared4 ;
> 
>     /* ------------------ */
>     /* added for UMFPACK: */
>     Int nextcol ;	/* next column in this supercolumn */
>     Int lastcol ;	/* last column in this supercolumn */
>     /* ------------------ */
> 
> } Colamd_Col ;
> 
> typedef struct Colamd_Row_struct
> {
>     Int start ;		/* index for A of first col in this row */
>     Int length ;	/* number of principal columns in this row */
>     union
>     {
> 	Int degree ;	/* number of principal & non-principal columns in row */
> 	Int p ;		/* used as a row pointer in init_rows_cols () */
>     } shared1 ;
>     union
>     {
> 	Int mark ;	/* for computing set differences and marking dead rows*/
> 	Int first_column ;/* first column in row (used in garbage collection) */
>     } shared2 ;
> 
>     /* ------------------ */
>     /* added for UMFPACK: */
>     Int thickness ;	/* number of original rows represented by this row */
> 			/* that are not yet pivotal */
>     Int front ;		/* -1 if an original row */
> 			/* k if this row represents the kth frontal matrix */
> 			/* where k goes from 0 to at most n_col-1 */
>     /* ------------------ */
> 
> } Colamd_Row ;
> 
> 
> 
> /* ========================================================================== */
> /* === Colamd recommended memory size ======================================= */
> /* ========================================================================== */
> 
> /*
>     The recommended length Alen of the array A passed to colamd is given by
>     the COLAMD_RECOMMENDED (nnz, n_row, n_col) macro.  It returns -1 if any
>     argument is negative.  2*nnz space is required for the row and column
>     indices of the matrix. COLAMD_C (n_col) + COLAMD_R (n_row) space is
>     required for the Col and Row arrays, respectively, which are internal to
>     colamd.  An additional n_col space is the minimal amount of "elbow room",
>     and nnz/5 more space is recommended for run time efficiency.
> 
>     This macro is not needed when using symamd.
> */
> 
> /* about 8*(n_col+1) integers: */
> #define UMF_COLAMD_C(n_col) ((n_col + 1) * sizeof (Colamd_Col) / sizeof (Int))
> 
> /* about 6*(n_row+1) integers: */
> #define UMF_COLAMD_R(n_row) ((n_row + 1) * sizeof (Colamd_Row) / sizeof (Int))
> 
> /* UMFPACK:  make sure Alen is >= 5*n_col + size of Col and Row structures.
>  * Alen is typically about 2.2*nz + 9*n_col + 6*n_row, or 2.2nz+15n for
>  * square matrices. */
> #define UMF_COLAMD_RECOMMENDED(nnz, n_row, n_col)	\
> (							\
> ((nnz) < 0 || (n_row) < 0 || (n_col) < 0)		\
> ?							\
>     (-1)						\
> :							\
>     (MAX (2 * (nnz), 4 * (n_col)) +			\
>     (Int) UMF_COLAMD_C (n_col) +			\
>     (Int) UMF_COLAMD_R (n_row) + (n_col) + ((nnz) / 5))	\
> )
> 
> /* ========================================================================== */
> /* === Prototypes of user-callable routines ================================= */
> /* ========================================================================== */
> 
> /* colamd_recommended removed for UMFPACK */
> 
> void UMF_colamd_set_defaults	/* sets default parameters */
> (				/* knobs argument is modified on output */
>     double knobs [COLAMD_KNOBS]	/* parameter settings for colamd */
> ) ;
> 
> Int UMF_colamd			/* returns (1) if successful, (0) otherwise*/
> (				/* A and p arguments are modified on output */
>     Int n_row,			/* number of rows in A */
>     Int n_col,			/* number of columns in A */
>     Int Alen,			/* size of the array A */
>     Int A [],			/* row indices of A, of size Alen */
>     Int p [],			/* column pointers of A, of size n_col+1 */
>     double knobs [COLAMD_KNOBS],/* parameter settings for colamd */
>     Int stats [COLAMD_STATS]	/* colamd output statistics and error codes */
>     /* ------------------ */
>     /* added for UMFPACK: */
>     , Int Front_npivcol [ ]
>     , Int Front_nrows [ ]
>     , Int Front_ncols [ ]
>     , Int Front_parent [ ]
>     , Int Front_cols [ ]
>     , Int *p_nfr
>     , Int InFront [ ]
>     /* ------------------ */
> ) ;
> 
> /* symamd deleted for UMFPACK */
> 
> /* colamd_report deleted for UMFPACK */
> 
> /* symamd_report deleted for UMFPACK */
> 
> #endif /* COLAMD_H */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_config.h pysparse/pysparse/direct/umfpack/include/umf_config.h
0a1,911
> /* ========================================================================== */
> /* === umf_config.h ========================================================= */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> /*
>     This file controls the compile-time configuration of UMFPACK.  Modify the
>     Makefile, the architecture-dependent Make.* file, and this file if
>     necessary, to control these options.  The following flags may be given
>     as options to your C compiler (as in "cc -DNBLAS", for example).  These
>     flags are normally placed in your CONFIG string, defined in your Make.*.
> 
>     All of these options, except for the timer, are for accessing the BLAS.
> 
> 	-DNBLAS
> 
> 	    BLAS mode.  If -DNBLAS is set, then no BLAS will be used.  Vanilla
> 	    C code will be used instead.  This is portable, and easier to
> 	    install, but you won't get the best performance.
> 
> 	    If -DNBLAS is not set, then externally-available BLAS routines
> 	    (dgemm, dger, and dgemv or the equivalent C-BLAS routines) will be
> 	    used.  This will give you the best performance, but perhaps at the
> 	    expense of portability.
> 
> 	    The default is to use the BLAS, for both the C-callable libumfpack.a
> 	    library and the MATLAB mexFunction.  If you have trouble installing
> 	    UMFPACK, set -DNBLAS (but then UMFPACK will be slow).
> 
> 	-DCBLAS
> 
> 	    If -DCBLAS is set, then the C-BLAS interface to the BLAS is
> 	    used.  If your vendor-supplied BLAS library does not have a C-BLAS
> 	    interface, you can obtain the ATLAS BLAS, available at
> 	    http://www.netlib.org/atlas.
> 
> 	    This flag is ignored if -DNBLAS is set.
> 
> 	-DLP64
> 
> 	    This should be defined if you are compiling in the LP64 model
> 	    (32 bit int's, 64 bit long's, and 64 bit pointers).  In Solaris,
> 	    this is obtained with the flags -xtarget=ultra -xarch=v9 for
> 	    the cc compiler (for example).
> 
> 	-DLONGBLAS
> 
> 	    If not defined, then the BLAS are not called in the long integer
> 	    version of UMFPACK (the umfpack_*l_* routines).  The most common
> 	    definitions of the BLAS, unfortunately, use int arguments, and
> 	    are thus not suitable for use in the LP64 model.  Only the Sun
> 	    Performance Library, as far as I can tell, has a version of the
> 	    BLAS that allows long integer (64-bit) input arguments.  This
> 	    flag is set automatically in Sun Solaris if you are using the
> 	    Sun Performance BLAS.  You can set it yourself, too, if your BLAS
> 	    routines can take long integer input arguments.
> 
> 	-DNSUNPERF
> 
> 	    Applies only to Sun Solaris.  If -DNSUNPERF is set, then the Sun
> 	    Performance Library BLAS will not be used.
> 
> 	    The Sun Performance Library BLAS is used by default when compiling
> 	    the C-callable libumfpack.a library on Sun Solaris.
> 
> 	    This flag is ignored if -DNBLAS is set.
> 
> 	-DNSCSL
> 
> 	    Applies only to SGI IRIX.  If -DSCSL is set, then the SGI SCSL
> 	    Scientific Library BLAS will not be used.
> 
> 	    The SGI SCSL Scientific Library BLAS is used by default when
> 	    compiling the C-callable libumfpack.a library on SGI IRIX.
> 
> 	    This flag is ignored if -DNBLAS is set.
> 
> 	-DNPOSIX
> 
> 	    If -DNPOSIX is set, then your Unix operating system is not POSIX-
> 	    compliant, and the POSIX routines sysconf ( ) and times ( )
> 	    routines are not used.  These routines provide CPU time and
> 	    wallclock time information.  If -DNPOSIX is set, then the ANSI
> 	    C clock ( ) routine is used.  If -DNPOSIX is not set, then
> 	    sysconf ( ) and times ( ) are used in umfpack_tic and umfpack_toc.
> 	    See umfpack_tictoc.c for more information.
> 	    The default is to use the POSIX routines, except for Windows,
> 	    which is not POSIX-compliant.
> 
> 	-DGETRUSAGE
> 
> 	    If -DGETRUSAGE is set, then your system's getrusage ( ) routine
> 	    will be used for getting the process CPU time.  Otherwise the ANSI
> 	    C clock ( ) routine will be used.  The default is to use getrusage
> 	    ( ) on Unix systems, and to use clock on all other architectures.
> 
> 	-DNUTIL
> 
> 	    If -DNUTIL is set, then the internal MATLAB utMalloc, utFree, and
> 	    utRealloc routines are not used in the UMFPACK mexFunction.  The
> 	    regular mxMalloc, mxFree, and mxRealloc routines are used instead.
> 	    These routines are not documented, but are available for use.  For
> 	    Windows, -DNUTIL is defined below, because access to the ut*
> 	    routines is not available by default.
> 
> 	-DNRECIPROCAL
> 
> 	    This option controls a tradeoff between speed and accuracy.  Using
> 	    -DNRECIPROCAL can lead to more accurate results, but with perhaps
> 	    some cost in performance, particularly if floating-point division
> 	    is much more costly than floating-point multiplication.
> 
> 	    This option determines the method used to scale the pivot column.
> 	    If set, or if the absolute value of the pivot is < 1e-12 (or is a
> 	    NaN), then the pivot column is divided by the pivot value.
> 	    Otherwise, the reciprocal of the pivot value is computed, and the
> 	    pivot column is multiplied by (1/pivot).  Multiplying by the
> 	    reciprocal can be slightly less accurate than dividing by the
> 	    pivot, but it is often faster.  See umf_scale.c.
> 
> 	    This has a small effect on the performance of UMFPACK, at least on
> 	    a Pentium 4M.  It may have a larger effect on other architectures
> 	    where floating-point division is much more costly than floating-
> 	    point multiplication.  The RS 6000 is one such example.
> 
> 	    By default, the method chosen is to multiply by the reciprocal
> 	    (sacrificing accuracy for speed), except when compiling UMFPACK
> 	    as a built-in routine in MATLAB, or when gcc is being used.
> 
> 	    When MATHWORKS is defined, -DNRECIPROCAL is forced on, and the pivot
> 	    column is divided by the pivot value.  The only way of using the
> 	    other method in this case is to edit this file.
> 
> 	    If -DNRECIPROCAL is enabled, then the row scaling factors are always
> 	    applied by dividing each row by the scale factor, rather than
> 	    multiplying by the reciprocal.  If -DNRECIPROCAL is not enabled
> 	    (the default case), then the scale factors are normally applied by
> 	    multiplying by the reciprocal.  If, however, the smallest scale
> 	    factor is tiny, then the scale factors are applied via division.
> 
>     You should normally not set these flags yourself:
> 
> 	-DBLAS_BY_VALUE		if scalars are passed by value, not reference
> 	-DBLAS_NO_UNDERSCORE	if no underscore should be appended
> 	-DBLAS_CHAR_ARG		if BLAS options are single char's, not strings
> 
> 	    The BLAS options are normally set automatically.  If your
> 	    architecture cannot be determined (see UMFPACK_ARCHITECTURE, below)
> 	    then you may need to set these flags yourself.
> 
>     The following options are controlled by amd_internal.h:
> 
> 	-DMATLAB_MEX_FILE
> 
> 	    This flag is turned on when compiling the umfpack mexFunction for
> 	    use in MATLAB.  When compiling the MATLAB mexFunction, the MATLAB
> 	    BLAS are used (unless -DNBLAS is set).  The -DCBLAS, -DNSCSL, and
> 	    -DNSUNPERF flags are all ignored.   The -DNRECIPROCAL flag is
> 	    forced on.  Otherwise, [L,U,P,Q,R] = umfpack (A) would return
> 	    either L*U = P*(R\A)*Q or L*U = P*R*A*Q.  Rather than returning a
> 	    flag stating how the scale factors R are to be applied, the umfpack
> 	    mexFunction always takes the more accurate route and returns
> 	    L*U = P*(R\A)*Q.
> 
> 	-DMATHWORKS
> 
> 	    This flag is turned on when compiling umfpack as a built-in routine
> 	    in MATLAB.  The MATLAB BLAS are used for all architectures (-DNBLAS,
> 	    -DCBLAS, -DNSCSL, and -DNSUNPERF flags are all ignored).  Internal
> 	    routines utMalloc, utFree, utRealloc, utPrintf, utDivideComplex,
> 	    and utFdlibm_hypot are used, and the "util.h" file is included.
> 	    This avoids the problem discussed in the User Guide regarding memory
> 	    allocation in MATLAB.  utMalloc returns NULL on failure, instead of
> 	    terminating the mexFunction (which is what mxMalloc does).  However,
> 	    the ut* routines are not documented by The MathWorks, Inc., so I
> 	    cannot guarantee that you will always be able to use them.
> 	    The -DNRECIPROCAL flag is turned on.
> 
> 	-DNDEBUG
> 
> 	    Debugging mode (if NDEBUG is not defined).  The default, of course,
> 	    is no debugging.  Turning on debugging takes some work (see below).
> 	    If you do not edit this file, then debugging is turned off anyway,
> 	    regardless of whether or not -DNDEBUG is specified in your compiler
> 	    options.
> */
> 
> /* ========================================================================== */
> /* === AMD configuration ==================================================== */
> /* ========================================================================== */
> 
> /* NDEBUG, PRINTF defined in amd_internal.h */
> 
> /* ========================================================================== */
> /* === reciprocal option ==================================================== */
> /* ========================================================================== */
> 
> /* Force the definition NRECIPROCAL when MATHWORKS or MATLAB_MEX_FILE
>  * are defined.  Do not multiply by the reciprocal in those cases. */
> 
> #ifndef NRECIPROCAL
> #if defined (MATHWORKS) || defined (MATLAB_MEX_FILE)
> #define NRECIPROCAL
> #endif
> #endif
> 
> /* ========================================================================== */
> /* === Microsoft Windows configuration ====================================== */
> /* ========================================================================== */
> 
> #ifdef UMF_WINDOWS
> /* Windows can't access the ut* routines, and it isn't Unix. */
> #define NUTIL
> #define NPOSIX
> #endif
> 
> /* ========================================================================== */
> /* === 0-based or 1-based printing ========================================== */
> /* ========================================================================== */
> 
> #if defined (MATLAB_MEX_FILE) && defined (NDEBUG)
> /* In MATLAB, matrices are 1-based to the user, but 0-based internally. */
> /* One is added to all row and column indices when printing matrices */
> /* for the MATLAB user.  The +1 shift is turned off when debugging. */
> #define INDEX(i) ((i)+1)
> #else
> /* In ANSI C, matrices are 0-based and indices are reported as such. */
> /* This mode is also used for debug mode, and if MATHWORKS is defined rather */
> /* than MATLAB_MEX_FILE. */
> #define INDEX(i) (i)
> #endif
> 
> /* ========================================================================== */
> /* === Timer ================================================================ */
> /* ========================================================================== */
> 
> /*
>     If you have the getrusage routine (all Unix systems I've test do), then use
>     that.  Otherwise, use the ANSI C clock function.   Note that on many
>     systems, the ANSI clock function wraps around after only 2147 seconds, or
>     about 36 minutes.  BE CAREFUL:  if you compare the run time of UMFPACK with
>     other sparse matrix packages, be sure to use the same timer.  See
>     umfpack_tictoc.c for the timer used internally by UMFPACK.  See also
>     umfpack_timer.c for the timer used in an earlier version of UMFPACK (V4.0).
>     That timer is still available as a user-callable routine, but it is no
>     longer used internally by UMFPACK.
> */
> 
> /* Sun Solaris, SGI Irix, Linux, Compaq Alpha, and IBM RS 6000 all have */
> /* getrusage.  It's in BSD unix, so perhaps all unix systems have it. */
> #if defined (UMF_SOL2) || defined (UMF_SGI) || defined (UMF_LINUX) \
> || defined (UMF_ALPHA) || defined (UMF_AIX)
> #define GETRUSAGE
> #endif
> 
> 
> /* ========================================================================== */
> /* === BLAS ================================================================= */
> /* ========================================================================== */
> 
> /*
>     The adventure begins.  Figure out how to call the BLAS ...
> 
>     This works, but it is incredibly ugly.  The C-BLAS was supposed to solve
>     this problem, and make it easier to interface a C program to the BLAS.
>     Unfortunately, the C-BLAS does not have a "long" integer (64 bit) version.
>     Various vendors have done their own 64-bit BLAS.  Sun has dgemm_64 routines
>     with "long" integers, SGI has a 64-bit dgemm in their scsl_blas_i8 library
>     with "long long" integers, and so on.
> 
>     Different vendors also have different ways of defining a complex number,
>     some using struct's.  That's a bad idea.  See umf_version.h for the better
>     way to do it (the method that was also chosen for the complex C-BLAS,
>     which is compatible and guaranteed to be portable with ANSI C).
> 
>     To make matters worse, SGI's SCSL BLAS has a C-BLAS interface which
>     differs from the ATLAS C-BLAS interface (see immediately below);
>     although a more recent version of SGI's C-BLAS interface is correct
>     if SCSL_VOID_ARGS is defined.
> */
> 
> 
> /* -------------------------------------------------------------------------- */
> /* Determine which BLAS to use. */
> /* -------------------------------------------------------------------------- */
> 
> #if defined (MATHWORKS)
> #define USE_MATLAB_BLAS
> 
> #elif defined (NBLAS)
> #define USE_NO_BLAS
> 
> #elif defined (MATLAB_MEX_FILE)
> #define USE_MATLAB_BLAS
> 
> #elif defined (CBLAS)
> #define USE_C_BLAS
> 
> #elif defined (UMF_SOL2) && !defined (NSUNPERF)
> #define USE_SUNPERF_BLAS
> 
> #elif defined (UMF_SGI) && !defined (NSCSL)
> #define USE_SCSL_BLAS
> 
> #else
> #define USE_FORTRAN_BLAS
> #endif
> 
> /* -------------------------------------------------------------------------- */
> /* int vs. long integer arguments */
> /* -------------------------------------------------------------------------- */
> 
> /*
>     Determine if the BLAS exists for the long integer version.  It exists if
>     LONGBLAS is defined in the Makefile, or if using the BLAS from the
>     Sun Performance Library, or SGI's SCSL Scientific Library.
> */
> 
> #if defined (USE_SUNPERF_BLAS) || defined (USE_SCSL_BLAS)
> #ifndef LONGBLAS
> #define LONGBLAS
> #endif
> #endif
> 
> /* do not use the BLAS if Int's are long and LONGBLAS is not defined */
> #if defined (LONG_INTEGER) && !defined (LONGBLAS) && !defined (USE_NO_BLAS)
> #define USE_NO_BLAS
> #endif
> 
> 
> /* -------------------------------------------------------------------------- */
> /* Use (void *) arguments for the SGI */
> /* -------------------------------------------------------------------------- */
> 
> #if defined (UMF_SGI)
> /*
>     Use (void *) pointers for complex types in SCSL.
>     The ATLAS C-BLAS, and the SGI C-BLAS differ.  The former uses (void *)
>     arguments, the latter uses SCSL_ZOMPLEX_T, which are either scsl_zomplex
>     or (void *).  Using (void *) is simpler, and is selected by defining
>     SCSL_VOID_ARGS, below.  The cc compiler doesn't complain, but gcc is
>     more picky, and generates a warning without this next statement.
>     With gcc and the 07/09/98 version of SGI's cblas.h, spurious warnings
>     about complex BLAS arguments will be reported anyway.  This is because this
>     older version of SGI's cblas.h does not make use of the SCSL_VOID_ARGS
>     parameter, which is present in the 12/6/01 version of SGI's cblas.h.  You
>     can safely ignore these warnings.
> */
> #define SCSL_VOID_ARGS
> #endif
> 
> 
> /* -------------------------------------------------------------------------- */
> /* The BLAS exists, construct appropriate macros */
> /* -------------------------------------------------------------------------- */
> 
> #if !defined (USE_NO_BLAS)		/* { */
> 
> /*
>     If the compile-time flag -DNBLAS is defined, then the BLAS are not used,
>     portable vanilla C code is used instead, and the remainder of this file
>     is ignored.
> 
>     Using the BLAS is much faster, but how C calls the Fortran BLAS is
>     machine-dependent and thus can cause portability problems.  Thus, use
>     -DNBLAS to ensure portability (at the expense of speed).
> 
>     Preferences:
> 
> 	*** The best interface to use, regardless of the option you select
> 	    below, is the standard C-BLAS interface.  Not all BLAS libraries
> 	    use this interface.  The only problem with this interface is that
> 	    it does not extend to the LP64 model.  The C-BLAS does not provide
> 	    for a 64-bit integer.  In addition, SGI's older cblas.h can cause
> 	    spurious warnings when using the C-BLAS interface.
> 
> 	1) often the most preferred (but see option (3)):  use the
> 	    optimized vendor-supplied library (such as the Sun Performance
> 	    Library, or IBM's ESSL).  This is often the fastest, but might not
> 	    be portable and might not always be available.  When compiling a
> 	    MATLAB mexFunction it might be difficult get the mex compiler
> 	    script to recognize the vendor- supplied BLAS.  Note that the
> 	    freely-available BLAS (option 3) can be faster than the vendor-
> 	    specific BLAS.  You are encourage to try both option (1) and (3).
> 
> 	2) When compiling the UMFPACK mexFunction to use UMFPACK in MATLAB, use
> 	    the BLAS provided by The Mathworks, Inc.  This assumes you are using
> 	    MATLAB V6 or higher, since the BLAS are not incorporated in V5 or
> 	    earlier versions.  On my Sun workstation, the MATLAB BLAS gave
> 	    slightly worse performance than the Sun Perf. BLAS.  The advantage
> 	    of using the MATLAB BLAS is that it's available on any computer that
> 	    has MATLAB V6 or higher.  I have not tried using MATLAB BLAS outside
> 	    of a mexFunction in a stand-alone C code, but MATLAB (V6) allows for
> 	    this.  This is well worth trying if you have MATLAB and don't want
> 	    to bother installing the ATLAS BLAS (option 3a, below).  The only
> 	    glitch to this is that MATLAB does not provide a portable interface
> 	    to the BLAS (an underscore is required for some but not all
> 	    architectures).  For Windows and MATLAB 6.0 or 6.1, you also need
> 	    to copy the libmwlapack.dll file into your MATLAB installation
> 	    directory; see the User Guide for details.
> 
> 	    In the current distribution, the only BLAS that the UMFPACK
> 	    mexFunction will use is the internal MATLAB BLAS.  It's possible to
> 	    use other BLAS, but handling the porting of using the mex compiler
> 	    with different BLAS libraries is not trivial.
> 
> 	    As of MATLAB 6.5, the BLAS used internally in MATLAB is the ATLAS
> 	    BLAS.
> 
> 	3) Use a freely-available high-performance BLAS library:
> 
> 	    (a) The BLAS by Kazashige Goto and Robert van de Geijn, at
> 		http://www.cs.utexas.edu/users/flame/goto.  This BLAS increased
> 		the performance of UMFPACK by almost 50% as compared to the
> 		ATLAS BLAS (v3.2).
> 
> 	    (b) The ATLAS BLAS, available at http://www.netlib.org/atlas,
> 		by R. Clint Whaley, Antoine Petitet, and Jack Dongarra.
> 		This has a standard C interface, and thus the interface to it is
> 		fully portable.  Its performance rivals, and sometimes exceeds,
> 		the vendor-supplied BLAS on many computers.
> 
> 	    (b) The Fortran RISC BLAS by Michel Dayde', Iain Duff, Antoine
> 		Petitet, and Abderrahim Qrichi Aniba, available via anonymous
> 		ftp to ftp.enseeiht.fr in the pub/numerique/BLAS/RISC directory,
> 		See M. J. Dayde' and I. S. Duff, "The RISC BLAS:  A blocked
> 		implementation of level 3 BLAS for RISC processors, ACM Trans.
> 		Math. Software, vol. 25, no. 3., Sept. 1999.  This will give
> 		you good performance, but with the same C-to-Fortran portability
> 		problems as option (1).
> 
> 	4) Use UMFPACK's built-in vanilla C code by setting -DNBLAS at compile
> 	    time.  The key advantage is portability, which is guaranteed if you
> 	    have an ANSI C compliant compiler.  You also don't need to download
> 	    any other package - UMFPACK is stand-alone.  No Fortran is used
> 	    anywhere in UMFPACK.  UMFPACK will be much slower than when using
> 	    options (1) through (3), however.
> 
> 	5) least preferred:  use the standard Fortran implementation of the
> 	    BLAS, also available at Netlib (http://www.netlib.org/blas).  This
> 	    will be no faster than option (4), and not portable because of
> 	    C-to-Fortran calling conventions.  Don't bother trying option (5).
> 
>     The mechanics of how C calls the BLAS on various computers are as follows:
> 
> 	* C-BLAS (from the ATLAS library, for example):
> 	    The same interface is used on all computers.
> 
> 	* Defaults for calling the Fortran BLAS:
> 	    add underscore, pass scalars by reference, use string arguments.
> 
> 	* The Fortran BLAS on Sun Solaris (when compiling the MATLAB mexFunction
> 	    or when using the Fortran RISC BLAS), SGI IRIX, Linux, and Compaq
> 	    Alpha: use defaults.
> 
> 	* Sun Solaris (when using the C-callable Sun Performance library):
> 	    no underscore, pass scalars by value, use character arguments.
> 
> 	* The Fortran BLAS (ESSL Library) on the IBM RS 6000, and HP Unix:
> 	    no underscore, pass scalars by reference, use string arguments.
> 
> 	* The Fortran BLAS on Windows:
> 	    no underscore, pass scalars by reference, use string arguments.
> 	    If you compile the umfpack mexFunction using umfpack_make, and are
> 	    using the lcc compiler bundled with MATLAB, then you must first
> 	    copy the umfpack\lcc_lib\libmwlapack.lib file into the
> 	    <matlab>\extern\lib\win32\lcc\ directory, where <matlab> is the
> 	    directory in which MATLAB is installed.  Next, type mex -setup
> 	    at the MATLAB prompt, and ask MATLAB to select the lcc compiler.
> 	    MATLAB has built-in BLAS, but it cannot be accessed by a program
> 	    compiled by lcc without first copying this file.
> */
> 
> 
> 
> /* -------------------------------------------------------------------------- */
> #ifdef USE_C_BLAS	/* { */
> /* -------------------------------------------------------------------------- */
> 
> 
> /* -------------------------------------------------------------------------- */
> /* use the C-BLAS (any computer) */
> /* -------------------------------------------------------------------------- */
> 
> /*
>     C-BLAS is the default interface, with the following exceptions.  Solaris
>     uses the Sun Performance BLAS for libumfpack.a (the C-callable library).
>     SGI IRIX uses the SCSL BLAS for libumfpack.a.  All architectures use
>     MATLAB's internal BLAS for the mexFunction on any architecture.  These
>     options are set in the Make.* files.  The Make.generic file uses no BLAS
>     at all.
> 
>     If you use the ATLAS C-BLAS, then be sure to set the -I flag to
>     -I/path/ATLAS/include, where /path/ATLAS is the ATLAS installation
>     directory.  See Make.solaris for an example.  You do not need to do this
>     for the SGI, which has a /usr/include/cblas.h.
> */
> 
> #include "cblas.h"
> 
> #ifdef COMPLEX
> #define BLAS_GEMM_ROUTINE cblas_zgemm
> #define BLAS_TRSM_ROUTINE cblas_ztrsm
> #define BLAS_TRSV_ROUTINE cblas_ztrsv
> #define BLAS_GEMV_ROUTINE cblas_zgemv
> #define BLAS_GER_ROUTINE  cblas_zgeru
> #define BLAS_SCAL_ROUTINE cblas_zscal
> #define BLAS_COPY_ROUTINE cblas_zcopy
> #define BLAS_DECLARE_SCALAR(x) double x [2]
> #define BLAS_ASSIGN(x,xr,xi) { x [0] = xr ; x [1] = xi ; }
> #else
> #define BLAS_GEMM_ROUTINE cblas_dgemm
> #define BLAS_TRSM_ROUTINE cblas_dtrsm
> #define BLAS_TRSV_ROUTINE cblas_dtrsv
> #define BLAS_GEMV_ROUTINE cblas_dgemv
> #define BLAS_GER_ROUTINE  cblas_dger
> #define BLAS_SCAL_ROUTINE cblas_dscal
> #define BLAS_COPY_ROUTINE cblas_dcopy
> #define BLAS_DECLARE_SCALAR(x) double x
> #define BLAS_ASSIGN(x,xr,xi) { x = xr ; }
> #endif
> 
> #define BLAS_LOWER CblasLower
> #define BLAS_UNIT_DIAGONAL CblasUnit
> #define BLAS_RIGHT CblasRight
> #define BLAS_NO_TRANSPOSE CblasNoTrans
> #define BLAS_TRANSPOSE CblasTrans
> #define BLAS_COLUMN_MAJOR_ORDER CblasColMajor,
> #define BLAS_SCALAR(x) x
> #define BLAS_INT_SCALAR(n) n
> #define BLAS_ARRAY(a) a
> 
> 
> 
> /* -------------------------------------------------------------------------- */
> #else	/* } USE_C_BLAS { */
> /* -------------------------------------------------------------------------- */
> 
> /* -------------------------------------------------------------------------- */
> /* use Fortran (or other architecture-specific) BLAS */
> /* -------------------------------------------------------------------------- */
> 
> /* No such argument when not using the C-BLAS */
> #define BLAS_COLUMN_MAJOR_ORDER
> 
> /* Determine which architecture we're on and set options accordingly. */
> /* The default, if nothing is defined is to add an underscore, */
> /* pass scalars by reference, and use string arguments. */
> 
> /* ---------------------------------- */
> /* Sun Performance BLAS */
> /* ---------------------------------- */
> 
> #ifdef USE_SUNPERF_BLAS
> #ifdef _SUNPERF_H
> /* <sunperf.h> has been included somehow anyway, outside of umf_config.h */
> #error "sunperf.h must NOT be #include'd.  See umf_config.h for details."
> #endif
> #define BLAS_BY_VALUE
> #define BLAS_NO_UNDERSCORE
> #define BLAS_CHAR_ARG
> #endif	/* USE_SUNPERF_BLAS */
> 
> /* ---------------------------------- */
> /* SGI SCSL BLAS */
> /* ---------------------------------- */
> 
> #ifdef USE_SCSL_BLAS
> #if defined (LP64)
> #include <scsl_blas_i8.h>
> #else
> #include <scsl_blas.h>
> #endif
> #define BLAS_BY_VALUE
> #define BLAS_NO_UNDERSCORE
> #endif	/* USE_SCSL_BLAS */
> 
> /* ---------------------------------- */
> /* IBM AIX, Windows, and HP Fortran BLAS */
> /* ---------------------------------- */
> 
> #if defined (UMF_AIX) || defined (UMF_WINDOWS) || defined (UMF_HP)
> #define BLAS_NO_UNDERSCORE
> #endif
> 
> 
> /* -------------------------------------------------------------------------- */
> /* BLAS names */
> /* -------------------------------------------------------------------------- */
> 
> #if defined (LP64) && defined (USE_SUNPERF_BLAS) && defined (LONG_INTEGER)
> 
> /* 64-bit sunperf BLAS, for Sun Solaris only */
> #ifdef COMPLEX
> #define BLAS_GEMM_ROUTINE zgemm_64
> #define BLAS_TRSM_ROUTINE ztrsm_64
> #define BLAS_TRSV_ROUTINE ztrsv_64
> #define BLAS_GEMV_ROUTINE zgemv_64
> #define BLAS_GER_ROUTINE  zgeru_64
> #define BLAS_SCAL_ROUTINE zscal_64
> #define BLAS_COPY_ROUTINE zcopy_64
> #else
> #define BLAS_GEMM_ROUTINE dgemm_64
> #define BLAS_TRSM_ROUTINE dtrsm_64
> #define BLAS_TRSV_ROUTINE dtrsv_64
> #define BLAS_GEMV_ROUTINE dgemv_64
> #define BLAS_GER_ROUTINE  dger_64
> #define BLAS_SCAL_ROUTINE dscal_64
> #define BLAS_COPY_ROUTINE dcopy_64
> #endif	/* COMPLEX */
> 
> #else
> 
> #ifdef COMPLEX
> 
> /* naming convention (use underscore, or not) */
> #ifdef BLAS_NO_UNDERSCORE
> #define BLAS_GEMM_ROUTINE zgemm
> #define BLAS_TRSM_ROUTINE ztrsm
> #define BLAS_TRSV_ROUTINE ztrsv
> #define BLAS_GEMV_ROUTINE zgemv
> #define BLAS_GER_ROUTINE  zgeru
> #define BLAS_SCAL_ROUTINE zscal
> #define BLAS_COPY_ROUTINE zcopy
> #else
> /* default:  add underscore */
> #define BLAS_GEMM_ROUTINE zgemm_
> #define BLAS_TRSM_ROUTINE ztrsm_
> #define BLAS_TRSV_ROUTINE ztrsv_
> #define BLAS_GEMV_ROUTINE zgemv_
> #define BLAS_GER_ROUTINE  zgeru_
> #define BLAS_SCAL_ROUTINE zscal_
> #define BLAS_COPY_ROUTINE zcopy_
> #endif
> 
> #else
> 
> /* naming convention (use underscore, or not) */
> #ifdef BLAS_NO_UNDERSCORE
> #define BLAS_GEMM_ROUTINE dgemm
> #define BLAS_TRSM_ROUTINE dtrsm
> #define BLAS_TRSV_ROUTINE dtrsv
> #define BLAS_GEMV_ROUTINE dgemv
> #define BLAS_GER_ROUTINE  dger
> #define BLAS_SCAL_ROUTINE dscal
> #define BLAS_COPY_ROUTINE dcopy
> #else
> /* default:  add underscore */
> #define BLAS_GEMM_ROUTINE dgemm_
> #define BLAS_TRSM_ROUTINE dtrsm_
> #define BLAS_TRSV_ROUTINE dtrsv_
> #define BLAS_GEMV_ROUTINE dgemv_
> #define BLAS_GER_ROUTINE  dger_
> #define BLAS_SCAL_ROUTINE dscal_
> #define BLAS_COPY_ROUTINE dcopy_
> #endif
> 
> #endif	/* COMPLEX */
> 
> #endif /* LP64 && USE_SUNPERF_BLAS */
> 
> 
> /* -------------------------------------------------------------------------- */
> /* BLAS real or complex floating-point scalars */
> /* -------------------------------------------------------------------------- */
> 
> #ifdef COMPLEX
> 
> /*
>     The SunPerf BLAS expects to see a doublecomplex scalar, but it
>     also will accept an array of size 2.  See the manual, normally at
>     file:///opt/SUNWspro/WS6U1/lib/locale/C/html/manuals/perflib/user_guide
>     /plug_using_perflib.html .  This manual is inconsistent with the man pages
>     for zgemm, zgemv, and zgeru and also inconsistent with the <sunperf.h>
>     include file.  Use this instead, for SunPerf (only works if you do NOT
>     include sunperf.h).  Fortunately, this file (umf_config.h) is not included
>     in any user code that calls UMFPACK.  Thus, the caller may include
>     sunperf.h in his or her own code, and that is safely ignored here.
>     SGI's SCSL BLAS has yet a different kind of struct, but we can use a
>     double array of size 2 instead (since SCSL_VOID_ARGS is defined).
>     Most BLAS expect complex scalars as pointers to double arrays of size 2.
> */
> 
> #define BLAS_DECLARE_SCALAR(x) double x [2]
> #define BLAS_ASSIGN(x,xr,xi) { x [0] = xr ; x [1] = xi ; }
> #define BLAS_SCALAR(x) x
> 
> #else
> 
> #define BLAS_DECLARE_SCALAR(x) double x
> #define BLAS_ASSIGN(x,xr,xi) { x = xr ; }
> #ifdef BLAS_BY_VALUE
> #define BLAS_SCALAR(x) x
> #else
> #define BLAS_SCALAR(x) &(x)
> #endif
> 
> #endif /* COMPLEX */
> 
> 
> /* -------------------------------------------------------------------------- */
> /* BLAS integer scalars */
> /* -------------------------------------------------------------------------- */
> 
> /*
>     Fortran requires integers to be passed by reference.
>     The SCSL BLAS requires long long arguments in LP64 mode.
> */
> 
> #if defined (USE_SCSL_BLAS) && defined (LP64)
> #define BLAS_INT_SCALAR(n) ((long long) n)
> #else
> #ifdef BLAS_BY_VALUE
> #define BLAS_INT_SCALAR(n) n
> #else
> #define BLAS_INT_SCALAR(n) &(n)
> #endif
> #endif
> 
> 
> /* -------------------------------------------------------------------------- */
> /* BLAS strings */
> /* -------------------------------------------------------------------------- */
> 
> /*
>     The Sun Performance BLAS wants a character instead of a string.
> */
> 
> #ifdef BLAS_CHAR_ARG
> #define BLAS_NO_TRANSPOSE 'N'
> #define BLAS_TRANSPOSE 'T'
> #define BLAS_LEFT 'L'
> #define BLAS_RIGHT 'R'
> #define BLAS_LOWER 'L'
> #define BLAS_UNIT_DIAGONAL 'U'
> #else
> #define BLAS_NO_TRANSPOSE "N"
> #define BLAS_TRANSPOSE "T"
> #define BLAS_LEFT "L"
> #define BLAS_RIGHT "R"
> #define BLAS_LOWER "L"
> #define BLAS_UNIT_DIAGONAL "U"
> #endif
> 
> 
> /* -------------------------------------------------------------------------- */
> /* BLAS arrays */
> /* -------------------------------------------------------------------------- */
> 
> /*
>     The complex SunPerf BLAS expects to see a doublecomplex array of size s.
>     This is broken (see above, regarding complex scalars in sunperf.h).
>     For SunPerf BLAS, just pass a pointer to the array, and ignore sunperf.h.
>     With sunperf.h, you would need:
> 
> 	#define BLAS_ARRAY(a) ((doublecomplex *)(a))
> 
>     SGI's SCSL BLAS has yet a different kind of struct, but we can use a
>     double array of size 2 instead (since SCSL_VOID_ARGS is defined).
> 
>     The real versions all use just a (double *) pointer.
> 
>     In all cases, no typecast is required.  This will break if <sunperf.h> is
>     included.
> 
>     If you have read this far, I hope you see now why (void *) a much better
>     choice for complex BLAS prototypes, and why double x [2] is better than
>     an architecture dependent struct { double real ; double imag ; }
>     type definition.
> 
> */
> 
> #define BLAS_ARRAY(a) (a)
> 
> 
> /* -------------------------------------------------------------------------- */
> #endif /* USE_C_BLAS } */
> /* -------------------------------------------------------------------------- */
> 
> 
> 
> 
> 
> /* -------------------------------------------------------------------------- */
> /* BLAS macros, for all interfaces */
> /* -------------------------------------------------------------------------- */
> 
> /*
>    All architecture dependent issues have now been taken into consideration,
>    and folded into the macros BLAS_DECLARE_SCALAR, BLAS_ASSIGN, BLAS_*_ROUTINE,
>    BLAS_COLUMN_MAJOR_ORDER, BLAS_NO_TRANSPOSE, BLAS_TRANSPOSE, BLAS_SCALAR,
>    BLAS_INT_SCALAR, BLAS_ARRAY, and Int.
> 
>    You will note that there is not a *** single *** name, declaration, or
>    argument to the BLAS which is not somehow different in one or more versions
>    of the BLAS!
> */
> 
> 
> /* C = C - A*B', where:
>  * A is m-by-k with leading dimension ldac
>  * B is k-by-n with leading dimension ldb
>  * C is m-by-n with leading dimension ldac */
> #define BLAS_GEMM(m,n,k,A,B,ldb,C,ldac) \
> { \
>     BLAS_DECLARE_SCALAR (alpha) ; \
>     BLAS_DECLARE_SCALAR (beta) ; \
>     BLAS_ASSIGN (alpha, -1.0, 0.0) ; \
>     BLAS_ASSIGN (beta, 1.0, 0.0) ; \
>     (void) BLAS_GEMM_ROUTINE (BLAS_COLUMN_MAJOR_ORDER \
> 	BLAS_NO_TRANSPOSE, BLAS_TRANSPOSE, \
> 	BLAS_INT_SCALAR (m), BLAS_INT_SCALAR (n), BLAS_INT_SCALAR (k), \
> 	BLAS_SCALAR (alpha), \
> 	BLAS_ARRAY (A), BLAS_INT_SCALAR (ldac), \
> 	BLAS_ARRAY (B), BLAS_INT_SCALAR (ldb), BLAS_SCALAR (beta), \
> 	BLAS_ARRAY (C), BLAS_INT_SCALAR (ldac)) ; \
> }
> 
> /* A = A - x*y', where:
>  * A is m-by-n with leading dimension d
>    x is a column vector with stride 1
>    y is a column vector with stride 1 */
> #define BLAS_GER(m,n,x,y,A,d) \
> { \
>     Int one = 1 ; \
>     BLAS_DECLARE_SCALAR (alpha) ; \
>     BLAS_ASSIGN (alpha, -1.0, 0.0) ; \
>     (void) BLAS_GER_ROUTINE (BLAS_COLUMN_MAJOR_ORDER \
> 	BLAS_INT_SCALAR (m), BLAS_INT_SCALAR (n), \
> 	BLAS_SCALAR (alpha), \
> 	BLAS_ARRAY (x), BLAS_INT_SCALAR (one), \
> 	BLAS_ARRAY (y), BLAS_INT_SCALAR (one), \
> 	BLAS_ARRAY (A), BLAS_INT_SCALAR (d)) ; \
> }
> 
> /* y = y - A*x, where A is m-by-n with leading dimension d,
>    x is a column vector with stride 1
>    y is a column vector with stride 1 */
> #define BLAS_GEMV(m,n,A,x,y,d) \
> { \
>     Int one = 1 ; \
>     BLAS_DECLARE_SCALAR (alpha) ; \
>     BLAS_DECLARE_SCALAR (beta) ; \
>     BLAS_ASSIGN (alpha, -1.0, 0.0) ; \
>     BLAS_ASSIGN (beta, 1.0, 0.0) ; \
>     (void) BLAS_GEMV_ROUTINE (BLAS_COLUMN_MAJOR_ORDER \
> 	BLAS_NO_TRANSPOSE, \
> 	BLAS_INT_SCALAR (m), BLAS_INT_SCALAR (n), \
> 	BLAS_SCALAR (alpha), \
> 	BLAS_ARRAY (A), BLAS_INT_SCALAR (d), \
> 	BLAS_ARRAY (x), BLAS_INT_SCALAR (one), BLAS_SCALAR (beta), \
> 	BLAS_ARRAY (y), BLAS_INT_SCALAR (one)) ; \
> }
> 
> 
> /* solve Lx=b, where:
>  * B is a column vector (m-by-1) with leading dimension d
>  * A is m-by-m with leading dimension d */
> #define BLAS_TRSV(m,A,b,d) \
> { \
>     Int one = 1 ; \
>     (void) BLAS_TRSV_ROUTINE (BLAS_COLUMN_MAJOR_ORDER \
> 	BLAS_LOWER, BLAS_NO_TRANSPOSE, BLAS_UNIT_DIAGONAL, \
> 	BLAS_INT_SCALAR (m), \
> 	BLAS_ARRAY (A), BLAS_INT_SCALAR (d), \
> 	BLAS_ARRAY (b), BLAS_INT_SCALAR (one)) ; \
> }
> 
> /* solve XL'=B where:
>  * B is m-by-n with leading dimension ldb
>  * A is n-by-n with leading dimension lda */
> #define BLAS_TRSM_RIGHT(m,n,A,lda,B,ldb) \
> { \
>     BLAS_DECLARE_SCALAR (alpha) ; \
>     BLAS_ASSIGN (alpha, 1.0, 0.0) ; \
>     (void) BLAS_TRSM_ROUTINE (BLAS_COLUMN_MAJOR_ORDER \
> 	BLAS_RIGHT, BLAS_LOWER, BLAS_TRANSPOSE, BLAS_UNIT_DIAGONAL, \
> 	BLAS_INT_SCALAR (m), BLAS_INT_SCALAR (n), \
> 	BLAS_SCALAR (alpha), \
> 	BLAS_ARRAY (A), BLAS_INT_SCALAR (lda), \
> 	BLAS_ARRAY (B), BLAS_INT_SCALAR (ldb)) ; \
> }
> 
> /* x = s*x, where x is a stride-1 vector of length n */
> #define BLAS_SCAL(n,s,x) \
> { \
>     Int one = 1 ; \
>     BLAS_DECLARE_SCALAR (alpha) ; \
>     BLAS_ASSIGN (alpha, REAL_COMPONENT (s), IMAG_COMPONENT (s)) ; \
>     (void) BLAS_SCAL_ROUTINE ( \
> 	BLAS_INT_SCALAR (n), BLAS_SCALAR (alpha), \
> 	BLAS_ARRAY (x), BLAS_INT_SCALAR (one)) ; \
> }
> 
> /* x = y, where x and y are a stride-1 vectors of length n */
> #define BLAS_COPY(n,x,y) \
> { \
>     Int one = 1 ; \
>     (void) BLAS_COPY_ROUTINE ( \
> 	BLAS_INT_SCALAR (n), \
> 	BLAS_ARRAY (x), BLAS_INT_SCALAR (one), \
> 	BLAS_ARRAY (y), BLAS_INT_SCALAR (one)) ; \
> }
> 
> #endif	/* !defined (USE_NO_BLAS) } */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_create_element.h pysparse/pysparse/direct/umfpack/include/umf_create_element.h
0a1,13
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL Int UMF_create_element
> (
>     NumericType *Numeric,
>     WorkType *Work,
>     SymbolicType *Symbolic
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_dump.h pysparse/pysparse/direct/umfpack/include/umf_dump.h
0a1,187
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> /* umf_dump.h: debugging definitions. */
> 
> #ifndef NDEBUG
> 
> GLOBAL void UMF_dump_dense
> (
>     Entry *C,
>     Int dim,
>     Int m,
>     Int n
> ) ;
> 
> GLOBAL void UMF_dump_element
> (
>     NumericType *Numeric,
>     WorkType *Work,
>     Int e,
>     Int clean
> ) ;
> 
> GLOBAL void UMF_dump_rowcol
> (
>     Int dump_which,
>     NumericType *Numeric,
>     WorkType *Work,
>     Int dump_index,
>     Int check_degree
> ) ;
> 
> GLOBAL void UMF_dump_matrix
> (
>     NumericType *Numeric,
>     WorkType *Work,
>     Int check_degree
> ) ;
> 
> GLOBAL void UMF_dump_current_front
> (
>     NumericType *Numeric,
>     WorkType *Work,
>     Int check
> ) ;
> 
> GLOBAL void UMF_dump_lu
> (
>     NumericType *Numeric
> ) ;
> 
> GLOBAL void UMF_dump_memory
> (
>     NumericType *Numeric
> ) ;
> 
> GLOBAL void UMF_dump_packed_memory
> (
>     NumericType *Numeric,
>     WorkType *Work
> ) ;
> 
> GLOBAL void UMF_dump_col_matrix
> (
>     const double Ax [ ],
> #ifdef COMPLEX
>     const double Az [ ],
> #endif
>     const Int Ai [ ],
>     const Int Ap [ ],
>     Int n_row,
>     Int n_col,
>     Int nz
> ) ;
> 
> GLOBAL void UMF_dump_chain
> (
>     Int frontid,
>     Int Front_parent [ ],
>     Int Front_npivcol [ ],
>     Int Front_nrows [ ],
>     Int Front_ncols [ ],
>     Int nfr
> ) ;
> 
> GLOBAL void UMF_dump_rowmerge
> (
>     NumericType *Numeric,
>     SymbolicType *Symbolic,
>     WorkType *Work
> ) ;
> 
> GLOBAL void UMF_dump_start
> (
>     void
> ) ;
> 
> 
> GLOBAL void UMF_dump_diagonal_map
> (
>     Int Diagonal_map [ ],
>     Int Diagonal_imap [ ],
>     Int n1,
>     Int nn,
>     Int nempty
> ) ;
> 
> #define UMF_DBMAX 50000
> GLOBAL extern Int UMF_debug ;
> GLOBAL extern Int UMF_allocfail ;
> GLOBAL extern double UMF_gprob ;
> 
> #define DEBUGk(k,params) { if (UMF_debug >= (k)) { PRINTF (params) ; } }
> 
> #define DEBUGm4(params) DEBUGk (-4, params)
> #define DEBUGm3(params) DEBUGk (-3, params)
> #define DEBUGm2(params) DEBUGk (-2, params)
> #define DEBUGm1(params) DEBUGk (-1, params)
> #define DEBUG0(params) DEBUGk (0, params)
> #define DEBUG1(params) DEBUGk (1, params)
> #define DEBUG2(params) DEBUGk (2, params)
> #define DEBUG3(params) DEBUGk (3, params)
> #define DEBUG4(params) DEBUGk (4, params)
> #define DEBUG5(params) DEBUGk (5, params)
> #define DEBUG6(params) DEBUGk (6, params)
> #define DEBUG7(params) DEBUGk (7, params)
> #define DEBUG8(params) DEBUGk (8, params)
> #define DEBUG9(params) DEBUGk (9, params)
> 
> #define EDEBUGk(k,a) { if (UMF_debug >= (k)) { PRINT_ENTRY (a) ; } }
> 
> #define EDEBUG0(a) EDEBUGk (0, a)
> #define EDEBUG1(a) EDEBUGk (1, a)
> #define EDEBUG2(a) EDEBUGk (2, a)
> #define EDEBUG3(a) EDEBUGk (3, a)
> #define EDEBUG4(a) EDEBUGk (4, a)
> #define EDEBUG5(a) EDEBUGk (5, a)
> #define EDEBUG6(a) EDEBUGk (6, a)
> #define EDEBUG7(a) EDEBUGk (7, a)
> #define EDEBUG8(a) EDEBUGk (8, a)
> #define EDEBUG9(a) EDEBUGk (9, a)
> 
> /* ASSERT defined in amd_dump.h */
> 
> #else
> 
> /* ========================================================================== */
> /* === No debugging ========================================================= */
> /* ========================================================================== */
> 
> /* turn off all debugging macros */
> 
> #define DEBUGk(k,params)
> 
> #define DEBUGm4(params)
> #define DEBUGm3(params)
> #define DEBUGm2(params)
> #define DEBUGm1(params)
> #define DEBUG0(params)
> #define DEBUG1(params)
> #define DEBUG2(params)
> #define DEBUG3(params)
> #define DEBUG4(params)
> #define DEBUG5(params)
> #define DEBUG6(params)
> #define DEBUG7(params)
> #define DEBUG8(params)
> #define DEBUG9(params)
> 
> #define EDEBUGk(k,a)
> 
> #define EDEBUG0(a)
> #define EDEBUG1(a)
> #define EDEBUG2(a)
> #define EDEBUG3(a)
> #define EDEBUG4(a)
> #define EDEBUG5(a)
> #define EDEBUG6(a)
> #define EDEBUG7(a)
> #define EDEBUG8(a)
> #define EDEBUG9(a)
> 
> #endif /* NDEBUG */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_extend_front.h pysparse/pysparse/direct/umfpack/include/umf_extend_front.h
0a1,12
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL Int UMF_extend_front
> (
>     NumericType *Numeric,
>     WorkType *Work
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_free.h pysparse/pysparse/direct/umfpack/include/umf_free.h
0a1,11
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL void *UMF_free
> (
>     void *p
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_fsize.h pysparse/pysparse/direct/umfpack/include/umf_fsize.h
0a1,16
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL void UMF_fsize
> (
>     Int nn,
>     Int MaxFsize [ ],
>     Int Fnrows [ ],
>     Int Fncols [ ],
>     Int Parent [ ],
>     Int Npiv [ ]
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_garbage_collection.h pysparse/pysparse/direct/umfpack/include/umf_garbage_collection.h
0a1,15
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL void UMF_garbage_collection
> (
>     NumericType *Numeric,
>     WorkType *Work,
>     Int drnew,
>     Int dcnew,
>     Int do_Fcpos
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_get_memory.h pysparse/pysparse/direct/umfpack/include/umf_get_memory.h
0a1,16
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL Int UMF_get_memory
> (
>     NumericType *Numeric,
>     WorkType *Work,
>     Int needunits,
>     Int r2,
>     Int c2,
>     Int do_Fcpos
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_grow_front.h pysparse/pysparse/direct/umfpack/include/umf_grow_front.h
0a1,15
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL Int UMF_grow_front
> (
>     NumericType *Numeric,
>     Int fnr2,
>     Int fnc2,
>     WorkType *Work,
>     Int do_what
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_init_front.h pysparse/pysparse/direct/umfpack/include/umf_init_front.h
0a1,12
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL Int UMF_init_front
> (
>     NumericType *Numeric,
>     WorkType *Work
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_internal.h pysparse/pysparse/direct/umfpack/include/umf_internal.h
0a1,753
> /* ========================================================================== */
> /* === umf_internal.h ======================================================= */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> /*
>     This file is for internal use in UMFPACK itself, and should not be included
>     in user code.  Use umfpack.h instead.  User-accessible file names and
>     routine names all start with the letters "umfpack_".  Non-user-accessible
>     file names and routine names all start with "umf_".
> */
> 
> /* -------------------------------------------------------------------------- */
> /* ANSI standard include files */
> /* -------------------------------------------------------------------------- */
> 
> /* from float.h:  DBL_EPSILON */
> #include <float.h>
> 
> /* from string.h: strcmp */
> #include <string.h>
> 
> /* when debugging, assert.h and the assert macro are used (see umf_dump.h) */
> 
> /* -------------------------------------------------------------------------- */
> /* Architecture */
> /* -------------------------------------------------------------------------- */
> 
> #if defined (__sun) || defined (MSOL2) || defined (ARCH_SOL2)
> #define UMF_SOL2
> #define UMFPACK_ARCHITECTURE "Sun Solaris"
> 
> #elif defined (__sgi) || defined (MSGI) || defined (ARCH_SGI)
> #define UMF_SGI
> #define UMFPACK_ARCHITECTURE "SGI Irix"
> 
> #elif defined (__linux) || defined (MGLNX86) || defined (ARCH_GLNX86)
> #define UMF_LINUX
> #define UMFPACK_ARCHITECTURE "Linux"
> 
> #elif defined (_AIX) || defined (MIBM_RS) || defined (ARCH_IBM_RS)
> #define UMF_AIX
> #define UMFPACK_ARCHITECTURE "IBM AIX"
> 
> #elif defined (__alpha) || defined (MALPHA) || defined (ARCH_ALPHA)
> #define UMF_ALPHA
> #define UMFPACK_ARCHITECTURE "Compaq Alpha"
> 
> #elif defined (__WIN32) || defined (_WIN32) || defined (_win32) || defined (__win32) || defined (WIN32)
> #define UMF_WINDOWS
> #define UMFPACK_ARCHITECTURE "Microsoft Windows"
> 
> #elif defined (__hppa) || defined (__hpux) || defined (MHPUX) || defined (ARCH_HPUX)
> #define UMF_HP
> #define UMFPACK_ARCHITECTURE "HP Unix"
> 
> #elif defined (__hp700) || defined (MHP700) || defined (ARCH_HP700)
> #define UMF_HP
> #define UMFPACK_ARCHITECTURE "HP 700 Unix"
> 
> #else
> /* If the architecture is unknown, and you call the BLAS, you may need to */
> /* define BLAS_BY_VALUE, BLAS_NO_UNDERSCORE, and/or BLAS_CHAR_ARG yourself. */
> #define UMFPACK_ARCHITECTURE "unknown"
> #endif
> 
> 
> /* -------------------------------------------------------------------------- */
> /* basic definitions (see also amd_internal.h) */
> /* -------------------------------------------------------------------------- */
> 
> #define ONES_COMPLEMENT(r) (-(r)-1)
> 
> /* -------------------------------------------------------------------------- */
> /* AMD include file */
> /* -------------------------------------------------------------------------- */
> 
> /* stdio.h, stdlib.h, limits.h, and math.h, NDEBUG definition,
>  * assert.h, and MATLAB include files */
> #include "amd_internal.h"
> 
> /* -------------------------------------------------------------------------- */
> /* Real/complex and int/long definitions, double relops */
> /* -------------------------------------------------------------------------- */
> 
> #include "umf_version.h"
> 
> /* -------------------------------------------------------------------------- */
> /* Compile-time configurations */
> /* -------------------------------------------------------------------------- */
> 
> #include "umf_config.h"
> 
> /* -------------------------------------------------------------------------- */
> /* umfpack include file */
> /* -------------------------------------------------------------------------- */
> 
> #include "umfpack.h"
> 
> /* -------------------------------------------------------------------------- */
> /* for contents of Info.  This must correlate with umfpack.h */
> /* -------------------------------------------------------------------------- */
> 
> #define ESTIMATE (UMFPACK_NUMERIC_SIZE_ESTIMATE - UMFPACK_NUMERIC_SIZE)
> #define ACTUAL 0
> 
> /* -------------------------------------------------------------------------- */
> /* get a parameter from the Control array */
> /* -------------------------------------------------------------------------- */
> 
> #define GET_CONTROL(i,default) \
>     ((Control != (double *) NULL) ? \
> 	(SCALAR_IS_NAN (Control [i]) ? default : Control [i]) \
> 	: default)
> 
> /* -------------------------------------------------------------------------- */
> /* for clearing the external degree counters */
> /* -------------------------------------------------------------------------- */
> 
> #define MAX_MARK(n) Int_MAX - (2*(n)+1)
> 
> /* -------------------------------------------------------------------------- */
> /* convert number of Units to MBytes */
> /* -------------------------------------------------------------------------- */
> 
> #define MBYTES(units) (((units) * sizeof (Unit)) / 1048576.0)
> 
> /* -------------------------------------------------------------------------- */
> /* dense row/column macro */
> /* -------------------------------------------------------------------------- */
> 
> /* In order for a row or column to be treated as "dense", it must have more */
> /* entries than the value returned by this macro.  n is the dimension of the */
> /* matrix, and alpha is the dense row/column control parameter. */
> 
> /* Note: this is not defined if alpha is NaN or Inf: */
> #define UMFPACK_DENSE_DEGREE_THRESHOLD(alpha,n) \
>     ((Int) MAX (16.0, (alpha) * 16.0 * sqrt ((double) (n))))
> 
> /* -------------------------------------------------------------------------- */
> /* PRINTF */
> /* -------------------------------------------------------------------------- */
> 
> #define PRINTFk(k,params) { if (prl >= (k)) { PRINTF (params) ; } }
> #define PRINTF1(params) PRINTFk (1, params)
> #define PRINTF2(params) PRINTFk (2, params)
> #define PRINTF3(params) PRINTFk (3, params)
> #define PRINTF4(params) PRINTFk (4, params)
> #define PRINTF5(params) PRINTFk (5, params)
> #define PRINTF6(params) PRINTFk (6, params)
> 
> /* -------------------------------------------------------------------------- */
> /* Fixed control parameters */
> /* -------------------------------------------------------------------------- */
> 
> /* maximum number of columns to consider at one time, in a single front */
> #define MAX_CANDIDATES 128
> 
> /* reduce Numeric->Memory request by this ratio, if allocation fails */
> #define UMF_REALLOC_REDUCTION (0.95)
> 
> /* increase Numeric->Memory request by this ratio, if we need more */
> #define UMF_REALLOC_INCREASE (1.2)
> 
> /* increase the dimensions of the current frontal matrix by this factor
>  * when it needs to grow. */
> #define UMF_FRONTAL_GROWTH (1.2)
> 
> /* largest BLAS block size permitted */
> #define MAXNB 64
> 
> /* if abs (y) < RECIPROCAL_TOLERANCE, then compute x/y.  Otherwise x*(1/y).
>  * Ignored if NRECIPROCAL is defined */
> #define RECIPROCAL_TOLERANCE 1e-12
> 
> /* -------------------------------------------------------------------------- */
> /* Memory allocator */
> /* -------------------------------------------------------------------------- */
> 
> /* The MATLAB mexFunction uses MATLAB's memory manager, while the C-callable
>  * AMD library uses the ANSI C malloc, free, and realloc routines.  To use
>  * the mx* memory allocation routines, use -DNUTIL when compiling.
>  */
> 
> #undef ALLOCATE
> #undef FREE
> #undef REALLOC
> 
> #ifdef MATLAB_MEX_FILE
> 
> #ifdef NUTIL
> 
> /* These functions simply terminate the mexFunction if they fail to allocate
>  * memory.  That's too restrictive for UMFPACK. */
> #define ALLOCATE mxMalloc
> #define FREE mxFree
> #define REALLOCATE mxRealloc
> 
> #else
> 
> /* Use internal MATLAB memory allocation routines, used by built-in MATLAB
>  * functions.  These are not documented, but are available for use.  Their
>  * prototypes are in util.h, but that file is not provided to the MATLAB user.
>  * The advantage of using these routines is that they return NULL if out of
>  * memory, instead of terminating the mexFunction.  UMFPACK attempts to allocate
>  * extra space for "elbow room", and then reduces its request if the memory is
>  * not available.  That strategy doesn't work with the mx* routines.
>  */
> void *utMalloc (size_t size) ;
> void utFree (void *p) ;
> void *utRealloc (void *p, size_t size) ;
> #define ALLOCATE utMalloc
> #define FREE utFree
> #define REALLOCATE utRealloc
> 
> #endif
> #else
> #ifdef MATHWORKS
> 
> /* Compiling as a built-in routine.  Since out-of-memory conditions are checked
>  * after every allocation, we can use ut* routines here. */
> #define ALLOCATE utMalloc
> #define FREE utFree
> #define REALLOCATE utRealloc
> 
> #else
> 
> /* use the ANSI C memory allocation routines */
> #define ALLOCATE malloc
> #define FREE free
> #define REALLOCATE realloc
> 
> #endif
> #endif
> 
> /* -------------------------------------------------------------------------- */
> /* Memory space definitions */
> /* -------------------------------------------------------------------------- */
> 
> /* for memory alignment - assume double has worst case alignment */
> typedef double Align ;
> 
> /* get number of bytes required to hold n items of a type: */
> /* note that this will not overflow, because sizeof (type) is always */
> /* greater than or equal to sizeof (Int) >= 2 */
> #define BYTES(type,n) (sizeof (type) * (n))
> 
> /* ceiling of (b/u).  Assumes b >= 0 and u > 0 */
> #define CEILING(b,u) (((b) + (u) - 1) / (u))
> 
> /* get number of Units required to hold n items of a type: */
> #define UNITS(type,n) (CEILING (BYTES (type, n), sizeof (Unit)))
> 
> /* same as DUNITS, but use double instead of int to avoid overflow */
> #define DUNITS(type,n) (ceil (BYTES (type, (double) n) / sizeof (Unit)))
> 
> union Unit_union
> {	/* memory is allocated in multiples of Unit */
>     struct
>     {
> 	Int
> 	    size,	/* size, in Units, of the block, excl. header block */
> 			/* size >= 0: block is in use */
> 			/* size < 0: block is free, of |size| Units */
> 	    prevsize ;	/* size, in Units, of preceding block in S->Memory */
> 			/* during garbage_collection, prevsize is set to -e-1 */
> 			/* for element e, or positive (and thus a free block) */
> 			/* otherwise */
>     } header ;		/* block header */
>     Align  xxxxxx ;	/* force alignment of blocks (xxxxxx is never used) */
> } ;
> 
> typedef union Unit_union Unit ;
> 
> /* get the size of an allocated block */
> #define GET_BLOCK_SIZE(p) (((p)-1)->header.size)
> 
> /* -------------------------------------------------------------------------- */
> /* Numeric */
> /* -------------------------------------------------------------------------- */
> 
> /*
>     NUMERIC_VALID and SYMBOLIC_VALID:
>     The different values of SYBOLIC_VALID and NUMERIC_VALID are chosen as a
>     first defense against corrupted *Symbolic or *Numeric pointers passed to an
>     UMFPACK routine.  They also ensure that the objects are used only by the
>     same version that created them (umfpack_di_*, umfpack_dl_*, umfpack_zi_*,
>     or umfpack_zl_*).  The values have also been changed since prior releases of
>     the code to ensure that all routines that operate on the objects are of the
>     same release.  The values themselves are purely arbitrary.  The are less
>     than the ANSI C required minimums of INT_MAX and LONG_MAX, respectively.
> */
> 
> #ifdef DINT
> #define NUMERIC_VALID  15974
> #define SYMBOLIC_VALID 41934
> #endif
> #ifdef DLONG
> #define NUMERIC_VALID  399789120
> #define SYMBOLIC_VALID 399192913
> #endif
> #ifdef ZINT
> #define NUMERIC_VALID  17954
> #define SYMBOLIC_VALID 40923
> #endif
> #ifdef ZLONG
> #define NUMERIC_VALID  129987654
> #define SYMBOLIC_VALID 110291234
> #endif
> 
> typedef struct	/* NumericType */
> {
>     double
> 	flops,		/* "true" flop count */
> 	relpt,		/* relative pivot tolerance used */
> 	relpt2,		/* relative pivot tolerance used for sym. */
> 	alloc_init,	/* initial allocation of Numeric->memory */
> 	front_alloc_init, /* frontal matrix allocation parameter */
> 	rsmin,		/* smallest row sum */
> 	rsmax,		/* largest row sum  */
> 	min_udiag,	/* smallest abs value on diagonal of D */
> 	max_udiag,	/* smallest abs value on diagonal of D */
> 	rcond ;		/* min (D) / max (D) */
> 
>     Int
> 	scale ;
> 
>     Int valid ;		/* set to NUMERIC_VALID, for validity check */
> 
>     /* Memory space for A and LU factors */
>     Unit
> 	*Memory ;	/* working memory for A and LU factors */
>     Int
> 	ihead,		/* pointer to tail of LU factors, in Numeric->Memory */
> 	itail,		/* pointer to top of elements & tuples,  */
> 			/* in Numeric->Memory */
> 	ibig,		/* pointer to largest free block seen in tail */
> 	size ;		/* size of Memory, in Units */
> 
>     Int
> 	*Rperm,		/* pointer to row perm array, size: n+1 */
> 			/* after UMF_kernel:  Rperm [new] = old */
> 			/* during UMF_kernel: Rperm [old] = new */
> 	*Cperm,		/* pointer to col perm array, size: n+1 */
> 			/* after UMF_kernel:  Cperm [new] = old */
> 			/* during UMF_kernel: Cperm [old] = new */
> 
> 	*Upos,		/* see UMFPACK_get_numeric for a description */
> 	*Lpos,
> 	*Lip,
> 	*Lilen,
> 	*Uip,
> 	*Uilen,
> 	*Upattern ;	/* pattern of last row of U (if singular) */
> 
>     Int
> 	ulen,		/* length of Upattern */
> 	npiv,		/* number of structural pivots found (sprank approx) */
> 	nnzpiv ;	/* number of numerical (nonzero) pivots found */
> 
>     Entry
> 	*D ;		/* D [i] is the diagonal entry of U */
> 
>     Int do_recip ;
>     double *Rs ;	/* scale factors for the rows of A and b */
> 			/* do_recip FALSE: Divide row i by Rs [i] */
> 			/* do_recip TRUE:  Multiply row i by Rs [i] */
> 
>     Int
> 	n_row, n_col,	/* A is n_row-by-n_row */
> 	n1 ;		/* number of singletons */
> 
>     /* for information only: */
>     Int
> 	tail_usage,	/* amount of memory allocated in tail */
> 			/* head_usage is Numeric->ihead */
> 	init_usage,	/* memory usage just after UMF_kernel_init */
> 	max_usage,	/* peak memory usage (excludes internal and external */
> 			/* fragmentation in the tail) */
> 	ngarbage,	/* number of garbage collections performed */
> 	nrealloc,	/* number of reallocations performed */
> 	ncostly,	/* number of costly reallocations performed */
> 	isize,		/* size of integer pattern of L and U */
> 	nLentries,	/* number of entries in L, excluding diagonal */
> 	nUentries,	/* number of entries in U, including diagonal */
> 			/* Some entries may be numerically zero. */
> 	lnz,		/* number of nonzero entries in L, excl. diagonal */
> 	unz,		/* number of nonzero entries in U, excl. diagonal */
> 	maxfrsize ;	/* largest actual front size */
> 
>     Int maxnrows, maxncols ;	/* not the same as Symbolic->maxnrows/cols* */
> 
> } NumericType ;
> 
> 
> 
> /* -------------------------------------------------------------------------- */
> /* Element tuples for connecting elements together in a matrix */
> /* -------------------------------------------------------------------------- */
> 
> typedef struct	/* Tuple */
> {
>     /* The (e,f) tuples for the element lists */
>     Int
> 	e,		/* element */
> 	f ;		/* contribution to the row/col appears at this offset */
> 
> } Tuple ;
> 
> #define TUPLES(t) MAX (4, (t) + 1)
> 
> /* Col_degree is aliased with Cperm, and Row_degree with Rperm */
> #define NON_PIVOTAL_COL(col) (Col_degree [col] >= 0)
> #define NON_PIVOTAL_ROW(row) (Row_degree [row] >= 0)
> 
> /* -------------------------------------------------------------------------- */
> /* An element */
> /* -------------------------------------------------------------------------- */
> 
> typedef struct	/* Element */
> {
>     Int
> 
> 	cdeg,		/* external column degree + cdeg0 offset */
> 	rdeg,		/* external row degree    + rdeg0 offset */
> 	nrowsleft,	/* number of rows remaining */
> 	ncolsleft,	/* number of columns remaining */
> 	nrows,		/* number of rows */
> 	ncols,		/* number of columns */
> 	next ;		/* for list link of sons, used during assembly only */
> 
>     /* followed in memory by:
>     Int
> 	col [0..ncols-1],	column indices of this element
> 	row [0..nrows-1] ;	row indices of this element
>     Entry			(suitably aligned, see macro below)
> 	C [0...nrows-1, 0...ncols-1] ;
> 	size of C is nrows*ncols Entry's
>     */
> 
> } Element ;
> 
> /* macros for computing pointers to row/col indices, and contribution block: */
> 
> #define GET_ELEMENT_SIZE(nr,nc) \
> (UNITS (Element, 1) + UNITS (Int, (nc) + (nr)) + UNITS (Entry, (nc) * (nr)))
> 
> #define DGET_ELEMENT_SIZE(nr,nc) \
> (DUNITS (Element, 1) + DUNITS (Int, (nc) + (nr)) + DUNITS (Entry, (nc) * (nr)))
> 
> #define GET_ELEMENT_COLS(ep,p,Cols) { \
>     ASSERT (p != (Unit *) NULL) ; \
>     ASSERT (p >= Numeric->Memory + Numeric->itail) ; \
>     ASSERT (p <= Numeric->Memory + Numeric->size) ; \
>     ep = (Element *) p ; \
>     p += UNITS (Element, 1) ; \
>     Cols = (Int *) p ; \
> }
> 
> #define GET_ELEMENT_PATTERN(ep,p,Cols,Rows,ncm) { \
>     GET_ELEMENT_COLS (ep, p, Cols) ; \
>     ncm = ep->ncols ; \
>     Rows = Cols + ncm ; \
> }
> 
> #define GET_ELEMENT(ep,p,Cols,Rows,ncm,nrm,C) { \
>     GET_ELEMENT_PATTERN (ep, p, Cols, Rows, ncm) ; \
>     nrm = ep->nrows ; \
>     p += UNITS (Int, ncm + nrm) ; \
>     C = (Entry *) p ; \
> }
> 
> /* -------------------------------------------------------------------------- */
> /* Work data structure */
> /* -------------------------------------------------------------------------- */
> 
> /*
>     This data structure holds items needed only during factorization.
>     All of this is freed when UMFPACK_numeric completes.  Note that some of
>     it is stored in the tail end of Numeric->S (namely, the Tuples and the
>     Elements).
> */
> 
> typedef struct	/* WorkType */
> {
> 
>     /* ---------------------------------------------------------------------- */
>     /* information about each row and col of A */
>     /* ---------------------------------------------------------------------- */
> 
>     /*
> 	Row_tuples:	pointer to tuple list (alias with Numeric->Uip)
> 	Row_tlen:	number of tuples (alias with Numeric->Uilen)
> 	Col_tuples:	pointer to tuple list (alias with Numeric->Lip)
> 	Col_tlen:	number of tuples (alias with Numeric->Lilen)
> 	Row_degree:	degree of the row or column (alias Numeric->Rperm)
> 	Col_degree:	degree of the row or column (alias Numeric->Cperm)
> 
> 	The Row_degree and Col_degree are MATLAB-style colmmd approximations,
> 	are equal to the sum of the sizes of the elements (contribution blocks)
> 	in each row and column.  They are maintained when elements are created
> 	and assembled.  They are used only during the pivot row and column
> 	search.  They are not needed to represent the pattern of the remaining
> 	matrix.
>     */
> 
>     /* ---------------------------------------------------------------------- */
>     /* information about each element */
>     /* ---------------------------------------------------------------------- */
> 
>     Int	*E ;		/* E [0 .. Work->elen-1] element "pointers" */
> 			/* (offsets in Numeric->Memory) */
> 
>     /* ---------------------------------------------------------------------- */
>     /* generic workspace */
>     /* ---------------------------------------------------------------------- */
> 
>     Entry *Wx, *Wy ;	/* each of size maxnrows+1 */
> 
>     Int			/* Sizes:  nn = MAX (n_row, n_col) */
> 	*Wp,		/* nn+1 */
> 	*Wrp,		/* n_col+1 */
> 	*Wm,		/* maxnrows+1 */
> 	*Wio,		/* maxncols+1 */
> 	*Woi,		/* maxncols+1 */
> 	*Woo,		/* MAX (maxnrows,maxncols)+1 */
> 	*Wrow,		/* pointer to Fcols, Wio, or Woi */
> 	*NewRows,	/* list of rows to scan */
> 	*NewCols ;	/* list of cols to scan */
> 
>     /* ---------------------------------------------------------------------- */
> 
>     Int
> 	*Lpattern,	/* pattern of column of L, for one Lchain */
> 	*Upattern,	/* pattern of row of U, for one Uchain */
> 	ulen, llen ;	/* length of Upattern and Lpattern */
> 
>     Int
> 	*Diagonal_map,	/* used for symmetric pivoting, of size nn+1 */
> 	*Diagonal_imap ;/* used for symmetric pivoting, of size nn+1 */
> 
>     /* ---------------------------------------------------------------------- */
> 
>     Int
> 	n_row, n_col,	/* matrix is n_row-by-n_col */
> 	nz,		/* nonzeros in the elements for this matrix */
> 	n1,		/* number of row and col singletons */
> 	elen,		/* max possible number of elements */
> 	npiv,		/* number of pivot rows and columns so far */
> 	ndiscard,	/* number of discarded pivot columns */
> 	Wrpflag,
> 	nel,		/* elements in use are in the range 1..nel */
> 	noff_diagonal,
> 	prior_element,
> 	rdeg0, cdeg0,
> 	rrdeg, ccdeg,
> 	Candidates [MAX_CANDIDATES],	 /* current candidate pivot columns */
> 	nCandidates,	/* number of candidates in Candidate set */
> 	ksuper,
> 	firstsuper,
> 	jsuper,
> 	ncand,		/* number of candidates (some not in Candidates[ ]) */
> 	nextcand,	/* next candidate to place in Candidate search set */
> 	lo,
> 	hi,
> 	pivrow,		/* current pivot row */
> 	pivcol,		/* current pivot column */
> 	do_extend,	/* true if the next pivot extends the current front */
> 	do_update,	/* true if update should be applied */
> 	nforced,	/* number of forced updates because of frontal growth */
> 	any_skip,
> 	do_scan2row,
> 	do_scan2col,
> 	do_grow,
> 	pivot_case,
> 	frontid,	/* id of current frontal matrix */
> 	nfr ;		/* number of frontal matrices */
> 
>     /* ---------------------------------------------------------------------- */
>     /* For row-merge tree */
>     /* ---------------------------------------------------------------------- */
> 
>     Int
> 	*Front_new1strow ;
> 
>     /* ---------------------------------------------------------------------- */
>     /* current frontal matrix, F */
>     /* ---------------------------------------------------------------------- */
> 
>     Int Pivrow [MAXNB],
> 	Pivcol [MAXNB] ;
> 
>     Entry
> 	*Flublock,	/* LU block, nb-by-nb */
> 	*Flblock,	/* L block,  fnr_curr-by-nb */
> 	*Fublock,	/* U block,  nb-by-fnc_curr, or U' fnc_curr-by-nb */
> 	*Fcblock ;	/* C block,  fnr_curr-by-fnc_curr */
> 
>     Int
> 	*Frows,		/* Frows [0.. ]: row indices of F */
> 
> 	*Fcols,		/* Fcols [0.. ]: column indices of F */
> 
> 	*Frpos,		/* position of row indices in F, or -1 if not present */
> 			/* if Frows[i] == row, then Frpos[row] == i */
> 
> 	*Fcpos,		/* position of col indices in F, or -1 if not present */
> 			/* if Fcols[j] == col, then */
> 			/* Fcpos[col] == j*Work->fnr_curr */
> 
> 	fnrows,		/* number of rows in contribution block in F */
> 	fncols,		/* number of columns in contribution block in F */
> 	fnr_curr,	/* maximum # of rows in F (leading dimension) */
> 	fnc_curr,	/* maximum # of columns in F */
> 	fcurr_size,	/* current size of F */
> 	fnrows_max,	/* max possible column-dimension (max # of rows) of F */
> 	fncols_max,	/* max possible row-dimension (max # of columns) of F */
> 	nb,
> 	fnpiv,		/* number of pivots in F */
> 	fnzeros,	/* number of explicit zero entries in LU block */
> 	fscan_row,	/* where to start scanning rows of F in UMF_assemble */
> 	fscan_col,	/* where to start scanning cols of F in UMF_assemble */
> 	fnrows_new,	/* number of new row indices in F after pivot added */
> 	fncols_new,	/* number of new col indices in F after pivot added */
> 	pivrow_in_front,	/* true if current pivot row in Frows */
> 	pivcol_in_front ;	/* true if current pivot column in Fcols */
> 
>     /* ----------------------------------------------------------------------
>      * Current frontal matrix
>      * ----------------------------------------------------------------------
>      * The current frontal matrix is held as a single block of memory allocated
>      * from the "tail" end of Numeric->Memory.  It is subdivided into four
>      * parts: an LU block, an L block, a U block, and a C block.
>      *
>      * Let k = fnpiv, r = fnrows, and c = fncols for the following discussion.
>      * Let dr = fnr_curr and dc = fnc_curr.  Note that r <= dr and c <= dc.
>      *
>      * The LU block is of dimension nb-by-nb.  The first k-by-k part holds the
>      * "diagonal" part of the LU factors for these k pivot rows and columns.
>      * The k pivot row and column indices in this part are Pivrow [0..k-1] and
>      * Pivcol [0..k-1], respectively.
>      *
>      * The L block is of dimension dr-by-nb.  It holds the k pivot columns,
>      * except for the leading k-by-k part in the LU block.  Only the leading
>      * r-by-k part is in use.
>      *
>      * The U block is of dimension dc-by-nb.  It holds the k pivot rows,
>      * except for the leading k-by-k part in the LU block.  It is stored in
>      * row-oriented form.  Only the leading c-by-k part is in use.
>      *
>      * The C block is of dimension dr-by-dc.  It holds the current contribution
>      * block.  Only the leading r-by-c part is in use.  The column indices in
>      * the C block are Fcols [0..c-1], and the row indices are Frows [0..r-1].
>      *
>      * dr is always odd, to avoid bad cache behavior.
>      */
> 
> } WorkType ;
> 
> 
> /* -------------------------------------------------------------------------- */
> /* Symbolic */
> /* -------------------------------------------------------------------------- */
> 
> /*
>     This is is constructed by UMFPACK_symbolic, and is needed by UMFPACK_numeric
>     to factor the matrix.
> */
> 
> typedef struct	/* SymbolicType */
> {
> 
>     double
> 	num_mem_usage_est,	/* estimated max Numeric->Memory size */
> 	num_mem_size_est,	/* estimated final Numeric->Memory size */
> 	peak_sym_usage,		/* peak Symbolic and SymbolicWork usage */
> 	sym,			/* symmetry of pattern */
> 	dnum_mem_init_usage,	/* min Numeric->Memory for UMF_kernel_init */
> 	amd_lunz,	/* nz in LU for AMD, with symmetric pivoting */
> 	lunz_bound ;	/* max nx in LU, for arbitrary row pivoting */
> 
>     Int valid,		/* set to SYMBOLIC_VALID, for validity check */
> 	max_nchains,
> 	nchains,
> 	*Chain_start,
> 	*Chain_maxrows,
> 	*Chain_maxcols,
> 	maxnrows,		/* largest number of rows in any front */
> 	maxncols,		/* largest number of columns in any front */
> 	*Front_npivcol,		/* Front_npivcol [j] = size of jth supercolumn*/
> 	*Front_1strow,		/* first row index in front j */
> 	*Front_leftmostdesc,	/* leftmost desc of front j */
> 	*Front_parent,		/* super-column elimination tree */
> 	*Cperm_init,		/* initial column ordering */
> 	*Rperm_init,		/* initial row ordering */
> 	*Cdeg, *Rdeg,
> 	*Esize,
> 	dense_row_threshold,
> 	n1,			/* number of singletons */
> 	nempty,			/* MIN (nempty_row, nempty_col) */
> 	*Diagonal_map,		/* initial "diagonal" (after 2by2) */
> 	esize,			/* size of Esize array */
> 	nfr,
> 	n_row, n_col,		/* matrix A is n_row-by-n_col */
> 	nz,			/* nz of original matrix */
> 	nb,			/* block size for BLAS 3 */
> 	num_mem_init_usage,	/* min Numeric->Memory for UMF_kernel_init */
> 	nempty_row, nempty_col,
> 
> 	strategy,
> 	ordering,
> 	fixQ,
> 	prefer_diagonal,
> 	nzaat,
> 	nzdiag,
> 	amd_dmax ;
> 
> } SymbolicType ;
> 
> 
> /* -------------------------------------------------------------------------- */
> /* for debugging only: */
> /* -------------------------------------------------------------------------- */
> 
> #include "umf_dump.h"
> 
> /* -------------------------------------------------------------------------- */
> /* for statement coverage testing only: */
> /* -------------------------------------------------------------------------- */
> 
> #ifdef TESTING
> 
> /* for testing integer overflow: */
> #ifdef TEST_FOR_INTEGER_OVERFLOW
> #undef MAX_MARK
> #define MAX_MARK(n) (3*(n))
> #endif
> 
> /* for testing out-of-memory conditions: */
> #define UMF_TCOV_TEST
> GLOBAL extern Int umf_fail, umf_fail_lo, umf_fail_hi ;
> GLOBAL extern Int umf_realloc_fail, umf_realloc_lo, umf_realloc_hi ;
> 
> /* for testing malloc count: */
> #define UMF_MALLOC_COUNT
> 
> #endif
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_is_permutation.h pysparse/pysparse/direct/umfpack/include/umf_is_permutation.h
0a1,14
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL Int UMF_is_permutation
> (
>     const Int P [ ],
>     Int W [ ],
>     Int n,
>     Int r
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_kernel.h pysparse/pysparse/direct/umfpack/include/umf_kernel.h
0a1,19
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL Int UMF_kernel
> (
>     const Int Ap [ ],
>     const Int Ai [ ],
>     const double Ax [ ],
> #ifdef COMPLEX
>     const double Az [ ],
> #endif
>     NumericType *Numeric,
>     WorkType *Work,
>     SymbolicType *Symbolic
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_kernel_init.h pysparse/pysparse/direct/umfpack/include/umf_kernel_init.h
0a1,19
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL Int UMF_kernel_init
> (
>     const Int Ap [ ],
>     const Int Ai [ ],
>     const double Ax [ ],
> #ifdef COMPLEX
>     const double Az [ ],
> #endif
>     NumericType *Numeric,
>     WorkType *Work,
>     SymbolicType *Symbolic
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_kernel_wrapup.h pysparse/pysparse/direct/umfpack/include/umf_kernel_wrapup.h
0a1,13
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL void UMF_kernel_wrapup
> (
>     NumericType *Numeric,
>     SymbolicType *Symbolic,
>     WorkType *Work
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_local_search.h pysparse/pysparse/direct/umfpack/include/umf_local_search.h
0a1,13
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL Int UMF_local_search
> (
>     NumericType *Numeric,
>     WorkType *Work,
>     SymbolicType *Symbolic
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_lsolve.h pysparse/pysparse/direct/umfpack/include/umf_lsolve.h
0a1,13
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL double UMF_lsolve
> (
>     NumericType *Numeric,
>     Entry X [ ],
>     Int Pattern [ ]
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_ltsolve.h pysparse/pysparse/direct/umfpack/include/umf_ltsolve.h
0a1,20
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL double UMF_ltsolve
> (
>     NumericType *Numeric,
>     Entry X [ ],
>     Int Pattern [ ]
> ) ;
> 
> GLOBAL double UMF_lhsolve
> (
>     NumericType *Numeric,
>     Entry X [ ],
>     Int Pattern [ ]
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_malloc.h pysparse/pysparse/direct/umfpack/include/umf_malloc.h
0a1,16
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> #if defined (UMF_MALLOC_COUNT) || !defined (NDEBUG)
> GLOBAL extern Int UMF_malloc_count ;
> #endif
> 
> GLOBAL void *UMF_malloc
> (
>     Int n_objects,
>     size_t size_of_object
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_mem_alloc_element.h pysparse/pysparse/direct/umfpack/include/umf_mem_alloc_element.h
0a1,18
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL Int UMF_mem_alloc_element
> (
>     NumericType *Numeric,
>     Int nrows,
>     Int ncols,
>     Int **Rows,
>     Int **Cols,
>     Entry **C,
>     Int *size,
>     Element **epout
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_mem_alloc_head_block.h pysparse/pysparse/direct/umfpack/include/umf_mem_alloc_head_block.h
0a1,12
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL Int UMF_mem_alloc_head_block
> (
>     NumericType *Numeric,
>     Int nunits
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_mem_alloc_tail_block.h pysparse/pysparse/direct/umfpack/include/umf_mem_alloc_tail_block.h
0a1,12
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL Int UMF_mem_alloc_tail_block
> (
>     NumericType *Numeric,
>     Int nunits
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_mem_free_tail_block.h pysparse/pysparse/direct/umfpack/include/umf_mem_free_tail_block.h
0a1,12
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL void UMF_mem_free_tail_block
> (
>     NumericType *Numeric,
>     Int i
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_mem_init_memoryspace.h pysparse/pysparse/direct/umfpack/include/umf_mem_init_memoryspace.h
0a1,11
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL void UMF_mem_init_memoryspace
> (
>     NumericType *Numeric
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_realloc.h pysparse/pysparse/direct/umfpack/include/umf_realloc.h
0a1,13
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL void *UMF_realloc
> (
>     void *p,
>     Int n_objects,
>     size_t size_of_object
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_report_perm.h pysparse/pysparse/direct/umfpack/include/umf_report_perm.h
0a1,15
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL Int UMF_report_perm
> (
>     Int n,
>     const Int P [ ],
>     Int W [ ],
>     Int prl,
>     Int user
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_report_vector.h pysparse/pysparse/direct/umfpack/include/umf_report_vector.h
0a1,16
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL Int UMF_report_vector
> (
>     Int n,
>     const double Xx [ ],
>     const double Xz [ ],
>     Int prl,
>     Int user,
>     Int scalar
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_row_search.h pysparse/pysparse/direct/umfpack/include/umf_row_search.h
0a1,33
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL Int UMF_row_search
> (
>     NumericType *Numeric,
>     WorkType *Work,
>     SymbolicType *Symbolic,
>     Int cdeg0,
>     Int cdeg1,
>     const Int Pattern [ ],
>     const Int Pos [ ],
>     Int pivrow [2],
>     Int rdeg [2],
>     Int W_i [ ],
>     Int W_o [ ],
>     Int prior_pivrow [2],
>     const Entry Wxy [ ],
>     Int pivcol,
>     Int freebie [2]
> ) ;
> 
> #define IN 0
> #define OUT 1
> 
> #define IN_IN 0
> #define IN_OUT 1
> #define OUT_IN 2
> #define OUT_OUT 3
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_scale.h pysparse/pysparse/direct/umfpack/include/umf_scale.h
0a1,13
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL void UMF_scale
> (
>     Int n,
>     Entry alpha,
>     Entry X [ ]
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_scale_column.h pysparse/pysparse/direct/umfpack/include/umf_scale_column.h
0a1,12
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL void UMF_scale_column
> (
>     NumericType *Numeric,
>     WorkType *Work
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_set_stats.h pysparse/pysparse/direct/umfpack/include/umf_set_stats.h
0a1,25
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL void UMF_set_stats
> (
>     double Info [ ],
>     SymbolicType *Symbolic,
>     double max_usage,
>     double num_mem_size,
>     double flops,
>     double lnz,
>     double unz,
>     double maxfrsize,
>     double ulen,
>     double npiv,
>     double maxnrows,
>     double maxncols,
>     Int scale,
>     Int prefer_diagonal,
>     Int what
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_singletons.h pysparse/pysparse/direct/umfpack/include/umf_singletons.h
0a1,31
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL Int UMF_singletons
> (
>     Int n_row,
>     Int n_col,
>     const Int Ap [ ],
>     const Int Ai [ ],
>     const Int Quser [ ],
>     Int Cdeg [ ],
>     Int Cperm [ ],
>     Int Rdeg [ ],
>     Int Rperm [ ],
>     Int InvRperm [ ],
>     Int *n1,
>     Int *n1c,
>     Int *n1r,
>     Int *nempty_col,
>     Int *nempty_row,
>     Int *is_sym,
>     Int *max_rdeg,
>     Int Rp [ ],
>     Int Ri [ ],
>     Int W [ ],
>     Int Next [ ]
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_solve.h pysparse/pysparse/direct/umfpack/include/umf_solve.h
0a1,26
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL Int UMF_solve
> (
>     Int sys,
>     const Int Ap [ ],
>     const Int Ai [ ],
>     const double Ax [ ],
>     double Xx [ ],
>     const double Bx [ ],
> #ifdef COMPLEX
>     const double Az [ ],
>     double Xz [ ],
>     const double Bz [ ],
> #endif
>     NumericType *Numeric,
>     Int irstep,
>     double Info [UMFPACK_INFO],
>     Int Pattern [ ],
>     double SolveWork [ ]
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_start_front.h pysparse/pysparse/direct/umfpack/include/umf_start_front.h
0a1,14
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL Int UMF_start_front
> (
>     Int chain,
>     NumericType *Numeric,
>     WorkType *Work,
>     SymbolicType *Symbolic
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_store_lu.h pysparse/pysparse/direct/umfpack/include/umf_store_lu.h
0a1,12
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL Int UMF_store_lu
> (
>     NumericType *Numeric,
>     WorkType *Work
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_symbolic_usage.h pysparse/pysparse/direct/umfpack/include/umf_symbolic_usage.h
0a1,16
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL double UMF_symbolic_usage
> (
>     Int n_row,
>     Int n_col,
>     Int nchains,
>     Int nfr,
>     Int esize,
>     Int prefer_diagonal
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_transpose.h pysparse/pysparse/direct/umfpack/include/umf_transpose.h
0a1,28
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL Int UMF_transpose
> (
>     Int n_row,
>     Int n_col,
>     const Int Ap [ ],
>     const Int Ai [ ],
>     const double Ax [ ],
>     const Int P [ ],
>     const Int Q [ ],
>     Int nq,
>     Int Rp [ ],
>     Int Ri [ ],
>     double Rx [ ],
>     Int W [ ],
>     Int check
> #ifdef COMPLEX
>     , const double Az [ ]
>     , double Rz [ ]
>     , Int do_conjugate
> #endif
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_triplet.h pysparse/pysparse/direct/umfpack/include/umf_triplet.h
0a1,86
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL Int UMF_triplet_map_x
> (
>     Int n_row,
>     Int n_col,
>     Int nz,
>     const Int Ti [ ],
>     const Int Tj [ ],
>     Int Ap [ ],
>     Int Ai [ ],
>     Int Rp [ ],
>     Int Rj [ ],
>     Int W [ ],
>     Int RowCount [ ]
>     , const double Tx [ ]
>     , double Ax [ ]
>     , double Rx [ ]
> #ifdef COMPLEX
>     , const double Tz [ ]
>     , double Az [ ]
>     , double Rz [ ]
> #endif
>     , Int Map [ ]
>     , Int Map2 [ ]
> ) ;
> 
> GLOBAL Int UMF_triplet_map_nox
> (
>     Int n_row,
>     Int n_col,
>     Int nz,
>     const Int Ti [ ],
>     const Int Tj [ ],
>     Int Ap [ ],
>     Int Ai [ ],
>     Int Rp [ ],
>     Int Rj [ ],
>     Int W [ ],
>     Int RowCount [ ]
>     , Int Map [ ]
>     , Int Map2 [ ]
> ) ;
> 
> GLOBAL Int UMF_triplet_nomap_x
> (
>     Int n_row,
>     Int n_col,
>     Int nz,
>     const Int Ti [ ],
>     const Int Tj [ ],
>     Int Ap [ ],
>     Int Ai [ ],
>     Int Rp [ ],
>     Int Rj [ ],
>     Int W [ ],
>     Int RowCount [ ]
>     , const double Tx [ ]
>     , double Ax [ ]
>     , double Rx [ ]
> #ifdef COMPLEX
>     , const double Tz [ ]
>     , double Az [ ]
>     , double Rz [ ]
> #endif
> ) ;
> 
> GLOBAL Int UMF_triplet_nomap_nox
> (
>     Int n_row,
>     Int n_col,
>     Int nz,
>     const Int Ti [ ],
>     const Int Tj [ ],
>     Int Ap [ ],
>     Int Ai [ ],
>     Int Rp [ ],
>     Int Rj [ ],
>     Int W [ ],
>     Int RowCount [ ]
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_tuple_lengths.h pysparse/pysparse/direct/umfpack/include/umf_tuple_lengths.h
0a1,13
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL Int UMF_tuple_lengths
> (
>     NumericType *Numeric,
>     WorkType *Work,
>     double *dusage
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_usolve.h pysparse/pysparse/direct/umfpack/include/umf_usolve.h
0a1,13
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL double UMF_usolve
> (
>     NumericType *Numeric,
>     Entry X [ ],
>     Int Pattern [ ]
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_utsolve.h pysparse/pysparse/direct/umfpack/include/umf_utsolve.h
0a1,21
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL double UMF_utsolve
> (
>     NumericType *Numeric,
>     Entry X [ ],
>     Int Pattern [ ]
> ) ;
> 
> 
> GLOBAL double UMF_uhsolve
> (
>     NumericType *Numeric,
>     Entry X [ ],
>     Int Pattern [ ]
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_valid_numeric.h pysparse/pysparse/direct/umfpack/include/umf_valid_numeric.h
0a1,11
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL Int UMF_valid_numeric
> (
>     NumericType *Numeric
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_valid_symbolic.h pysparse/pysparse/direct/umfpack/include/umf_valid_symbolic.h
0a1,11
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> GLOBAL Int UMF_valid_symbolic
> (
>     SymbolicType *Symbolic
> ) ;
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umf_version.h pysparse/pysparse/direct/umfpack/include/umf_version.h
0a1,985
> /* ========================================================================== */
> /* === umf_version.h ======================================================== */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> /*
>    Define routine names, depending on version being compiled.
> 
>    DINT:	double precision, int's as integers
>    DLONG:	double precision, long's as integers
>    ZLONG:	complex double precision, long's as integers
>    ZINT:	complex double precision, int's as integers
> */
> 
> /* Set DINT as the default, if nothing is defined */
> #if !defined (DLONG) && !defined (DINT) && !defined (ZLONG) && !defined (ZINT)
> #define DINT
> #endif
> 
> /* Determine if this is a real or complex version */
> #if defined (ZLONG) || defined (ZINT)
> #define COMPLEX
> #endif
> 
> /* -------------------------------------------------------------------------- */
> /* integer type (Int is int or long) now defined in amd_internal.h */
> /* -------------------------------------------------------------------------- */
> 
> #if defined (DLONG) || defined (ZLONG)
> #define LONG_INTEGER
> #endif
> 
> /* -------------------------------------------------------------------------- */
> /* Numerical relop macros for correctly handling the NaN case */
> /* -------------------------------------------------------------------------- */
> 
> /*
> SCALAR_IS_NAN(x):
>     True if x is NaN.  False otherwise.  The commonly-existing isnan(x)
>     function could be used, but it's not in Kernighan & Ritchie 2nd edition
>     (ANSI C).  It may appear in <math.h>, but I'm not certain about
>     portability.  The expression x != x is true if and only if x is NaN,
>     according to the IEEE 754 floating-point standard.
> 
> SCALAR_IS_ZERO(x):
>     True if x is zero.  False if x is nonzero, NaN, or +/- Inf.
>     This is (x == 0) if the compiler is IEEE 754 compliant.
> 
> SCALAR_IS_NONZERO(x):
>     True if x is nonzero, NaN, or +/- Inf.  False if x zero.
>     This is (x != 0) if the compiler is IEEE 754 compliant.
> 
> SCALAR_IS_LTZERO(x):
>     True if x is < zero or -Inf.  False if x is >= 0, NaN, or +Inf.
>     This is (x < 0) if the compiler is IEEE 754 compliant.
> */
> 
> #if defined (MATHWORKS)
> 
> /* The MathWorks has their own macros in util.h that handle NaN's properly. */
> #define SCALAR_IS_NAN(x)	(utIsNaN (x))
> #define SCALAR_IS_ZERO(x)	(utEQZero (x))
> #define SCALAR_IS_NONZERO(x)	(utNEZero (x))
> #define SCALAR_IS_LTZERO(x)	(utLTZero (x))
> 
> #elif defined (UMF_WINDOWS)
> 
> /* Yes, this is exceedingly ugly.  Blame Microsoft, which hopelessly */
> /* violates the IEEE 754 floating-point standard in a bizarre way. */
> /* If you're using an IEEE 754-compliant compiler, then x != x is true */
> /* iff x is NaN.  For Microsoft, (x < x) is true iff x is NaN. */
> /* So either way, this macro safely detects a NaN. */
> #define SCALAR_IS_NAN(x)	(((x) != (x)) || (((x) < (x))))
> #define SCALAR_IS_ZERO(x)	(((x) == 0.) && !SCALAR_IS_NAN(x))
> #define SCALAR_IS_NONZERO(x)	(((x) != 0.) || SCALAR_IS_NAN(x))
> #define SCALAR_IS_LTZERO(x)	(((x) < 0.) && !SCALAR_IS_NAN(x))
> 
> #else
> 
> /* These all work properly, according to the IEEE 754 standard ... except on */
> /* a PC with windows.  Works fine in Linux on the same PC... */
> #define SCALAR_IS_NAN(x)	((x) != (x))
> #define SCALAR_IS_ZERO(x)	((x) == 0.)
> #define SCALAR_IS_NONZERO(x)	((x) != 0.)
> #define SCALAR_IS_LTZERO(x)	((x) < 0.)
> 
> #endif
> 
> /* scalar absolute value macro. If x is NaN, the result is NaN: */
> #define SCALAR_ABS(x) ((SCALAR_IS_LTZERO (x)) ? -(x) : (x))
> 
> /* true if an integer (stored in double x) would overflow (or if x is NaN) */
> #define INT_OVERFLOW(x) ((!((x) * (1.0+1e-8) <= (double) Int_MAX)) \
> 			|| SCALAR_IS_NAN (x))
> 
> /* print a scalar (avoid printing "-0" for negative zero).  */
> #define PRINT_SCALAR(a) \
> { \
>     if (SCALAR_IS_NONZERO (a)) \
>     { \
> 	PRINTF ((" (%g)", (a))) ; \
>     } \
>     else \
>     { \
> 	PRINTF ((" (0)")) ; \
>     } \
> }
> 
> /* -------------------------------------------------------------------------- */
> /* Real floating-point arithmetic */
> /* -------------------------------------------------------------------------- */
> 
> #ifndef COMPLEX
> 
> #define Entry double
> 
> #define REAL_COMPONENT(c)		(c)
> #define IMAG_COMPONENT(c)		(0.)
> #define ASSIGN(c,s1,s2)		    { (c) = (s1) ; }
> #define CLEAR(c)		    { (c) = 0. ; }
> #define CLEAR_AND_INCREMENT(p)	    { *p++ = 0. ; }
> #define IS_NAN(a)		    SCALAR_IS_NAN (a)
> #define IS_ZERO(a)		    SCALAR_IS_ZERO (a)
> #define IS_NONZERO(a)		    SCALAR_IS_NONZERO (a)
> #define SCALE_DIV(c,s)		    { (c) /= (s) ; }
> #ifndef NRECIPROCAL
> #define SCALE_RECIP(c,s)	    { (c) *= (s) ; }
> #endif
> #define ASSEMBLE(c,a)		    { (c) += (a) ; }
> #define ASSEMBLE_AND_INCREMENT(c,p) { (c) += *p++ ; }
> #define DECREMENT(c,a)		    { (c) -= (a) ; }
> #define MULT(c,a,b)		    { (c) = (a) * (b) ; }
> #define MULT_CONJ(c,a,b)	    { (c) = (a) * (b) ; }
> #define MULT_SUB(c,a,b)		    { (c) -= (a) * (b) ; }
> #define MULT_SUB_CONJ(c,a,b)	    { (c) -= (a) * (b) ; }
> #define DIV(c,a,b)		    { (c) = (a) / (b) ; }
> #define RECIPROCAL(c)		    { (c) = 1.0 / (c) ; }
> #define DIV_CONJ(c,a,b)		    { (c) = (a) / (b) ; }
> #define APPROX_ABS(s,a)		    { (s) = SCALAR_ABS (a) ; }
> #define ABS(s,a)		    { (s) = SCALAR_ABS (a) ; }
> #define PRINT_ENTRY(a)		    PRINT_SCALAR (a)
> 
> /* for flop counts */
> #define MULTSUB_FLOPS	2.	/* c -= a*b */
> #define DIV_FLOPS	1.	/* c = a/b */
> #define ABS_FLOPS	0.	/* c = abs (a) */
> #define ASSEMBLE_FLOPS	1.	/* c += a */
> #define DECREMENT_FLOPS	1.	/* c -= a */
> #define MULT_FLOPS	1.	/* c = a*b */
> #define SCALE_FLOPS	1.	/* c = a/s */
> 
> #else
> 
> /* -------------------------------------------------------------------------- */
> /* Complex floating-point arithmetic */
> /* -------------------------------------------------------------------------- */
> 
> /*
>     Note:  An alternative to this DoubleComplex type would be to use a
>     struct { double r ; double i ; }.  The problem with that method
>     (used by the Sun Performance Library, for example) is that ANSI C provides
>     no guarantee about the layout of a struct.  It is possible that the sizeof
>     the struct above would be greater than 2 * sizeof (double).  This would
>     mean that the complex BLAS could not be used.  The method used here avoids
>     that possibility.  ANSI C *does* guarantee that an array of structs has
>     the same size as n times the size of one struct.
> 
>     The ANSI C99 version of the C language includes a "double _Complex" type.
>     It should be possible in that case to do the following:
> 
>     #define Entry double _Complex
> 
>     and remove the DoubleComplex struct.  The macros, below, could then be
>     replaced with instrinsic operators.  Note that the #define Real and
>     #define Imag should also be removed (they only appear in this file).
> 
>     For the MULT, MULT_SUB, MULT_SUB_CONJ, and MULT_CONJ macros,
>     the output argument c cannot be the same as any input argument.
> 
> */
> 
> typedef struct
> {
>     double component [2] ;	/* real and imaginary parts */
> 
> } DoubleComplex ;
> 
> #define Entry DoubleComplex
> #define Real component [0]
> #define Imag component [1]
> 
> /* for flop counts */
> #define MULTSUB_FLOPS	8.	/* c -= a*b */
> #define DIV_FLOPS	9.	/* c = a/b */
> #define ABS_FLOPS	6.	/* c = abs (a), count sqrt as one flop */
> #define ASSEMBLE_FLOPS	2.	/* c += a */
> #define DECREMENT_FLOPS	2.	/* c -= a */
> #define MULT_FLOPS	6.	/* c = a*b */
> #define SCALE_FLOPS	2.	/* c = a/s or c = a*s */
> 
> /* -------------------------------------------------------------------------- */
> 
> /* real part of c */
> #define REAL_COMPONENT(c) ((c).Real)
> 
> /* -------------------------------------------------------------------------- */
> 
> /* imag part of c */
> #define IMAG_COMPONENT(c) ((c).Imag)
> 
> /* -------------------------------------------------------------------------- */
> 
> /* c = (s1) + (s2)i */
> #define ASSIGN(c,s1,s2) \
> { \
>     (c).Real = (s1) ; \
>     (c).Imag = (s2) ; \
> }
> 
> /* -------------------------------------------------------------------------- */
> 
> /* c = 0 */
> #define CLEAR(c) \
> { \
>     (c).Real = 0. ; \
>     (c).Imag = 0. ; \
> }
> 
> /* -------------------------------------------------------------------------- */
> 
> /* *p++ = 0 */
> #define CLEAR_AND_INCREMENT(p) \
> { \
>     p->Real = 0. ; \
>     p->Imag = 0. ; \
>     p++ ; \
> }
> 
> /* -------------------------------------------------------------------------- */
> 
> /* True if a == 0 */
> #define IS_ZERO(a) \
>     (SCALAR_IS_ZERO ((a).Real) && SCALAR_IS_ZERO ((a).Imag))
> 
> /* -------------------------------------------------------------------------- */
> 
> /* True if a is NaN */
> #define IS_NAN(a) \
>     (SCALAR_IS_NAN ((a).Real) || SCALAR_IS_NAN ((a).Imag))
> 
> /* -------------------------------------------------------------------------- */
> 
> /* True if a != 0 */
> #define IS_NONZERO(a) \
>     (SCALAR_IS_NONZERO ((a).Real) || SCALAR_IS_NONZERO ((a).Imag))
> 
> /* -------------------------------------------------------------------------- */
> 
> /* c /= s */
> #define SCALE_DIV(c,s) \
> { \
>     (c).Real /= (s) ; \
>     (c).Imag /= (s) ; \
> }
> 
> /* -------------------------------------------------------------------------- */
> 
> /* c *= s, where s is the reciprocal scale factor.  Not used if
>  * NRECIPROCAL is defined at compile time. */
> #ifndef NRECIPROCAL
> #define SCALE_RECIP(c,s) \
> { \
>     (c).Real *= (s) ; \
>     (c).Imag *= (s) ; \
> }
> #endif
> 
> /* -------------------------------------------------------------------------- */
> 
> /* c += a */
> #define ASSEMBLE(c,a) \
> { \
>     (c).Real += (a).Real ; \
>     (c).Imag += (a).Imag ; \
> }
> 
> /* -------------------------------------------------------------------------- */
> 
> /* c += *p++ */
> #define ASSEMBLE_AND_INCREMENT(c,p) \
> { \
>     (c).Real += p->Real ; \
>     (c).Imag += p->Imag ; \
>     p++ ; \
> }
> 
> /* -------------------------------------------------------------------------- */
> 
> /* c -= a */
> #define DECREMENT(c,a) \
> { \
>     (c).Real -= (a).Real ; \
>     (c).Imag -= (a).Imag ; \
> }
> 
> /* -------------------------------------------------------------------------- */
> 
> /* c = a*b, assert because c cannot be the same as a or b */
> #define MULT(c,a,b) \
> { \
>     ASSERT (&(c) != &(a) && &(c) != &(b)) ; \
>     (c).Real = (a).Real * (b).Real - (a).Imag * (b).Imag ; \
>     (c).Imag = (a).Imag * (b).Real + (a).Real * (b).Imag ; \
> }
> 
> /* -------------------------------------------------------------------------- */
> 
> /* c = a*conjugate(b), assert because c cannot be the same as a or b */
> #define MULT_CONJ(c,a,b) \
> { \
>     ASSERT (&(c) != &(a) && &(c) != &(b)) ; \
>     (c).Real = (a).Real * (b).Real + (a).Imag * (b).Imag ; \
>     (c).Imag = (a).Imag * (b).Real - (a).Real * (b).Imag ; \
> }
> 
> /* -------------------------------------------------------------------------- */
> 
> /* c -= a*b, assert because c cannot be the same as a or b */
> #define MULT_SUB(c,a,b) \
> { \
>     ASSERT (&(c) != &(a) && &(c) != &(b)) ; \
>     (c).Real -= (a).Real * (b).Real - (a).Imag * (b).Imag ; \
>     (c).Imag -= (a).Imag * (b).Real + (a).Real * (b).Imag ; \
> }
> 
> /* -------------------------------------------------------------------------- */
> 
> /* c -= a*conjugate(b), assert because c cannot be the same as a or b */
> #define MULT_SUB_CONJ(c,a,b) \
> { \
>     ASSERT (&(c) != &(a) && &(c) != &(b)) ; \
>     (c).Real -= (a).Real * (b).Real + (a).Imag * (b).Imag ; \
>     (c).Imag -= (a).Imag * (b).Real - (a).Real * (b).Imag ; \
> }
> 
> /* -------------------------------------------------------------------------- */
> 
> /* c = a/b, be careful to avoid underflow and overflow */
> #ifdef MATHWORKS
> #define DIV(c,a,b) \
> { \
>     (void) utDivideComplex ((a).Real, (a).Imag, (b).Real, (b).Imag, \
> 	&((c).Real), &((c).Imag)) ; \
> }
> #else
> /* This uses ACM Algo 116, by R. L. Smith, 1962. */
> /* c can be the same variable as a or b. */
> /* Ignore NaN case for double relop br>=bi. */
> #define DIV(c,a,b) \
> { \
>     double r, den, ar, ai, br, bi ; \
>     br = (b).Real ; \
>     bi = (b).Imag ; \
>     ar = (a).Real ; \
>     ai = (a).Imag ; \
>     if (SCALAR_ABS (br) >= SCALAR_ABS (bi)) \
>     { \
> 	r = bi / br ; \
> 	den = br + r * bi ; \
> 	(c).Real = (ar + ai * r) / den ; \
> 	(c).Imag = (ai - ar * r) / den ; \
>     } \
>     else \
>     { \
> 	r = br / bi ; \
> 	den = r * br + bi ; \
> 	(c).Real = (ar * r + ai) / den ; \
> 	(c).Imag = (ai * r - ar) / den ; \
>     } \
> }
> #endif
> 
> /* -------------------------------------------------------------------------- */
> 
> /* c = 1/c, be careful to avoid underflow and overflow */
> /* Not used if MATHWORKS is defined. */
> /* This uses ACM Algo 116, by R. L. Smith, 1962. */
> /* Ignore NaN case for double relop cr>=ci. */
> #define RECIPROCAL(c) \
> { \
>     double r, den, cr, ci ; \
>     cr = (c).Real ; \
>     ci = (c).Imag ; \
>     if (SCALAR_ABS (cr) >= SCALAR_ABS (ci)) \
>     { \
> 	r = ci / cr ; \
> 	den = cr + r * ci ; \
> 	(c).Real = 1.0 / den ; \
> 	(c).Imag = - r / den ; \
>     } \
>     else \
>     { \
> 	r = cr / ci ; \
> 	den = r * cr + ci ; \
> 	(c).Real = r / den ; \
> 	(c).Imag = - 1.0 / den ; \
>     } \
> }
> 
> 
> /* -------------------------------------------------------------------------- */
> 
> /* c = a/conjugate(b), be careful to avoid underflow and overflow */
> #ifdef MATHWORKS
> #define DIV_CONJ(c,a,b) \
> { \
>     (void) utDivideComplex ((a).Real, (a).Imag, (b).Real, (-(b).Imag), \
> 	&((c).Real), &((c).Imag)) ; \
> }
> #else
> /* This uses ACM Algo 116, by R. L. Smith, 1962. */
> /* c can be the same variable as a or b. */
> /* Ignore NaN case for double relop br>=bi. */
> #define DIV_CONJ(c,a,b) \
> { \
>     double r, den, ar, ai, br, bi ; \
>     br = (b).Real ; \
>     bi = (b).Imag ; \
>     ar = (a).Real ; \
>     ai = (a).Imag ; \
>     if (SCALAR_ABS (br) >= SCALAR_ABS (bi)) \
>     { \
> 	r = (-bi) / br ; \
> 	den = br - r * bi ; \
> 	(c).Real = (ar + ai * r) / den ; \
> 	(c).Imag = (ai - ar * r) / den ; \
>     } \
>     else \
>     { \
> 	r = br / (-bi) ; \
> 	den =  r * br - bi; \
> 	(c).Real = (ar * r + ai) / den ; \
> 	(c).Imag = (ai * r - ar) / den ; \
>     } \
> }
> #endif
> 
> /* -------------------------------------------------------------------------- */
> 
> /* approximate absolute value, s = |r|+|i| */
> #define APPROX_ABS(s,a) \
> { \
>     (s) = SCALAR_ABS ((a).Real) + SCALAR_ABS ((a).Imag) ; \
> }
> 
> /* -------------------------------------------------------------------------- */
> 
> /* exact absolute value, s = sqrt (a.real^2 + amag^2) */
> #ifdef MATHWORKS
> #define ABS(s,a) \
> { \
>     (s) = utFdlibm_hypot ((a).Real, (a).Imag) ; \
> }
> #else
> /* Ignore NaN case for the double relops ar>=ai and ar+ai==ar. */
> #define ABS(s,a) \
> { \
>     double r, ar, ai ; \
>     ar = SCALAR_ABS ((a).Real) ; \
>     ai = SCALAR_ABS ((a).Imag) ; \
>     if (ar >= ai) \
>     { \
> 	if (ar + ai == ar) \
> 	{ \
> 	    (s) = ar ; \
> 	} \
> 	else \
> 	{ \
> 	    r = ai / ar ; \
> 	    (s) = ar * sqrt (1.0 + r*r) ; \
> 	} \
>     } \
>     else \
>     { \
> 	if (ai + ar == ai) \
> 	{ \
> 	    (s) = ai ; \
> 	} \
> 	else \
> 	{ \
> 	    r = ar / ai ; \
> 	    (s) = ai * sqrt (1.0 + r*r) ; \
> 	} \
>     } \
> }
> #endif
> 
> /* -------------------------------------------------------------------------- */
> 
> /* print an entry (avoid printing "-0" for negative zero).  */
> #define PRINT_ENTRY(a) \
> { \
>     if (SCALAR_IS_NONZERO ((a).Real)) \
>     { \
> 	PRINTF ((" (%g", (a).Real)) ; \
>     } \
>     else \
>     { \
> 	PRINTF ((" (0")) ; \
>     } \
>     if (SCALAR_IS_LTZERO ((a).Imag)) \
>     { \
> 	PRINTF ((" - %gi)", -(a).Imag)) ; \
>     } \
>     else if (SCALAR_IS_ZERO ((a).Imag)) \
>     { \
> 	PRINTF ((" + 0i)")) ; \
>     } \
>     else \
>     { \
> 	PRINTF ((" + %gi)", (a).Imag)) ; \
>     } \
> }
> 
> /* -------------------------------------------------------------------------- */
> 
> #endif	/* #ifndef COMPLEX */
> 
> /* -------------------------------------------------------------------------- */
> /* Double precision, with int's as integers */
> /* -------------------------------------------------------------------------- */
> 
> #ifdef DINT
> 
> #define UMF_analyze		 umf_i_analyze
> #define UMF_apply_order		 umf_i_apply_order
> #define UMF_assemble		 umfdi_assemble
> #define UMF_assemble_fixq	 umfdi_assemble_fixq
> #define UMF_blas3_update	 umfdi_blas3_update
> #define UMF_build_tuples	 umfdi_build_tuples
> #define UMF_build_tuples_usage	 umfdi_build_tuples_usage
> #define UMF_colamd		 umf_i_colamd
> #define UMF_colamd_set_defaults	 umf_i_colamd_set_defaults
> #define UMF_create_element	 umfdi_create_element
> #define UMF_extend_front	 umfdi_extend_front
> #define UMF_free		 umf_i_free
> #define UMF_fsize		 umf_i_fsize
> #define UMF_garbage_collection	 umfdi_garbage_collection
> #define UMF_get_memory		 umfdi_get_memory
> #define UMF_grow_front		 umfdi_grow_front
> #define UMF_init_front		 umfdi_init_front
> #define UMF_is_permutation	 umf_i_is_permutation
> #define UMF_kernel		 umfdi_kernel
> #define UMF_kernel_init		 umfdi_kernel_init
> #define UMF_kernel_init_usage	 umfdi_kernel_init_usage
> #define UMF_kernel_wrapup	 umfdi_kernel_wrapup
> #define UMF_local_search	 umfdi_local_search
> #define UMF_lsolve		 umfdi_lsolve
> #define UMF_ltsolve		 umfdi_ltsolve
> #define UMF_lhsolve		 umfdi_lhsolve
> #define UMF_malloc		 umf_i_malloc
> #define UMF_mem_alloc_element	 umfdi_mem_alloc_element
> #define UMF_mem_alloc_head_block umfdi_mem_alloc_head_block
> #define UMF_mem_alloc_tail_block umfdi_mem_alloc_tail_block
> #define UMF_mem_free_tail_block	 umfdi_mem_free_tail_block
> #define UMF_mem_init_memoryspace umfdi_mem_init_memoryspace
> #define UMF_realloc		 umf_i_realloc
> #define UMF_report_perm		 umf_i_report_perm
> #define UMF_report_vector	 umfdi_report_vector
> #define UMF_row_search		 umfdi_row_search
> #define UMF_scale		 umfdi_scale
> #define UMF_scale_column	 umfdi_scale_column
> #define UMF_set_stats		 umf_i_set_stats
> #define UMF_singletons		 umf_i_singletons
> #define UMF_solve		 umfdi_solve
> #define UMF_start_front		 umfdi_start_front
> #define UMF_store_lu		 umfdi_store_lu
> #define UMF_symbolic_usage	 umfdi_symbolic_usage
> #define UMF_transpose		 umfdi_transpose
> #define UMF_tuple_lengths	 umfdi_tuple_lengths
> #define UMF_usolve		 umfdi_usolve
> #define UMF_utsolve		 umfdi_utsolve
> #define UMF_uhsolve		 umfdi_uhsolve
> #define UMF_valid_numeric	 umfdi_valid_numeric
> #define UMF_valid_symbolic	 umfdi_valid_symbolic
> #define UMF_triplet_map_x	 umfdi_triplet_map_x
> #define UMF_triplet_map_nox	 umfdi_triplet_map_nox
> #define UMF_triplet_nomap_x	 umfdi_triplet_nomap_x
> #define UMF_triplet_nomap_nox	 umfdi_triplet_nomap_nox
> #define UMF_2by2		 umfdi_2by2
> 
> #define UMFPACK_col_to_triplet	 umfpack_di_col_to_triplet
> #define UMFPACK_defaults	 umfpack_di_defaults
> #define UMFPACK_free_numeric	 umfpack_di_free_numeric
> #define UMFPACK_free_symbolic	 umfpack_di_free_symbolic
> #define UMFPACK_get_lunz	 umfpack_di_get_lunz
> #define UMFPACK_get_numeric	 umfpack_di_get_numeric
> #define UMFPACK_get_symbolic	 umfpack_di_get_symbolic
> #define UMFPACK_numeric		 umfpack_di_numeric
> #define UMFPACK_qsymbolic	 umfpack_di_qsymbolic
> #define UMFPACK_report_control	 umfpack_di_report_control
> #define UMFPACK_report_info	 umfpack_di_report_info
> #define UMFPACK_report_matrix	 umfpack_di_report_matrix
> #define UMFPACK_report_numeric	 umfpack_di_report_numeric
> #define UMFPACK_report_perm	 umfpack_di_report_perm
> #define UMFPACK_report_status	 umfpack_di_report_status
> #define UMFPACK_report_symbolic	 umfpack_di_report_symbolic
> #define UMFPACK_report_triplet	 umfpack_di_report_triplet
> #define UMFPACK_report_vector	 umfpack_di_report_vector
> #define UMFPACK_save_numeric	 umfpack_di_save_numeric
> #define UMFPACK_save_symbolic	 umfpack_di_save_symbolic
> #define UMFPACK_load_numeric	 umfpack_di_load_numeric
> #define UMFPACK_load_symbolic	 umfpack_di_load_symbolic
> #define UMFPACK_scale		 umfpack_di_scale
> #define UMFPACK_solve		 umfpack_di_solve
> #define UMFPACK_symbolic	 umfpack_di_symbolic
> #define UMFPACK_transpose	 umfpack_di_transpose
> #define UMFPACK_triplet_to_col	 umfpack_di_triplet_to_col
> #define UMFPACK_wsolve		 umfpack_di_wsolve
> 
> /* for debugging only: */
> #define UMF_malloc_count	 umf_i_malloc_count
> #define UMF_debug		 umfdi_debug
> #define UMF_allocfail		 umfdi_allocfail
> #define UMF_gprob		 umfdi_gprob
> #define UMF_dump_dense		 umfdi_dump_dense
> #define UMF_dump_element	 umfdi_dump_element
> #define UMF_dump_rowcol		 umfdi_dump_rowcol
> #define UMF_dump_matrix		 umfdi_dump_matrix
> #define UMF_dump_current_front	 umfdi_dump_current_front
> #define UMF_dump_lu		 umfdi_dump_lu
> #define UMF_dump_memory		 umfdi_dump_memory
> #define UMF_dump_packed_memory	 umfdi_dump_packed_memory
> #define UMF_dump_col_matrix	 umfdi_dump_col_matrix
> #define UMF_dump_chain		 umfdi_dump_chain
> #define UMF_dump_start		 umfdi_dump_start
> #define UMF_dump_rowmerge	 umfdi_dump_rowmerge
> #define UMF_dump_diagonal_map	 umfdi_dump_diagonal_map
> 
> #endif
> 
> /* -------------------------------------------------------------------------- */
> /* Double precision, with long's as integers */
> /* -------------------------------------------------------------------------- */
> 
> #ifdef DLONG
> 
> #define UMF_analyze		 umf_l_analyze
> #define UMF_apply_order		 umf_l_apply_order
> #define UMF_assemble		 umfdl_assemble
> #define UMF_assemble_fixq	 umfdl_assemble_fixq
> #define UMF_blas3_update	 umfdl_blas3_update
> #define UMF_build_tuples	 umfdl_build_tuples
> #define UMF_build_tuples_usage	 umfdl_build_tuples_usage
> #define UMF_colamd		 umf_l_colamd
> #define UMF_colamd_set_defaults	 umf_l_colamd_set_defaults
> #define UMF_create_element	 umfdl_create_element
> #define UMF_extend_front	 umfdl_extend_front
> #define UMF_free		 umf_l_free
> #define UMF_fsize		 umf_l_fsize
> #define UMF_garbage_collection	 umfdl_garbage_collection
> #define UMF_get_memory		 umfdl_get_memory
> #define UMF_grow_front		 umfdl_grow_front
> #define UMF_init_front		 umfdl_init_front
> #define UMF_is_permutation	 umf_l_is_permutation
> #define UMF_kernel		 umfdl_kernel
> #define UMF_kernel_init		 umfdl_kernel_init
> #define UMF_kernel_init_usage	 umfdl_kernel_init_usage
> #define UMF_kernel_wrapup	 umfdl_kernel_wrapup
> #define UMF_local_search	 umfdl_local_search
> #define UMF_lsolve		 umfdl_lsolve
> #define UMF_ltsolve		 umfdl_ltsolve
> #define UMF_lhsolve		 umfdl_lhsolve
> #define UMF_malloc		 umf_l_malloc
> #define UMF_mem_alloc_element	 umfdl_mem_alloc_element
> #define UMF_mem_alloc_head_block umfdl_mem_alloc_head_block
> #define UMF_mem_alloc_tail_block umfdl_mem_alloc_tail_block
> #define UMF_mem_free_tail_block	 umfdl_mem_free_tail_block
> #define UMF_mem_init_memoryspace umfdl_mem_init_memoryspace
> #define UMF_realloc		 umf_l_realloc
> #define UMF_report_perm		 umf_l_report_perm
> #define UMF_report_vector	 umfdl_report_vector
> #define UMF_row_search		 umfdl_row_search
> #define UMF_scale		 umfdl_scale
> #define UMF_scale_column	 umfdl_scale_column
> #define UMF_set_stats		 umf_l_set_stats
> #define UMF_singletons		 umf_l_singletons
> #define UMF_solve		 umfdl_solve
> #define UMF_start_front		 umfdl_start_front
> #define UMF_store_lu		 umfdl_store_lu
> #define UMF_symbolic_usage	 umfdl_symbolic_usage
> #define UMF_transpose		 umfdl_transpose
> #define UMF_tuple_lengths	 umfdl_tuple_lengths
> #define UMF_usolve		 umfdl_usolve
> #define UMF_utsolve		 umfdl_utsolve
> #define UMF_uhsolve		 umfdl_uhsolve
> #define UMF_valid_numeric	 umfdl_valid_numeric
> #define UMF_valid_symbolic	 umfdl_valid_symbolic
> #define UMF_triplet_map_x	 umfdl_triplet_map_x
> #define UMF_triplet_map_nox	 umfdl_triplet_map_nox
> #define UMF_triplet_nomap_x	 umfdl_triplet_nomap_x
> #define UMF_triplet_nomap_nox	 umfdl_triplet_nomap_nox
> #define UMF_2by2		 umfdl_2by2
> 
> #define UMFPACK_col_to_triplet	 umfpack_dl_col_to_triplet
> #define UMFPACK_defaults	 umfpack_dl_defaults
> #define UMFPACK_free_numeric	 umfpack_dl_free_numeric
> #define UMFPACK_free_symbolic	 umfpack_dl_free_symbolic
> #define UMFPACK_get_lunz	 umfpack_dl_get_lunz
> #define UMFPACK_get_numeric	 umfpack_dl_get_numeric
> #define UMFPACK_get_symbolic	 umfpack_dl_get_symbolic
> #define UMFPACK_numeric		 umfpack_dl_numeric
> #define UMFPACK_qsymbolic	 umfpack_dl_qsymbolic
> #define UMFPACK_report_control	 umfpack_dl_report_control
> #define UMFPACK_report_info	 umfpack_dl_report_info
> #define UMFPACK_report_matrix	 umfpack_dl_report_matrix
> #define UMFPACK_report_numeric	 umfpack_dl_report_numeric
> #define UMFPACK_report_perm	 umfpack_dl_report_perm
> #define UMFPACK_report_status	 umfpack_dl_report_status
> #define UMFPACK_report_symbolic	 umfpack_dl_report_symbolic
> #define UMFPACK_report_triplet	 umfpack_dl_report_triplet
> #define UMFPACK_report_vector	 umfpack_dl_report_vector
> #define UMFPACK_save_numeric	 umfpack_dl_save_numeric
> #define UMFPACK_save_symbolic	 umfpack_dl_save_symbolic
> #define UMFPACK_load_numeric	 umfpack_dl_load_numeric
> #define UMFPACK_load_symbolic	 umfpack_dl_load_symbolic
> #define UMFPACK_scale		 umfpack_dl_scale
> #define UMFPACK_solve		 umfpack_dl_solve
> #define UMFPACK_symbolic	 umfpack_dl_symbolic
> #define UMFPACK_transpose	 umfpack_dl_transpose
> #define UMFPACK_triplet_to_col	 umfpack_dl_triplet_to_col
> #define UMFPACK_wsolve		 umfpack_dl_wsolve
> 
> /* for debugging only: */
> #define UMF_malloc_count	 umf_l_malloc_count
> #define UMF_debug		 umfdl_debug
> #define UMF_allocfail		 umfdl_allocfail
> #define UMF_gprob		 umfdl_gprob
> #define UMF_dump_dense		 umfdl_dump_dense
> #define UMF_dump_element	 umfdl_dump_element
> #define UMF_dump_rowcol		 umfdl_dump_rowcol
> #define UMF_dump_matrix		 umfdl_dump_matrix
> #define UMF_dump_current_front	 umfdl_dump_current_front
> #define UMF_dump_lu		 umfdl_dump_lu
> #define UMF_dump_memory		 umfdl_dump_memory
> #define UMF_dump_packed_memory	 umfdl_dump_packed_memory
> #define UMF_dump_col_matrix	 umfdl_dump_col_matrix
> #define UMF_dump_chain		 umfdl_dump_chain
> #define UMF_dump_start		 umfdl_dump_start
> #define UMF_dump_rowmerge	 umfdl_dump_rowmerge
> #define UMF_dump_diagonal_map	 umfdl_dump_diagonal_map
> 
> #endif
> 
> /* -------------------------------------------------------------------------- */
> /* Complex double precision, with int's as integers */
> /* -------------------------------------------------------------------------- */
> 
> #ifdef ZINT
> 
> #define UMF_analyze		 umf_i_analyze
> #define UMF_apply_order		 umf_i_apply_order
> #define UMF_assemble		 umfzi_assemble
> #define UMF_assemble_fixq	 umfzi_assemble_fixq
> #define UMF_blas3_update	 umfzi_blas3_update
> #define UMF_build_tuples	 umfzi_build_tuples
> #define UMF_build_tuples_usage	 umfzi_build_tuples_usage
> #define UMF_colamd		 umf_i_colamd
> #define UMF_colamd_set_defaults	 umf_i_colamd_set_defaults
> #define UMF_create_element	 umfzi_create_element
> #define UMF_extend_front	 umfzi_extend_front
> #define UMF_free		 umf_i_free
> #define UMF_fsize		 umf_i_fsize
> #define UMF_garbage_collection	 umfzi_garbage_collection
> #define UMF_get_memory		 umfzi_get_memory
> #define UMF_grow_front		 umfzi_grow_front
> #define UMF_init_front		 umfzi_init_front
> #define UMF_is_permutation	 umf_i_is_permutation
> #define UMF_kernel		 umfzi_kernel
> #define UMF_kernel_init		 umfzi_kernel_init
> #define UMF_kernel_init_usage	 umfzi_kernel_init_usage
> #define UMF_kernel_wrapup	 umfzi_kernel_wrapup
> #define UMF_local_search	 umfzi_local_search
> #define UMF_lsolve		 umfzi_lsolve
> #define UMF_ltsolve		 umfzi_ltsolve
> #define UMF_lhsolve		 umfzi_lhsolve
> #define UMF_malloc		 umf_i_malloc
> #define UMF_mem_alloc_element	 umfzi_mem_alloc_element
> #define UMF_mem_alloc_head_block umfzi_mem_alloc_head_block
> #define UMF_mem_alloc_tail_block umfzi_mem_alloc_tail_block
> #define UMF_mem_free_tail_block	 umfzi_mem_free_tail_block
> #define UMF_mem_init_memoryspace umfzi_mem_init_memoryspace
> #define UMF_realloc		 umf_i_realloc
> #define UMF_report_perm		 umf_i_report_perm
> #define UMF_report_vector	 umfzi_report_vector
> #define UMF_row_search		 umfzi_row_search
> #define UMF_scale		 umfzi_scale
> #define UMF_scale_column	 umfzi_scale_column
> #define UMF_set_stats		 umfzi_set_stats
> #define UMF_singletons		 umf_i_singletons
> #define UMF_solve		 umfzi_solve
> #define UMF_start_front		 umfzi_start_front
> #define UMF_store_lu		 umfzi_store_lu
> #define UMF_symbolic_usage	 umfzi_symbolic_usage
> #define UMF_transpose		 umfzi_transpose
> #define UMF_tuple_lengths	 umfzi_tuple_lengths
> #define UMF_usolve		 umfzi_usolve
> #define UMF_utsolve		 umfzi_utsolve
> #define UMF_uhsolve		 umfzi_uhsolve
> #define UMF_valid_numeric	 umfzi_valid_numeric
> #define UMF_valid_symbolic	 umfzi_valid_symbolic
> #define UMF_triplet_map_x	 umfzi_triplet_map_x
> #define UMF_triplet_map_nox	 umfzi_triplet_map_nox
> #define UMF_triplet_nomap_x	 umfzi_triplet_nomap_x
> #define UMF_triplet_nomap_nox	 umfzi_triplet_nomap_nox
> #define UMF_2by2		 umfzi_2by2
> 
> #define UMFPACK_col_to_triplet	 umfpack_zi_col_to_triplet
> #define UMFPACK_defaults	 umfpack_zi_defaults
> #define UMFPACK_free_numeric	 umfpack_zi_free_numeric
> #define UMFPACK_free_symbolic	 umfpack_zi_free_symbolic
> #define UMFPACK_get_lunz	 umfpack_zi_get_lunz
> #define UMFPACK_get_numeric	 umfpack_zi_get_numeric
> #define UMFPACK_get_symbolic	 umfpack_zi_get_symbolic
> #define UMFPACK_numeric		 umfpack_zi_numeric
> #define UMFPACK_qsymbolic	 umfpack_zi_qsymbolic
> #define UMFPACK_report_control	 umfpack_zi_report_control
> #define UMFPACK_report_info	 umfpack_zi_report_info
> #define UMFPACK_report_matrix	 umfpack_zi_report_matrix
> #define UMFPACK_report_numeric	 umfpack_zi_report_numeric
> #define UMFPACK_report_perm	 umfpack_zi_report_perm
> #define UMFPACK_report_status	 umfpack_zi_report_status
> #define UMFPACK_report_symbolic	 umfpack_zi_report_symbolic
> #define UMFPACK_report_triplet	 umfpack_zi_report_triplet
> #define UMFPACK_report_vector	 umfpack_zi_report_vector
> #define UMFPACK_save_numeric	 umfpack_zi_save_numeric
> #define UMFPACK_save_symbolic	 umfpack_zi_save_symbolic
> #define UMFPACK_load_numeric	 umfpack_zi_load_numeric
> #define UMFPACK_load_symbolic	 umfpack_zi_load_symbolic
> #define UMFPACK_scale		 umfpack_zi_scale
> #define UMFPACK_solve		 umfpack_zi_solve
> #define UMFPACK_symbolic	 umfpack_zi_symbolic
> #define UMFPACK_transpose	 umfpack_zi_transpose
> #define UMFPACK_triplet_to_col	 umfpack_zi_triplet_to_col
> #define UMFPACK_wsolve		 umfpack_zi_wsolve
> 
> /* for debugging only: */
> #define UMF_malloc_count	 umf_i_malloc_count
> #define UMF_debug		 umfzi_debug
> #define UMF_allocfail		 umfzi_allocfail
> #define UMF_gprob		 umfzi_gprob
> #define UMF_dump_dense		 umfzi_dump_dense
> #define UMF_dump_element	 umfzi_dump_element
> #define UMF_dump_rowcol		 umfzi_dump_rowcol
> #define UMF_dump_matrix		 umfzi_dump_matrix
> #define UMF_dump_current_front	 umfzi_dump_current_front
> #define UMF_dump_lu		 umfzi_dump_lu
> #define UMF_dump_memory		 umfzi_dump_memory
> #define UMF_dump_packed_memory	 umfzi_dump_packed_memory
> #define UMF_dump_col_matrix	 umfzi_dump_col_matrix
> #define UMF_dump_chain		 umfzi_dump_chain
> #define UMF_dump_start		 umfzi_dump_start
> #define UMF_dump_rowmerge	 umfzi_dump_rowmerge
> #define UMF_dump_diagonal_map	 umfzi_dump_diagonal_map
> 
> #endif
> 
> /* -------------------------------------------------------------------------- */
> /* Complex double precision, with long's as integers */
> /* -------------------------------------------------------------------------- */
> 
> #ifdef ZLONG
> 
> #define UMF_analyze		 umf_l_analyze
> #define UMF_apply_order		 umf_l_apply_order
> #define UMF_assemble		 umfzl_assemble
> #define UMF_assemble_fixq	 umfzl_assemble_fixq
> #define UMF_blas3_update	 umfzl_blas3_update
> #define UMF_build_tuples	 umfzl_build_tuples
> #define UMF_build_tuples_usage	 umfzl_build_tuples_usage
> #define UMF_colamd		 umf_l_colamd
> #define UMF_colamd_set_defaults	 umf_l_colamd_set_defaults
> #define UMF_create_element	 umfzl_create_element
> #define UMF_extend_front	 umfzl_extend_front
> #define UMF_free		 umf_l_free
> #define UMF_fsize		 umf_l_fsize
> #define UMF_garbage_collection	 umfzl_garbage_collection
> #define UMF_get_memory		 umfzl_get_memory
> #define UMF_grow_front		 umfzl_grow_front
> #define UMF_init_front		 umfzl_init_front
> #define UMF_is_permutation	 umf_l_is_permutation
> #define UMF_kernel		 umfzl_kernel
> #define UMF_kernel_init		 umfzl_kernel_init
> #define UMF_kernel_init_usage	 umfzl_kernel_init_usage
> #define UMF_kernel_wrapup	 umfzl_kernel_wrapup
> #define UMF_local_search	 umfzl_local_search
> #define UMF_lsolve		 umfzl_lsolve
> #define UMF_ltsolve		 umfzl_ltsolve
> #define UMF_lhsolve		 umfzl_lhsolve
> #define UMF_malloc		 umf_l_malloc
> #define UMF_mem_alloc_element	 umfzl_mem_alloc_element
> #define UMF_mem_alloc_head_block umfzl_mem_alloc_head_block
> #define UMF_mem_alloc_tail_block umfzl_mem_alloc_tail_block
> #define UMF_mem_free_tail_block	 umfzl_mem_free_tail_block
> #define UMF_mem_init_memoryspace umfzl_mem_init_memoryspace
> #define UMF_realloc		 umf_l_realloc
> #define UMF_report_perm		 umf_l_report_perm
> #define UMF_report_vector	 umfzl_report_vector
> #define UMF_row_search		 umfzl_row_search
> #define UMF_scale		 umfzl_scale
> #define UMF_scale_column	 umfzl_scale_column
> #define UMF_set_stats		 umfzl_set_stats
> #define UMF_singletons		 umf_l_singletons
> #define UMF_solve		 umfzl_solve
> #define UMF_start_front		 umfzl_start_front
> #define UMF_store_lu		 umfzl_store_lu
> #define UMF_symbolic_usage	 umfzl_symbolic_usage
> #define UMF_transpose		 umfzl_transpose
> #define UMF_tuple_lengths	 umfzl_tuple_lengths
> #define UMF_usolve		 umfzl_usolve
> #define UMF_utsolve		 umfzl_utsolve
> #define UMF_uhsolve		 umfzl_uhsolve
> #define UMF_valid_numeric	 umfzl_valid_numeric
> #define UMF_valid_symbolic	 umfzl_valid_symbolic
> #define UMF_triplet_map_x	 umfzl_triplet_map_x
> #define UMF_triplet_map_nox	 umfzl_triplet_map_nox
> #define UMF_triplet_nomap_x	 umfzl_triplet_nomap_x
> #define UMF_triplet_nomap_nox	 umfzl_triplet_nomap_nox
> #define UMF_2by2		 umfzl_2by2
> 
> #define UMFPACK_col_to_triplet	 umfpack_zl_col_to_triplet
> #define UMFPACK_defaults	 umfpack_zl_defaults
> #define UMFPACK_free_numeric	 umfpack_zl_free_numeric
> #define UMFPACK_free_symbolic	 umfpack_zl_free_symbolic
> #define UMFPACK_get_lunz	 umfpack_zl_get_lunz
> #define UMFPACK_get_numeric	 umfpack_zl_get_numeric
> #define UMFPACK_get_symbolic	 umfpack_zl_get_symbolic
> #define UMFPACK_numeric		 umfpack_zl_numeric
> #define UMFPACK_qsymbolic	 umfpack_zl_qsymbolic
> #define UMFPACK_report_control	 umfpack_zl_report_control
> #define UMFPACK_report_info	 umfpack_zl_report_info
> #define UMFPACK_report_matrix	 umfpack_zl_report_matrix
> #define UMFPACK_report_numeric	 umfpack_zl_report_numeric
> #define UMFPACK_report_perm	 umfpack_zl_report_perm
> #define UMFPACK_report_status	 umfpack_zl_report_status
> #define UMFPACK_report_symbolic	 umfpack_zl_report_symbolic
> #define UMFPACK_report_triplet	 umfpack_zl_report_triplet
> #define UMFPACK_report_vector	 umfpack_zl_report_vector
> #define UMFPACK_save_numeric	 umfpack_zl_save_numeric
> #define UMFPACK_save_symbolic	 umfpack_zl_save_symbolic
> #define UMFPACK_load_numeric	 umfpack_zl_load_numeric
> #define UMFPACK_load_symbolic	 umfpack_zl_load_symbolic
> #define UMFPACK_scale		 umfpack_zl_scale
> #define UMFPACK_solve		 umfpack_zl_solve
> #define UMFPACK_symbolic	 umfpack_zl_symbolic
> #define UMFPACK_transpose	 umfpack_zl_transpose
> #define UMFPACK_triplet_to_col	 umfpack_zl_triplet_to_col
> #define UMFPACK_wsolve		 umfpack_zl_wsolve
> 
> /* for debugging only: */
> #define UMF_malloc_count	 umf_l_malloc_count
> #define UMF_debug		 umfzl_debug
> #define UMF_allocfail		 umfzl_allocfail
> #define UMF_gprob		 umfzl_gprob
> #define UMF_dump_dense		 umfzl_dump_dense
> #define UMF_dump_element	 umfzl_dump_element
> #define UMF_dump_rowcol		 umfzl_dump_rowcol
> #define UMF_dump_matrix		 umfzl_dump_matrix
> #define UMF_dump_current_front	 umfzl_dump_current_front
> #define UMF_dump_lu		 umfzl_dump_lu
> #define UMF_dump_memory		 umfzl_dump_memory
> #define UMF_dump_packed_memory	 umfzl_dump_packed_memory
> #define UMF_dump_col_matrix	 umfzl_dump_col_matrix
> #define UMF_dump_chain		 umfzl_dump_chain
> #define UMF_dump_start		 umfzl_dump_start
> #define UMF_dump_rowmerge	 umfzl_dump_rowmerge
> #define UMF_dump_diagonal_map	 umfzl_dump_diagonal_map
> 
> #endif
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack.h pysparse/pysparse/direct/umfpack/include/umfpack.h
0a1,400
> /* ========================================================================== */
> /* === umfpack.h ============================================================ */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> /*
>     This is the umfpack.h include file, and should be included in all user code
>     that uses UMFPACK.  Do not include any of the umf_* header files in user
>     code.  All routines in UMFPACK starting with "umfpack_" are user-callable.
>     All other routines are prefixed "umf_XY_", (where X is d or z, and Y is
>     i or l) and are not user-callable.
> */
> 
> #ifndef UMFPACK_H
> #define UMFPACK_H
> 
> /* -------------------------------------------------------------------------- */
> /* size of Info and Control arrays */
> /* -------------------------------------------------------------------------- */
> 
> #define UMFPACK_INFO 90		/* these might be larger in future versions */
> #define UMFPACK_CONTROL 20
> 
> /* -------------------------------------------------------------------------- */
> /* User-callable routines */
> /* -------------------------------------------------------------------------- */
> 
> /* Primary routines: */
> #include "umfpack_symbolic.h"
> #include "umfpack_numeric.h"
> #include "umfpack_solve.h"
> #include "umfpack_free_symbolic.h"
> #include "umfpack_free_numeric.h"
> 
> /* Alternative routines: */
> #include "umfpack_defaults.h"
> #include "umfpack_qsymbolic.h"
> #include "umfpack_wsolve.h"
> 
> /* Matrix manipulation routines: */
> #include "umfpack_triplet_to_col.h"
> #include "umfpack_col_to_triplet.h"
> #include "umfpack_transpose.h"
> #include "umfpack_scale.h"
> 
> /* Getting the contents of the Symbolic and Numeric opaque objects: */
> #include "umfpack_get_lunz.h"
> #include "umfpack_get_numeric.h"
> #include "umfpack_get_symbolic.h"
> #include "umfpack_save_numeric.h"
> #include "umfpack_load_numeric.h"
> #include "umfpack_save_symbolic.h"
> #include "umfpack_load_symbolic.h"
> 
> /* Reporting routines (the above 14 routines print nothing): */
> #include "umfpack_report_status.h"
> #include "umfpack_report_info.h"
> #include "umfpack_report_control.h"
> #include "umfpack_report_matrix.h"
> #include "umfpack_report_triplet.h"
> #include "umfpack_report_vector.h"
> #include "umfpack_report_symbolic.h"
> #include "umfpack_report_numeric.h"
> #include "umfpack_report_perm.h"
> 
> /* Utility routines: */
> #include "umfpack_timer.h"
> #include "umfpack_tictoc.h"
> 
> /* -------------------------------------------------------------------------- */
> /* Version, copyright, and license */
> /* -------------------------------------------------------------------------- */
> 
> #define UMFPACK_VERSION "UMFPACK V4.1 (Apr. 30, 2003)"
> 
> #define UMFPACK_COPYRIGHT \
> "UMFPACK:  Copyright (c) 2003 by Timothy A. Davis.  All Rights Reserved.\n"
> 
> #define UMFPACK_LICENSE_PART1 \
> "\nUMFPACK License:\n" \
> "\n" \
> "   Your use or distribution of UMFPACK or any modified version of\n" \
> "   UMFPACK implies that you agree to this License.\n" \
> "\n" \
> "   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY\n" \
> "   EXPRESSED OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n"
> #define UMFPACK_LICENSE_PART2 \
> "\n" \
> "   Permission is hereby granted to use or copy this program, provided\n" \
> "   that the Copyright, this License, and the Availability of the original\n" \
> "   version is retained on all copies.  User documentation of any code that\n" \
> "   uses UMFPACK or any modified version of UMFPACK code must cite the\n" \
> "   Copyright, this License, the Availability note, and \"Used by permission.\"\n"
> #define UMFPACK_LICENSE_PART3 \
> "   Permission to modify the code and to distribute modified code is granted,\n" \
> "   provided the Copyright, this License, and the Availability note are\n" \
> "   retained, and a notice that the code was modified is included.  This\n" \
> "   software was developed with support from the National Science Foundation,\n" \
> "   and is provided to you free of charge.\n" \
> "\n" \
> "Availability: http://www.cise.ufl.edu/research/sparse/umfpack\n" \
> "\n"
> 
> /* -------------------------------------------------------------------------- */
> /* contents of Info */
> /* -------------------------------------------------------------------------- */
> 
> /* Note that umfpack_report.m must coincide with these definitions. */
> 
> /* returned by all routines that use Info: */
> #define UMFPACK_STATUS 0	/* UMFPACK_OK, or other result */
> #define UMFPACK_NROW 1		/* n_row input value */
> #define UMFPACK_NCOL 16		/* n_col input value */
> #define UMFPACK_NZ 2		/* # of entries in A */
> 
> /* computed in UMFPACK_*symbolic and UMFPACK_numeric: */
> #define UMFPACK_SIZE_OF_UNIT 3		/* sizeof (Unit) */
> 
> /* computed in UMFPACK_*symbolic: */
> #define UMFPACK_SIZE_OF_INT 4		/* sizeof (int) */
> #define UMFPACK_SIZE_OF_LONG 5		/* sizeof (long) */
> #define UMFPACK_SIZE_OF_POINTER 6	/* sizeof (void *) */
> #define UMFPACK_SIZE_OF_ENTRY 7		/* sizeof (Entry), real or complex */
> #define UMFPACK_NDENSE_ROW 8		/* number of dense rows */
> #define UMFPACK_NEMPTY_ROW 9		/* number of empty rows */
> #define UMFPACK_NDENSE_COL 10		/* number of dense rows */
> #define UMFPACK_NEMPTY_COL 11		/* number of empty rows */
> #define UMFPACK_SYMBOLIC_DEFRAG 12	/* # of memory compactions */
> #define UMFPACK_SYMBOLIC_PEAK_MEMORY 13	/* memory used by symbolic analysis */
> #define UMFPACK_SYMBOLIC_SIZE 14	/* size of Symbolic object, in Units */
> #define UMFPACK_SYMBOLIC_TIME 15	/* time (sec.) for symbolic analysis */
> #define UMFPACK_SYMBOLIC_WALLTIME 17	/* wall clock time for sym. analysis */
> #define UMFPACK_STRATEGY_USED 18	/* strategy used: sym, unsym, 2by2 */
> #define UMFPACK_ORDERING_USED 19	/* ordering used: colamd, amd, given */
> #define UMFPACK_QFIXED 31		/* whether Q is fixed or refined */
> #define UMFPACK_DIAG_PREFERRED 32	/* whether diagonal pivoting attempted*/
> #define UMFPACK_PATTERN_SYMMETRY 33	/* symmetry of pattern of S */
> #define UMFPACK_NZ_A_PLUS_AT 34		/* nnz (S+S'), excl. diagonal */
> #define UMFPACK_NZDIAG 35		/* nnz (diag (S)) */
> 
> /* AMD statistics, computed in UMFPACK_*symbolic: */
> #define UMFPACK_SYMMETRIC_LUNZ 36	/* nz in L+U, if AMD ordering used */
> #define UMFPACK_SYMMETRIC_FLOPS 37	/* flops for LU, if AMD ordering used */
> #define UMFPACK_SYMMETRIC_NDENSE 38	/* # of "dense" rows/cols in S+S' */
> #define UMFPACK_SYMMETRIC_DMAX 39	/* max nz in cols of L, for AMD */
> 
> /* statistics for 2-by-2 strategy */
> #define UMFPACK_2BY2_NWEAK 51		    /* number of weak diagonal entries*/
> #define UMFPACK_2BY2_UNMATCHED 52	    /* # of weak diagonals not matched*/
> #define UMFPACK_2BY2_PATTERN_SYMMETRY 53    /* symmetry of pattern of P*S */
> #define UMFPACK_2BY2_NZ_PA_PLUS_PAT 54	    /* nz in PS+(PS)' */
> #define UMFPACK_2BY2_NZDIAG 55		    /* nz on diagonal of PS+(PS)' */
> 
> /* statistcs for singleton pruning */
> #define UMFPACK_COL_SINGLETONS 56
> #define UMFPACK_ROW_SINGLETONS 57
> #define UMFPACK_N2 58
> #define UMFPACK_S_SYMMETRIC 59
> 
> /* estimates computed in UMFPACK_*symbolic: */
> #define UMFPACK_NUMERIC_SIZE_ESTIMATE 20    /* final size of Numeric->Memory */
> #define UMFPACK_PEAK_MEMORY_ESTIMATE 21	    /* for symbolic & numeric */
> #define UMFPACK_FLOPS_ESTIMATE 22	    /* flop count */
> #define UMFPACK_LNZ_ESTIMATE 23		    /* nz in L, incl. diagonal */
> #define UMFPACK_UNZ_ESTIMATE 24		    /* nz in U, incl. diagonal */
> #define UMFPACK_VARIABLE_INIT_ESTIMATE 25   /* initial size of Numeric->Memory*/
> #define UMFPACK_VARIABLE_PEAK_ESTIMATE 26   /* peak size of Numeric->Memory */
> #define UMFPACK_VARIABLE_FINAL_ESTIMATE 27  /* final size of Numeric->Memory */
> #define UMFPACK_MAX_FRONT_SIZE_ESTIMATE 28  /* max frontal matrix size */
> #define UMFPACK_MAX_FRONT_NROWS_ESTIMATE 29 /* max # rows in any front */
> #define UMFPACK_MAX_FRONT_NCOLS_ESTIMATE 30 /* max # columns in any front */
> 
> /* exact values, (estimates shown above) computed in UMFPACK_numeric: */
> #define UMFPACK_NUMERIC_SIZE 40		    /* final size of Numeric->Memory */
> #define UMFPACK_PEAK_MEMORY 41		    /* for symbolic & numeric */
> #define UMFPACK_FLOPS 42		    /* flop count */
> #define UMFPACK_LNZ 43			    /* nz in L, incl. diagonal */
> #define UMFPACK_UNZ 44			    /* nz in U, incl. diagonal */
> #define UMFPACK_VARIABLE_INIT 45	    /* initial size of Numeric->Memory*/
> #define UMFPACK_VARIABLE_PEAK 46	    /* peak size of Numeric->Memory */
> #define UMFPACK_VARIABLE_FINAL 47	    /* final size of Numeric->Memory */
> #define UMFPACK_MAX_FRONT_SIZE 48	    /* max frontal matrix size */
> #define UMFPACK_MAX_FRONT_NROWS 49	    /* max # rows in any front */
> #define UMFPACK_MAX_FRONT_NCOLS 50	    /* max # columns in any front */
> 
> /* computed in UMFPACK_numeric: */
> #define UMFPACK_NUMERIC_DEFRAG 60	    /* # of garbage collections */
> #define UMFPACK_NUMERIC_REALLOC 61	    /* # of memory reallocations */
> #define UMFPACK_NUMERIC_COSTLY_REALLOC 62   /* # of costlly memory realloc's */
> #define UMFPACK_COMPRESSED_PATTERN 63	    /* # of integers in LU pattern */
> #define UMFPACK_LU_ENTRIES 64		    /* # of reals in LU factors */
> #define UMFPACK_NUMERIC_TIME 65		    /* numeric factorization time */
> #define UMFPACK_UDIAG_NZ 66		    /* nz on diagonal of U */
> #define UMFPACK_RCOND 67		    /* est. reciprocal condition # */
> #define UMFPACK_WAS_SCALED 68		    /* none, max row, or sum row */
> #define UMFPACK_RSMIN 69		    /* min (max row) or min (sum row) */
> #define UMFPACK_RSMAX 70		    /* max (max row) or max (sum row) */
> #define UMFPACK_UMIN 71			    /* min abs diagonal entry of U */
> #define UMFPACK_UMAX 72			    /* max abs diagonal entry of U */
> #define UMFPACK_ALLOC_INIT_USED 73	    /* alloc_init parameter used */
> #define UMFPACK_FORCED_UPDATES 74	    /* # of forced updates */
> #define UMFPACK_NUMERIC_WALLTIME 75	    /* numeric wall clock time */
> #define UMFPACK_NOFF_DIAG 76		    /* number of off-diagonal pivots */
> 
> /* computed in UMFPACK_solve: */
> #define UMFPACK_IR_TAKEN 80	    /* # of iterative refinement steps taken */
> #define UMFPACK_IR_ATTEMPTED 81	    /* # of iter. refinement steps attempted */
> #define UMFPACK_OMEGA1 82	    /* omega1, sparse backward error estimate */
> #define UMFPACK_OMEGA2 83	    /* omega2, sparse backward error estimate */
> #define UMFPACK_SOLVE_FLOPS 84	    /* flop count for solve */
> #define UMFPACK_SOLVE_TIME 85	    /* solve time (seconds) */
> #define UMFPACK_SOLVE_WALLTIME 86   /* solve time (wall clock, seconds) */
> 
> /* Info [77, 78, 79, 87, 88, 89] unused */
> 
> /* Unused parts of Info may be used in future versions of UMFPACK. */
> 
> /* -------------------------------------------------------------------------- */
> 
> /* Info [UMFPACK_ORDERING_USED] is one of the following: */
> #define UMFPACK_ORDERING_COLAMD 0	/* COLAMD(A) */
> #define UMFPACK_ORDERING_AMD 1		/* AMD(A+A') */
> #define UMFPACK_ORDERING_GIVEN 2	/* Q is provided on input */
> 
> /* -------------------------------------------------------------------------- */
> /* contents of Control */
> /* -------------------------------------------------------------------------- */
> 
> /* used in all UMFPACK_report_* routines: */
> #define UMFPACK_PRL 0			/* print level */
> 
> /* used in UMFPACK_*symbolic only: */
> #define UMFPACK_DENSE_ROW 1		/* dense row parameter */
> #define UMFPACK_DENSE_COL 2		/* dense col parameter */
> #define UMFPACK_BLOCK_SIZE 4		/* BLAS-3 block size */
> #define UMFPACK_STRATEGY 5		/* auto, symmetric, unsym., or 2by2 */
> #define UMFPACK_2BY2_TOLERANCE 12	/* 2-by-2 pivot tolerance */
> #define UMFPACK_FIXQ 13			/* -1: no fixQ, 0: default, 1: fixQ */
> #define UMFPACK_AMD_DENSE 14		/* for AMD ordering */
> #define UMFPACK_AGGRESSIVE 19		/* whether or not to use aggressive
> 					 * absorption in AMD and COLAMD */
> 
> /* used in UMFPACK_numeric only: */
> #define UMFPACK_PIVOT_TOLERANCE 3	/* threshold partial pivoting setting */
> #define UMFPACK_ALLOC_INIT 6		/* initial allocation ratio */
> #define UMFPACK_SYM_PIVOT_TOLERANCE 15	/* threshold, only for diag. entries */
> #define UMFPACK_SCALE 16		/* what row scaling to do */
> #define UMFPACK_FRONT_ALLOC_INIT 17	/* frontal matrix allocation ratio */
> 
> 
> /* used in UMFPACK_*solve only: */
> #define UMFPACK_IRSTEP 7		/* max # of iterative refinements */
> 
> /* compile-time settings - Control [8..11] cannot be changed at run time: */
> #define UMFPACK_COMPILED_WITH_BLAS 8	    /* uses the BLAS */
> #define UMFPACK_COMPILED_FOR_MATLAB 9	    /* 1 if MATLAB mexFunction, etc. */
> #define UMFPACK_COMPILED_WITH_GETRUSAGE 10  /* uses getrusage timer, or not */
> #define UMFPACK_COMPILED_IN_DEBUG_MODE 11   /* debugging enabled (very slow!) */
> 
> #if 0
> /* No longer unused.  These parameters are now used for the new symmetric and
>  * 2-by-2 ordering strategies.  See 5, 12, 13, and 14, above. */
> #define UMFPACK_RELAXED_AMALGAMATION 5	    /* unused (was in v4.0) */
> #define UMFPACK_PIVOT_OPTION 12		    /* unused (was in v3.2) */
> #define UMFPACK_RELAXED2_AMALGAMATION 13    /* unused (was in v4.0) */
> #define UMFPACK_RELAXED3_AMALGAMATION 14    /* unused (was in v4.0) */
> #endif
> 
> /* Control [18] unused */
> 
> /* -------------------------------------------------------------------------- */
> 
> /* Control [UMFPACK_STRATEGY] is one of the following: */
> #define UMFPACK_STRATEGY_AUTO 0		/* use sym. or unsym. strategy */
> #define UMFPACK_STRATEGY_UNSYMMETRIC 1	/* COLAMD(A), coletree postorder,
> 					   not prefer diag*/
> #define UMFPACK_STRATEGY_2BY2 2		/* AMD(PA+PA'), no coletree postorder,
> 					   prefer diag(PA) where P is pseudo
> 					   max transversal */
> #define UMFPACK_STRATEGY_SYMMETRIC 3	/* AMD(A+A'), no coletree postorder,
> 					   prefer diagonal */
> 
> /* Control [UMFPACK_SCALE] is one of the following: */
> #define UMFPACK_SCALE_NONE 0	/* no scaling */
> #define UMFPACK_SCALE_SUM 1	/* default: divide each row by sum (abs (row))*/
> #define UMFPACK_SCALE_MAX 2	/* divide each row by max (abs (row)) */
> 
> /* -------------------------------------------------------------------------- */
> /* default values of Control: */
> /* -------------------------------------------------------------------------- */
> 
> /* Note that the default block sized changed for Version 3.1 and following.
>  * In Version 4.1, the relaxed amalgamation parameters were removed.  These are
>  * now fixed internally (see umf_local_search.c), and cannot be changed.
>  * COLAMD aggressive absorption did not exist in v4.0.  In v4.1, it is in
>  * use by default (but can be turned off).  Aggressive absorption is used by
>  * default in AMD, also.
>  */
> 
> #define UMFPACK_DEFAULT_PRL 1
> #define UMFPACK_DEFAULT_DENSE_ROW 0.2
> #define UMFPACK_DEFAULT_DENSE_COL 0.2
> #define UMFPACK_DEFAULT_PIVOT_TOLERANCE 0.1
> #define UMFPACK_DEFAULT_2BY2_TOLERANCE 0.01
> #define UMFPACK_DEFAULT_SYM_PIVOT_TOLERANCE 0.001
> #define UMFPACK_DEFAULT_BLOCK_SIZE 32
> #define UMFPACK_DEFAULT_ALLOC_INIT 0.7
> #define UMFPACK_DEFAULT_FRONT_ALLOC_INIT 0.5
> #define UMFPACK_DEFAULT_IRSTEP 2
> #define UMFPACK_DEFAULT_SCALE UMFPACK_SCALE_SUM
> #define UMFPACK_DEFAULT_STRATEGY UMFPACK_STRATEGY_AUTO
> #define UMFPACK_DEFAULT_AMD_DENSE AMD_DEFAULT_DENSE
> #define UMFPACK_DEFAULT_FIXQ 0
> #define UMFPACK_DEFAULT_AGGRESSIVE 1
> 
> #if 0
> /* no longer unused: for unsymmetric strategy (were used in v4.0) */
> #define UMFPACK_DEFAULT_RELAXED_AMALGAMATION 0.25	/* unused */
> #define UMFPACK_DEFAULT_RELAXED2_AMALGAMATION 0.1	/* unused */
> #define UMFPACK_DEFAULT_RELAXED3_AMALGAMATION 0.125	/* unused */
> #endif
> 
> /* default values of Control may change in future versions of UMFPACK. */
> 
> /* -------------------------------------------------------------------------- */
> /* status codes */
> /* -------------------------------------------------------------------------- */
> 
> #define UMFPACK_OK (0)
> 
> /* status > 0 means a warning, but the method was successful anyway. */
> /* A Symbolic or Numeric object was still created. */
> #define UMFPACK_WARNING_singular_matrix (1)
> 
> /* status < 0 means an error, and the method was not successful. */
> /* No Symbolic of Numeric object was created. */
> #define UMFPACK_ERROR_out_of_memory (-1)
> #define UMFPACK_ERROR_invalid_Numeric_object (-3)
> #define UMFPACK_ERROR_invalid_Symbolic_object (-4)
> #define UMFPACK_ERROR_argument_missing (-5)
> #define UMFPACK_ERROR_n_nonpositive (-6)
> #define UMFPACK_ERROR_invalid_matrix (-8)   /* replaces errors -[7:10,12,14] */
> #define UMFPACK_ERROR_different_pattern (-11)
> #define UMFPACK_ERROR_invalid_system (-13)
> #define UMFPACK_ERROR_invalid_permutation (-15)
> #define UMFPACK_ERROR_internal_error (-911)
> #define UMFPACK_ERROR_file_IO (-17)
> 
> /* The following error codes are no longer used.  They are left in for
>  * historical reasons.  They appeared in Version 4.0.  Most of them are combined
>  * into the single UMFPACK_ERROR_invalid_matrix error code (-8).  The last one,
>  * UMFPACK_ERROR_problem_too_large, has been removed.  This error can no longer
>  * occur. */
> #define UMFPACK_ERROR_nz_negative (-7)			/* unused */
> #define UMFPACK_ERROR_jumbled_matrix (-8)		/* unused */
> #define UMFPACK_ERROR_Ap0_nonzero (-9)			/* unused */
> #define UMFPACK_ERROR_row_index_out_of_bounds (-10)	/* unused */
> #define UMFPACK_ERROR_col_length_negative (-12)		/* unused */
> #define UMFPACK_ERROR_invalid_triplet (-14)		/* unused */
> #define UMFPACK_ERROR_problem_too_large (-16)		/* unused */
> 
> /* -------------------------------------------------------------------------- */
> /* solve codes */
> /* -------------------------------------------------------------------------- */
> 
> /* Solve the system ( )x=b, where ( ) is defined below.  "t" refers to the */
> /* linear algebraic transpose (complex conjugate if A is complex), or the (') */
> /* operator in MATLAB.  "at" refers to the array transpose, or the (.') */
> /* operator in MATLAB. */
> 
> #define UMFPACK_A	(0)	/* Ax=b    */
> #define UMFPACK_At	(1)	/* A'x=b   */
> #define UMFPACK_Aat	(2)	/* A.'x=b  */
> 
> #define UMFPACK_Pt_L	(3)	/* P'Lx=b  */
> #define UMFPACK_L	(4)	/* Lx=b    */
> #define UMFPACK_Lt_P	(5)	/* L'Px=b  */
> #define UMFPACK_Lat_P	(6)	/* L.'Px=b */
> #define UMFPACK_Lt	(7)	/* L'x=b   */
> #define UMFPACK_Lat	(8)	/* L.'x=b  */
> 
> #define UMFPACK_U_Qt	(9)	/* UQ'x=b  */
> #define UMFPACK_U	(10)	/* Ux=b    */
> #define UMFPACK_Q_Ut	(11)	/* QU'x=b  */
> #define UMFPACK_Q_Uat	(12)	/* QU.'x=b */
> #define UMFPACK_Ut	(13)	/* U'x=b   */
> #define UMFPACK_Uat	(14)	/* U.'x=b  */
> 
> /* -------------------------------------------------------------------------- */
> 
> /* Integer constants are used for status and solve codes instead of enum */
> /* to make it easier for a Fortran code to call UMFPACK. */
> 
> #endif /* UMFPACK_H */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_col_to_triplet.h pysparse/pysparse/direct/umfpack/include/umfpack_col_to_triplet.h
0a1,111
> /* ========================================================================== */
> /* === umfpack_col_to_triplet =============================================== */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> int umfpack_di_col_to_triplet
> (
>     int n_col,
>     const int Ap [ ],
>     int Tj [ ]
> ) ;
> 
> long umfpack_dl_col_to_triplet
> (
>     long n_col,
>     const long Ap [ ],
>     long Tj [ ]
> ) ;
> 
> int umfpack_zi_col_to_triplet
> (
>     int n_col,
>     const int Ap [ ],
>     int Tj [ ]
> ) ;
> 
> long umfpack_zl_col_to_triplet
> (
>     long n_col,
>     const long Ap [ ],
>     long Tj [ ]
> ) ;
> 
> /*
> double int Syntax:
> 
>     #include "umfpack.h"
>     int n_col, *Tj, *Ap, status ;
>     status = umfpack_di_col_to_triplet (n_col, Ap, Tj) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     long n_col, *Tj, *Ap, status ;
>     status = umfpack_dl_col_to_triplet (n_col, Ap, Tj) ;
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     int n_col, *Tj, *Ap, status ;
>     status = umfpack_zi_col_to_triplet (n_col, Ap, Tj) ;
> 
> complex long Syntax:
> 
>     #include "umfpack.h"
>     long n_col, *Tj, *Ap, status ;
>     status = umfpack_zl_col_to_triplet (n_col, Ap, Tj) ;
> 
> Purpose:
> 
>     Converts a column-oriented matrix to a triplet form.  Only the column
>     pointers, Ap, are required, and only the column indices of the triplet form
>     are constructed.   This routine is the opposite of umfpack_*_triplet_to_col.
>     The matrix may be singular and/or rectangular.  Analogous to [i, Tj, x] =
>     find (A) in MATLAB, except that zero entries present in the column-form of
>     A are present in the output, and i and x are not created (those are just Ai
>     and Ax+Az*1i, respectively, for a column-form matrix A).
> 
> Returns:
> 
>     UMFPACK_OK if successful
>     UMFPACK_ERROR_argument_missing if Ap or Tj is missing
>     UMFPACK_ERROR_n_nonpositive if n_col <= 0
>     UMFPACK_ERROR_invalid_matrix if Ap [n_col] < 0, Ap [0] != 0, or
> 	Ap [j] > Ap [j+1] for any j in the range 0 to n-1.
>     Unsorted columns and duplicate entries do not cause an error (these would
>     only be evident by examining Ai).  Empty rows and columns are OK.
> 
> Arguments:
> 
>     Int n_col ;		Input argument, not modified.
> 
> 	A is an n_row-by-n_col matrix.  Restriction: n_col > 0.
> 	(n_row is not required)
> 
>     Int Ap [n_col+1] ;	Input argument, not modified.
> 
> 	The column pointers of the column-oriented form of the matrix.  See
> 	umfpack_*_*symbolic for a description.  The number of entries in
> 	the matrix is nz = Ap [n_col].  Restrictions on Ap are the same as those
> 	for umfpack_*_transpose.  Ap [0] must be zero, nz must be >= 0, and
> 	Ap [j] <= Ap [j+1] and Ap [j] <= Ap [n_col] must be true for all j in
> 	the range 0 to n_col-1.  Empty columns are OK (that is, Ap [j] may equal
> 	Ap [j+1] for any j in the range 0 to n_col-1).
> 
>     Int Tj [nz] ;	Output argument.
> 
> 	Tj is an integer array of size nz on input, where nz = Ap [n_col].
> 	Suppose the column-form of the matrix is held in Ap, Ai, Ax, and Az
> 	(see umfpack_*_*symbolic for a description).  Then on output, the
> 	triplet form of the same matrix is held in Ai (row indices), Tj (column
> 	indices), and Ax (numerical values).  Note, however, that this routine
> 	does not require Ai and Ax (or Az for the complex version) in order to
> 	do the conversion.
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_defaults.h pysparse/pysparse/direct/umfpack/include/umfpack_defaults.h
0a1,75
> /* ========================================================================== */
> /* === umfpack_defaults ===================================================== */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> void umfpack_di_defaults
> (
>     double Control [UMFPACK_CONTROL]
> ) ;
> 
> void umfpack_dl_defaults
> (
>     double Control [UMFPACK_CONTROL]
> ) ;
> 
> void umfpack_zi_defaults
> (
>     double Control [UMFPACK_CONTROL]
> ) ;
> 
> void umfpack_zl_defaults
> (
>     double Control [UMFPACK_CONTROL]
> ) ;
> 
> /*
> double int Syntax:
> 
>     #include "umfpack.h"
>     double Control [UMFPACK_CONTROL] ;
>     umfpack_di_defaults (Control) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     double Control [UMFPACK_CONTROL] ;
>     umfpack_dl_defaults (Control) ;
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     double Control [UMFPACK_CONTROL] ;
>     umfpack_zi_defaults (Control) ;
> 
> complex long Syntax:
> 
>     #include "umfpack.h"
>     double Control [UMFPACK_CONTROL] ;
>     umfpack_zl_defaults (Control) ;
> 
> Purpose:
> 
>     Sets the default control parameter settings.
> 
>     NOTE:  new control parameters have been added to the Control array for
>     Version 4.1.  These entries were unused in Version 4.0.  The default block
>     size for the BLAS has increased from 24 to 32.  Some rarely used control
>     parameters have been removed (those that controlled relaxed amalgamation).
> 
> Arguments:
> 
>     double Control [UMFPACK_CONTROL] ;	Output argument.
> 
> 	Control is set to the default control parameter settings.  You can
> 	then modify individual settings by changing specific entries in the
> 	Control array.  If Control is a (double *) NULL pointer, then
> 	umfpack_*_defaults returns silently (no error is generated, since
> 	passing a NULL pointer for Control to any UMFPACK routine is valid).
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_free_numeric.h pysparse/pysparse/direct/umfpack/include/umfpack_free_numeric.h
0a1,68
> /* ========================================================================== */
> /* === umfpack_free_numeric ================================================= */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> void umfpack_di_free_numeric
> (
>     void **Numeric
> ) ;
> 
> void umfpack_dl_free_numeric
> (
>     void **Numeric
> ) ;
> 
> void umfpack_zi_free_numeric
> (
>     void **Numeric
> ) ;
> 
> void umfpack_zl_free_numeric
> (
>     void **Numeric
> ) ;
> 
> /*
> double int Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     umfpack_di_free_numeric (&Numeric) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     umfpack_dl_free_numeric (&Numeric) ;
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     umfpack_zi_free_numeric (&Numeric) ;
> 
> complex long Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     umfpack_zl_free_numeric (&Numeric) ;
> 
> Purpose:
> 
>     Deallocates the Numeric object and sets the Numeric handle to NULL.  This
>     routine is the only valid way of destroying the Numeric object.
> 
> Arguments:
> 
>     void **Numeric ;	    Input argument, set to (void *) NULL on output.
> 
> 	Numeric points to a valid Numeric object, computed by umfpack_*_numeric.
> 	No action is taken if Numeric is a (void *) NULL pointer.
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_free_symbolic.h pysparse/pysparse/direct/umfpack/include/umfpack_free_symbolic.h
0a1,68
> /* ========================================================================== */
> /* === umfpack_free_symbolic ================================================ */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> void umfpack_di_free_symbolic
> (
>     void **Symbolic
> ) ;
> 
> void umfpack_dl_free_symbolic
> (
>     void **Symbolic
> ) ;
> 
> void umfpack_zi_free_symbolic
> (
>     void **Symbolic
> ) ;
> 
> void umfpack_zl_free_symbolic
> (
>     void **Symbolic
> ) ;
> 
> /*
> double int Syntax:
> 
>     #include "umfpack.h"
>     void *Symbolic ;
>     umfpack_di_free_symbolic (&Symbolic) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     void *Symbolic ;
>     umfpack_dl_free_symbolic (&Symbolic) ;
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     void *Symbolic ;
>     umfpack_zi_free_symbolic (&Symbolic) ;
> 
> complex long Syntax:
> 
>     #include "umfpack.h"
>     void *Symbolic ;
>     umfpack_zl_free_symbolic (&Symbolic) ;
> 
> Purpose:
> 
>     Deallocates the Symbolic object and sets the Symbolic handle to NULL.  This
>     routine is the only valid way of destroying the Symbolic object.
> 
> Arguments:
> 
>     void **Symbolic ;	    Input argument, set to (void *) NULL on output.
> 
> 	Points to a valid Symbolic object computed by umfpack_*_symbolic.
> 	No action is taken if Symbolic is a (void *) NULL pointer.
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_get_lunz.h pysparse/pysparse/direct/umfpack/include/umfpack_get_lunz.h
0a1,134
> /* ========================================================================== */
> /* === umfpack_get_lunz ===================================================== */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> int umfpack_di_get_lunz
> (
>     int *lnz,
>     int *unz,
>     int *n_row,
>     int *n_col,
>     int *nz_udiag,
>     void *Numeric
> ) ;
> 
> long umfpack_dl_get_lunz
> (
>     long *lnz,
>     long *unz,
>     long *n_row,
>     long *n_col,
>     long *nz_udiag,
>     void *Numeric
> ) ;
> 
> int umfpack_zi_get_lunz
> (
>     int *lnz,
>     int *unz,
>     int *n_row,
>     int *n_col,
>     int *nz_udiag,
>     void *Numeric
> ) ;
> 
> long umfpack_zl_get_lunz
> (
>     long *lnz,
>     long *unz,
>     long *n_row,
>     long *n_col,
>     long *nz_udiag,
>     void *Numeric
> ) ;
> 
> /*
> double int Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     int status, lnz, unz, n_row, n_col ;
>     status = umfpack_di_get_lunz (&lnz, &unz, &n_row, &n_col, Numeric) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     long status, lnz, unz, n_row, n_col ;
>     status = umfpack_dl_get_lunz (&lnz, &unz, &n_row, &n_col, Numeric) ;
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     int status, lnz, unz, n_row, n_col ;
>     status = umfpack_zi_get_lunz (&lnz, &unz, &n_row, &n_col, Numeric) ;
> 
> complex long Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     long status, lnz, unz, n_row, n_col ;
>     status = umfpack_zl_get_lunz (&lnz, &unz, &n_row, &n_col, Numeric) ;
> 
> Purpose:
> 
>     Determines the size and number of nonzeros in the LU factors held by the
>     Numeric object.  These are also the sizes of the output arrays required
>     by umfpack_*_get_numeric.
> 
>     The matrix L is n_row -by- min(n_row,n_col), with lnz nonzeros, including
>     the entries on the unit diagonal of L.
> 
>     The matrix U is min(n_row,n_col) -by- n_col, with unz nonzeros, including
>     nonzeros on the diagonal of U.
> 
> Returns:
> 
>     UMFPACK_OK if successful.
>     UMFPACK_ERROR_invalid_Numeric_object if Numeric is not a valid object.
>     UMFPACK_ERROR_argument_missing if any other argument is (Int *) NULL.
> 
> Arguments:
> 
>     Int *lnz ;		Output argument.
> 
> 	The number of nonzeros in L, including the diagonal (which is all
> 	one's).  This value is the required size of the Lj and Lx arrays as
> 	computed by umfpack_*_get_numeric.  The value of lnz is identical to
> 	Info [UMFPACK_LNZ], if that value was returned by umfpack_*_numeric.
> 
>     Int *unz ;		Output argument.
> 
> 	The number of nonzeros in U, including the diagonal.  This value is the
> 	required size of the Ui and Ux arrays as computed by
> 	umfpack_*_get_numeric.  The value of unz is identical to
> 	Info [UMFPACK_UNZ], if that value was returned by umfpack_*_numeric.
> 
>     Int *n_row ;	Output argument.
>     Int *n_col ;	Output argument.
> 
> 	The order of the L and U matrices.  L is n_row -by- min(n_row,n_col)
> 	and U is min(n_row,n_col) -by- n_col.
> 
>     Int *nz_udiag ;	Output argument.
> 
> 	The number of numerically nonzero values on the diagonal of U.  The
> 	matrix is singular if nz_diag < min(n_row,n_col).  A divide-by-zero
> 	will occur if nz_diag < n_row == n_col when solving a sparse system
> 	involving the matrix U in umfpack_*_*solve.  The value of nz_udiag is
> 	identical to Info [UMFPACK_UDIAG_NZ] if that value was returned by
> 	umfpack_*_numeric.
> 
>     void *Numeric ;	Input argument, not modified.
> 
> 	Numeric must point to a valid Numeric object, computed by
> 	umfpack_*_numeric.
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_get_numeric.h pysparse/pysparse/direct/umfpack/include/umfpack_get_numeric.h
0a1,253
> /* ========================================================================== */
> /* === umfpack_get_numeric ================================================== */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> int umfpack_di_get_numeric
> (
>     int Lp [ ],
>     int Lj [ ],
>     double Lx [ ],
>     int Up [ ],
>     int Ui [ ],
>     double Ux [ ],
>     int P [ ],
>     int Q [ ],
>     double Dx [ ],
>     int *do_recip,
>     double Rs [ ],
>     void *Numeric
> ) ;
> 
> long umfpack_dl_get_numeric
> (
>     long Lp [ ],
>     long Lj [ ],
>     double Lx [ ],
>     long Up [ ],
>     long Ui [ ],
>     double Ux [ ],
>     long P [ ],
>     long Q [ ],
>     double Dx [ ],
>     long *do_recip,
>     double Rs [ ],
>     void *Numeric
> ) ;
> 
> int umfpack_zi_get_numeric
> (
>     int Lp [ ],
>     int Lj [ ],
>     double Lx [ ], double Lz [ ],
>     int Up [ ],
>     int Ui [ ],
>     double Ux [ ], double Uz [ ],
>     int P [ ],
>     int Q [ ],
>     double Dx [ ], double Dz [ ],
>     int *do_recip,
>     double Rs [ ],
>     void *Numeric
> ) ;
> 
> long umfpack_zl_get_numeric
> (
>     long Lp [ ],
>     long Lj [ ],
>     double Lx [ ], double Lz [ ],
>     long Up [ ],
>     long Ui [ ],
>     double Ux [ ], double Uz [ ],
>     long P [ ],
>     long Q [ ],
>     double Dx [ ], double Dz [ ],
>     long *do_recip,
>     double Rs [ ],
>     void *Numeric
> ) ;
> 
> /*
> double int Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     int *Lp, *Lj, *Up, *Ui, *P, *Q, status, do_recip ;
>     double *Lx, *Ux, *Dx, *Rs ;
>     status = umfpack_di_get_numeric (Lp, Lj, Lx, Up, Ui, Ux, P, Q, Dx,
> 	&do_recip, Rs, Numeric) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     long *Lp, *Lj, *Up, *Ui, *P, *Q, status, do_recip ;
>     double *Lx, *Ux, *Dx, *Rs ;
>     status = umfpack_dl_get_numeric (Lp, Lj, Lx, Up, Ui, Ux, P, Q, Dx,
> 	&do_recip, Rs, Numeric) ;
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     int *Lp, *Lj, *Up, *Ui, *P, *Q, status, do_recip ;
>     double *Lx, *Lz, *Ux, *Uz, *Dx, *Dz, *Rs ;
>     status = umfpack_zi_get_numeric (Lp, Lj, Lx, Lz, Up, Ui, Ux, Uz, P, Q,
> 	Dx, Dz, &do_recip, Rs, Numeric) ;
> 
> complex long Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     long *Lp, *Lj, *Up, *Ui, *P, *Q, status, do_recip ;
>     double *Lx, *Lz, *Ux, *Uz, *Dx, *Dz, *Rs ;
>     status = umfpack_zl_get_numeric (Lp, Lj, Lx, Lz, Up, Ui, Ux, Uz, P, Q,
> 	Dx, Dz, &do_recip, Rs, Numeric) ;
> 
> Purpose:
> 
>     This routine copies the LU factors and permutation vectors from the Numeric
>     object into user-accessible arrays.  This routine is not needed to solve a
>     linear system.  Note that the output arrays Lp, Lj, Lx, Up, Ui, Ux, P, Q,
>     Dx, and Rs are not allocated by umfpack_*_get_numeric; they must exist on
>     input.  Similarly, Lz, Uz and Dz must exist on input for the complex
>     versions.
> 
>     All output arguments are optional.  If any of them are NULL
>     on input, then that part of the LU factorization is not copied.  You can
>     use this routine to extract just the parts of the LU factorization that
>     you want.  For example, to retrieve just the column permutation Q, use:
> 
>     #define noD (double *) NULL
>     #define noI (int *) NULL
>     status = umfpack_di_get_numeric (noI, noI, noD, noI, noI, noD, noI,
> 	Q, noD, noI, noD, Numeric) ;
> 
> Returns:
> 
>     Returns UMFPACK_OK if successful.  Returns UMFPACK_ERROR_out_of_memory
>     if insufficient memory is available for the 2*max(n_row,n_col) integer
>     workspace that umfpack_*_get_numeric allocates to construct L and/or U.
>     Returns UMFPACK_ERROR_invalid_Numeric_object if the Numeric object provided
>     as input is invalid.
> 
> Arguments:
> 
>     Int Lp [n_row+1] ;	Output argument.
>     Int Lj [lnz] ;	Output argument.
>     double Lx [lnz] ;	Output argument.
>     double Lz [lnz] ;	Output argument for complex versions.
> 
> 	The n_row-by-min(n_row,n_col) matrix L is returned in compressed-row
> 	form.  The column indices of row i and corresponding numerical values
> 	are in:
> 
> 	    Lj [Lp [i] ... Lp [i+1]-1]
> 	    Lx [Lp [i] ... Lp [i+1]-1]	real part
> 	    Lz [Lp [i] ... Lp [i+1]-1]	imaginary part (complex versions)
> 
> 	respectively.  Each row is stored in sorted order, from low column
> 	indices to higher.  The last entry in each row is the diagonal, which
> 	is numerically equal to one.  The sizes of Lp, Lj, Lx, and Lz are
> 	returned by umfpack_*_get_lunz.    If Lp, Lj, or Ux (or Uz for the
> 	complex version) are not present, then the matrix L is not returned.
> 	This is not an error condition.  The L matrix can be printed if n_row,
> 	Lp, Lj, Lx (and Lz for the complex versions) are passed to
> 	umfpack_*_report_matrix (using the "row" form).
> 
> 	Future complex version:  if Lx is present and Lz is NULL, then both real
> 	and imaginary parts will be returned in Lx[0..2*lnz-1], with Lx[2*k]
> 	and Lx[2*k+1] being the real and imaginary part of the kth entry.
> 
>     Int Up [n_col+1] ;	Output argument.
>     Int Ui [unz] ;	Output argument.
>     double Ux [unz] ;	Output argument.
>     double Uz [unz] ;	Output argument for complex versions.
> 
> 	The min(n_row,n_col)-by-n_col matrix U is returned in compressed-column
> 	form.  The row indices of column j and corresponding numerical values
> 	are in
> 
> 	    Ui [Up [j] ... Up [j+1]-1]
> 	    Ux [Up [j] ... Up [j+1]-1]	real part
> 	    Uz [Up [j] ... Up [j+1]-1]	imaginary part (complex versions)
> 
> 	respectively.  Each column is stored in sorted order, from low row
> 	indices to higher.  The last entry in each column is the diagonal
> 	(assuming that it is nonzero).  The sizes of Up, Ui, Ux, and Uz are
> 	returned by umfpack_*_get_lunz.  If Up, Ui, or Ux (or Uz for the complex
> 	version) are not present, then the matrix U is not returned.  This is
> 	not an error condition.  The U matrix can be printed if n_col, Up, Ui,
> 	Ux (and Uz for the complex versions) are passed to
> 	umfpack_*_report_matrix (using the "column" form).
> 
> 	Future complex version:  if Ux is present and Uz is NULL, then both real
> 	and imaginary parts will be returned in Ux[0..2*unz-1], with Ux[2*k]
> 	and Ux[2*k+1] being the real and imaginary part of the kth entry.
> 
>     Int P [n_row] ;		Output argument.
> 
> 	The permutation vector P is defined as P [k] = i, where the original
> 	row i of A is the kth pivot row in PAQ.  If you do not want the P vector
> 	to be returned, simply pass (Int *) NULL for P.  This is not an error
> 	condition.  You can print P and Q with umfpack_*_report_perm.
> 
>     Int Q [n_col] ;		Output argument.
> 
> 	The permutation vector Q is defined as Q [k] = j, where the original
> 	column j of A is the kth pivot column in PAQ.  If you not want the Q
> 	vector to be returned, simply pass (Int *) NULL for Q.  This is not
> 	an error condition.  Note that Q is not necessarily identical to
> 	Qtree, the column pre-ordering held in the Symbolic object.  Refer to
> 	the description of Qtree and Front_npivcol in umfpack_*_get_symbolic for
> 	details.
> 
>     double Dx [min(n_row,n_col)] ;	Output argument.
>     double Dz [min(n_row,n_col)] ;	Output argument for complex versions.
> 
> 	The diagonal of U is also returned in Dx and Dz.  You can extract the
> 	diagonal of U without getting all of U by passing a non-NULL Dx (and
> 	Dz for the complex version) and passing Up, Ui, and Ux as NULL.  Dx is
> 	the real part of the diagonal, and Dz is the imaginary part.
> 
> 	Future complex version:  if Dx is present and Dz is NULL, then both real
> 	and imaginary parts will be returned in Dx[0..2*min(n_row,n_col)-1],
> 	with Dx[2*k] and Dx[2*k+1] being the real and imaginary part of the kth
> 	entry.
> 
>     Int *do_recip ;		Output argument.
> 
> 	If do_recip is returned as zero (false), then the scale factors Rs [i]
> 	are to be used by multiplying row i by Rs [i].  Otherwise, the entries
> 	in row i are to be divided by Rs [i].
> 
> 	If UMFPACK has been compiled with gcc, or for MATLAB as either a
> 	built-in routine or as a mexFunction, then the NRECIPROCAL flag is
> 	set, and do_recip will always be zero (false).
> 
> 	NOTE: this argument is new to version 4.1.
> 
>     double Rs [n_row] ;		Output argument.
> 
> 	The row scale factors are returned in Rs [0..n_row-1].  Row i of A is
> 	scaled by dividing or multiplying its values by Rs [i].  If default
> 	scaling is in use, Rs [i] is the sum of the absolute values of row i
> 	(or its reciprocal).  If max row scaling is in use, then Rs [i] is the
> 	maximum absolute value in row i (or its reciprocal).
> 	Otherwise, Rs [i] = 1.  If row i is all zero, Rs [i] = 1 as well.  For
> 	the complex version, an approximate absolute value is used
> 	(|x_real|+|x_imag|).
> 
> 	NOTE: this argument is new to version 4.1.
> 
>     void *Numeric ;	Input argument, not modified.
> 
> 	Numeric must point to a valid Numeric object, computed by
> 	umfpack_*_numeric.
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_get_symbolic.h pysparse/pysparse/direct/umfpack/include/umfpack_get_symbolic.h
0a1,342
> /* ========================================================================== */
> /* === umfpack_get_symbolic ================================================= */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> int umfpack_di_get_symbolic
> (
>     int *n_row,
>     int *n_col,
>     int *n1,
>     int *nz,
>     int *nfr,
>     int *nchains,
>     int P [ ],
>     int Q [ ],
>     int Front_npivcol [ ],
>     int Front_parent [ ],
>     int Front_1strow [ ],
>     int Front_leftmostdesc [ ],
>     int Chain_start [ ],
>     int Chain_maxrows [ ],
>     int Chain_maxcols [ ],
>     void *Symbolic
> ) ;
> 
> long umfpack_dl_get_symbolic
> (
>     long *n_row,
>     long *n_col,
>     long *n1,
>     long *nz,
>     long *nfr,
>     long *nchains,
>     long P [ ],
>     long Q [ ],
>     long Front_npivcol [ ],
>     long Front_parent [ ],
>     long Front_1strow [ ],
>     long Front_leftmostdesc [ ],
>     long Chain_start [ ],
>     long Chain_maxrows [ ],
>     long Chain_maxcols [ ],
>     void *Symbolic
> ) ;
> 
> int umfpack_zi_get_symbolic
> (
>     int *n_row,
>     int *n_col,
>     int *n1,
>     int *nz,
>     int *nfr,
>     int *nchains,
>     int P [ ],
>     int Q [ ],
>     int Front_npivcol [ ],
>     int Front_parent [ ],
>     int Front_1strow [ ],
>     int Front_leftmostdesc [ ],
>     int Chain_start [ ],
>     int Chain_maxrows [ ],
>     int Chain_maxcols [ ],
>     void *Symbolic
> ) ;
> 
> long umfpack_zl_get_symbolic
> (
>     long *n_row,
>     long *n_col,
>     long *n1,
>     long *nz,
>     long *nfr,
>     long *nchains,
>     long P [ ],
>     long Q [ ],
>     long Front_npivcol [ ],
>     long Front_parent [ ],
>     long Front_1strow [ ],
>     long Front_leftmostdesc [ ],
>     long Chain_start [ ],
>     long Chain_maxrows [ ],
>     long Chain_maxcols [ ],
>     void *Symbolic
> ) ;
> 
> /*
> 
> double int Syntax:
> 
>     #include "umfpack.h"
>     int status, n_row, n_col, nz, nfr, nchains, *P, *Q,
> 	*Front_npivcol, *Front_parent, *Front_1strow, *Front_leftmostdesc,
> 	*Chain_start, *Chain_maxrows, *Chain_maxcols ;
>     void *Symbolic ;
>     status = umfpack_di_get_symbolic (&n_row, &n_col, &nz, &nfr, &nchains,
> 	P, Q, Front_npivcol, Front_parent, Front_1strow,
> 	Front_leftmostdesc, Chain_start, Chain_maxrows, Chain_maxcols,
> 	Symbolic) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     long status, n_row, n_col, nz, nfr, nchains, *P, *Q,
> 	*Front_npivcol, *Front_parent, *Front_1strow, *Front_leftmostdesc,
> 	*Chain_start, *Chain_maxrows, *Chain_maxcols ;
>     void *Symbolic ;
>     status = umfpack_dl_get_symbolic (&n_row, &n_col, &nz, &nfr, &nchains,
> 	P, Q, Front_npivcol, Front_parent, Front_1strow,
> 	Front_leftmostdesc, Chain_start, Chain_maxrows, Chain_maxcols,
> 	Symbolic) ;
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     int status, n_row, n_col, nz, nfr, nchains, *P, *Q,
> 	*Front_npivcol, *Front_parent, *Front_1strow, *Front_leftmostdesc,
> 	*Chain_start, *Chain_maxrows, *Chain_maxcols ;
>     void *Symbolic ;
>     status = umfpack_zi_get_symbolic (&n_row, &n_col, &nz, &nfr, &nchains,
> 	P, Q, Front_npivcol, Front_parent, Front_1strow,
> 	Front_leftmostdesc, Chain_start, Chain_maxrows, Chain_maxcols,
> 	Symbolic) ;
> 
> complex long Syntax:
> 
>     #include "umfpack.h"
>     long status, n_row, n_col, nz, nfr, nchains, *P, *Q,
> 	*Front_npivcol, *Front_parent, *Front_1strow, *Front_leftmostdesc,
> 	*Chain_start, *Chain_maxrows, *Chain_maxcols ;
>     void *Symbolic ;
>     status = umfpack_zl_get_symbolic (&n_row, &n_col, &nz, &nfr, &nchains,
> 	P, Q, Front_npivcol, Front_parent, Front_1strow,
> 	Front_leftmostdesc, Chain_start, Chain_maxrows, Chain_maxcols,
> 	Symbolic) ;
> 
> Purpose:
> 
>     Copies the contents of the Symbolic object into simple integer arrays
>     accessible to the user.  This routine is not needed to factorize and/or
>     solve a sparse linear system using UMFPACK.  Note that the output arrays
>     P, Q, Front_npivcol, Front_parent, Front_1strow, Front_leftmostdesc,
>     Chain_start, Chain_maxrows, and Chain_maxcols are not allocated by
>     umfpack_*_get_symbolic; they must exist on input.
> 
>     All output arguments are optional.  If any of them are NULL
>     on input, then that part of the symbolic analysis is not copied.  You can
>     use this routine to extract just the parts of the symbolic analysis that
>     you want.  For example, to retrieve just the column permutation Q, use:
> 
>     #define noI (int *) NULL
>     status = umfpack_di_get_symbolic (noI, noI, noI, noI, noI, noI, noI,
> 	    Q, noI, noI, noI, noI, noI, noI, noI, Symbolic) ;
> 
>     The only required argument the last one, the pointer to the Symbolic object.
> 
>     The Symbolic object is small.  Its size for an n-by-n square matrix varies
>     from 4*n to 13*n, depending on the matrix.  The object holds the initial
>     column permutation, the supernodal column elimination tree, and information
>     about each frontal matrix.  You can print it with umfpack_*_report_symbolic.
> 
> Returns:
> 
>     Returns UMFPACK_OK if successful, UMFPACK_ERROR_invalid_Symbolic_object
>     if Symbolic is an invalid object.
> 
> Arguments:
> 
>     Int *n_row ;	Output argument.
>     Int *n_col ;	Output argument.
> 
> 	The dimensions of the matrix A analyzed by the call to
> 	umfpack_*_symbolic that generated the Symbolic object.
> 
>     Int *n1 ;		Output argument.
> 
> 	The number of pivots with zero Markowitz cost (they have just one entry
> 	in the pivot row, or the pivot column, or both).  These appear first in
> 	the output permutations P and Q.
> 
> 	NOTE: this argument is new to version 4.1.
> 
>     Int *nz ;		Output argument.
> 
> 	The number of nonzeros in A.
> 
>     Int *nfr ;	Output argument.
> 
> 	The number of frontal matrices that will be used by umfpack_*_numeric
> 	to factorize the matrix A.  It is in the range 0 to n_col.
> 
>     Int *nchains ;	Output argument.
> 
> 	The frontal matrices are related to one another by the supernodal
> 	column elimination tree.  Each node in this tree is one frontal matrix.
> 	The tree is partitioned into a set of disjoint paths, and a frontal
> 	matrix chain is one path in this tree.  Each chain is factorized using
> 	a unifrontal technique, with a single working array that holds each
> 	frontal matrix in the chain, one at a time.  nchains is in the range
> 	0 to nfr.
> 
>     Int P [n_row] ;	Output argument.
> 
> 	The initial row permutation.  If P [k] = i, then this means that
> 	row i is the kth row in the pre-ordered matrix.  In general, this P is
> 	not the same as the final row permutation computed by umfpack_*_numeric.
> 
> 	For the unsymmetric strategy, P defines the row-merge order.  Let j be
> 	the column index of the leftmost nonzero entry in row i of A*Q.  Then
> 	P defines a sort of the rows according to this value.  A row can appear
> 	earlier in this ordering if it is aggressively absorbed before it can
> 	become a pivot row.  If P [k] = i, row i typically will not be the kth
> 	pivot row.
> 
> 	For the symmetric strategy, P = Q.  For the 2-by-2 strategy, P is the
> 	row permutation that places large entries on the diagonal of P*A*Q.
> 	If no pivoting occurs during numerical factorization, P [k] = i also
> 	defines the final permutation of umfpack_*_numeric, for either the
> 	symmetric or 2-by-2 strategies.
> 
>     Int Q [n_col] ;	Output argument.
> 
> 	The initial column permutation.  If Q [k] = j, then this means that
> 	column j is the kth pivot column in the pre-ordered matrix.  Q is
> 	not necessarily the same as the final column permutation Q, computed by
> 	umfpack_*_numeric.  The numeric factorization may reorder the pivot
> 	columns within each frontal matrix to reduce fill-in.  If the matrix is
> 	structurally singular, and if the symmetric or 2-by-2 strategies or
> 	used (or if Control [UMFPACK_FIXQ] > 0), then this Q will be the same
> 	as the final column permutation computed in umfpack_*_numeric.
> 
>     Int Front_npivcol [n_col+1] ;	Output argument.
> 
> 	This array should be of size at least n_col+1, in order to guarantee
> 	that it will be large enough to hold the output.  Only the first nfr+1
> 	entries are used, however.
> 
> 	The kth frontal matrix holds Front_npivcol [k] pivot columns.  Thus, the
> 	first frontal matrix, front 0, is used to factorize the first
> 	Front_npivcol [0] columns; these correspond to the original columns
> 	Q [0] through Q [Front_npivcol [0]-1].  The next frontal matrix
> 	is used to factorize the next Front_npivcol [1] columns, which are thus
> 	the original columns Q [Front_npivcol [0]] through
> 	Q [Front_npivcol [0] + Front_npivcol [1] - 1], and so on.  Columns
> 	with no entries at all are put in a placeholder "front",
> 	Front_npivcol [nfr].  The sum of Front_npivcol [0..nfr] is equal to
> 	n_col.
> 
> 	Any modifications that umfpack_*_numeric makes to the initial column
> 	permutation are constrained to within each frontal matrix.  Thus, for
> 	the first frontal matrix, Q [0] through Q [Front_npivcol [0]-1] is some
> 	permutation of the columns Q [0] through
> 	Q [Front_npivcol [0]-1].  For second frontal matrix,
> 	Q [Front_npivcol [0]] through Q [Front_npivcol [0] + Front_npivcol[1]-1]
> 	is some permutation of the same portion of Q, and so on.  All pivot
> 	columns are numerically factorized within the frontal matrix originally
> 	determined by the symbolic factorization; there is no delayed pivoting
> 	across frontal matrices.
> 
>     Int Front_parent [n_col+1] ;	Output argument.
> 
> 	This array should be of size at least n_col+1, in order to guarantee
> 	that it will be large enough to hold the output.  Only the first nfr+1
> 	entries are used, however.
> 
> 	Front_parent [0..nfr] holds the supernodal column elimination tree
> 	(including the placeholder front nfr, which may be empty).  Each node in
> 	the tree corresponds to a single frontal matrix.  The parent of node f
> 	is Front_parent [f].
> 
>     Int Front_1strow [n_col+1] ;	Output argument.
> 
> 	This array should be of size at least n_col+1, in order to guarantee
> 	that it will be large enough to hold the output.  Only the first nfr+1
> 	entries are used, however.
> 
> 	Front_1strow [k] is the row index of the first row in A (P,Q)
> 	whose leftmost entry is in a pivot column for the kth front.  This is
> 	necessary only to properly factorize singular matrices.  It is new to
> 	Version 4.0.  Rows in the range Front_1strow [k] to
> 	Front_1strow [k+1]-1 first become pivot row candidates at the kth front.
> 	Any rows not eliminated in the kth front may be selected as pivot rows
> 	in the parent of k (Front_parent [k]) and so on up the tree.
> 
>     Int Front_leftmostdesc [n_col+1] ;	Output argument.
> 
> 	This array should be of size at least n_col+1, in order to guarantee
> 	that it will be large enough to hold the output.  Only the first nfr+1
> 	entries are used, however.
> 
> 	Front_leftmostdesc [k] is the leftmost descendant of front k, or k
> 	if the front has no children in the tree.  Since the rows and columns
> 	(P and Q) have been post-ordered via a depth-first-search of
> 	the tree, rows in the range Front_1strow [Front_leftmostdesc [k]] to
> 	Front_1strow [k+1]-1 form the entire set of candidate pivot rows for
> 	the kth front (some of these will typically have already been selected
> 	by fronts in the range Front_leftmostdesc [k] to front k-1, before
> 	the factorization reaches front k).
> 
>     Chain_start [n_col+1] ;	Output argument.
> 
> 	This array should be of size at least n_col+1, in order to guarantee
> 	that it will be large enough to hold the output.  Only the first
> 	nchains+1 entries are used, however.
> 
> 	The kth frontal matrix chain consists of frontal matrices Chain_start[k]
> 	through Chain_start [k+1]-1.  Thus, Chain_start [0] is always 0, and
> 	Chain_start [nchains] is the total number of frontal matrices, nfr.  For
> 	two adjacent fronts f and f+1 within a single chain, f+1 is always the
> 	parent of f (that is, Front_parent [f] = f+1).
> 
>     Int Chain_maxrows [n_col+1] ;	Output argument.
>     Int Chain_maxcols [n_col+1] ;	Output argument.
> 
> 	These arrays should be of size at least n_col+1, in order to guarantee
> 	that they will be large enough to hold the output.  Only the first
> 	nchains entries are used, however.
> 
> 	The kth frontal matrix chain requires a single working array of
> 	dimension Chain_maxrows [k] by Chain_maxcols [k], for the unifrontal
> 	technique that factorizes the frontal matrix chain.  Since the symbolic
> 	factorization only provides an upper bound on the size of each frontal
> 	matrix, not all of the working array is necessarily used during the
> 	numerical factorization.
> 
> 	Note that the upper bound on the number of rows and columns of each
> 	frontal matrix is computed by umfpack_*_symbolic, but all that is
> 	required by umfpack_*_numeric is the maximum of these two sets of
> 	values for each frontal matrix chain.  Thus, the size of each
> 	individual frontal matrix is not preserved in the Symbolic object.
> 
>     void *Symbolic ;			Input argument, not modified.
> 
> 	The Symbolic object, which holds the symbolic factorization computed by
> 	umfpack_*_symbolic.  The Symbolic object is not modified by
> 	umfpack_*_get_symbolic.
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_load_numeric.h pysparse/pysparse/direct/umfpack/include/umfpack_load_numeric.h
0a1,96
> /* ========================================================================== */
> /* === umfpack_load_numeric ================================================= */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> int umfpack_di_load_numeric
> (
>     void **Numeric,
>     char *filename
> ) ;
> 
> long umfpack_dl_load_numeric
> (
>     void **Numeric,
>     char *filename
> ) ;
> 
> int umfpack_zi_load_numeric
> (
>     void **Numeric,
>     char *filename
> ) ;
> 
> long umfpack_zl_load_numeric
> (
>     void **Numeric,
>     char *filename
> ) ;
> 
> /*
> double int Syntax:
> 
>     #include "umfpack.h"
>     int status ;
>     char *filename ;
>     void *Numeric ;
>     status = umfpack_di_load_numeric (&Numeric, filename) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     long status ;
>     char *filename ;
>     void *Numeric ;
>     status = umfpack_dl_load_numeric (&Numeric, filename) ;
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     int status ;
>     char *filename ;
>     void *Numeric ;
>     status = umfpack_zi_load_numeric (&Numeric, filename) ;
> 
> complex long Syntax:
> 
>     #include "umfpack.h"
>     long status ;
>     char *filename ;
>     void *Numeric ;
>     status = umfpack_zl_load_numeric (&Numeric, filename) ;
> 
> Purpose:
> 
>     Loads a Numeric object from a file created by umfpack_*_save_numeric.  The
>     Numeric handle passed to this routine is overwritten with the new object.
>     If that object exists prior to calling this routine, a memory leak will
>     occur.  The contents of Numeric are ignored on input.
> 
> Returns:
> 
>     UMFPACK_OK if successful.
>     UMFPACK_ERROR_out_of_memory if not enough memory is available.
>     UMFPACK_ERROR_file_IO if an I/O error occurred.
> 
> Arguments:
> 
>     void **Numeric ;	    Output argument.
> 
> 	**Numeric is the address of a (void *) pointer variable in the user's
> 	calling routine (see Syntax, above).  On input, the contents of this
> 	variable are not defined.  On output, this variable holds a (void *)
> 	pointer to the Numeric object (if successful), or (void *) NULL if
> 	a failure occurred.
> 
>     char *filename ;	    Input argument, not modified.
> 
> 	A string that contains the filename from which to read the Numeric
> 	object.
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_load_symbolic.h pysparse/pysparse/direct/umfpack/include/umfpack_load_symbolic.h
0a1,96
> /* ========================================================================== */
> /* === umfpack_load_symbolic ================================================ */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> int umfpack_di_load_symbolic
> (
>     void **Symbolic,
>     char *filename
> ) ;
> 
> long umfpack_dl_load_symbolic
> (
>     void **Symbolic,
>     char *filename
> ) ;
> 
> int umfpack_zi_load_symbolic
> (
>     void **Symbolic,
>     char *filename
> ) ;
> 
> long umfpack_zl_load_symbolic
> (
>     void **Symbolic,
>     char *filename
> ) ;
> 
> /*
> double int Syntax:
> 
>     #include "umfpack.h"
>     int status ;
>     char *filename ;
>     void *Symbolic ;
>     status = umfpack_di_load_symbolic (&Symbolic, filename) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     long status ;
>     char *filename ;
>     void *Symbolic ;
>     status = umfpack_dl_load_symbolic (&Symbolic, filename) ;
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     int status ;
>     char *filename ;
>     void *Symbolic ;
>     status = umfpack_zi_load_symbolic (&Symbolic, filename) ;
> 
> complex long Syntax:
> 
>     #include "umfpack.h"
>     long status ;
>     char *filename ;
>     void *Symbolic ;
>     status = umfpack_zl_load_symbolic (&Symbolic, filename) ;
> 
> Purpose:
> 
>     Loads a Symbolic object from a file created by umfpack_*_save_symbolic. The
>     Symbolic handle passed to this routine is overwritten with the new object.
>     If that object exists prior to calling this routine, a memory leak will
>     occur.  The contents of Symbolic are ignored on input.
> 
> Returns:
> 
>     UMFPACK_OK if successful.
>     UMFPACK_ERROR_out_of_memory if not enough memory is available.
>     UMFPACK_ERROR_file_IO if an I/O error occurred.
> 
> Arguments:
> 
>     void **Symbolic ;	    Output argument.
> 
> 	**Symbolic is the address of a (void *) pointer variable in the user's
> 	calling routine (see Syntax, above).  On input, the contents of this
> 	variable are not defined.  On output, this variable holds a (void *)
> 	pointer to the Symbolic object (if successful), or (void *) NULL if
> 	a failure occurred.
> 
>     char *filename ;	    Input argument, not modified.
> 
> 	A string that contains the filename from which to read the Symbolic
> 	object.
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_numeric.h pysparse/pysparse/direct/umfpack/include/umfpack_numeric.h
0a1,529
> /* ========================================================================== */
> /* === umfpack_numeric ====================================================== */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> int umfpack_di_numeric
> (
>     const int Ap [ ],
>     const int Ai [ ],
>     const double Ax [ ],
>     void *Symbolic,
>     void **Numeric,
>     const double Control [UMFPACK_CONTROL],
>     double Info [UMFPACK_INFO]
> ) ;
> 
> long umfpack_dl_numeric
> (
>     const long Ap [ ],
>     const long Ai [ ],
>     const double Ax [ ],
>     void *Symbolic,
>     void **Numeric,
>     const double Control [UMFPACK_CONTROL],
>     double Info [UMFPACK_INFO]
> ) ;
> 
> int umfpack_zi_numeric
> (
>     const int Ap [ ],
>     const int Ai [ ],
>     const double Ax [ ], const double Az [ ],
>     void *Symbolic,
>     void **Numeric,
>     const double Control [UMFPACK_CONTROL],
>     double Info [UMFPACK_INFO]
> ) ;
> 
> long umfpack_zl_numeric
> (
>     const long Ap [ ],
>     const long Ai [ ],
>     const double Ax [ ], const double Az [ ],
>     void *Symbolic,
>     void **Numeric,
>     const double Control [UMFPACK_CONTROL],
>     double Info [UMFPACK_INFO]
> ) ;
> 
> /*
> double int Syntax:
> 
>     #include "umfpack.h"
>     void *Symbolic, *Numeric ;
>     int *Ap, *Ai, status ;
>     double *Ax, Control [UMFPACK_CONTROL], Info [UMFPACK_INFO] ;
>     status = umfpack_di_numeric (Ap, Ai, Ax, Symbolic, &Numeric, Control, Info);
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     void *Symbolic, *Numeric ;
>     long *Ap, *Ai, status ;
>     double *Ax, Control [UMFPACK_CONTROL], Info [UMFPACK_INFO] ;
>     status = umfpack_dl_numeric (Ap, Ai, Ax, Symbolic, &Numeric, Control, Info);
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     void *Symbolic, *Numeric ;
>     int *Ap, *Ai, status ;
>     double *Ax, *Az, Control [UMFPACK_CONTROL], Info [UMFPACK_INFO] ;
>     status = umfpack_zi_numeric (Ap, Ai, Ax, Az, Symbolic, &Numeric,
> 	Control, Info) ;
> 
> complex long Syntax:
> 
>     #include "umfpack.h"
>     void *Symbolic, *Numeric ;
>     long *Ap, *Ai, status ;
>     double *Ax, *Az, Control [UMFPACK_CONTROL], Info [UMFPACK_INFO] ;
>     status = umfpack_zl_numeric (Ap, Ai, Ax, Symbolic, &Numeric,
> 	Control, Info) ;
> 
> Purpose:
> 
>     Given a sparse matrix A in column-oriented form, and a symbolic analysis
>     computed by umfpack_*_*symbolic, the umfpack_*_numeric routine performs the
>     numerical factorization, PAQ=LU, PRAQ=LU, or P(R\A)Q=LU, where P and Q are
>     permutation matrices (represented as permutation vectors), R is the row
>     scaling, L is unit-lower triangular, and U is upper triangular.  This is
>     required before the system Ax=b (or other related linear systems) can be
>     solved.  umfpack_*_numeric can be called multiple times for each call to
>     umfpack_*_*symbolic, to factorize a sequence of matrices with identical
>     nonzero pattern.  Simply compute the Symbolic object once, with
>     umfpack_*_*symbolic, and reuse it for subsequent matrices.  This routine
>     safely detects if the pattern changes, and sets an appropriate error code.
> 
> Returns:
> 
>     The status code is returned.  See Info [UMFPACK_STATUS], below.
> 
> Arguments:
> 
>     Int Ap [n_col+1] ;	Input argument, not modified.
> 
> 	This must be identical to the Ap array passed to umfpack_*_*symbolic.
> 	The value of n_col is what was passed to umfpack_*_*symbolic (this is
> 	held in the Symbolic object).
> 
>     Int Ai [nz] ;	Input argument, not modified, of size nz = Ap [n_col].
> 
> 	This must be identical to the Ai array passed to umfpack_*_*symbolic.
> 
>     double Ax [nz] ;	Input argument, not modified, of size nz = Ap [n_col].
> 
> 	The numerical values of the sparse matrix A.  The nonzero pattern (row
> 	indices) for column j is stored in Ai [(Ap [j]) ... (Ap [j+1]-1)], and
> 	the corresponding numerical values are stored in
> 	Ax [(Ap [j]) ... (Ap [j+1]-1)].
> 
>     double Az [nz] ;	Input argument, not modified, for complex versions.
> 
> 	For the complex versions, this holds the imaginary part of A.  The
> 	imaginary part of column j is held in Az [(Ap [j]) ... (Ap [j+1]-1)].
> 
> 	Future complex version:  if Ax is present and Az is NULL, then both real
> 	and imaginary parts will be contained in Ax[0..2*nz-1], with Ax[2*k]
> 	and Ax[2*k+1] being the real and imaginary part of the kth entry.
> 
>     void *Symbolic ;	Input argument, not modified.
> 
> 	The Symbolic object, which holds the symbolic factorization computed by
> 	umfpack_*_*symbolic.  The Symbolic object is not modified by
> 	umfpack_*_numeric.
> 
>     void **Numeric ;	Output argument.
> 
> 	**Numeric is the address of a (void *) pointer variable in the user's
> 	calling routine (see Syntax, above).  On input, the contents of this
> 	variable are not defined.  On output, this variable holds a (void *)
> 	pointer to the Numeric object (if successful), or (void *) NULL if
> 	a failure occurred.
> 
>     double Control [UMFPACK_CONTROL] ;   Input argument, not modified.
> 
> 	If a (double *) NULL pointer is passed, then the default control
> 	settings are used.  Otherwise, the settings are determined from the
> 	Control array.  See umfpack_*_defaults on how to fill the Control
> 	array with the default settings.  If Control contains NaN's, the
> 	defaults are used.  The following Control parameters are used:
> 
> 	Control [UMFPACK_PIVOT_TOLERANCE]:  relative pivot tolerance for
> 	    threshold partial pivoting with row interchanges.  In any given
> 	    column, an entry is numerically acceptable if its absolute value is
> 	    greater than or equal to Control [UMFPACK_PIVOT_TOLERANCE] times
> 	    the largest absolute value in the column.  A value of 1.0 gives true
> 	    partial pivoting.  If less than or equal to zero, then any nonzero
> 	    entry is numerically acceptable as a pivot (this is changed from
> 	    Version 4.0).  Default: 0.1.
> 
> 	    Smaller values tend to lead to sparser LU factors, but the solution
> 	    to the linear system can become inaccurate.  Larger values can lead
> 	    to a more accurate solution (but not always), and usually an
> 	    increase in the total work.
> 
> 	    For complex matrices, a cheap approximate of the absolute value
> 	    is used for the threshold partial pivoting test (|a_real| + |a_imag|
> 	    instead of the more expensive-to-compute exact absolute value
> 	    sqrt (a_real^2 + a_imag^2)).
> 
> 	Control [UMFPACK_SYM_PIVOT_TOLERANCE]:  This parameter is new to V4.1.
> 	    If diagonal pivoting is attempted (the symmetric or symmetric-2by2
> 	    strategies are used) then this parameter is used to control when the
> 	    diagonal entry is selected in a given pivot column.  The absolute
> 	    value of the entry must be >= Control [UMFPACK_SYM_PIVOT_TOLERANCE]
> 	    times the largest absolute value in the column.  A value of zero
> 	    will ensure that no off-diagonal pivoting is performed, except that
> 	    zero diagonal entries are not selected if there are any off-diagonal
> 	    nonzero entries.
> 
> 	    If an off-diagonal pivot is selected, an attempt is made to restore
> 	    symmetry later on.  Suppose A (i,j) is selected, where i != j.
> 	    If column i has not yet been selected as a pivot column, then
> 	    the entry A (j,i) is redefined as a "diagonal" entry, except that
> 	    the tighter tolerance (Control [UMFPACK_PIVOT_TOLERANCE]) is
> 	    applied.  This strategy has an effect similar to 2-by-2 pivoting
> 	    for symmetric indefinite matrices.  If a 2-by-2 block pivot with
> 	    nonzero structure
> 
> 		       i j
> 		    i: 0 x
> 		    j: x 0
> 
> 	    is selected in a symmetric indefinite factorization method, the
> 	    2-by-2 block is inverted and a rank-2 update is applied.  In
> 	    UMFPACK, this 2-by-2 block would be reordered as
> 
> 		       j i
> 		    i: x 0
> 		    j: 0 x
> 
> 	    In both cases, the symmetry of the Schur complement is preserved.
> 
> 	Control [UMFPACK_SCALE]:  This parameter is new to V4.1.  Version 4.0
> 	    did not scale the matrix.  Note that the user's input matrix is
> 	    never modified, only an internal copy is scaled.
> 
> 	    There are three valid settings for this parameter.  If any other
> 	    value is provided, the default is used.
> 
> 	    UMFPACK_SCALE_NONE:  no scaling is performed.
> 
> 	    UMFPACK_SCALE_SUM:  each row of the input matrix A is divided by
> 		the sum of the absolute values of the entries in that row.
> 		The scaled matrix has an infinity norm of 1.
> 
> 	    UMFPACK_SCALE_MAX:  each row of the input matrix A is divided by
> 		the maximum the absolute values of the entries in that row.
> 		In the scaled matrix the largest entry in each row has
> 		a magnitude exactly equal to 1.
> 
> 	    Note that for complex matrices, a cheap approximate absolute value
> 	    is used, |a_real| + |a_imag|, instead of the exact absolute value
> 	    sqrt ((a_real)^2 + (a_imag)^2).
> 
> 	    Scaling is very important for the "symmetric" strategy when
> 	    diagonal pivoting is attempted.  It also improves the performance
> 	    of the "unsymmetric" strategy.
> 
> 	    Default: UMFPACK_SCALE_SUM.
> 
> 	Control [UMFPACK_ALLOC_INIT]:  This parameter has changed in V4.1.
> 
> 	    When umfpack_*_numeric starts, it allocates memory for the Numeric
> 	    object.  Part of this is of fixed size (approximately n double's +
> 	    12*n integers).  The remainder is of variable size, which grows to
> 	    hold the LU factors and the frontal matrices created during
> 	    factorization.  A estimate of the upper bound is computed by
> 	    umfpack_*_*symbolic, and returned by umfpack_*_*symbolic in
> 	    Info [UMFPACK_VARIABLE_PEAK_ESTIMATE] (in Units).
> 
> 	    If Control [UMFPACK_ALLOC_INIT] is >= 0, umfpack_*_numeric initially
> 	    allocates space for the variable-sized part equal to this estimate
> 	    times Control [UMFPACK_ALLOC_INIT].  Typically, for matrices for
> 	    which the "unsymmetric" strategy applies, umfpack_*_numeric needs
> 	    only about half the estimated memory space, so a setting of 0.5 or
> 	    0.6 often provides enough memory for umfpack_*_numeric to factorize
> 	    the matrix with no subsequent increases in the size of this block.
> 
> 	    If the matrix is ordered via AMD, then this non-negative parameter
> 	    is ignored.  The initial allocation ratio computed automatically,
> 	    as 1.2 * (nz + Info [UMFPACK_SYMMETRIC_LUNZ]) /
> 	    (Info [UMFPACK_LNZ_ESTIMATE] + Info [UMFPACK_UNZ_ESTIMATE] -
> 	    min (n_row, n_col)).
> 
> 	    If Control [UMFPACK_ALLOC_INIT] is negative, then umfpack_*_numeric
> 	    allocates a space with initial size (in Units) equal to
> 	    (-Control [UMFPACK_ALLOC_INIT]).
> 
> 	    Regardless of the value of this parameter, a space equal to or
> 	    greater than the the bare minimum amount of memory needed to start
> 	    the factorization is always initially allocated.  The bare initial
> 	    memory required is returned by umfpack_*_*symbolic in
> 	    Info [UMFPACK_VARIABLE_INIT_ESTIMATE] (an exact value, not an
> 	    estimate).
> 
> 	    If the variable-size part of the Numeric object is found to be too
> 	    small sometime after numerical factorization has started, the memory
> 	    is increased in size by a factor of 1.2.   If this fails, the
> 	    request is reduced by a factor of 0.95 until it succeeds, or until
> 	    it determines that no increase in size is possible.  Garbage
> 	    collection then occurs.
> 
> 	    The strategy of attempting to "malloc" a working space, and
> 	    re-trying with a smaller space, may not work under MATLAB, since
> 	    mxMalloc aborts the mexFunction if it fails.  The built-in umfpack
> 	    routine (version 4.0) in MATLAB 6.5 uses utMalloc instead, which
> 	    avoids this problem.  As a mexFunction, utMalloc is used unless
> 	    -DNUTIL is defined at compile time.  The utMalloc routine, and
> 	    utFree and utRealloc, are not documented.  If the mexFunction
> 	    doesn't work, then compile it with -DNUTIL instead.
> 
> 	    If you are using the umfpack mexFunction, decrease the magnitude of
> 	    Control [UMFPACK_ALLOC_INIT] if you run out of memory in MATLAB.
> 
> 	    Default initial allocation size: 0.7.  Thus, with the default
> 	    control settings and the "unsymmetric" strategy, the upper-bound is
> 	    reached after two reallocations (0.7 * 1.2 * 1.2 = 1.008).
> 
> 	    Changing this parameter has little effect on fill-in or operation
> 	    count.  It has a small impact on run-time (the extra time required
> 	    to do the garbage collection and memory reallocation).
> 
> 	Control [UMFPACK_FRONT_ALLOC_INIT]:  This parameter is new to V4.1.
> 
> 	    When UMFPACK starts the factorization of each "chain" of frontal
> 	    matrices, it allocates a working array to hold the frontal matrices
> 	    as they are factorized.  The symbolic factorization computes the
> 	    size of the largest possible frontal matrix that could occur during
> 	    the factorization of each chain.
> 
> 	    If Control [UMFPACK_FRONT_ALLOC_INIT] is >= 0, the following
> 	    strategy is used.  If the AMD ordering was used, this non-negative
> 	    parameter is ignored.  A front of size (d+2)*(d+2) is allocated,
> 	    where d = Info [UMFPACK_SYMMETRIC_DMAX].  Otherwise, a front of
> 	    size Control [UMFPACK_FRONT_ALLOC_INIT] times the largest front
> 	    possible for this chain is allocated.
> 
> 	    If Control [UMFPACK_FRONT_ALLOC_INIT] is negative, then a front of
> 	    size (-Control [UMFPACK_FRONT_ALLOC_INIT]) is allocated (where the
> 	    size is in terms of the number of numerical entries).  This is done
> 	    regardless of the ordering method or ordering strategy used.
> 
> 	    Default: 0.5.
> 
>     double Info [UMFPACK_INFO] ;	Output argument.
> 
> 	Contains statistics about the numeric factorization.  If a
> 	(double *) NULL pointer is passed, then no statistics are returned in
> 	Info (this is not an error condition).  The following statistics are
> 	computed in umfpack_*_numeric:
> 
> 	Info [UMFPACK_STATUS]: status code.  This is also the return value,
> 	    whether or not Info is present.
> 
> 	    UMFPACK_OK
> 
> 		Numeric factorization was successful.  umfpack_*_numeric
> 		computed a valid numeric factorization.
> 
> 	    UMFPACK_WARNING_singular_matrix
> 
> 		Numeric factorization was successful, but the matrix is
> 		singular.  umfpack_*_numeric computed a valid numeric
> 		factorization, but you will get a divide by zero in
> 		umfpack_*_*solve.  For the other cases below, no Numeric object
> 		is created (*Numeric is (void *) NULL).
> 
> 	    UMFPACK_ERROR_out_of_memory
> 
> 		Insufficient memory to complete the numeric factorization.
> 
> 	    UMFPACK_ERROR_argument_missing
> 
> 		One or more required arguments are missing.
> 
> 	    UMFPACK_ERROR_invalid_Symbolic_object
> 
> 		Symbolic object provided as input is invalid.
> 
> 	    UMFPACK_ERROR_different_pattern
> 
> 		The pattern (Ap and/or Ai) has changed since the call to
> 		umfpack_*_*symbolic which produced the Symbolic object.
> 
> 	Info [UMFPACK_NROW]:  the value of n_row stored in the Symbolic object.
> 
> 	Info [UMFPACK_NCOL]:  the value of n_col stored in the Symbolic object.
> 
> 	Info [UMFPACK_NZ]:  the number of entries in the input matrix.
> 	    This value is obtained from the Symbolic object.
> 
> 	Info [UMFPACK_SIZE_OF_UNIT]:  the number of bytes in a Unit, for memory
> 	    usage statistics below.
> 
> 	Info [UMFPACK_VARIABLE_INIT]: the initial size (in Units) of the
> 	    variable-sized part of the Numeric object.  If this differs from
> 	    Info [UMFPACK_VARIABLE_INIT_ESTIMATE], then the pattern (Ap and/or
> 	    Ai) has changed since the last call to umfpack_*_*symbolic, which is
> 	    an error condition.
> 
> 	Info [UMFPACK_VARIABLE_PEAK]: the peak size (in Units) of the
> 	    variable-sized part of the Numeric object.  This size is the amount
> 	    of space actually used inside the block of memory, not the space
> 	    allocated via UMF_malloc.  You can reduce UMFPACK's memory
> 	    requirements by setting Control [UMFPACK_ALLOC_INIT] to the ratio
> 	    Info [UMFPACK_VARIABLE_PEAK] / Info[UMFPACK_VARIABLE_PEAK_ESTIMATE].
> 	    This will ensure that no memory reallocations occur (you may want to
> 	    add 0.001 to make sure that integer roundoff does not lead to a
> 	    memory size that is 1 Unit too small; otherwise, garbage collection
> 	    and reallocation will occur).
> 
> 	Info [UMFPACK_VARIABLE_FINAL]: the final size (in Units) of the
> 	    variable-sized part of the Numeric object.  It holds just the
> 	    sparse LU factors.
> 
> 	Info [UMFPACK_NUMERIC_SIZE]:  the actual final size (in Units) of the
> 	    entire Numeric object, including the final size of the variable
> 	    part of the object.  Info [UMFPACK_NUMERIC_SIZE_ESTIMATE],
> 	    an estimate, was computed by umfpack_*_*symbolic.  The estimate is
> 	    normally an upper bound on the actual final size, but this is not
> 	    guaranteed.
> 
> 	Info [UMFPACK_PEAK_MEMORY]:  the actual peak memory usage (in Units) of
> 	    both umfpack_*_*symbolic and umfpack_*_numeric.  An estimate,
> 	    Info [UMFPACK_PEAK_MEMORY_ESTIMATE], was computed by
> 	    umfpack_*_*symbolic.  The estimate is normally an upper bound on the
> 	    actual peak usage, but this is not guaranteed.  With testing on
> 	    hundreds of matrix arising in real applications, I have never
> 	    observed a matrix where this estimate or the Numeric size estimate
> 	    was less than the actual result, but this is theoretically possible.
> 	    Please send me one if you find such a matrix.
> 
> 	Info [UMFPACK_FLOPS]:  the actual count of the (useful) floating-point
> 	    operations performed.  An estimate, Info [UMFPACK_FLOPS_ESTIMATE],
> 	    was computed by umfpack_*_*symbolic.  The estimate is guaranteed to
> 	    be an upper bound on this flop count.  The flop count excludes
> 	    "useless" flops on zero values, flops performed during the pivot
> 	    search (for tentative updates and assembly of candidate columns),
> 	    and flops performed to add frontal matrices together.
> 
> 	    For the real version, only (+ - * /) are counted.  For the complex
> 	    version, the following counts are used:
> 
> 		operation	flops
> 	    	c = 1/b		6
> 		c = a*b		6
> 		c -= a*b	8
> 
> 	Info [UMFPACK_LNZ]: the actual nonzero entries in final factor L,
> 	    including the diagonal.  This excludes any zero entries in L,
> 	    although some of these are stored in the Numeric object.  The
> 	    Info [UMFPACK_LU_ENTRIES] statistic does account for all
> 	    explicitly stored zeros, however.  Info [UMFPACK_LNZ_ESTIMATE],
> 	    an estimate, was computed by umfpack_*_*symbolic.  The estimate is
> 	    guaranteed to be an upper bound on Info [UMFPACK_LNZ].
> 
> 	Info [UMFPACK_UNZ]: the actual nonzero entries in final factor U,
> 	    including the diagonal.  This excludes any zero entries in U,
> 	    although some of these are stored in the Numeric object.  The
> 	    Info [UMFPACK_LU_ENTRIES] statistic does account for all
> 	    explicitly stored zeros, however.  Info [UMFPACK_UNZ_ESTIMATE],
> 	    an estimate, was computed by umfpack_*_*symbolic.  The estimate is
> 	    guaranteed to be an upper bound on Info [UMFPACK_UNZ].
> 
> 	Info [UMFPACK_NUMERIC_DEFRAG]:  The number of garbage collections
> 	    performed during umfpack_*_numeric, to compact the contents of the
> 	    variable-sized workspace used by umfpack_*_numeric.  No estimate was
> 	    computed by umfpack_*_*symbolic.  In the current version of UMFPACK,
> 	    garbage collection is performed and then the memory is reallocated,
> 	    so this statistic is the same as Info [UMFPACK_NUMERIC_REALLOC],
> 	    below.  It may differ in future releases.
> 
> 	Info [UMFPACK_NUMERIC_REALLOC]:  The number of times that the Numeric
> 	    object was increased in size from its initial size.  A rough upper
> 	    bound on the peak size of the Numeric object was computed by
> 	    umfpack_*_*symbolic, so reallocations should be rare.  However, if
> 	    umfpack_*_numeric is unable to allocate that much storage, it
> 	    reduces its request until either the allocation succeeds, or until
> 	    it gets too small to do anything with.  If the memory that it
> 	    finally got was small, but usable, then the reallocation count
> 	    could be high.  No estimate of this count was computed by
> 	    umfpack_*_*symbolic.
> 
> 	Info [UMFPACK_NUMERIC_COSTLY_REALLOC]:  The number of times that the
> 	    system realloc library routine (or mxRealloc for the mexFunction)
> 	    had to move the workspace.  Realloc can sometimes increase the size
> 	    of a block of memory without moving it, which is much faster.  This
> 	    statistic will always be <= Info [UMFPACK_NUMERIC_REALLOC].  If your
> 	    memory space is fragmented, then the number of "costly" realloc's
> 	    will be equal to Info [UMFPACK_NUMERIC_REALLOC].
> 
> 	Info [UMFPACK_COMPRESSED_PATTERN]:  The number of integers used to
> 	    represent the pattern of L and U.
> 
> 	Info [UMFPACK_LU_ENTRIES]:  The total number of numerical values that
> 	    are stored for the LU factors.  Some of the values may be explicitly
> 	    zero in order to save space (allowing for a smaller compressed
> 	    pattern).
> 
> 	Info [UMFPACK_NUMERIC_TIME]:  The CPU time taken, in seconds.
> 
> 	Info [UMFPACK_RCOND]:  A rough estimate of the condition number, equal
> 	    to min (abs (diag (U))) / max (abs (diag (U))), or zero if the
> 	    diagonal of U is all zero.
> 
> 	Info [UMFPACK_UDIAG_NZ]:  The number of numerically nonzero values on
> 	    the diagonal of U.
> 
> 	Info [UMFPACK_UMIN]:  the smallest absolute value on the diagonal of U.
> 
> 	Info [UMFPACK_UMAX]:  the smallest absolute value on the diagonal of U.
> 
> 	Info [UMFPACK_MAX_FRONT_SIZE]: the size of the
> 	    largest frontal matrix (number of entries).
> 
> 	------------------------------------------------------------------------
> 	The following statistics were added to Version 4.1:
> 	------------------------------------------------------------------------
> 
> 	Info [UMFPACK_NUMERIC_WALLTIME]:  The wallclock time taken, in seconds.
> 
> 	Info [UMFPACK_MAX_FRONT_NROWS]: the max number of
> 	    rows in any frontal matrix.
> 
> 	Info [UMFPACK_MAX_FRONT_NCOLS]: the max number of
> 	    columns in any frontal matrix.
> 
> 	Info [UMFPACK_WAS_SCALED]:  the scaling used, either UMFPACK_SCALE_NONE,
> 	    UMFPACK_SCALE_SUM, or UMFPACK_SCALE_MAX.
> 
> 	Info [UMFPACK_RSMIN]: if scaling is performed, the smallest scale factor
> 	    for any row (either the smallest sum of absolute entries, or the
> 	    smallest maximum of absolute entries).
> 
> 	Info [UMFPACK_RSMAX]: if scaling is performed, the largest scale factor
> 	    for any row (either the largest sum of absolute entries, or the
> 	    largest maximum of absolute entries).
> 
> 	Info [UMFPACK_ALLOC_INIT_USED]:  the initial allocation parameter used.
> 
> 	Info [UMFPACK_FORCED_UPDATES]:  the number of BLAS-3 updates to the
> 	    frontal matrices that were required because the frontal matrix
> 	    grew larger than its current working array.
> 
> 	Info [UMFPACK_NOFF_DIAG]: number of off-diagonal pivots selected, if the
> 	    symmetric or 2-by-2 strategies are used.
> 
> 	Only the above listed Info [...] entries are accessed.  The remaining
> 	entries of Info are not accessed or modified by umfpack_*_numeric.
> 	Future versions might modify different parts of Info.
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_qsymbolic.h pysparse/pysparse/direct/umfpack/include/umfpack_qsymbolic.h
0a1,140
> /* ========================================================================== */
> /* === umfpack_qsymbolic ==================================================== */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> int umfpack_di_qsymbolic
> (
>     int n_row,
>     int n_col,
>     const int Ap [ ],
>     const int Ai [ ],
>     const double Ax [ ],
>     const int Qinit [ ],
>     void **Symbolic,
>     const double Control [UMFPACK_CONTROL],
>     double Info [UMFPACK_INFO]
> ) ;
> 
> long umfpack_dl_qsymbolic
> (
>     long n_row,
>     long n_col,
>     const long Ap [ ],
>     const long Ai [ ],
>     const double Ax [ ],
>     const long Qinit [ ],
>     void **Symbolic,
>     const double Control [UMFPACK_CONTROL],
>     double Info [UMFPACK_INFO]
> ) ;
> 
> int umfpack_zi_qsymbolic
> (
>     int n_row,
>     int n_col,
>     const int Ap [ ],
>     const int Ai [ ],
>     const double Ax [ ], const double Az [ ],
>     const int Qinit [ ],
>     void **Symbolic,
>     const double Control [UMFPACK_CONTROL],
>     double Info [UMFPACK_INFO]
> ) ;
> 
> long umfpack_zl_qsymbolic
> (
>     long n_row,
>     long n_col,
>     const long Ap [ ],
>     const long Ai [ ],
>     const double Ax [ ], const double Az [ ],
>     const long Qinit [ ],
>     void **Symbolic,
>     const double Control [UMFPACK_CONTROL],
>     double Info [UMFPACK_INFO]
> ) ;
> 
> /*
> double int Syntax:
> 
>     #include "umfpack.h"
>     void *Symbolic ;
>     int n_row, n_col, *Ap, *Ai, *Qinit, status ;
>     double Control [UMFPACK_CONTROL], Info [UMFPACK_INFO], *Ax ;
>     status = umfpack_di_qsymbolic (n_row, n_col, Ap, Ai, Ax, Qinit,
> 	&Symbolic, Control, Info) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     void *Symbolic ;
>     long n_row, n_col, *Ap, *Ai, *Qinit, status ;
>     double Control [UMFPACK_CONTROL], Info [UMFPACK_INFO], *Ax ;
>     status = umfpack_dl_qsymbolic (n_row, n_col, Ap, Ai, Ax, Qinit,
> 	&Symbolic, Control, Info) ;
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     void *Symbolic ;
>     int n_row, n_col, *Ap, *Ai, *Qinit, status ;
>     double Control [UMFPACK_CONTROL], Info [UMFPACK_INFO], *Ax, *Az ;
>     status = umfpack_zi_qsymbolic (n_row, n_col, Ap, Ai, Ax, Az, Qinit,
> 	&Symbolic, Control, Info) ;
> 
> complex long Syntax:
> 
>     #include "umfpack.h"
>     void *Symbolic ;
>     long n_row, n_col, *Ap, *Ai, *Qinit, status ;
>     double Control [UMFPACK_CONTROL], Info [UMFPACK_INFO], *Ax, *Az ;
>     status = umfpack_zl_qsymbolic (n_row, n_col, Ap, Ai, Ax, Az, Qinit,
> 	&Symbolic, Control, Info) ;
> 
> Purpose:
> 
>     Given the nonzero pattern of a sparse matrix A in column-oriented form, and
>     a sparsity preserving column pre-ordering Qinit, umfpack_*_qsymbolic
>     performs the symbolic factorization of A*Qinit (or A (:,Qinit) in MATLAB
>     notation).  This is identical to umfpack_*_symbolic, except that neither
>     COLAMD nor AMD are called and the user input column order Qinit is used
>     instead.  Note that in general, the Qinit passed to umfpack_*_qsymbolic
>     can differ from the final Q found in umfpack_*_numeric.  The unsymmetric
>     strategy will perform a column etree postordering done in
>     umfpack_*_qsymbolic and sparsity-preserving modifications are made within
>     each frontal matrix during umfpack_*_numeric.  The symmetric and 2-by-2
>     strategies will preserve Qinit, unless the matrix is structurally singular.
> 
>     See umfpack_*_symbolic for more information.
> 
>     *** WARNING ***  A poor choice of Qinit can easily cause umfpack_*_numeric
>     to use a huge amount of memory and do a lot of work.  The "default" symbolic
>     analysis method is umfpack_*_symbolic, not this routine.  If you use this
>     routine, the performance of UMFPACK is your responsibility;  UMFPACK will
>     not try to second-guess a poor choice of Qinit.
> 
> Returns:
> 
>     The value of Info [UMFPACK_STATUS]; see umfpack_*_symbolic.
>     Also returns UMFPACK_ERROR_invalid_permuation if Qinit is not a valid
>     permutation vector.
> 
> Arguments:
> 
>     All arguments are the same as umfpack_*_symbolic, except for the following:
> 
>     Int Qinit [n_col] ;		Input argument, not modified.
> 
> 	The user's fill-reducing initial column pre-ordering.  This must be a
> 	permutation of 0..n_col-1.  If Qinit [k] = j, then column j is the kth
> 	column of the matrix A (:,Qinit) to be factorized.  If Qinit is an
> 	(Int *) NULL pointer, then COLAMD or AMD are called instead.
> 
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_report_control.h pysparse/pysparse/direct/umfpack/include/umfpack_report_control.h
0a1,77
> /* ========================================================================== */
> /* === umfpack_report_control =============================================== */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> void umfpack_di_report_control
> (
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> void umfpack_dl_report_control
> (
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> void umfpack_zi_report_control
> (
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> void umfpack_zl_report_control
> (
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> /*
> double int Syntax:
> 
>     #include "umfpack.h"
>     double Control [UMFPACK_CONTROL] ;
>     umfpack_di_report_control (Control) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     double Control [UMFPACK_CONTROL] ;
>     umfpack_dl_report_control (Control) ;
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     double Control [UMFPACK_CONTROL] ;
>     umfpack_zi_report_control (Control) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     double Control [UMFPACK_CONTROL] ;
>     umfpack_zl_report_control (Control) ;
> 
> Purpose:
> 
>     Prints the current control settings.  Note that with the default print
>     level, nothing is printed.  Does nothing if Control is (double *) NULL.
> 
> Arguments:
> 
>     double Control [UMFPACK_CONTROL] ;   Input argument, not modified.
> 
> 	If a (double *) NULL pointer is passed, then the default control
> 	settings are used.  Otherwise, the settings are determined from the
> 	Control array.  See umfpack_*_defaults on how to fill the Control
> 	array with the default settings.  If Control contains NaN's, the
> 	defaults are used.  The following Control parameters are used:
> 
> 	Control [UMFPACK_PRL]:  printing level.
> 
> 	    1 or less: no output
> 	    2 or more: print all of Control
> 	    Default: 1
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_report_info.h pysparse/pysparse/direct/umfpack/include/umfpack_report_info.h
0a1,87
> /* ========================================================================== */
> /* === umfpack_report_info ================================================== */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> void umfpack_di_report_info
> (
>     const double Control [UMFPACK_CONTROL],
>     const double Info [UMFPACK_INFO]
> ) ;
> 
> void umfpack_dl_report_info
> (
>     const double Control [UMFPACK_CONTROL],
>     const double Info [UMFPACK_INFO]
> ) ;
> 
> void umfpack_zi_report_info
> (
>     const double Control [UMFPACK_CONTROL],
>     const double Info [UMFPACK_INFO]
> ) ;
> 
> void umfpack_zl_report_info
> (
>     const double Control [UMFPACK_CONTROL],
>     const double Info [UMFPACK_INFO]
> ) ;
> 
> /*
> double int Syntax:
> 
>     #include "umfpack.h"
>     double Control [UMFPACK_CONTROL], Info [UMFPACK_INFO] ;
>     umfpack_di_report_info (Control, Info) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     double Control [UMFPACK_CONTROL], Info [UMFPACK_INFO] ;
>     umfpack_dl_report_info (Control, Info) ;
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     double Control [UMFPACK_CONTROL], Info [UMFPACK_INFO] ;
>     umfpack_zi_report_info (Control, Info) ;
> 
> complex long Syntax:
> 
>     #include "umfpack.h"
>     double Control [UMFPACK_CONTROL], Info [UMFPACK_INFO] ;
>     umfpack_zl_report_info (Control, Info) ;
> 
> Purpose:
> 
>     Reports statistics from the umfpack_*_*symbolic, umfpack_*_numeric, and
>     umfpack_*_*solve routines.
> 
> Arguments:
> 
>     double Control [UMFPACK_CONTROL] ;   Input argument, not modified.
> 
> 	If a (double *) NULL pointer is passed, then the default control
> 	settings are used.  Otherwise, the settings are determined from the
> 	Control array.  See umfpack_*_defaults on how to fill the Control
> 	array with the default settings.  If Control contains NaN's, the
> 	defaults are used.  The following Control parameters are used:
> 
> 	Control [UMFPACK_PRL]:  printing level.
> 
> 	    0 or less: no output, even when an error occurs
> 	    1: error messages only
> 	    2 or more: error messages, and print all of Info
> 	    Default: 1
> 
>     double Info [UMFPACK_INFO] ;		Input argument, not modified.
> 
> 	Info is an output argument of several UMFPACK routines.
> 	The contents of Info are printed on standard output.
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_report_matrix.h pysparse/pysparse/direct/umfpack/include/umfpack_report_matrix.h
0a1,198
> /* ========================================================================== */
> /* === umfpack_report_matrix ================================================ */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> int umfpack_di_report_matrix
> (
>     int n_row,
>     int n_col,
>     const int Ap [ ],
>     const int Ai [ ],
>     const double Ax [ ],
>     int col_form,
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> long umfpack_dl_report_matrix
> (
>     long n_row,
>     long n_col,
>     const long Ap [ ],
>     const long Ai [ ],
>     const double Ax [ ],
>     long col_form,
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> int umfpack_zi_report_matrix
> (
>     int n_row,
>     int n_col,
>     const int Ap [ ],
>     const int Ai [ ],
>     const double Ax [ ], const double Az [ ],
>     int col_form,
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> long umfpack_zl_report_matrix
> (
>     long n_row,
>     long n_col,
>     const long Ap [ ],
>     const long Ai [ ],
>     const double Ax [ ], const double Az [ ],
>     long col_form,
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> /*
> double int Syntax:
> 
>     #include "umfpack.h"
>     int n_row, n_col, *Ap, *Ai, status ;
>     double *Ax, Control [UMFPACK_CONTROL] ;
>     status = umfpack_di_report_matrix (n_row, n_col, Ap, Ai, Ax, 1, Control) ;
> or:
>     status = umfpack_di_report_matrix (n_row, n_col, Ap, Ai, Ax, 0, Control) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     long n_row, n_col, *Ap, *Ai, status ;
>     double *Ax, Control [UMFPACK_CONTROL] ;
>     status = umfpack_dl_report_matrix (n_row, n_col, Ap, Ai, Ax, 1, Control) ;
> or:
>     status = umfpack_dl_report_matrix (n_row, n_col, Ap, Ai, Ax, 0, Control) ;
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     int n_row, n_col, *Ap, *Ai, status ;
>     double *Ax, *Az, Control [UMFPACK_CONTROL] ;
>     status = umfpack_zi_report_matrix (n_row, n_col, Ap, Ai, Ax, Az, 1,
>         Control) ;
> or:
>     status = umfpack_zi_report_matrix (n_row, n_col, Ap, Ai, Ax, Az, 0,
>         Control) ;
> 
> complex long Syntax:
> 
>     #include "umfpack.h"
>     long n_row, n_col, *Ap, *Ai, status ;
>     double *Ax, Control [UMFPACK_CONTROL] ;
>     status = umfpack_zl_report_matrix (n_row, n_col, Ap, Ai, Ax, Az, 1,
> 	Control) ;
> or:
>     status = umfpack_zl_report_matrix (n_row, n_col, Ap, Ai, Ax, Az, 0,
> 	Control) ;
> 
> Purpose:
> 
>     Verifies and prints a row or column-oriented sparse matrix.
> 
> Returns:
> 
>     UMFPACK_OK if Control [UMFPACK_PRL] <= 2 (the input is not checked).
> 
>     Otherwise (where n is n_col for the column form and n_row for row
>     and let ni be n_row for the column form and n_col for row):
> 
>     UMFPACK_OK if the matrix is valid.
> 
>     UMFPACK_ERROR_n_nonpositive if n_row <= 0 or n_col <= 0.
>     UMFPACK_ERROR_argument_missing if Ap and/or Ai are missing.
>     UMFPACK_ERROR_invalid_matrix if Ap [n] < 0, if Ap [0] is not zero,
> 	if Ap [j+1] < Ap [j] for any j in the range 0 to n-1,
> 	if any row index in Ai is not in the range 0 to ni-1, or
> 	if the row indices in any column are not in
> 	ascending order, or contain duplicates.
>     UMFPACK_ERROR_out_of_memory if out of memory.
> 
> Arguments:
> 
>     Int n_row ;		Input argument, not modified.
>     Int n_col ;		Input argument, not modified.
> 
> 	A is an n_row-by-n_row matrix.  Restriction: n_row > 0 and n_col > 0.
> 
>     Int Ap [n+1] ;	Input argument, not modified.
> 
> 	n is n_row for a row-form matrix, and n_col for a column-form matrix.
> 
> 	Ap is an integer array of size n+1.  If col_form is true (nonzero),
> 	then on input, it holds the "pointers" for the column form of the
> 	sparse matrix A.  The row indices of column j of the matrix A are held
> 	in Ai [(Ap [j]) ... (Ap [j+1]-1)].  Otherwise, Ap holds the
> 	row pointers, and the column indices of row j of the matrix are held
> 	in Ai [(Ap [j]) ... (Ap [j+1]-1)].
> 
> 	The first entry, Ap [0], must be zero, and Ap [j] <= Ap [j+1] must hold
> 	for all j in the range 0 to n-1.  The value nz = Ap [n] is thus the
> 	total number of entries in the pattern of the matrix A.
> 
>     Int Ai [nz] ;	Input argument, not modified, of size nz = Ap [n].
> 
> 	If col_form is true (nonzero), then the nonzero pattern (row indices)
> 	for column j is stored in Ai [(Ap [j]) ... (Ap [j+1]-1)].  Row indices
> 	must be in the range 0 to n_row-1 (the matrix is 0-based).
> 
> 	Otherwise, the nonzero pattern (column indices) for row j is stored in
> 	Ai [(Ap [j]) ... (Ap [j+1]-1)]. Column indices must be in the range 0
> 	to n_col-1 (the matrix is 0-based).
> 
>     double Ax [nz] ;	Input argument, not modified, of size nz = Ap [n].
> 
> 	The numerical values of the sparse matrix A.
> 
> 	If col_form is true (nonzero), then the nonzero pattern (row indices)
> 	for column j is stored in Ai [(Ap [j]) ... (Ap [j+1]-1)], and the
> 	corresponding (real) numerical values are stored in
> 	Ax [(Ap [j]) ... (Ap [j+1]-1)].  The imaginary parts are stored in
> 	Az [(Ap [j]) ... (Ap [j+1]-1)], for the complex versions.
> 
> 	Otherwise, the nonzero pattern (column indices) for row j
> 	is stored in Ai [(Ap [j]) ... (Ap [j+1]-1)], and the corresponding
> 	(real) numerical values are stored in Ax [(Ap [j]) ... (Ap [j+1]-1)].
> 	The imaginary parts are stored in Az [(Ap [j]) ... (Ap [j+1]-1)],
> 	for the complex versions.
> 
> 	No numerical values are printed if Ax or Az are (double *) NULL.
> 
>     double Az [nz] ;	Input argument, not modified, for complex versions.
> 
> 	The imaginary values of the sparse matrix A.   See the description
> 	of Ax, above.  No numerical values are printed if Az is NULL. 
> 
> 	Future complex version:  if Ax is present and Az is NULL, then both real
> 	and imaginary parts will be contained in Ax[0..2*nz-1], with Ax[2*k]
> 	and Ax[2*k+1] being the real and imaginary part of the kth entry.
> 
>     Int col_form ;	Input argument, not modified.
> 
> 	The matrix is in row-oriented form if form is col_form is false (0).
> 	Otherwise, the matrix is in column-oriented form.
> 
>     double Control [UMFPACK_CONTROL] ;	Input argument, not modified.
> 
> 	If a (double *) NULL pointer is passed, then the default control
> 	settings are used.  Otherwise, the settings are determined from the
> 	Control array.  See umfpack_*_defaults on how to fill the Control
> 	array with the default settings.  If Control contains NaN's, the
> 	defaults are used.  The following Control parameters are used:
> 
> 	Control [UMFPACK_PRL]:  printing level.
> 
> 	    2 or less: no output.  returns silently without checking anything.
> 	    3: fully check input, and print a short summary of its status
> 	    4: as 3, but print first few entries of the input
> 	    5: as 3, but print all of the input
> 	    Default: 1
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_report_numeric.h pysparse/pysparse/direct/umfpack/include/umfpack_report_numeric.h
0a1,113
> /* ========================================================================== */
> /* === umfpack_report_numeric =============================================== */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> int umfpack_di_report_numeric
> (
>     void *Numeric,
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> long umfpack_dl_report_numeric
> (
>     void *Numeric,
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> int umfpack_zi_report_numeric
> (
>     void *Numeric,
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> long umfpack_zl_report_numeric
> (
>     void *Numeric,
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> /*
> double int Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     double Control [UMFPACK_CONTROL] ;
>     int status ;
>     status = umfpack_di_report_numeric (Numeric, Control) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     double Control [UMFPACK_CONTROL] ;
>     long status ;
>     status = umfpack_dl_report_numeric (Numeric, Control) ;
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     double Control [UMFPACK_CONTROL] ;
>     int status ;
>     status = umfpack_zi_report_numeric (Numeric, Control) ;
> 
> complex long Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     double Control [UMFPACK_CONTROL] ;
>     long status ;
>     status = umfpack_zl_report_numeric (Numeric, Control) ;
> 
> Purpose:
> 
>     Verifies and prints a Numeric object (the LU factorization, both its pattern
>     numerical values, and permutation vectors P and Q).  This routine checks the
>     object more carefully than the computational routines.  Normally, this check
>     is not required, since umfpack_*_numeric either returns (void *) NULL, or a
>     valid Numeric object.  However, if you suspect that your own code has
>     corrupted the Numeric object (by overruning memory bounds, for example),
>     then this routine might be able to detect a corrupted Numeric object.  Since
>     this is a complex object, not all such user-generated errors are guaranteed
>     to be caught by this routine.
> 
> Returns:
> 
>     UMFPACK_OK if Control [UMFPACK_PRL] <= 2 (the input is not checked).
> 
>     Otherwise:
> 
>     UMFPACK_OK if the Numeric object is valid.
>     UMFPACK_ERROR_invalid_Numeric_object if the Numeric object is invalid.
>     UMFPACK_ERROR_out_of_memory if out of memory.
> 
> Arguments:
> 
>     void *Numeric ;			Input argument, not modified.
> 
> 	The Numeric object, which holds the numeric factorization computed by
> 	umfpack_*_numeric.
> 
>     double Control [UMFPACK_CONTROL] ;	Input argument, not modified.
> 
> 	If a (double *) NULL pointer is passed, then the default control
> 	settings are used.  Otherwise, the settings are determined from the
> 	Control array.  See umfpack_*_defaults on how to fill the Control
> 	array with the default settings.  If Control contains NaN's, the
> 	defaults are used.  The following Control parameters are used:
> 
> 	Control [UMFPACK_PRL]:  printing level.
> 
> 	    2 or less: no output.  returns silently without checking anything.
> 	    3: fully check input, and print a short summary of its status
> 	    4: as 3, but print first few entries of the input
> 	    5: as 3, but print all of the input
> 	    Default: 1
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_report_perm.h pysparse/pysparse/direct/umfpack/include/umfpack_report_perm.h
0a1,113
> /* ========================================================================== */
> /* === umfpack_report_perm ================================================== */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> int umfpack_di_report_perm
> (
>     int np,
>     const int Perm [ ],
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> long umfpack_dl_report_perm
> (
>     long np,
>     const long Perm [ ],
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> int umfpack_zi_report_perm
> (
>     int np,
>     const int Perm [ ],
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> long umfpack_zl_report_perm
> (
>     long np,
>     const long Perm [ ],
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> /*
> double int Syntax:
> 
>     #include "umfpack.h"
>     int np, *Perm, status ;
>     double Control [UMFPACK_CONTROL] ;
>     status = umfpack_di_report_perm (np, Perm, Control) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     long np, *Perm, status ;
>     double Control [UMFPACK_CONTROL] ;
>     status = umfpack_dl_report_perm (np, Perm, Control) ;
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     int np, *Perm, status ;
>     double Control [UMFPACK_CONTROL] ;
>     status = umfpack_zi_report_perm (np, Perm, Control) ;
> 
> complex long Syntax:
> 
>     #include "umfpack.h"
>     long np, *Perm, status ;
>     double Control [UMFPACK_CONTROL] ;
>     status = umfpack_zl_report_perm (np, Perm, Control) ;
> 
> Purpose:
> 
>     Verifies and prints a permutation vector.
> 
> Returns:
> 
>     UMFPACK_OK if Control [UMFPACK_PRL] <= 2 (the input is not checked).
> 
>     Otherwise:
>     UMFPACK_OK if the permutation vector is valid (this includes that case
> 	when Perm is (Int *) NULL, which is not an error condition).
>     UMFPACK_ERROR_n_nonpositive if np <= 0.
>     UMFPACK_ERROR_out_of_memory if out of memory.
>     UMFPACK_ERROR_invalid_permutation if Perm is not a valid permutation vector.
> 
> Arguments:
> 
>     Int np ;		Input argument, not modified.
> 
> 	Perm is an integer vector of size np.  Restriction: np > 0.
> 
>     Int Perm [np] ;	Input argument, not modified.
> 
> 	A permutation vector of size np.  If Perm is not present (an (Int *)
> 	NULL pointer), then it is assumed to be the identity permutation.  This
> 	is consistent with its use as an input argument to umfpack_*_qsymbolic,
> 	and is not an error condition.  If Perm is present, the entries in Perm
> 	must range between 0 and np-1, and no duplicates may exist.
> 
>     double Control [UMFPACK_CONTROL] ;	Input argument, not modified.
> 
> 	If a (double *) NULL pointer is passed, then the default control
> 	settings are used.  Otherwise, the settings are determined from the
> 	Control array.  See umfpack_*_defaults on how to fill the Control
> 	array with the default settings.  If Control contains NaN's, the
> 	defaults are used.  The following Control parameters are used:
> 
> 	Control [UMFPACK_PRL]:  printing level.
> 
> 	    2 or less: no output.  returns silently without checking anything.
> 	    3: fully check input, and print a short summary of its status
> 	    4: as 3, but print first few entries of the input
> 	    5: as 3, but print all of the input
> 	    Default: 1
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_report_status.h pysparse/pysparse/direct/umfpack/include/umfpack_report_status.h
0a1,91
> /* ========================================================================== */
> /* === umfpack_report_status ================================================ */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> void umfpack_di_report_status
> (
>     const double Control [UMFPACK_CONTROL],
>     int status
> ) ;
> 
> void umfpack_dl_report_status
> (
>     const double Control [UMFPACK_CONTROL],
>     long status
> ) ;
> 
> void umfpack_zi_report_status
> (
>     const double Control [UMFPACK_CONTROL],
>     int status
> ) ;
> 
> void umfpack_zl_report_status
> (
>     const double Control [UMFPACK_CONTROL],
>     long status
> ) ;
> 
> /*
> double int Syntax:
> 
>     #include "umfpack.h"
>     double Control [UMFPACK_CONTROL] ;
>     int status ;
>     umfpack_di_report_status (Control, status) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     double Control [UMFPACK_CONTROL] ;
>     long status ;
>     umfpack_dl_report_status (Control, status) ;
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     double Control [UMFPACK_CONTROL] ;
>     int status ;
>     umfpack_zi_report_status (Control, status) ;
> 
> complex long Syntax:
> 
>     #include "umfpack.h"
>     double Control [UMFPACK_CONTROL] ;
>     long status ;
>     umfpack_zl_report_status (Control, status) ;
> 
> Purpose:
> 
>     Prints the status (return value) of other umfpack_* routines.
> 
> Arguments:
> 
>     double Control [UMFPACK_CONTROL] ;   Input argument, not modified.
> 
> 	If a (double *) NULL pointer is passed, then the default control
> 	settings are used.  Otherwise, the settings are determined from the
> 	Control array.  See umfpack_*_defaults on how to fill the Control
> 	array with the default settings.  If Control contains NaN's, the
> 	defaults are used.  The following Control parameters are used:
> 
> 	Control [UMFPACK_PRL]:  printing level.
> 
> 	    0 or less: no output, even when an error occurs
> 	    1: error messages only
> 	    2 or more: print status, whether or not an error occured
> 	    4 or more: also print the UMFPACK Copyright
> 	    6 or more: also print the UMFPACK License
> 	    Default: 1
> 
>     Int status ;			Input argument, not modified.
> 
> 	The return value from another umfpack_* routine.
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_report_symbolic.h pysparse/pysparse/direct/umfpack/include/umfpack_report_symbolic.h
0a1,112
> /* ========================================================================== */
> /* === umfpack_report_symbolic ============================================== */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> int umfpack_di_report_symbolic
> (
>     void *Symbolic,
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> long umfpack_dl_report_symbolic
> (
>     void *Symbolic,
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> int umfpack_zi_report_symbolic
> (
>     void *Symbolic,
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> long umfpack_zl_report_symbolic
> (
>     void *Symbolic,
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> /*
> double int Syntax:
> 
>     #include "umfpack.h"
>     void *Symbolic ;
>     double Control [UMFPACK_CONTROL] ;
>     int status ;
>     status = umfpack_di_report_symbolic (Symbolic, Control) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     void *Symbolic ;
>     double Control [UMFPACK_CONTROL] ;
>     long status ;
>     status = umfpack_dl_report_symbolic (Symbolic, Control) ;
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     void *Symbolic ;
>     double Control [UMFPACK_CONTROL] ;
>     int status ;
>     status = umfpack_zi_report_symbolic (Symbolic, Control) ;
> 
> complex long Syntax:
> 
>     #include "umfpack.h"
>     void *Symbolic ;
>     double Control [UMFPACK_CONTROL] ;
>     long status ;
>     status = umfpack_zl_report_symbolic (Symbolic, Control) ;
> 
> Purpose:
> 
>     Verifies and prints a Symbolic object.  This routine checks the object more
>     carefully than the computational routines.  Normally, this check is not
>     required, since umfpack_*_*symbolic either returns (void *) NULL, or a valid
>     Symbolic object.  However, if you suspect that your own code has corrupted
>     the Symbolic object (by overruning memory bounds, for example), then this
>     routine might be able to detect a corrupted Symbolic object.  Since this is
>     a complex object, not all such user-generated errors are guaranteed to be
>     caught by this routine.
> 
> Returns:
> 
>     UMFPACK_OK if Control [UMFPACK_PRL] is <= 2 (no inputs are checked).
> 
>     Otherwise:
> 
>     UMFPACK_OK if the Symbolic object is valid.
>     UMFPACK_ERROR_invalid_Symbolic_object if the Symbolic object is invalid.
>     UMFPACK_ERROR_out_of_memory if out of memory.
> 
> Arguments:
> 
>     void *Symbolic ;			Input argument, not modified.
> 
> 	The Symbolic object, which holds the symbolic factorization computed by
> 	umfpack_*_*symbolic.
> 
>     double Control [UMFPACK_CONTROL] ;	Input argument, not modified.
> 
> 	If a (double *) NULL pointer is passed, then the default control
> 	settings are used.  Otherwise, the settings are determined from the
> 	Control array.  See umfpack_*_defaults on how to fill the Control
> 	array with the default settings.  If Control contains NaN's, the
> 	defaults are used.  The following Control parameters are used:
> 
> 	Control [UMFPACK_PRL]:  printing level.
> 
> 	    2 or less: no output.  returns silently without checking anything.
> 	    3: fully check input, and print a short summary of its status
> 	    4: as 3, but print first few entries of the input
> 	    5: as 3, but print all of the input
> 	    Default: 1
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_report_triplet.h pysparse/pysparse/direct/umfpack/include/umfpack_report_triplet.h
0a1,149
> /* ========================================================================== */
> /* === umfpack_report_triplet =============================================== */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> int umfpack_di_report_triplet
> (
>     int n_row,
>     int n_col,
>     int nz,
>     const int Ti [ ],
>     const int Tj [ ],
>     const double Tx [ ],
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> long umfpack_dl_report_triplet
> (
>     long n_row,
>     long n_col,
>     long nz,
>     const long Ti [ ],
>     const long Tj [ ],
>     const double Tx [ ],
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> int umfpack_zi_report_triplet
> (
>     int n_row,
>     int n_col,
>     int nz,
>     const int Ti [ ],
>     const int Tj [ ],
>     const double Tx [ ], const double Tz [ ],
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> long umfpack_zl_report_triplet
> (
>     long n_row,
>     long n_col,
>     long nz,
>     const long Ti [ ],
>     const long Tj [ ],
>     const double Tx [ ], const double Tz [ ],
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> /*
> double int Syntax:
> 
>     #include "umfpack.h"
>     int n_row, n_col, nz, *Ti, *Tj, status ;
>     double *Tx, Control [UMFPACK_CONTROL] ;
>     status = umfpack_di_report_triplet (n_row, n_col, nz, Ti, Tj, Tx, Control) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     long n_row, n_col, nz, *Ti, *Tj, status ;
>     double *Tx, Control [UMFPACK_CONTROL] ;
>     status = umfpack_dl_report_triplet (n_row, n_col, nz, Ti, Tj, Tx, Control) ;
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     int n_row, n_col, nz, *Ti, *Tj, status ;
>     double *Tx, *Tz, Control [UMFPACK_CONTROL] ;
>     status = umfpack_zi_report_triplet (n_row, n_col, nz, Ti, Tj, Tx, Tz,
> 	Control) ;
> 
> complex long Syntax:
> 
>     #include "umfpack.h"
>     long n_row, n_col, nz, *Ti, *Tj, status ;
>     double *Tx, *Tz, Control [UMFPACK_CONTROL] ;
>     status = umfpack_zl_report_triplet (n_row, n_col, nz, Ti, Tj, Tx, Tz,
> 	Control) ;
> 
> Purpose:
> 
>     Verifies and prints a matrix in triplet form.
> 
> Returns:
> 
>     UMFPACK_OK if Control [UMFPACK_PRL] <= 2 (the input is not checked).
> 
>     Otherwise:
> 
>     UMFPACK_OK if the Triplet matrix is OK.
>     UMFPACK_ERROR_argument_missing if Ti and/or Tj are missing.
>     UMFPACK_ERROR_n_nonpositive if n_row <= 0 or n_col <= 0.
>     UMFPACK_ERROR_invalid_matrix if nz < 0, or
> 	if any row or column index in Ti and/or Tj
> 	is not in the range 0 to n_row-1 or 0 to n_col-1, respectively.
> 
> Arguments:
> 
>     Int n_row ;		Input argument, not modified.
>     Int n_col ;		Input argument, not modified.
> 
> 	A is an n_row-by-n_col matrix.
> 
>     Int nz ;		Input argument, not modified.
> 
> 	The number of entries in the triplet form of the matrix.
> 
>     Int Ti [nz] ;	Input argument, not modified.
>     Int Tj [nz] ;	Input argument, not modified.
>     double Tx [nz] ;	Input argument, not modified.
>     double Tz [nz] ;	Input argument, not modified, for complex versions.
> 
> 	Ti, Tj, Tx (and Tz for complex versions) hold the "triplet" form of a
> 	sparse matrix.  The kth nonzero entry is in row i = Ti [k], column
> 	j = Tj [k], the real numerical value of a_ij is Tx [k], and the
> 	imaginary part of a_ij is Tz [k] (for complex versions).  The row and
> 	column indices i and j must be in the range 0 to n_row-1 or 0 to
> 	n_col-1, respectively.  Duplicate entries may be present.  The
> 	"triplets" may be in any order.  Tx and Tz are optional; if Tx or Tz are
> 	not present ((double *) NULL pointers), then the numerical values are
> 	not printed.
> 
> 	Future complex version:  if Tx is present and Tz is NULL, then both real
> 	and imaginary parts will be contained in Tx[0..2*nz-1], with Tx[2*k]
> 	and Tx[2*k+1] being the real and imaginary part of the kth entry.
> 
>     double Control [UMFPACK_CONTROL] ;	Input argument, not modified.
> 
> 	If a (double *) NULL pointer is passed, then the default control
> 	settings are used.  Otherwise, the settings are determined from the
> 	Control array.  See umfpack_*_defaults on how to fill the Control
> 	array with the default settings.  If Control contains NaN's, the
> 	defaults are used.  The following Control parameters are used:
> 
> 	Control [UMFPACK_PRL]:  printing level.
> 
> 	    2 or less: no output.  returns silently without checking anything.
> 	    3: fully check input, and print a short summary of its status
> 	    4: as 3, but print first few entries of the input
> 	    5: as 3, but print all of the input
> 	    Default: 1
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_report_vector.h pysparse/pysparse/direct/umfpack/include/umfpack_report_vector.h
0a1,134
> /* ========================================================================== */
> /* === umfpack_report_vector ================================================ */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> int umfpack_di_report_vector
> (
>     int n,
>     const double X [ ],
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> long umfpack_dl_report_vector
> (
>     long n,
>     const double X [ ],
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> int umfpack_zi_report_vector
> (
>     int n,
>     const double Xx [ ], const double Xz [ ],
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> long umfpack_zl_report_vector
> (
>     long n,
>     const double Xx [ ], const double Xz [ ],
>     const double Control [UMFPACK_CONTROL]
> ) ;
> 
> /*
> double int Syntax:
> 
>     #include "umfpack.h"
>     int n, status ;
>     double *X, Control [UMFPACK_CONTROL] ;
>     status = umfpack_di_report_vector (n, X, Control) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     long n, status ;
>     double *X, Control [UMFPACK_CONTROL] ;
>     status = umfpack_dl_report_vector (n, X, Control) ;
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     int n, status ;
>     double *Xx, *Xz, Control [UMFPACK_CONTROL] ;
>     status = umfpack_zi_report_vector (n, Xx, Xz, Control) ;
> 
> complex long Syntax:
> 
>     #include "umfpack.h"
>     long n, status ;
>     double *Xx, *Xz, Control [UMFPACK_CONTROL] ;
>     status = umfpack_zl_report_vector (n, Xx, Xz, Control) ;
> 
> Purpose:
> 
>     Verifies and prints a dense vector.
> 
> Returns:
> 
>     UMFPACK_OK if Control [UMFPACK_PRL] <= 2 (the input is not checked).
> 
>     Otherwise:
>     
>     UMFPACK_OK if the vector is valid.
>     UMFPACK_ERROR_argument_missing if X or Xx is missing.
>     UMFPACK_ERROR_n_nonpositive if n <= 0.
> 
> Arguments:
> 
>     Int n ;		Input argument, not modified.
> 
> 	X is a real or complex vector of size n.  Restriction: n > 0.
> 
>     double X [n] ;	Input argument, not modified.  For real versions.
> 
> 	A real vector of size n.  X must not be (double *) NULL.
> 
>     double Xx [n or 2*n] ; Input argument, not modified.  For complex versions.
>     double Xz [n or 0] ;   Input argument, not modified.  For complex versions.
> 
> 	A complex vector of size n, in one of two storage formats.
> 	Xx must not be (double *) NULL.
> 
> 	If Xz is not (double *) NULL, then Xx [i] is the real part of X (i) and
> 	Xz [i] is the imaginary part of X (i).  Both vectors are of length n.
> 	This is the "split" form of the complex vector X.
> 
> 	If Xz is (double *) NULL, then Xx holds both real and imaginary parts,
> 	where Xx [2*i] is the real part of X (i) and Xx [2*i+1] is the imaginary
> 	part of X (i).  Xx is of length 2*n doubles.  If you have an ANSI C99
> 	compiler with the intrinsic double _Complex type, then Xx can be of
> 	type double _Complex in the calling routine and typecast to (double *)
> 	when passed to umfpack_*_report_vector (this is untested, however).
> 	This is the "merged" form of the complex vector X.
> 
> 	Future work:  all complex routines in UMFPACK could use this same
> 	strategy for their complex arguments.  The split format is useful for
> 	MATLAB, which holds its real and imaginary parts in seperate arrays.
> 	The merged format is compatible with the intrinsic double _Complex
> 	type in ANSI C99, and is also compatible with SuperLU's method of
> 	storing complex matrices.  In the current version, only 
> 	umfpack_*_report_vector supports both formats.
> 
>     double Control [UMFPACK_CONTROL] ;	Input argument, not modified.
> 
> 	If a (double *) NULL pointer is passed, then the default control
> 	settings are used.  Otherwise, the settings are determined from the
> 	Control array.  See umfpack_*_defaults on how to fill the Control
> 	array with the default settings.  If Control contains NaN's, the
> 	defaults are used.  The following Control parameters are used:
> 
> 	Control [UMFPACK_PRL]:  printing level.
> 
> 	    2 or less: no output.  returns silently without checking anything.
> 	    3: fully check input, and print a short summary of its status
> 	    4: as 3, but print first few entries of the input
> 	    5: as 3, but print all of the input
> 	    Default: 1
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_save_numeric.h pysparse/pysparse/direct/umfpack/include/umfpack_save_numeric.h
0a1,93
> /* ========================================================================== */
> /* === umfpack_save_numeric ================================================= */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> int umfpack_di_save_numeric
> (
>     void *Numeric,
>     char *filename
> ) ;
> 
> long umfpack_dl_save_numeric
> (
>     void *Numeric,
>     char *filename
> ) ;
> 
> int umfpack_zi_save_numeric
> (
>     void *Numeric,
>     char *filename
> ) ;
> 
> long umfpack_zl_save_numeric
> (
>     void *Numeric,
>     char *filename
> ) ;
> 
> /*
> double int Syntax:
> 
>     #include "umfpack.h"
>     int status ;
>     char *filename ;
>     void *Numeric ;
>     status = umfpack_di_save_numeric (Numeric, filename) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     long status ;
>     char *filename ;
>     void *Numeric ;
>     status = umfpack_dl_save_numeric (Numeric, filename) ;
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     int status ;
>     char *filename ;
>     void *Numeric ;
>     status = umfpack_zi_save_numeric (Numeric, filename) ;
> 
> complex long Syntax:
> 
>     #include "umfpack.h"
>     long status ;
>     char *filename ;
>     void *Numeric ;
>     status = umfpack_zl_save_numeric (Numeric, filename) ;
> 
> Purpose:
> 
>     Saves a Numeric object to a file, which can later be read by
>     umfpack_*_load_numeric.  The Numeric object is not modified.  You need
>     to call umfpack_*_free_numeric if you to delete the Numeric object after
>     saving it to a file.
> 
> Returns:
> 
>     UMFPACK_OK if successful.
>     UMFPACK_ERROR_invalid_Numeric_object if Numeric is not valid.
>     UMFPACK_ERROR_file_IO if an I/O error occurred.
> 
> Arguments:
> 
>     void *Numeric ;	    Input argument, not modified.
> 
> 	Numeric must point to a valid Numeric object, computed by
> 	umfpack_*_numeric or loaded by umfpack_*_load_numeric.
> 
>     char *filename ;	    Input argument, not modified.
> 
> 	A string that contains the filename to which the Numeric
> 	object is written.
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_save_symbolic.h pysparse/pysparse/direct/umfpack/include/umfpack_save_symbolic.h
0a1,93
> /* ========================================================================== */
> /* === umfpack_save_symbolic================================================= */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> int umfpack_di_save_symbolic
> (
>     void *Symbolic,
>     char *filename
> ) ;
> 
> long umfpack_dl_save_symbolic
> (
>     void *Symbolic,
>     char *filename
> ) ;
> 
> int umfpack_zi_save_symbolic
> (
>     void *Symbolic,
>     char *filename
> ) ;
> 
> long umfpack_zl_save_symbolic
> (
>     void *Symbolic,
>     char *filename
> ) ;
> 
> /*
> double int Syntax:
> 
>     #include "umfpack.h"
>     int status ;
>     char *filename ;
>     void *Symbolic ;
>     status = umfpack_di_save_symbolic (Symbolic, filename) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     long status ;
>     char *filename ;
>     void *Symbolic ;
>     status = umfpack_dl_save_symbolic (Symbolic, filename) ;
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     int status ;
>     char *filename ;
>     void *Symbolic ;
>     status = umfpack_zi_save_symbolic (Symbolic, filename) ;
> 
> complex long Syntax:
> 
>     #include "umfpack.h"
>     long status ;
>     char *filename ;
>     void *Symbolic ;
>     status = umfpack_zl_save_symbolic (Symbolic, filename) ;
> 
> Purpose:
> 
>     Saves a Symbolic object to a file, which can later be read by
>     umfpack_*_load_symbolic.  The Symbolic object is not modified.  You need
>     to call umfpack_*_free_symbolic if you to delete the Symbolic object after
>     saving it to a file.
> 
> Returns:
> 
>     UMFPACK_OK if successful.
>     UMFPACK_ERROR_invalid_Symbolic_object if Symbolic is not valid.
>     UMFPACK_ERROR_file_IO if an I/O error occurred.
> 
> Arguments:
> 
>     void *Symbolic ;	    Input argument, not modified.
> 
> 	Symbolic must point to a valid Symbolic object, computed by
> 	umfpack_*_symbolic or loaded by umfpack_*_load_symbolic.
> 
>     char *filename ;	    Input argument, not modified.
> 
> 	A string that contains the filename to which the Symbolic
> 	object is written.
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_scale.h pysparse/pysparse/direct/umfpack/include/umfpack_scale.h
0a1,105
> /* ========================================================================== */
> /* === umfpack_scale ======================================================== */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> int umfpack_di_scale
> (
>     double X [ ],
>     const double B [ ],
>     void *Numeric
> ) ;
> 
> long umfpack_dl_scale
> (
>     double X [ ],
>     const double B [ ],
>     void *Numeric
> ) ;
> 
> int umfpack_zi_scale
> (
>     double Xx [ ],	 double Xz [ ],
>     const double Bx [ ], const double Bz [ ],
>     void *Numeric
> ) ;
> 
> long umfpack_zl_scale
> (
>     double Xx [ ],	 double Xz [ ],
>     const double Bx [ ], const double Bz [ ],
>     void *Numeric
> ) ;
> 
> /*
> double int Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     double *B, *X ;
>     status = umfpack_di_scale (X, B, Numeric) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     double *B, *X ;
>     status = umfpack_dl_scale (X, B, Numeric) ;
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     double *Bx, *Bz, *Xx, *Xz ;
>     status = umfpack_zi_scale (Xx, Xz, Bx, Bz, Numeric) ;
> 
> complex long Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     double *Bx, *Bz, *Xx, *Xz ;
>     status = umfpack_zl_scale (Xx, Xz, Bx, Bz, Numeric) ;
> 
> Purpose:
> 
>     Given LU factors computed by umfpack_*_numeric (PAQ=LU, PRAQ=LU, or
>     P(R\A)Q=LU), and a vector B, this routine computes X = B, X = R*B, or
>     X = R\B, as appropriate.  X and B must be vectors equal in length to the
>     number of rows of A.
> 
> Returns:
> 
>     The status code is returned.  UMFPACK_OK is returned if successful.
>     UMFPACK_ERROR_invalid_Numeric_object is returned in the Numeric
>     object is invalid.  UMFPACK_ERROR_argument_missing is returned if
>     any of the input vectors are missing (X and B for the real version,
>     and Xx, Xz, Bx, and Bz for the complex version).
> 
> Arguments:
> 
>     double X [n_row] ;	Output argument.
>     or:
>     double Xx [n_row] ;	Output argument, real part.
>     double Xz [n_row] ;	Output argument, imaginary part.
> 
> 	The output vector X.
> 
>     double B [n_row] ;	Input argument, not modified.
>     or:
>     double Bx [n_row] ;	Input argument, not modified, real part.
>     double Bz [n_row] ;	Input argument, not modified, imaginary part.
> 
> 	The input vector B.
> 
>     void *Numeric ;		Input argument, not modified.
> 
> 	Numeric must point to a valid Numeric object, computed by
> 	umfpack_*_numeric.
> 
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_solve.h pysparse/pysparse/direct/umfpack/include/umfpack_solve.h
0a1,302
> /* ========================================================================== */
> /* === umfpack_solve ======================================================== */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> int umfpack_di_solve
> (
>     int sys,
>     const int Ap [ ],
>     const int Ai [ ],
>     const double Ax [ ],
>     double X [ ],
>     const double B [ ],
>     void *Numeric,
>     const double Control [UMFPACK_CONTROL],
>     double Info [UMFPACK_INFO]
> ) ;
> 
> long umfpack_dl_solve
> (
>     long sys,
>     const long Ap [ ],
>     const long Ai [ ],
>     const double Ax [ ],
>     double X [ ],
>     const double B [ ],
>     void *Numeric,
>     const double Control [UMFPACK_CONTROL],
>     double Info [UMFPACK_INFO]
> ) ;
> 
> int umfpack_zi_solve
> (
>     int sys,
>     const int Ap [ ],
>     const int Ai [ ],
>     const double Ax [ ], const double Az [ ],
>     double Xx [ ],	 double Xz [ ],
>     const double Bx [ ], const double Bz [ ],
>     void *Numeric,
>     const double Control [UMFPACK_CONTROL],
>     double Info [UMFPACK_INFO]
> ) ;
> 
> long umfpack_zl_solve
> (
>     long sys,
>     const long Ap [ ],
>     const long Ai [ ],
>     const double Ax [ ], const double Az [ ],
>     double Xx [ ],	 double Xz [ ],
>     const double Bx [ ], const double Bz [ ],
>     void *Numeric,
>     const double Control [UMFPACK_CONTROL],
>     double Info [UMFPACK_INFO]
> ) ;
> 
> /*
> double int Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     int status, *Ap, *Ai, sys ;
>     double *B, *X, *Ax, Info [UMFPACK_INFO], Control [UMFPACK_CONTROL] ;
>     status = umfpack_di_solve (sys, Ap, Ai, Ax, X, B, Numeric, Control, Info) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     long status, *Ap, *Ai, sys ;
>     double *B, *X, *Ax, Info [UMFPACK_INFO], Control [UMFPACK_CONTROL] ;
>     status = umfpack_dl_solve (sys, Ap, Ai, Ax, X, B, Numeric, Control, Info) ;
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     int status, *Ap, *Ai, sys ;
>     double *Bx, *Bz, *Xx, *Xz, *Ax, *Az, Info [UMFPACK_INFO],
> 	Control [UMFPACK_CONTROL] ;
>     status = umfpack_zi_solve (sys, Ap, Ai, Ax, Az, Xx, Xz, Bx, Bz, Numeric,
> 	Control, Info) ;
> 
> complex long Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     long status, *Ap, *Ai, sys ;
>     double *Bx, *Bz, *Xx, *Xz, *Ax, *Az, Info [UMFPACK_INFO],
> 	Control [UMFPACK_CONTROL] ;
>     status = umfpack_zl_solve (sys, Ap, Ai, Ax, Az, Xx, Xz, Bx, Bz, Numeric,
> 	Control, Info) ;
> 
> Purpose:
> 
>     Given LU factors computed by umfpack_*_numeric (PAQ=LU, PRAQ=LU, or
>     P(R\A)Q=LU) and the right-hand-side, B, solve a linear system for the
>     solution X.  Iterative refinement is optionally performed.  Only square
>     systems are handled.  Singular matrices result in a divide-by-zero for all
>     systems except those involving just the matrix L.  Iterative refinement is
>     not performed for singular matrices.  In the discussion below, n is equal
>     to n_row and n_col, because only square systems are handled.
> 
> Returns:
> 
>     The status code is returned.  See Info [UMFPACK_STATUS], below.
> 
> Arguments:
> 
>     Int sys ;		Input argument, not modified.
> 
> 	Defines which system to solve.  (') is the linear algebraic transpose
> 	(complex conjugate if A is complex), and (.') is the array transpose.
> 
> 	    sys value	    system solved
> 	    UMFPACK_A       Ax=b
> 	    UMFPACK_At      A'x=b
> 	    UMFPACK_Aat     A.'x=b
> 	    UMFPACK_Pt_L    P'Lx=b
> 	    UMFPACK_L       Lx=b
> 	    UMFPACK_Lt_P    L'Px=b
> 	    UMFPACK_Lat_P   L.'Px=b
> 	    UMFPACK_Lt      L'x=b
> 	    UMFPACK_U_Qt    UQ'x=b
> 	    UMFPACK_U       Ux=b
> 	    UMFPACK_Q_Ut    QU'x=b
> 	    UMFPACK_Q_Uat   QU.'x=b
> 	    UMFPACK_Ut      U'x=b
> 	    UMFPACK_Uat     U.'x=b
> 
> 	Iterative refinement can be optionally performed when sys is any of
> 	the following:
> 
> 	    UMFPACK_A       Ax=b
> 	    UMFPACK_At      A'x=b
> 	    UMFPACK_Aat     A.'x=b
> 
> 	For the other values of the sys argument, iterative refinement is not
> 	performed (Control [UMFPACK_IRSTEP], Ap, Ai, Ax, and Az are ignored).
> 
> 	Earlier versions used a string argument for sys.  It was changed to an
> 	integer to make it easier for a Fortran code to call UMFPACK.
> 
>     Int Ap [n+1] ;	Input argument, not modified.
>     Int Ai [nz] ;	Input argument, not modified.
>     double Ax [nz] ;	Input argument, not modified.
>     double Az [nz] ;	Input argument, not modified, for complex versions.
> 
> 	If iterative refinement is requested (Control [UMFPACK_IRSTEP] >= 1,
> 	Ax=b, A'x=b, or A.'x=b is being solved, and A is nonsingular), then
> 	these arrays must be identical to the same ones passed to
> 	umfpack_*_numeric.  The umfpack_*_solve routine does not check the
> 	contents of these arguments, so the results are undefined if Ap, Ai, Ax,
> 	and/or Az are modified between the calls the umfpack_*_numeric and
> 	umfpack_*_solve.  These three arrays do not need to be present (NULL
> 	pointers can be passed) if Control [UMFPACK_IRSTEP] is zero, or if a
> 	system other than Ax=b, A'x=b, or A.'x=b is being solved, or if A is
> 	singular, since in each of these cases A is not accessed.
> 
> 	Future complex version:  if Ax is present and Az is NULL, then both real
> 	and imaginary parts will be contained in Ax[0..2*nz-1], with Ax[2*k]
> 	and Ax[2*k+1] being the real and imaginary part of the kth entry.
> 
>     double X [n] ;	Output argument.
>     or:
>     double Xx [n] ;	Output argument, real part.
>     double Xz [n] ;	Output argument, imaginary part.
> 
> 	The solution to the linear system, where n = n_row = n_col is the
> 	dimension of the matrices A, L, and U.
> 
> 	Future complex version:  if Xx is present and Xz is NULL, then both real
> 	and imaginary parts will be returned in Xx[0..2*n-1], with Xx[2*k] and
> 	Xx[2*k+1] being the real and imaginary part of the kth entry.
> 
>     double B [n] ;	Input argument, not modified.
>     or:
>     double Bx [n] ;	Input argument, not modified, real part.
>     double Bz [n] ;	Input argument, not modified, imaginary part.
> 
> 	The right-hand side vector, b, stored as a conventional array of size n
> 	(or two arrays of size n for complex versions).  This routine does not
> 	solve for multiple right-hand-sides, nor does it allow b to be stored in
> 	a sparse-column form.
> 
> 	Future complex version:  if Bx is present and Bz is NULL, then both real
> 	and imaginary parts will be contained in Bx[0..2*n-1], with Bx[2*k]
> 	and Bx[2*k+1] being the real and imaginary part of the kth entry.
> 
>     void *Numeric ;		Input argument, not modified.
> 
> 	Numeric must point to a valid Numeric object, computed by
> 	umfpack_*_numeric.
> 
>     double Control [UMFPACK_CONTROL] ;	Input argument, not modified.
> 
> 	If a (double *) NULL pointer is passed, then the default control
> 	settings are used.  Otherwise, the settings are determined from the
> 	Control array.  See umfpack_*_defaults on how to fill the Control
> 	array with the default settings.  If Control contains NaN's, the
> 	defaults are used.  The following Control parameters are used:
> 
> 	Control [UMFPACK_IRSTEP]:  The maximum number of iterative refinement
> 	    steps to attempt.  A value less than zero is treated as zero.  If
> 	    less than 1, or if Ax=b, A'x=b, or A.'x=b is not being solved, or
> 	    if A is singular, then the Ap, Ai, Ax, and Az arguments are not
> 	    accessed.  Default: 2.
> 
>     double Info [UMFPACK_INFO] ;	Output argument.
> 
> 	Contains statistics about the solution factorization.  If a
> 	(double *) NULL pointer is passed, then no statistics are returned in
> 	Info (this is not an error condition).  The following statistics are
> 	computed in umfpack_*_solve:
> 
> 	Info [UMFPACK_STATUS]: status code.  This is also the return value,
> 	    whether or not Info is present.
> 
> 	    UMFPACK_OK
> 
> 		The linear system was successfully solved.
> 
> 	    UMFPACK_WARNING_singular_matrix
> 
> 		A divide-by-zero occured.  Your solution will contain Inf's
> 		and/or NaN's.  Some parts of the solution may be valid.  For
> 		example, solving Ax=b with
> 
> 		A = [2 0]  b = [ 1 ]  returns x = [ 0.5 ]
> 		    [0 0]      [ 0 ]              [ Inf ]
> 
> 	    UMFPACK_ERROR_out_of_memory
> 
> 		Insufficient memory to solve the linear system.
> 
> 	    UMFPACK_ERROR_argument_missing
> 
> 		One or more required arguments are missing.  The B, X, (or
> 		Bx, Bz, Xx and Xz for the complex versions) arguments
> 		are always required.  Info and Control are not required.  Ap,
> 		Ai, Ax (and Az for complex versions) are required if Ax=b,
> 		A'x=b, A.'x=b is to be solved, the (default) iterative
> 		refinement is requested, and the matrix A is nonsingular.
> 
> 	    UMFPACK_ERROR_invalid_system
> 
> 		The sys argument is not valid, or the matrix A is not square.
> 
> 	    UMFPACK_ERROR_invalid_Numeric_object
> 
> 		The Numeric object is not valid.
> 
> 	Info [UMFPACK_NROW], Info [UMFPACK_NCOL]:
> 		The dimensions of the matrix A (L is n_row-by-n_inner and
> 		U is n_inner-by-n_col, with n_inner = min(n_row,n_col)).
> 
> 	Info [UMFPACK_NZ]:  the number of entries in the input matrix, Ap [n],
> 	    if iterative refinement is requested (Ax=b, A'x=b, or A.'x=b is
> 	    being solved, Control [UMFPACK_IRSTEP] >= 1, and A is nonsingular).
> 
> 	Info [UMFPACK_IR_TAKEN]:  The number of iterative refinement steps
> 	    effectively taken.  The number of steps attempted may be one more
> 	    than this; the refinement algorithm backtracks if the last
> 	    refinement step worsens the solution.
> 
> 	Info [UMFPACK_IR_ATTEMPTED]:   The number of iterative refinement steps
> 	    attempted.  The number of times a linear system was solved is one
> 	    more than this (once for the initial Ax=b, and once for each Ay=r
> 	    solved for each iterative refinement step attempted).
> 
> 	Info [UMFPACK_OMEGA1]:  sparse backward error estimate, omega1, if
> 	    iterative refinement was performed, or -1 if iterative refinement
> 	    not performed.
> 
> 	Info [UMFPACK_OMEGA2]:  sparse backward error estimate, omega2, if
> 	    iterative refinement was performed, or -1 if iterative refinement
> 	    not performed.
> 
> 	Info [UMFPACK_SOLVE_FLOPS]:  the number of floating point operations
> 	    performed to solve the linear system.  This includes the work
> 	    taken for all iterative refinement steps, including the backtrack
> 	    (if any).
> 
> 	Info [UMFPACK_SOLVE_TIME]:  The time taken, in seconds.
> 
> 	------------------------------------------------------------------------
> 	The following statistic was added to Version 4.1:
> 	------------------------------------------------------------------------
> 
>         Info [UMFPACK_SOLVE_WALLTIME]:  The wallclock time taken, in seconds.
> 
> 	Only the above listed Info [...] entries are accessed.  The remaining
> 	entries of Info are not accessed or modified by umfpack_*_solve.
> 	Future versions might modify different parts of Info.
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_symbolic.h pysparse/pysparse/direct/umfpack/include/umfpack_symbolic.h
0a1,542
> /* ========================================================================== */
> /* === umfpack_symbolic ===================================================== */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> int umfpack_di_symbolic
> (
>     int n_row,
>     int n_col,
>     const int Ap [ ],
>     const int Ai [ ],
>     const double Ax [ ],
>     void **Symbolic,
>     const double Control [UMFPACK_CONTROL],
>     double Info [UMFPACK_INFO]
> ) ;
> 
> long umfpack_dl_symbolic
> (
>     long n_row,
>     long n_col,
>     const long Ap [ ],
>     const long Ai [ ],
>     const double Ax [ ],
>     void **Symbolic,
>     const double Control [UMFPACK_CONTROL],
>     double Info [UMFPACK_INFO]
> ) ;
> 
> int umfpack_zi_symbolic
> (
>     int n_row,
>     int n_col,
>     const int Ap [ ],
>     const int Ai [ ],
>     const double Ax [ ], const double Az [ ],
>     void **Symbolic,
>     const double Control [UMFPACK_CONTROL],
>     double Info [UMFPACK_INFO]
> ) ;
> 
> long umfpack_zl_symbolic
> (
>     long n_row,
>     long n_col,
>     const long Ap [ ],
>     const long Ai [ ],
>     const double Ax [ ], const double Az [ ],
>     void **Symbolic,
>     const double Control [UMFPACK_CONTROL],
>     double Info [UMFPACK_INFO]
> ) ;
> 
> /*
> double int Syntax:
> 
>     #include "umfpack.h"
>     void *Symbolic ;
>     int n_row, n_col, *Ap, *Ai, status ;
>     double Control [UMFPACK_CONTROL], Info [UMFPACK_INFO], *Ax ;
>     status = umfpack_di_symbolic (n_row, n_col, Ap, Ai, Ax,
> 	&Symbolic, Control, Info) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     void *Symbolic ;
>     long n_row, n_col, *Ap, *Ai, status ;
>     double Control [UMFPACK_CONTROL], Info [UMFPACK_INFO], *Ax ;
>     status = umfpack_dl_symbolic (n_row, n_col, Ap, Ai, Ax,
> 	&Symbolic, Control, Info) ;
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     void *Symbolic ;
>     int n_row, n_col, *Ap, *Ai, status ;
>     double Control [UMFPACK_CONTROL], Info [UMFPACK_INFO], *Ax, *Az ;
>     status = umfpack_zi_symbolic (n_row, n_col, Ap, Ai, Ax, Az,
> 	&Symbolic, Control, Info) ;
> 
> complex long Syntax:
> 
>     #include "umfpack.h"
>     void *Symbolic ;
>     long n_row, n_col, *Ap, *Ai, status ;
>     double Control [UMFPACK_CONTROL], Info [UMFPACK_INFO], *Ax, *Az ;
>     status = umfpack_zl_symbolic (n_row, n_col, Ap, Ai, Ax, Az,
> 	&Symbolic, Control, Info) ;
> 
> Purpose:
> 
>     Given nonzero pattern of a sparse matrix A in column-oriented form,
>     umfpack_*_symbolic performs a column pre-ordering to reduce fill-in
>     (using COLAMD or AMD) and a symbolic factorization.  This is required
>     before the matrix can be numerically factorized with umfpack_*_numeric.
>     If you wish to bypass the COLAMD or AMD pre-ordering and provide your own
>     ordering, use umfpack_*_qsymbolic instead.
> 
>     Since umfpack_*_symbolic and umfpack_*_qsymbolic are very similar, options
>     for both routines are discussed below.
> 
>     For the following discussion, let S be the submatrix of A obtained after
>     eliminating all pivots of zero Markowitz cost.  S has dimension
>     (n_row-n1-nempty_row) -by- (n_col-n1-nempty_col), where
>     n1 = Info [UMFPACK_COL_SINGLETONS] + Info [UMFPACK_ROW_SINGLETONS],
>     nempty_row = Info [UMFPACK_NEMPTY_ROW] and
>     nempty_col = Info [UMFPACK_NEMPTY_COL].
> 
> Returns:
> 
>     The status code is returned.  See Info [UMFPACK_STATUS], below.
> 
> Arguments:
> 
>     Int n_row ;		Input argument, not modified.
>     Int n_col ;		Input argument, not modified.
> 
> 	A is an n_row-by-n_col matrix.  Restriction: n_row > 0 and n_col > 0.
> 
>     Int Ap [n_col+1] ;	Input argument, not modified.
> 
> 	Ap is an integer array of size n_col+1.  On input, it holds the
> 	"pointers" for the column form of the sparse matrix A.  Column j of
> 	the matrix A is held in Ai [(Ap [j]) ... (Ap [j+1]-1)].  The first
> 	entry, Ap [0], must be zero, and Ap [j] <= Ap [j+1] must hold for all
> 	j in the range 0 to n_col-1.  The value nz = Ap [n_col] is thus the
> 	total number of entries in the pattern of the matrix A.  nz must be
> 	greater than or equal to zero.
> 
>     Int Ai [nz] ;	Input argument, not modified, of size nz = Ap [n_col].
> 
> 	The nonzero pattern (row indices) for column j is stored in
> 	Ai [(Ap [j]) ... (Ap [j+1]-1)].  The row indices in a given column j
> 	must be in ascending order, and no duplicate row indices may be present.
> 	Row indices must be in the range 0 to n_row-1 (the matrix is 0-based).
> 	See umfpack_*_triplet_to_col for how to sort the columns of a matrix
> 	and sum up the duplicate entries.  See umfpack_*_report_matrix for how
> 	to print the matrix A.
> 
>     double Ax [nz] ;	Optional input argument, not modified.
> 
> 	The numerical values of the sparse matrix A.  The nonzero pattern (row
> 	indices) for column j is stored in Ai [(Ap [j]) ... (Ap [j+1]-1)], and
> 	the corresponding numerical values are stored in
> 	Ax [(Ap [j]) ... (Ap [j+1]-1)].  Used only by the 2-by-2 strategy to
> 	determine whether entries are "large" or "small".  You do not have to
> 	pass the same numerical values to umfpack_*_numeric.  If Ax is not
> 	present (a (double *) NULL pointer), then any entry in A is assumed to
> 	be "large".
> 
>     double Az [nz] ;	Optional input argument, not modified, for complex
> 			versions.
> 
> 	For the complex versions, this holds the imaginary part of A.  The
> 	imaginary part of column j is held in Az [(Ap [j]) ... (Ap [j+1]-1)].
> 
> 	Future complex version:  if Ax is present and Az is NULL, then both real
> 	and imaginary parts will be contained in Ax[0..2*nz-1], with Ax[2*k]
> 	and Ax[2*k+1] being the real and imaginary part of the kth entry.
> 
> 	Used by the 2-by-2 strategy only.  See the description of Ax, above.
> 
>     void **Symbolic ;	Output argument.
> 
> 	**Symbolic is the address of a (void *) pointer variable in the user's
> 	calling routine (see Syntax, above).  On input, the contents of this
> 	variable are not defined.  On output, this variable holds a (void *)
> 	pointer to the Symbolic object (if successful), or (void *) NULL if
> 	a failure occurred.
> 
>     double Control [UMFPACK_CONTROL] ;	Input argument, not modified.
> 
> 	If a (double *) NULL pointer is passed, then the default control
> 	settings are used (the defaults are suitable for all matrices,
> 	ranging from those with highly unsymmetric nonzero pattern, to
> 	symmetric matrices).  Otherwise, the settings are determined from the
> 	Control array.  See umfpack_*_defaults on how to fill the Control
> 	array with the default settings.  If Control contains NaN's, the
> 	defaults are used.  The following Control parameters are used:
> 
> 	Control [UMFPACK_STRATEGY]:  This is the most important control
> 	    parameter.  It determines what kind of ordering and pivoting
> 	    strategy that UMFPACK should use.  It is new to Version 4.1
> 	    There are 4 options:
> 
> 	    UMFPACK_STRATEGY_AUTO:  This is the default.  The input matrix is
> 		analyzed to determine how symmetric the nonzero pattern is, and
> 		how many entries there are on the diagonal.  It then selects one
> 		of the following strategies.  Refer to the User Guide for a
> 		description of how the strategy is automatically selected.
> 
> 	    UMFPACK_STRATEGY_UNSYMMETRIC:  Use the unsymmetric strategy.  COLAMD
> 		is used to order the columns of A, followed by a postorder of
> 		the column elimination tree.  No attempt is made to perform
> 		diagonal pivoting.  The column ordering is refined during
> 		factorization.  This strategy was the only one provided with
> 		UMFPACK V4.0.
> 
> 		In the numerical factorization, the
> 		Control [UMFPACK_SYM_PIVOT_TOLERANCE] parameter is ignored.  A
> 		pivot is selected if its magnitude is >=
> 		Control [UMFPACK_PIVOT_TOLERANCE] (default 0.1) times the
> 		largest entry in its column.
> 
> 	    UMFPACK_STRATEGY_SYMMETRIC:  Use the symmetric strategy (new to
> 		Version 4.1).  In this method, the approximate minimum degree
> 		ordering (AMD) is applied to A+A', followed by a postorder of
> 		the elimination tree of A+A'.  UMFPACK attempts to perform
> 		diagonal pivoting during numerical factorization.  No refinement
> 		of the column pre-ordering is performed during factorization.
> 
> 		In the numerical factorization, a nonzero entry on the diagonal
> 		is selected as the pivot if its magnitude is >= Control
> 		[UMFPACK_SYM_PIVOT_TOLERANCE] (default 0.001) times the largest
> 		entry in its column.  If this is not acceptable, then an
> 		off-diagonal pivot is selected with magnitude >= Control
> 		[UMFPACK_PIVOT_TOLERANCE] (default 0.1) times the largest entry
> 		in its column.
> 
> 	    UMFPACK_STRATEGY_2BY2:  a row permutation P2 is found that places
> 		large entries on the diagonal.  The matrix P2*A is then
> 		factorized using the symmetric strategy, described above.
> 		Refer to the User Guide for more information.
> 
> 	Control [UMFPACK_DENSE_COL]:
> 	    If COLAMD is used, columns with more than
> 	    max (16, Control [UMFPACK_DENSE_COL] * 16 * sqrt (n_row)) entries
> 	    are placed placed last in the column pre-ordering.  Default: 0.2.
> 
> 	Control [UMFPACK_DENSE_ROW]:
> 	    Rows with more than max (16, Control [UMFPACK_DENSE_ROW] * 16 *
> 	    sqrt (n_col)) entries are treated differently in the COLAMD
> 	    pre-ordering, and in the internal data structures during the
> 	    subsequent numeric factorization.  Default: 0.2.
> 
> 	Control [UMFPACK_AMD_DENSE]:  rows/columns in A+A' with more than
> 	    max (16, Control [UMFPACK_AMD_DENSE] * sqrt (n)) entries
> 	    (where n = n_row = n_col) are ignored in the AMD pre-ordering.
> 	    Default: 10.
> 
> 	Control [UMFPACK_BLOCK_SIZE]:  the block size to use for Level-3 BLAS
> 	    in the subsequent numerical factorization (umfpack_*_numeric).
> 	    A value less than 1 is treated as 1.  Default: 32.  Modifying this
> 	    parameter affects when updates are applied to the working frontal
> 	    matrix, and can indirectly affect fill-in and operation count.
> 	    As long as the block size is large enough (8 or so), this parameter
> 	    has a modest effect on performance. 
> 
> 	Control [UMFPACK_2BY2_TOLERANCE]:  a diagonal entry S (k,k) is
> 	    considered "small" if it is < tol * max (abs (S (:,k))), where S a
> 	    submatrix of the scaled input matrix, with pivots of zero Markowitz
> 	    cost removed.
> 
> 	Control [UMFPACK_SCALE]:  This parameter is new to V4.1.  See
> 	    umfpack_numeric.h for a description.  Only affects the 2-by-2
> 	    strategy.  Default: UMFPACK_SCALE_SUM.
> 
> 	Control [UMFPACK_FIXQ]:  If > 0, then the pre-ordering Q is not modified
> 	    during numeric factorization.  If < 0, then Q may be modified.  If
> 	    zero, then this is controlled automatically (the unsymmetric
> 	    strategy modifies Q, the others do not).  Default: 0.
> 
> 	Control [UMFPACK_AGGRESSIVE]:  If nonzero, aggressive absorption is used
> 	    in COLAMD and AMD.  Default: 1.
> 
>     double Info [UMFPACK_INFO] ;	Output argument, not defined on input.
> 
> 	Contains statistics about the symbolic analysis.  If a (double *) NULL
> 	pointer is passed, then no statistics are returned in Info (this is not
> 	an error condition).  The entire Info array is cleared (all entries set
> 	to -1) and then the following statistics are computed:
> 
> 	Info [UMFPACK_STATUS]: status code.  This is also the return value,
> 	    whether or not Info is present.
> 
> 	    UMFPACK_OK
> 
> 		Each column of the input matrix contained row indices
> 		in increasing order, with no duplicates.  Only in this case
> 		does umfpack_*_symbolic compute a valid symbolic factorization.
> 		For the other cases below, no Symbolic object is created
> 		(*Symbolic is (void *) NULL).
> 
> 	    UMFPACK_ERROR_n_nonpositive
> 
> 		n is less than or equal to zero.
> 
> 	    UMFPACK_ERROR_invalid_matrix
> 
> 		Number of entries in the matrix is negative, Ap [0] is nonzero,
> 		a column has a negative number of entries, a row index is out of
> 		bounds, or the columns of input matrix were jumbled (unsorted
> 		columns or duplicate entries).
> 
> 	    UMFPACK_ERROR_out_of_memory
> 
> 		Insufficient memory to perform the symbolic analysis.  If the
> 		analysis requires more than 2GB of memory and you are using
> 		the 32-bit ("int") version of UMFPACK, then you are guaranteed
> 		to run out of memory.  Try using the 64-bit version of UMFPACK.
> 
> 	    UMFPACK_ERROR_argument_missing
> 
> 		One or more required arguments is missing.
> 
> 	    UMFPACK_ERROR_internal_error
> 
> 		Something very serious went wrong.  This is a bug.
> 		Please contact the author (davis@cise.ufl.edu).
> 
> 	    Note that the UMFPACK_ERROR_problem_too_large error code is no
> 	    longer returned (it was in Version 4.0).
> 
> 	Info [UMFPACK_NROW]:  the value of the input argument n_row.
> 
> 	Info [UMFPACK_NCOL]:  the value of the input argument n_col.
> 
> 	Info [UMFPACK_NZ]:  the number of entries in the input matrix
> 	    (Ap [n_col]).
> 
> 	Info [UMFPACK_SIZE_OF_UNIT]:  the number of bytes in a Unit,
> 	    for memory usage statistics below.
> 
> 	Info [UMFPACK_SIZE_OF_INT]:  the number of bytes in an int.
> 
> 	Info [UMFPACK_SIZE_OF_LONG]:  the number of bytes in a long.
> 
> 	Info [UMFPACK_SIZE_OF_POINTER]:  the number of bytes in a void *
> 	    pointer.
> 
> 	Info [UMFPACK_SIZE_OF_ENTRY]:  the number of bytes in a numerical entry.
> 
> 	Info [UMFPACK_NDENSE_ROW]:  number of "dense" rows in A.  These rows are
> 	    ignored when the column pre-ordering is computed in COLAMD.  They
> 	    are also treated differently during numeric factorization.  If > 0,
> 	    then the matrix had to be re-analyzed by UMF_analyze, which does
> 	    not ignore these rows.
> 
> 	Info [UMFPACK_NEMPTY_ROW]:  number of "empty" rows in A, as determined
> 	    These are rows that either have no entries, or whose entries are
> 	    all in pivot columns of zero-Markowitz-cost pivots.
> 
> 	Info [UMFPACK_NDENSE_COL]:  number of "dense" columns in A.  COLAMD
> 	    orders these columns are ordered last in the factorization, but
> 	    before "empty" columns.
> 
> 	Info [UMFPACK_NEMPTY_COL]:  number of "empty" columns in A.  These are
> 	    columns that either have no entries, or whose entries are all in
> 	    pivot rows of zero-Markowitz-cost pivots.  These columns are
> 	    ordered last in the factorization, to the right of "dense" columns.
> 
> 	Info [UMFPACK_SYMBOLIC_DEFRAG]:  number of garbage collections
> 	    performed during ordering and symbolic pre-analysis.
> 
> 	Info [UMFPACK_SYMBOLIC_PEAK_MEMORY]:  the amount of memory (in Units)
> 	    required for umfpack_*_symbolic to complete.  This count includes
> 	    the size of the Symbolic object itself, which is also reported in
> 	    Info [UMFPACK_SYMBOLIC_SIZE].
> 
> 	Info [UMFPACK_SYMBOLIC_SIZE]: the final size of the Symbolic object (in
> 	    Units).  This is fairly small, roughly 2*n to 13*n integers,
> 	    depending on the matrix.
> 
> 	Info [UMFPACK_VARIABLE_INIT_ESTIMATE]: the Numeric object contains two
> 	    parts.  The first is fixed in size (O (n_row+n_col)).  The
> 	    second part holds the sparse LU factors and the contribution blocks
> 	    from factorized frontal matrices.  This part changes in size during
> 	    factorization.  Info [UMFPACK_VARIABLE_INIT_ESTIMATE] is the exact
> 	    size (in Units) required for this second variable-sized part in
> 	    order for the numerical factorization to start.
> 
> 	Info [UMFPACK_VARIABLE_PEAK_ESTIMATE]: the estimated peak size (in
> 	    Units) of the variable-sized part of the Numeric object.  This is
> 	    usually an upper bound, but that is not guaranteed. 
> 
> 	Info [UMFPACK_VARIABLE_FINAL_ESTIMATE]: the estimated final size (in
> 	    Units) of the variable-sized part of the Numeric object.  This is
> 	    usually an upper bound, but that is not guaranteed.  It holds just
> 	    the sparse LU factors.
> 
> 	Info [UMFPACK_NUMERIC_SIZE_ESTIMATE]:  an estimate of the final size (in
> 	    Units) of the entire Numeric object (both fixed-size and variable-
> 	    sized parts), which holds the LU factorization (including the L, U,
> 	    P and Q matrices).
> 
> 	Info [UMFPACK_PEAK_MEMORY_ESTIMATE]:  an estimate of the total amount of
> 	    memory (in Units) required by umfpack_*_symbolic and
> 	    umfpack_*_numeric to perform both the symbolic and numeric
> 	    factorization.  This is the larger of the amount of memory needed
> 	    in umfpack_*_numeric itself, and the amount of memory needed in
> 	    umfpack_*_symbolic (Info [UMFPACK_SYMBOLIC_PEAK_MEMORY]).  The
> 	    count includes the size of both the Symbolic and Numeric objects
> 	    themselves.  It can be a very loose upper bound, particularly when
> 	    the symmetric or 2-by-2 strategies are used.
> 
> 	Info [UMFPACK_FLOPS_ESTIMATE]:  an estimate of the total floating-point
> 	    operations required to factorize the matrix.  This is a "true"
> 	    theoretical estimate of the number of flops that would be performed
> 	    by a flop-parsimonious sparse LU algorithm.  It assumes that no
> 	    extra flops are performed except for what is strictly required to
> 	    compute the LU factorization.  It ignores, for example, the flops
>             performed by umfpack_di_numeric to add contribution blocks of
> 	    frontal matrices together.  If L and U are the upper bound on the
> 	    pattern of the factors, then this flop count estimate can be
> 	    represented in MATLAB (for real matrices, not complex) as:
> 
> 		Lnz = full (sum (spones (L))) - 1 ;	% nz in each col of L
> 		Unz = full (sum (spones (U')))' - 1 ;	% nz in each row of U
> 		flops = 2*Lnz*Unz + sum (Lnz) ;
> 
> 	    The actual "true flop" count found by umfpack_*_numeric will be
> 	    less than this estimate.
> 
> 	    For the real version, only (+ - * /) are counted.  For the complex
> 	    version, the following counts are used:
> 
> 		operation	flops
> 	    	c = 1/b		6
> 		c = a*b		6
> 		c -= a*b	8
> 
> 	Info [UMFPACK_LNZ_ESTIMATE]:  an estimate of the number of nonzeros in
> 	    L, including the diagonal.  Since L is unit-diagonal, the diagonal
> 	    of L is not stored.  This estimate is a strict upper bound on the
> 	    actual nonzeros in L to be computed by umfpack_*_numeric.
> 
> 	Info [UMFPACK_UNZ_ESTIMATE]:  an estimate of the number of nonzeros in
> 	    U, including the diagonal.  This estimate is a strict upper bound on
> 	    the actual nonzeros in U to be computed by umfpack_*_numeric.
> 
> 	Info [UMFPACK_MAX_FRONT_SIZE_ESTIMATE]: estimate of the size of the
> 	    largest frontal matrix (# of entries), for arbitrary partial
> 	    pivoting during numerical factorization.
> 
> 	Info [UMFPACK_SYMBOLIC_TIME]:  The CPU time taken, in seconds.
> 
> 	------------------------------------------------------------------------
> 	The rest of the statistics are new to Version 4.1:
> 	------------------------------------------------------------------------
> 
> 	Info [UMFPACK_SYMBOLIC_WALLTIME]:  The wallclock time taken, in seconds.
> 
> 	Info [UMFPACK_STRATEGY_USED]: The ordering strategy used:
> 	    UMFPACK_STRATEGY_SYMMETRIC, UMFPACK_STRATEGY_UNSYMMETRIC, or
> 	    UMFPACK_STRATEGY_2BY2.
> 
> 	Info [UMFPACK_ORDERING_USED]:  The ordering method used:
> 	    UMFPACK_ORDERING_COLAMD or UMFPACK_ORDERING_AMD.  It can be
> 	    UMFPACK_ORDERING_GIVEN for umfpack_*_qsymbolic.
> 
> 	Info [UMFPACK_QFIXED]: 1 if the column pre-ordering will be refined
> 	    during numerical factorization, 0 if not.
> 
> 	Info [UMFPACK_DIAG_PREFERED]: 1 if diagonal pivoting will be attempted,
> 	    0 if not.
> 
> 	Info [UMFPACK_COL_SINGLETONS]:  the matrix A is analyzed by first
> 	    eliminating all pivots with zero Markowitz cost.  This count is the
> 	    number of these pivots with exactly one nonzero in their pivot
> 	    column.
> 
> 	Info [UMFPACK_ROW_SINGLETONS]:  the number of zero-Markowitz-cost
> 	    pivots with exactly one nonzero in their pivot row.
> 
> 	Info [UMFPACK_PATTERN_SYMMETRY]: the symmetry of the pattern of S.
> 
> 	Info [UMFPACK_NZ_A_PLUS_AT]: the number of off-diagonal entries in S+S'.
> 
> 	Info [UMFPACK_NZDIAG]:  the number of entries on the diagonal of S.
> 
> 	Info [UMFPACK_N2]:  if S is square, and nempty_row = nempty_col, this
> 	    is equal to n_row - n1 - nempty_row.
> 
> 	Info [UMFPACK_S_SYMMETRIC]: 1 if S is square and its diagonal has been
> 	    preserved, 0 otherwise.
> 
> 
> 	Info [UMFPACK_MAX_FRONT_NROWS_ESTIMATE]: estimate of the max number of
> 	    rows in any frontal matrix, for arbitrary partial pivoting.
> 
> 	Info [UMFPACK_MAX_FRONT_NCOLS_ESTIMATE]: estimate of the max number of
> 	    columns in any frontal matrix, for arbitrary partial pivoting.
> 
> 	------------------------------------------------------------------------
> 	The next four statistics are computed only if AMD is used:
> 	------------------------------------------------------------------------
> 
> 	Info [UMFPACK_SYMMETRIC_LUNZ]: The number of nonzeros in L and U,
> 	    assuming no pivoting during numerical factorization, and assuming a
> 	    zero-free diagonal of U.  Excludes the entries on the diagonal of
> 	    L.  If the matrix has a purely symmetric nonzero pattern, this is
> 	    often a lower bound on the nonzeros in the actual L and U computed
> 	    in the numerical factorization, for matrices that fit the criteria
> 	    for the "symmetric" strategy.
> 
> 	Info [UMFPACK_SYMMETRIC_FLOPS]: The floating-point operation count in
> 	    the numerical factorization phase, assuming no pivoting.  If the
> 	    pattern of the matrix is symmetric, this is normally a lower bound
> 	    on the floating-point operation count in the actual numerical
> 	    factorization, for matrices that fit the criteria for the symmetric
> 	    or 2-by-2 strategies
> 
> 	Info [UMFPACK_SYMMETRIC_NDENSE]: The number of "dense" rows/columns of
> 	    S+S' that were ignored during the AMD ordering.  These are placed
> 	    last in the output order.  If > 0, then the
> 	    Info [UMFPACK_SYMMETRIC_*] statistics, above are rough upper bounds.
> 
> 	Info [UMFPACK_SYMMETRIC_DMAX]: The maximum number of nonzeros in any
> 	    column of L, if no pivoting is performed during numerical
> 	    factorization.  Excludes the part of the LU factorization for
> 	    pivots with zero Markowitz cost.
> 
> 	------------------------------------------------------------------------
> 	The following statistics are computed only if the 2-by-2 strategy is
> 	used or attempted:
> 	------------------------------------------------------------------------
> 
> 	Info [UMFPACK_2BY2_NWEAK]: the number of small diagonal entries in S.
> 
> 	Info [UMFPACK_2BY2_UNMATCHED]: the number of small diagonal entries
> 	    in P2*S.
> 
> 	Info [UMFPACK_2BY2_PATTERN_SYMMETRY]: the symmetry of P2*S.
> 
> 	Info [UMFPACK_2BY2_NZ_PA_PLUS_AT]:  the number of off-diagonal entries
> 	    in (P2*S)+(P2*S)'.
> 
> 	Info [UMFPACK_2BY2_NZDIAG]:  the number of nonzero entries on the
> 	    diagonal of P2*S.
> 
> 
> 	At the start of umfpack_*_symbolic, all of Info is set of -1, and then
> 	after that only the above listed Info [...] entries are accessed.
> 	Future versions might modify different parts of Info.
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_tictoc.h pysparse/pysparse/direct/umfpack/include/umfpack_tictoc.h
0a1,61
> /* ========================================================================== */
> /* === umfpack_tictoc ======================================================= */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> void umfpack_tic (double stats [2]) ;
> 
> void umfpack_toc (double stats [2]) ;
> 
> 
> /*
> Syntax (for all versions: di, dl, zi, and zl):
> 
>     #include "umfpack.h"
>     double stats [2] ;
>     umfpack_tic (stats) ;
>     ...
>     umfpack_toc (stats) ;
> 
> Purpose:
> 
>     umfpack_tic returns the CPU time and wall clock time used by the process.
>     The CPU time includes both "user" and "system" time (the latter is time
>     spent by the system on behalf of the process, and is thus charged to the
>     process).  umfpack_toc returns the CPU time and wall clock time since the
>     last call to umfpack_tic with the same stats array.
> 
>     Typical usage:
> 
> 	umfpack_tic (stats) ;
> 	... do some work ...
> 	umfpack_toc (stats) ;
> 
>     then stats [1] contains the time in seconds used by the code between
>     umfpack_tic and umfpack_toc, and stats [0] contains the wall clock time
>     elapsed between the umfpack_tic and umfpack_toc.  These two routines act
>     just like tic and toc in MATLAB, except that the both process time and
>     wall clock time are returned.
> 
>     This routine normally uses the sysconf and times routines in the POSIX
>     standard.  If -DNPOSIX is defined at compile time, then the ANSI C clock
>     routine is used instead, and only the CPU time is returned (stats [0]
>     is set to zero).
> 
>     umfpack_tic and umfpack_toc are the routines used internally in UMFPACK
>     to time the symbolic analysis, numerical factorization, and the forward/
>     backward solve.
> 
> Arguments:
> 
>     double stats [2]:
> 
> 	stats [0]:  wall clock time, in seconds
> 	stats [1]:  CPU time, in seconds
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_timer.h pysparse/pysparse/direct/umfpack/include/umfpack_timer.h
0a1,41
> /* ========================================================================== */
> /* === umfpack_timer ======================================================== */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> double umfpack_timer ( void ) ;
> 
> /*
> Syntax (for all versions: di, dl, zi, and zl):
> 
>     #include "umfpack.h"
>     double t ;
>     t = umfpack_timer ( ) ;
> 
> Purpose:
> 
>     Returns the CPU time used by the process.  Includes both "user" and "system"
>     time (the latter is time spent by the system on behalf of the process, and
>     is thus charged to the process).  It does not return the wall clock time.
>     This was the timer used internally in UMFPACK V4.0.  See umfpack_tic and
>     umfpack_toc (the file umfpack_tictoc.h) for the timer used internally by
>     UMFPACK V4.1.
> 
>     This routine uses the Unix getrusage routine, if available.  It is less
>     subject to overflow than the ANSI C clock routine.  If getrusage is not
>     available, the portable ANSI C clock routine is used instead.
>     Unfortunately, clock ( ) overflows if the CPU time exceeds 2147 seconds
>     (about 36 minutes) when sizeof (clock_t) is 4 bytes.  If you have getrusage,
>     be sure to compile UMFPACK with the -DGETRUSAGE flag set; see umf_config.h
>     and the User Guide for details.  Even the getrusage routine can overlow.
> 
> Arguments:
> 
>     None.
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_transpose.h pysparse/pysparse/direct/umfpack/include/umfpack_transpose.h
0a1,217
> /* ========================================================================== */
> /* === umfpack_transpose ==================================================== */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> int umfpack_di_transpose
> (
>     int n_row,
>     int n_col,
>     const int Ap [ ],
>     const int Ai [ ],
>     const double Ax [ ],
>     const int P [ ],
>     const int Q [ ],
>     int Rp [ ],
>     int Ri [ ],
>     double Rx [ ]
> ) ;
> 
> long umfpack_dl_transpose
> (
>     long n_row,
>     long n_col,
>     const long Ap [ ],
>     const long Ai [ ],
>     const double Ax [ ],
>     const long P [ ],
>     const long Q [ ],
>     long Rp [ ],
>     long Ri [ ],
>     double Rx [ ]
> ) ;
> 
> int umfpack_zi_transpose
> (
>     int n_row,
>     int n_col,
>     const int Ap [ ],
>     const int Ai [ ],
>     const double Ax [ ], const double Az [ ],
>     const int P [ ],
>     const int Q [ ],
>     int Rp [ ],
>     int Ri [ ],
>     double Rx [ ], double Rz [ ],
>     int do_conjugate
> ) ;
> 
> long umfpack_zl_transpose
> (
>     long n_row,
>     long n_col,
>     const long Ap [ ],
>     const long Ai [ ],
>     const double Ax [ ], const double Az [ ],
>     const long P [ ],
>     const long Q [ ],
>     long Rp [ ],
>     long Ri [ ],
>     double Rx [ ], double Rz [ ],
>     long do_conjugate
> ) ;
> 
> /*
> double int Syntax:
> 
>     #include "umfpack.h"
>     int n_row, n_col, status, *Ap, *Ai, *P, *Q, *Rp, *Ri ;
>     double *Ax, *Rx ;
>     status = umfpack_di_transpose (n_row, n_col, Ap, Ai, Ax, P, Q, Rp, Ri, Rx) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     long n_row, n_col, status, *Ap, *Ai, *P, *Q, *Rp, *Ri ;
>     double *Ax, *Rx ;
>     status = umfpack_dl_transpose (n_row, n_col, Ap, Ai, Ax, P, Q, Rp, Ri, Rx) ;
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     int n_row, n_col, status, *Ap, *Ai, *P, *Q, *Rp, *Ri, do_conjugate ;
>     double *Ax, *Az, *Rx, *Rz ;
>     status = umfpack_zi_transpose (n_row, n_col, Ap, Ai, Ax, Az, P, Q,
> 	Rp, Ri, Rx, Rz, do_conjugate) ;
> 
> complex long Syntax:
> 
>     #include "umfpack.h"
>     long n_row, n_col, status, *Ap, *Ai, *P, *Q, *Rp, *Ri, do_conjugate ;
>     double *Ax, *Az, *Rx, *Rz ;
>     status = umfpack_zl_transpose (n_row, n_col, Ap, Ai, Ax, Az, P, Q,
> 	Rp, Ri, Rx, Rz, do_conjugate) ;
> 
> Purpose:
> 
>     Transposes and optionally permutes a sparse matrix in row or column-form,
>     R = (PAQ)'.  In MATLAB notation, R = (A (P,Q))' or R = (A (P,Q)).' doing
>     either the linear algebraic transpose or the array transpose. Alternatively,
>     this routine can be viewed as converting A (P,Q) from column-form to
>     row-form, or visa versa (for the array transpose).  Empty rows and columns
>     may exist.  The matrix A may be singular and/or rectangular.
> 
>     umfpack_*_transpose is useful if you want to factorize A' or A.' instead of
>     A.  Factorizing A' or A.' instead of A can be much better, particularly if
>     AA' is much sparser than A'A.  You can still solve Ax=b if you factorize
>     A' or A.', by solving with the sys argument UMFPACK_At or UMFPACK_Aat,
>     respectively, in umfpack_*_*solve.  The umfpack mexFunction (umfpackmex.c)
>     is one example.  To compute x = A/b, it computes x = (A.'\b.').' instead,
>     by factorizing A.'.  It then uses the regular solve, since b.' and x.' are
>     stored identically as b and x, respectively (both b.' and b are dense
>     vectors).  If b and x were arrays, the umfpack mexFunction would need to
>     first compute b.' and then transpose the resulting solution.
> 
> Returns:
> 
>     UMFPACK_OK if successful.
>     UMFPACK_ERROR_out_of_memory if umfpack_*_transpose fails to allocate a
> 	size-max (n_row,n_col) workspace.
>     UMFPACK_ERROR_argument_missing if Ai, Ap, Ri, and/or Rp are missing.
>     UMFPACK_ERROR_n_nonpositive if n_row <= 0 or n_col <= 0
>     UMFPACK_ERROR_invalid_permutation if P and/or Q are invalid.
>     UMFPACK_ERROR_invalid_matrix if Ap [n_col] < 0, if Ap [0] != 0,
> 	if Ap [j] > Ap [j+1] for any j in the range 0 to n_col-1,
> 	if any row index i is < 0 or >= n_row, or if the row indices
> 	in any column are not in ascending order.
> 
> Arguments:
> 
>     Int n_row ;		Input argument, not modified.
>     Int n_col ;		Input argument, not modified.
> 
> 	A is an n_row-by-n_col matrix.  Restriction: n_row > 0 and n_col > 0.
> 
>     Int Ap [n_col+1] ;	Input argument, not modified.
> 
> 	The column pointers of the column-oriented form of the matrix A.  See
> 	umfpack_*_symbolic for a description.  The number of entries in
> 	the matrix is nz = Ap [n_col].  Ap [0] must be zero, Ap [n_col] must be
> 	=> 0, and Ap [j] <= Ap [j+1] and Ap [j] <= Ap [n_col] must be true for
> 	all j in the range 0 to n_col-1.  Empty columns are OK (that is, Ap [j]
> 	may equal Ap [j+1] for any j in the range 0 to n_col-1).
> 
>     Int Ai [nz] ;	Input argument, not modified, of size nz = Ap [n_col].
> 
> 	The nonzero pattern (row indices) for column j is stored in
> 	Ai [(Ap [j]) ... (Ap [j+1]-1)].  The row indices in a given column j
> 	must be in ascending order, and no duplicate row indices may be present.
> 	Row indices must be in the range 0 to n_row-1 (the matrix is 0-based).
> 
>     double Ax [nz] ;	Input argument, not modified, of size nz = Ap [n_col].
>     double Az [nz] ;	Input argument, not modified, for complex versions.
> 
> 	If present, these are the numerical values of the sparse matrix A.
> 	The nonzero pattern (row indices) for column j is stored in
> 	Ai [(Ap [j]) ... (Ap [j+1]-1)], and the corresponding real numerical
> 	values are stored in Ax [(Ap [j]) ... (Ap [j+1]-1)].  The imaginary
> 	values are stored in Az [(Ap [j]) ... (Ap [j+1]-1)].  The values are
> 	transposed only if Ax and Rx are present (for the real version), and
> 	only if all four (Ax, Az, Rx, and Rz) are present for the complex
> 	version.  These are not an error conditions; you are able to transpose
> 	and permute just the pattern of a matrix.
> 
> 	Future complex version:  if Ax is present and Az is NULL, then both real
> 	and imaginary parts will be contained in Ax[0..2*nz-1], with Ax[2*k]
> 	and Ax[2*k+1] being the real and imaginary part of the kth entry.
> 
>     Int P [n_row] ;		Input argument, not modified.
> 
> 	The permutation vector P is defined as P [k] = i, where the original
> 	row i of A is the kth row of PAQ.  If you want to use the identity
> 	permutation for P, simply pass (Int *) NULL for P.  This is not an error
> 	condition.  P is a complete permutation of all the rows of A; this
> 	routine does not support the creation of a transposed submatrix of A
> 	(R = A (1:3,:)' where A has more than 3 rows, for example, cannot be
> 	done; a future version might support this operation).
> 
>     Int Q [n_col] ;		Input argument, not modified.
> 
> 	The permutation vector Q is defined as Q [k] = j, where the original
> 	column j of A is the kth column of PAQ.  If you want to use the identity
> 	permutation for Q, simply pass (Int *) NULL for Q.  This is not an error
> 	condition.  Q is a complete permutation of all the columns of A; this
> 	routine does not support the creation of a transposed submatrix of A.
> 
>     Int Rp [n_row+1] ;	Output argument.
> 
> 	The column pointers of the matrix R = (A (P,Q))' or (A (P,Q)).', in the
> 	same form as the column pointers Ap for the matrix A.
> 
>     Int Ri [nz] ;	Output argument.
> 
> 	The row indices of the matrix R = (A (P,Q))' or (A (P,Q)).' , in the
> 	same form as the row indices Ai for the matrix A.
> 
>     double Rx [nz] ;	Output argument.
>     double Rz [nz] ;	Output argument, imaginary part for complex versions.
> 
> 	If present, these are the numerical values of the sparse matrix R,
> 	in the same form as the values Ax and Az of the matrix A.
> 
> 	Future complex version:  if Rx is present and Rz is NULL, then both real
> 	and imaginary parts will be contained in Rx[0..2*nz-1], with Rx[2*k]
> 	and Rx[2*k+1] being the real and imaginary part of the kth entry.
> 
>     Int do_conjugate ;	Input argument for complex versions only.
> 
> 	If true, and if Ax, Az, Rx, and Rz are all present, then the linear
> 	algebraic transpose is computed (complex conjugate).  If false, the
> 	array transpose is computed instead.
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_triplet_to_col.h pysparse/pysparse/direct/umfpack/include/umfpack_triplet_to_col.h
0a1,261
> /* ========================================================================== */
> /* === umfpack_triplet_to_col =============================================== */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> int umfpack_di_triplet_to_col
> (
>     int n_row,
>     int n_col,
>     int nz,
>     const int Ti [ ],
>     const int Tj [ ],
>     const double Tx [ ],
>     int Ap [ ],
>     int Ai [ ],
>     double Ax [ ],
>     int Map [ ]
> ) ;
> 
> long umfpack_dl_triplet_to_col
> (
>     long n_row,
>     long n_col,
>     long nz,
>     const long Ti [ ],
>     const long Tj [ ],
>     const double Tx [ ],
>     long Ap [ ],
>     long Ai [ ],
>     double Ax [ ],
>     long Map [ ]
> ) ;
> 
> int umfpack_zi_triplet_to_col
> (
>     int n_row,
>     int n_col,
>     int nz,
>     const int Ti [ ],
>     const int Tj [ ],
>     const double Tx [ ], const double Tz [ ],
>     int Ap [ ],
>     int Ai [ ],
>     double Ax [ ], double Az [ ],
>     int Map [ ]
> ) ;
> 
> long umfpack_zl_triplet_to_col
> (
>     long n_row,
>     long n_col,
>     long nz,
>     const long Ti [ ],
>     const long Tj [ ],
>     const double Tx [ ], const double Tz [ ],
>     long Ap [ ],
>     long Ai [ ],
>     double Ax [ ], double Az [ ],
>     long Map [ ]
> ) ;
> 
> /*
> double int Syntax:
> 
>     #include "umfpack.h"
>     int n_row, n_col, nz, *Ti, *Tj, *Ap, *Ai, status, *Map ;
>     double *Tx, *Ax ;
>     status = umfpack_di_triplet_to_col (n_row, n_col, nz, Ti, Tj, Tx,
> 	Ap, Ai, Ax, Map) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     long n_row, n_col, nz, *Ti, *Tj, *Ap, *Ai, status, *Map ;
>     double *Tx, *Ax ;
>     status = umfpack_dl_triplet_to_col (n_row, n_col, nz, Ti, Tj, Tx,
> 	Ap, Ai, Ax, Map) ;
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     int n_row, n_col, nz, *Ti, *Tj, *Ap, *Ai, status, *Map ;
>     double *Tx, *Tz, *Ax, *Az ;
>     status = umfpack_zi_triplet_to_col (n_row, n_col, nz, Ti, Tj, Tx, Tz,
> 	Ap, Ai, Ax, Az, Map) ;
> 
> long Syntax:
> 
>     #include "umfpack.h"
>     long n_row, n_col, nz, *Ti, *Tj, *Ap, *Ai, status, *Map ;
>     double *Tx, *Tz, *Ax, *Az ;
>     status = umfpack_zl_triplet_to_col (n_row, n_col, nz, Ti, Tj, Tx, Tz,
> 	Ap, Ai, Ax, Az, Map) ;
> 
> Purpose:
> 
>     Converts a sparse matrix from "triplet" form to compressed-column form.
>     Analogous to A = spconvert (Ti, Tj, Tx + Tx*1i) in MATLAB, except that
>     zero entries present in the triplet form are present in A.
> 
>     The triplet form of a matrix is a very simple data structure for basic
>     sparse matrix operations.  For example, suppose you wish to factorize a
>     matrix A coming from a finite element method, in which A is a sum of
>     dense submatrices, A = E1 + E2 + E3 + ... .  The entries in each element
>     matrix Ei can be concatenated together in the three triplet arrays, and
>     any overlap between the elements will be correctly summed by
>     umfpack_*_triplet_to_col.
> 
>     Transposing a matrix in triplet form is simple; just interchange the
>     use of Ti and Tj.  You can construct the complex conjugate transpose by
>     negating Tz, for the complex versions.
> 
>     Permuting a matrix in triplet form is also simple.  If you want the matrix
>     PAQ, or A (P,Q) in MATLAB notation, where P [k] = i means that row i of
>     A is the kth row of PAQ and Q [k] = j means that column j of A is the kth
>     column of PAQ, then do the following.  First, create inverse permutations
>     Pinv and Qinv such that Pinv [i] = k if P [k] = i and Qinv [j] = k if
>     Q [k] = j.  Next, for the mth triplet (Ti [m], Tj [m], Tx [m], Tz [m]),
>     replace Ti [m] with Pinv [Ti [m]] and replace Tj [m] with Qinv [Tj [m]].
> 
>     If you have a column-form matrix with duplicate entries or unsorted
>     columns, you can sort it and sum up the duplicates by first converting it
>     to triplet form with umfpack_*_col_to_triplet, and then converting it back
>     with umfpack_*_triplet_to_col.
> 
>     Constructing a submatrix is also easy.  Just scan the triplets and remove
>     those entries outside the desired subset of 0...n_row-1 and 0...n_col-1,
>     and renumber the indices according to their position in the subset.
> 
>     You can do all these operations on a column-form matrix by first
>     converting it to triplet form with umfpack_*_col_to_triplet, doing the
>     operation on the triplet form, and then converting it back with
>     umfpack_*_triplet_to_col.
> 
>     The only operation not supported easily in the triplet form is the
>     multiplication of two sparse matrices (UMFPACK does not provide this
>     operation).
> 
>     You can print the input triplet form with umfpack_*_report_triplet, and
>     the output matrix with umfpack_*_report_matrix.
> 
>     The matrix may be singular (nz can be zero, and empty rows and/or columns
>     may exist).  It may also be rectangular and/or complex.
> 
> Returns:
> 
>     UMFPACK_OK if successful.
>     UMFPACK_ERROR_argument_missing if Ap, Ai, Ti, and/or Tj are missing.
>     UMFPACK_ERROR_n_nonpositive if n_row <= 0 or n_col <= 0.
>     UMFPACK_ERROR_invalid_matrix if nz < 0, or if for any k, Ti [k] and/or
> 	Tj [k] are not in the range 0 to n_row-1 or 0 to n_col-1, respectively.
>     UMFPACK_ERROR_out_of_memory if unable to allocate sufficient workspace.
> 
> Arguments:
> 
>     Int n_row ;		Input argument, not modified.
>     Int n_col ;		Input argument, not modified.
> 
> 	A is an n_row-by-n_col matrix.  Restriction: n_row > 0 and n_col > 0.
> 	All row and column indices in the triplet form must be in the range
> 	0 to n_row-1 and 0 to n_col-1, respectively.
> 
>     Int nz ;		Input argument, not modified.
> 
> 	The number of entries in the triplet form of the matrix.  Restriction:
> 	nz >= 0.
> 
>     Int Ti [nz] ;	Input argument, not modified.
>     Int Tj [nz] ;	Input argument, not modified.
>     double Tx [nz] ;	Input argument, not modified.
>     double Tz [nz] ;	Input argument, not modified, for complex versions.
> 
> 	Ti, Tj, Tx, and Tz hold the "triplet" form of a sparse matrix.  The kth
> 	nonzero entry is in row i = Ti [k], column j = Tj [k], and the real part
> 	of a_ij is Tx [k].  The imaginary part of a_ij is Tz [k], for complex
> 	versions.  The row and column indices i and j must be in the range 0 to
> 	n_row-1 and 0 to n_col-1, respectively.  Duplicate entries may be
> 	present; they are summed in the output matrix.  This is not an error
> 	condition.  The "triplets" may be in any order.  Tx, Tz, Ax, and Az
> 	are optional.  For the real version, Ax is computed only if both Ax
> 	and Tx are present (not (double *) NULL).  For the complex version, Ax
> 	and Az are computed only if Tx, Tz, Ax, and Az are all present.  These
> 	are not error conditions; the routine can create just the pattern of
> 	the output matrix from the pattern of the triplets.
> 
> 	Future complex version:  if Tx is present and Tz is NULL, then both real
> 	and imaginary parts will be contained in Tx[0..2*nz-1], with Tx[2*k]
> 	and Tx[2*k+1] being the real and imaginary part of the kth entry.
> 
>     Int Ap [n_col+1] ;	Output argument.
> 
> 	Ap is an integer array of size n_col+1 on input.  On output, Ap holds
> 	the "pointers" for the column form of the sparse matrix A.  Column j of
> 	the matrix A is held in Ai [(Ap [j]) ... (Ap [j+1]-1)].  The first
> 	entry, Ap [0], is zero, and Ap [j] <= Ap [j+1] holds for all j in the
> 	range 0 to n_col-1.  The value nz2 = Ap [n_col] is thus the total
> 	number of entries in the pattern of the matrix A.  Equivalently, the
> 	number of duplicate triplets is nz - Ap [n_col].
> 
>     Int Ai [nz] ;	Output argument.
> 
> 	Ai is an integer array of size nz on input.  Note that only the first
> 	Ap [n_col] entries are used.
> 
> 	The nonzero pattern (row indices) for column j is stored in
> 	Ai [(Ap [j]) ... (Ap [j+1]-1)].  The row indices in a given column j
> 	are in ascending order, and no duplicate row indices are present.
> 	Row indices are in the range 0 to n_col-1 (the matrix is 0-based).
> 
>     double Ax [nz] ;	Output argument.
>     double Az [nz] ;	Output argument for complex versions.
> 
> 	Ax and Az (for the complex versions) are double arrays of size nz on
> 	input.  Note that only the first Ap [n_col] entries are used
> 	in both arrays.
> 
> 	Ax is optional; if Tx and/or Ax are not present (a (double *) NULL
> 	pointer), then Ax is not computed.  Az is also optional; if Tz and/or
> 	Az are not present, then Az is not computed.  If present, Ax holds the
> 	numerical values of the the real part of the sparse matrix A and Az
> 	holds the imaginary parts.  The nonzero pattern (row indices) for
> 	column j is stored in Ai [(Ap [j]) ... (Ap [j+1]-1)], and the
> 	corresponding numerical values are stored in
> 	Ax [(Ap [j]) ... (Ap [j+1]-1)].  The imaginary parts are stored in
> 	Az [(Ap [j]) ... (Ap [j+1]-1)], for the complex versions.
> 
> 	Future complex version:  if Ax is present and Az is NULL, then both real
> 	and imaginary parts will be returned in Ax[0..2*nz2-1], with Ax[2*k]
> 	and Ax[2*k+1] being the real and imaginary part of the kth entry.
> 
>     int Map [nz] ;	Optional output argument.
> 
> 	If Map is present (a non-NULL pointer to an Int array of size nz), then
> 	on output it holds the position of the triplets in the column-form
> 	matrix.  That is, suppose p = Map [k], and the k-th triplet is i=Ti[k],
> 	j=Tj[k], and aij=Tx[k].  Then i=Ai[p], and aij will have been summed
> 	into Ax[p] (or simply aij=Ax[p] if there were no duplicate entries also
> 	in row i and column j).  Also, Ap[j] <= p < Ap[j+1].  The Map array is
> 	not computed if it is (Int *) NULL.  The Map array is useful for
> 	converting a subsequent triplet form matrix with the same pattern as the
> 	first one, without calling this routine.  If Ti and Tj do not change,
> 	then Ap, and Ai can be reused from the prior call to
> 	umfpack_*_triplet_to_col.  You only need to recompute Ax (and Az for the
> 	complex version).  This code excerpt properly sums up all duplicate
> 	values (for the real version):
> 
> 	    for (p = 0 ; p < Ap [n_col] ; p++) Ax [p] = 0 ;
> 	    for (k = 0 ; k < nz ; k++) Ax [Map [k]] += Tx [k] ;
> 
> 	This feature is useful (along with the reuse of the Symbolic object) if
> 	you need to factorize a sequence of triplet matrices with identical
> 	nonzero pattern (the order of the triplets in the Ti,Tj,Tx arrays must
> 	also remain unchanged).  It is faster than calling this routine for
> 	each matrix, and requires no workspace.
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/direct/umfpack/include/umfpack_wsolve.h pysparse/pysparse/direct/umfpack/include/umfpack_wsolve.h
0a1,166
> /* ========================================================================== */
> /* === umfpack_wsolve ======================================================= */
> /* ========================================================================== */
> 
> /* -------------------------------------------------------------------------- */
> /* UMFPACK Version 4.1 (Apr. 30, 2003), Copyright (c) 2003 by Timothy A.      */
> /* Davis.  All Rights Reserved.  See ../README for License.                   */
> /* email: davis@cise.ufl.edu    CISE Department, Univ. of Florida.            */
> /* web: http://www.cise.ufl.edu/research/sparse/umfpack                       */
> /* -------------------------------------------------------------------------- */
> 
> int umfpack_di_wsolve
> (
>     int sys,
>     const int Ap [ ],
>     const int Ai [ ],
>     const double Ax [ ],
>     double X [ ],
>     const double B [ ],
>     void *Numeric,
>     const double Control [UMFPACK_CONTROL],
>     double Info [UMFPACK_INFO],
>     int Wi [ ],
>     double W [ ]
> ) ;
> 
> long umfpack_dl_wsolve
> (
>     long sys,
>     const long Ap [ ],
>     const long Ai [ ],
>     const double Ax [ ],
>     double X [ ],
>     const double B [ ],
>     void *Numeric,
>     const double Control [UMFPACK_CONTROL],
>     double Info [UMFPACK_INFO],
>     long Wi [ ],
>     double W [ ]
> ) ;
> 
> int umfpack_zi_wsolve
> (
>     int sys,
>     const int Ap [ ],
>     const int Ai [ ],
>     const double Ax [ ], const double Az [ ],
>     double Xx [ ],	 double Xz [ ],
>     const double Bx [ ], const double Bz [ ],
>     void *Numeric,
>     const double Control [UMFPACK_CONTROL],
>     double Info [UMFPACK_INFO],
>     int Wi [ ],
>     double W [ ]
> ) ;
> 
> long umfpack_zl_wsolve
> (
>     long sys,
>     const long Ap [ ],
>     const long Ai [ ],
>     const double Ax [ ], const double Az [ ],
>     double Xx [ ],	 double Xz [ ],
>     const double Bx [ ], const double Bz [ ],
>     void *Numeric,
>     const double Control [UMFPACK_CONTROL],
>     double Info [UMFPACK_INFO],
>     long Wi [ ],
>     double W [ ]
> ) ;
> 
> /*
> double int Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     int status, *Ap, *Ai, *Wi, sys ;
>     double *B, *X, *Ax, *W, Info [UMFPACK_INFO], Control [UMFPACK_CONTROL] ;
>     status = umfpack_di_wsolve (sys, Ap, Ai, Ax, X, B, Numeric,
> 	Control, Info, Wi, W) ;
> 
> double long Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     long status, *Ap, *Ai, *Wi, sys ;
>     double *B, *X, *Ax, *W, Info [UMFPACK_INFO], Control [UMFPACK_CONTROL] ;
>     status = umfpack_dl_wsolve (sys, Ap, Ai, Ax, X, B, Numeric,
> 	Control, Info, Wi, W) ;
> 
> complex int Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     int status, *Ap, *Ai, *Wi, sys ;
>     double *Bx, *Bz, *Xx, *Xz, *Ax, *Az, *W,
> 	Info [UMFPACK_INFO], Control [UMFPACK_CONTROL] ;
>     status = umfpack_zi_wsolve (sys, Ap, Ai, Ax, Az, Xx, Xz, Bx, Bz, Numeric,
> 	Control, Info, Wi, W) ;
> 
> complex long Syntax:
> 
>     #include "umfpack.h"
>     void *Numeric ;
>     long status, *Ap, *Ai, *Wi, sys ;
>     double *Bx, *Bz, *Xx, *Xz, *Ax, *Az, *W,
> 	Info [UMFPACK_INFO], Control [UMFPACK_CONTROL] ;
>     status = umfpack_zl_wsolve (sys, Ap, Ai, Ax, Az, Xx, Xz, Bx, Bz, Numeric,
> 	Control, Info, Wi, W) ;
> 
> Purpose:
> 
>     Given LU factors computed by umfpack_*_numeric (PAQ=LU) and the
>     right-hand-side, B, solve a linear system for the solution X.  Iterative
>     refinement is optionally performed.  This routine is identical to
>     umfpack_*_solve, except that it does not dynamically allocate any workspace.
>     When you have many linear systems to solve, this routine is faster than
>     umfpack_*_solve, since the workspace (Wi, W) needs to be allocated only
>     once, prior to calling umfpack_*_wsolve.
> 
> Returns:
> 
>     The status code is returned.  See Info [UMFPACK_STATUS], below.
> 
> Arguments:
> 
>     Int sys ;		Input argument, not modified.
>     Int Ap [n+1] ;	Input argument, not modified.
>     Int Ai [nz] ;	Input argument, not modified.
>     double Ax [nz] ;	Input argument, not modified.
>     double X [n] ;	Output argument.
>     double B [n] ;	Input argument, not modified.
>     void *Numeric ;	Input argument, not modified.
>     double Control [UMFPACK_CONTROL] ;	Input argument, not modified.
>     double Info [UMFPACK_INFO] ;	Output argument.
> 
>     for complex versions:
>     double Az [nz] ;	Input argument, not modified, imaginary part
>     double Xx [n] ;	Output argument, real part.
>     double Xz [n] ;	Output argument, imaginary part
>     double Bx [n] ;	Input argument, not modified, real part
>     double Bz [n] ;	Input argument, not modified, imaginary part
> 
> 	The above arguments are identical to umfpack_*_solve, except that the
> 	error code UMFPACK_ERROR_out_of_memory will not be returned in
> 	Info [UMFPACK_STATUS], since umfpack_*_wsolve does not allocate any
> 	memory.
> 
>     Int Wi [n] ;		Workspace.
>     double W [c*n] ;		Workspace, where c is defined below.
> 
> 	The Wi and W arguments are workspace used by umfpack_*_wsolve.  They
> 	need not be initialized on input, and their contents are undefined on
> 	output.  The size of W depends on whether or not iterative refinement is
> 	used, and which version (real or complex) is called.  Iterative
> 	refinement is performed if Ax=b, A'x=b, or A.'x=b is being solved,
> 	Control [UMFPACK_IRSTEP] > 0, and A is nonsingular.  The size of W is
> 	given below:
> 
> 				no iter.	with iter.
> 				refinement	refinement
> 	umfpack_di_wsolve	n		5*n
> 	umfpack_dl_wsolve	n		5*n
> 	umfpack_zi_wsolve	4*n		10*n
> 	umfpack_zl_wsolve	4*n		10*n
> */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/eigen/src/correq.c pysparse/pysparse/eigen/src/correq.c
0a1,341
> #define JDSYM_OP_UNSYM 1
> #define JDSYM_OP_SYM   2
> 
> typedef struct CorrEqObject {
>   PyObject_VAR_HEAD
>   int op_type;
>   int n;
>   int k;
>   PyObject *amat;
>   PyObject *mmat;
>   PyObject *prec;
>   double theta;
>   double *Q;
>   double *Qm;
>   double *Y;
>   /* ldQ and ldQm are equal to n */
>   int *Hpiv;
>   double *Hlu;
>   int ldh;
>   double *work;
>   void (*right)(struct CorrEqObject *, double *);
>   void (*update)(struct CorrEqObject *, int, double);
> } CorrEqObject;
> 
> 
> static void 
> CorrEq_A_theta_M(CorrEqObject *self, int n, double *x, double *y, double *w) {
> 
>   double alpha = -self->theta;
> 
>   SpMatrix_Matvec(self->amat, n, x, n, y);	   /* y := A*x; */
>   if (alpha != 0.0) {
>     SpMatrix_Matvec(self->mmat, n, x, n, w);	   /* work := M*x */
>     F77(daxpy)(&n, &alpha, w, &ONE, y, &ONE);      /* y := -theta*work + y */
>   }
> }
> 
> static void 
> CorrEq_A_theta_I(CorrEqObject *self, int n, double *x, double *y) {
> 
>   double alpha = -self->theta;
> 
>   SpMatrix_Matvec(self->amat, n, x, n, y);	   /* y := A*x; */
>   F77(daxpy)(&n, &alpha, x, &ONE, y, &ONE);        /* y := -theta*x + y*/
> }
> 
> /* PROJECT1 - compute y := (I - A*B')*x
>  *
>  * sizes of matrices and vectors:
>  *   A and B     --  r-by-c matrices, ldim = r
>  *   x, y and w  --  r vectors
>  *
>  * (x, y) and also (A, B) may point to the same memory locations
>  */
> static void 
> CorrEq_project1(int r, int c, double *A, double *B, double *x, double *y, double *w){
>   /* if x and y do not refer to the same vector, we copy x to y */
>   if (x != y)
>     F77(dcopy)(&r, x, &ONE, y, &ONE);
>   /* w = B'*y */
>   F77(dgemv)("t", &r, &c, &DONE, B, &r, y, &ONE, &DZER, w, &ONE, 1);
>   /* y = y - A*w */
>   F77(dgemv)("n", &r, &c, &DMONE, A, &r, w, &ONE, &DONE, y, &ONE, 1);
> }
> 
> /* PROJECT2 - compute y := (I - Y*inv(H)*Qm') * x
>  *                     or
>  *                    y := (I - Y*inv(H)*Q' ) * x
>  *
>  *            depending on parameter Qx                  
>  */
> static void 
> CorrEq_project2(CorrEqObject *self, double *Qx, double *x, double *y, double *w){
>   int info;
>   int n = self->n;
>   int k = self->k;
> 
>   /* if x and y do not refer to the same vector, we copy x to y */
>   if (x != y)
>     F77(dcopy)(&n, x, &ONE, y, &ONE);
>   /* w = Qx'*x */
>   F77(dgemv)("t", &n, &k, &DONE, Qx, &n,
> 	     x, &ONE, &DZER, w, &ONE, 1);
>   /* w = inv(H)*w */
>   F77(dgetrs)("n", &k, &ONE, self->Hlu, &(self->ldh),
> 	      self->Hpiv, w, &n, &info, 1);
>   assert(info == 0);
>   /* y = y - Y*w */
>   F77(dgemv)("n", &n, &k, &DMONE, self->Y, &n,
> 	     w, &ONE, &DONE, y, &ONE, 1);
> }
> 
> static void
> CorrEq_update(CorrEqObject *self, int k, double theta) {
>   self->k = k;
>   self->theta = theta;
> }
> 
> static void
> CorrEq_right(CorrEqObject *self, double *r) {
>   int n = self->n;
>   int k = self->k;
> 
>   if (self->op_type == JDSYM_OP_SYM)
>     if (self->mmat) {
>       /* r = r - Qb*(Q'*r); */
>       CorrEq_project1(n, k, self->Qm, self->Q, r, r, self->work); 
>     } else {
>       /* r :=  (I - Q*Q')*r */
>       mgs(r, n, k, self->Q);
>     }
>   else /* op_type = JDSYM_OP_UNSYM */
>     if (self->mmat)
>       if (self->prec) {
> 	/* mmat && prec */
> 	/* r := (I - Y'*inv(H)*Qb')*inv(K)*r */
> 	SpMatrix_Precon(self->prec, n, r, self->work);
> 	CorrEq_project2(self, self->Qm, self->work, r, self->work + n);
>       } else {
> 	/* mmat && !prec */
> 	/* r :=  (I - Q*Qb')*r */
> 	CorrEq_project1(n, k, self->Q, self->Qm, r, r, self->work);
>       }
>     else
>       if (self->prec) {
> 	/* !mmat && prec */
> 	/* r := (I - Y'*inv(H)*Q')*inv(K)*r */
> 	SpMatrix_Precon(self->prec, n, r, self->work);
> 	CorrEq_project2(self, self->Q, self->work, r, self->work + n);
>       } else {
> 	/* !mmat && !prec */
> 	/* r :=  (I - Q*Q')*r */
> 	mgs(r, n, k, self->Q);
>       }
> }
> 
> static PyObject *
> CorrEq_matvec(CorrEqObject *self, PyObject *args) {
>   PyArrayObject *xp, *yp;
>   double *x, *y;
>   int n = self->n;
>   int k = self->k;
> 
>   /* parse input arguments */
>   SPMATRIX_PARSE_ARGS_ARR_ARR(args, xp, yp, self->n, self->n);
>   x = (double *)(xp->data);
>   y = (double *)(yp->data);
> 
>   if (self->op_type == JDSYM_OP_SYM) {
>     if (self->mmat) {
>       /* y := (I - Qm*Q')*(A - theta*M)*x */
>       CorrEq_A_theta_M(self, n, x, y, self->work);
>       CorrEq_project1(n, k, self->Qm, self->Q, y, y, self->work);
>     } else {
>       /* y := (I - Q*Q')*(A - theta*I)*x */
>       CorrEq_A_theta_I(self, n, x, y);
>       CorrEq_project1(n, k, self->Q, self->Q, y, y, self->work);
>     }
>   } else { /* self->op_type = JDSYM_OP_UNSYM */
>     if (self->mmat)
>       if (self->prec) {
> 	/* mmat && prec */
> 	/* y := (I - Y'*inv(H)*QM')*inv(K)*(A-theta*M)*x */
> 	CorrEq_A_theta_M(self, n, x, self->work + n, self->work);
> 	SpMatrix_Precon(self->prec, n, self->work + n, y);
> 	CorrEq_project2(self, self->Qm, y, y, self->work);
>       } else { 
> 	/* mmat && !prec */
> 	/* y := (I - Q*Qm')*(A-theta*M)*x */
> 	CorrEq_A_theta_M(self, n, x, y, self->work);
> 	CorrEq_project1(n, k, self->Q, self->Qm, y, y, self->work);
>       }
>     else /* ! self->mmat */
>       if (self->prec) {
> 	/* !mmat && prec */
> 	/* y := (I - Y'*inv(H)*Q')*inv(K)*(A-theta*I)*x */
> 	CorrEq_A_theta_I(self, n, x, self->work + n);
> 	SpMatrix_Precon(self->prec, n, self->work + n, y);
> 	CorrEq_project2(self, self->Q, y, y, self->work);
>       } else { 
> 	/* !mmat && !prec */
> 	/* y := (I - Q*Q')*(A-theta*I)*x */
> 	CorrEq_A_theta_I(self, n, x, y);
> 	CorrEq_project1(n, k, self->Q, self->Q, y, y, self->work);
>       }
>   }
> 
>   /* return Py_None */
>   Py_INCREF(Py_None); 
>   return Py_None;
> }
> 
> static PyObject *
> CorrEq_precon(CorrEqObject *self, PyObject *args) {
>   PyArrayObject *xp, *yp;
>   double *x, *y;
>   int n = self->n;
>   int k = self->k;
> 
>   /* parse input arguments */
>   SPMATRIX_PARSE_ARGS_ARR_ARR(args, xp, yp, self->n, self->n);
>   x = (double *)(xp->data);
>   y = (double *)(yp->data);
> 
>   if (self->op_type == JDSYM_OP_SYM)
>     if (self->mmat)
>       if (self->prec) {
> 	/* mmat && prec */
> 	/* y = (I-Y*H\Qm')*inv(K)*x */
> 	SpMatrix_Precon(self->prec, n, x, y);
> 	CorrEq_project2(self, self->Qm, y, y, self->work);
>       } else {
> 	/* mmat && !prec */
> 	/* y = (I - Q*Qm')*x */
> 	CorrEq_project1(n, k, self->Q, self->Qm, x, y, self->work);
>       }
>     else
>       if (self->prec) {
> 	/* !mmat && prec */
> 	/* y = (I-Y*H\Q')*inv(K)*x */
> 	SpMatrix_Precon(self->prec, n, x, y);
> 	CorrEq_project2(self, self->Q, y, y, self->work);
>       } else {
> 	/* !mmat && !prec */
> 	/* y = x */
> 	F77(dcopy)(&n, x, &ONE, y, &ONE);
>       }
>   else { /* self->optype == JDSYM_OP_UNSYM */
>     /* the Preconditioner is contained in the operator */
>     F77(dcopy)(&n, x, &ONE, y, &ONE);
>   }
> 
>   /* return Py_None */
>   Py_INCREF(Py_None); 
>   return Py_None;
> }
> 
> /** table of object methods
>  */
> PyMethodDef CorrEq_methods[] = {
>   {"matvec", (PyCFunction)CorrEq_matvec, METH_VARARGS},
>   {"precon", (PyCFunction)CorrEq_precon, METH_VARARGS},
>   {NULL, NULL}			/* sentinel */
> };
> 
> /*********************************************************************** 
>  * CorrEqType methods
>  */
> 
> static void
> CorrEq_dealloc(CorrEqObject *self)
> {
>   PyMem_DEL(self->work);
>   PyObject_Del(self);
> }
> 
> static PyObject *
> CorrEq_getattr(CorrEqObject *self, char *name)
> {
>   if (strcmp(name, "shape") == 0)
>     return Py_BuildValue("(i,i)", self->n, self->n);
>   if (strcmp(name, "__members__") == 0) {
>     char *members[] = {"shape"};
>     int i;
> 
>     PyObject *list = PyList_New(sizeof(members)/sizeof(char *));
>     if (list != NULL) {
>       for (i = 0; i < sizeof(members)/sizeof(char *); i ++)
> 	PyList_SetItem(list, i, PyString_FromString(members[i]));
>       if (PyErr_Occurred()) {
> 	Py_DECREF(list);
> 	list = NULL;
>       }
>     }
>     return list;
>   }
>   return Py_FindMethod(CorrEq_methods, (PyObject *)self, name);
> }
> 
> /***********************************************************************
>  * Type structures
>  */
> 
> PyTypeObject CorrEqType = {
>   PyObject_HEAD_INIT(NULL)
>   0,
>   "CorrEqSystem",
>   sizeof(CorrEqObject),
>   0,
>   (destructor)CorrEq_dealloc,   /* tp_dealloc */
>   0,				/* tp_print */
>   (getattrfunc)CorrEq_getattr,  /* tp_getattr */
>   0,				/* tp_setattr */
>   0,				/* tp_compare */
>   0,				/* tp_repr */
>   0,				/* tp_as_number*/
>   0,				/* tp_as_sequence*/
>   0,				/* tp_as_mapping*/
>   0,				/* tp_hash */
> };
> 
> /*********************************************************************** 
>  * Object construction functions
>  */
> 
> PyObject *
> newCorrEqObject(int op_type, int n, 
> 		PyObject *amat, PyObject *mmat, PyObject *prec,
> 		double *Q, double *Qm, double *Y, int *Hpiv, double *Hlu, int ldh) {
>   CorrEqObject *self;
>   
>   /* create new CorrEqObject */
>   self = PyObject_New(CorrEqObject, &CorrEqType);
>   if (self == NULL)
>     return PyErr_NoMemory();
> 
>   /* setup work arrays */
>   self->work = PyMem_New(double, 2*n);
>   if (self->work == NULL) {
>     PyObject_Del(self);
>     return PyErr_NoMemory();
>   }
> 
>   /* set function pointers */
>   self->right = CorrEq_right;
>   self->update = CorrEq_update;
> 
>   self->op_type = op_type;
>   self->n = n;
>   self->amat = amat;
>   self->mmat = mmat;
>   self->prec = prec;
>   self->Q = Q;
>   self->Qm = Qm;
>   self->Y = Y;
>   self->Hpiv = Hpiv;
>   self->Hlu = Hlu;
>   self->ldh = ldh;
>   
>   return (PyObject *)self;  
> }
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/eigen/src/jdsym.c pysparse/pysparse/eigen/src/jdsym.c
0a1,857
> /**************************************************************************
> *                                                                         *
> *               Swiss Federal Institute of Technology (ETH)               *
> *                       CH-8092 Zuerich, Switzerland                      *
> *                                                                         *
> *                       (C) 1999 All Rights Reserved                      *
> *                                                                         *
> *                                NOTICE                                   *
> *                                                                         *
> *  Permission to use, copy, modify, and distribute this software and      *
> *  its documentation for any purpose and without fee is hereby granted    *
> *  provided that the above copyright notice appear in all copies and      *
> *  that both the copyright notice and this permission notice appear in    *
> *  supporting documentation.                                              *
> *                                                                         *
> *  Neither the Swiss Federal Institute of Technology nor the author make  *
> *  any representations about the suitability of this software for any     *
> *  purpose.  This software is provided ``as is'' without express or       *
> *  implied warranty.                                                      *
> *                                                                         *
> ***************************************************************************
> *
> *  Main routine of eigensolver
> *
> *  $Id$
> *
> *
> **************************************************************************/
> 
> 
> /****************************************************************************
>  *                                                                          *
>  * Prototypes of static functions                                           *
>  *                                                                          *
>  ****************************************************************************/
> static void print_status(int clvl, int it, int k, int j, int kmax, 
> 			 int blksize, int actblksize,
> 			 double *s, double *resnrm, int *actcorrits);
> static void quicksort(int n, double arr[], int idx[]);
> static void sorteig(int j, double S[], double U[], int ldu, double tau,
> 		    double dtemp[], int idx1[], int idx2[], int strategy);
> 
> 
> /****************************************************************************
>  *                                                                          *
>  * Main eigensolver routine                                                 *
>  *                                                                          *
>  ****************************************************************************/
> 
> static int
> jdsym (int n, double tau, double jdtol, 
>        int kmax, int jmax, int jmin, int itmax,
>        int blksize, int blkwise, 
>        PyArrayObject *V0, 
>        PyObject *linsolver,
>        int optype, 
>        int linitmax, double eps_tr, double toldecay,
>        int strategy, int clvl,
>        int *k_conv, double *Q, double *lambda, int *it, int *it_inner,
>        PyObject *amat,
>        PyObject *mmat,
>        PyObject *prec,
>        PyObject *proj) {
>   
>   /****************************************************************************
>    *                                                                          *
>    * Local variables                                                          *
>    *                                                                          *
>    ****************************************************************************/
> 
>   /* Correction equation object */
>   CorrEqObject *correq = NULL;
> 
>   /* allocatables: 
>    * initialize with NULL, so we can free even unallocated ptrs */
>   double *V = NULL, *Vtmp = NULL, *U = NULL, *Qm = NULL, *Y = NULL, 
>     *s = NULL, *Res = NULL, *resnrm = NULL, 
>     *M = NULL, *H = NULL, *Hlu = NULL, 
>     *eigwork = NULL, *temp1 = NULL, *temp2 = NULL;
> 
>   int *Hpiv = NULL, *idx1 = NULL, *idx2 = NULL, 
>     *convind = NULL, *keepind = NULL, *solvestep = NULL, 
>     *actcorrits = NULL;
> 
>   /* non-allocated ptrs */
>   double *q, *v, *u, *r, *y, *qm;
>   double *matdummy, *vecdummy;
> 
>   /* scalar vars */
>   double theta, alpha, it_tol;
> 
>   int eigworklen, found, conv, keep, act, cnt, idummy, info, ret;
>   double linres;		/* return values from linear solver */
>   int linit;
>   int k;			/* number of already converged eigenpairs */
>   int j;			/* dimension of serach subspace (matrix V) */
>   int nof_ce_its = 0;		/* number of inner iterations spent in CE */
>   int nof_ce = 0;		/* number of CE solved */
>   int actblksize;		/* current block size (may be smaller than blksize) */
>   int i;			/* look variable */
> 
>   /* variables for random number generator */
>   int IDIST = 1;
>   int ISEED[4] = {2, 3, 5, 7};
> 
>   /****************************************************************************
>    *                                                                          *
>    * Execution starts here...                                                 *
>    *                                                                          *
>    ****************************************************************************/
> 
>   /* print info header */
>   if (clvl >= 1) {
>     printf("JDSYM     Solving  %s  %s preconditioning.\n\n",
> 	   !mmat ? "A*x = lambda*x" : "A*x = lambda*M*x",
> 	   !prec ? "without" : "with");
>     printf("  N=      %10d  ITMAX=%4d\n", n, itmax);
>     printf("  KMAX=%3d  JMIN=%3d  JMAX=%3d  V0DIM=%3ld\n", 
> 	   kmax, jmin, jmax, 
> 	   V0 == NULL ? 0 : (V0->nd == 1 ? 1 : V0->dimensions[1]));
>     printf("  BLKSIZE=        %2d  BLKWISE=      %5s\n", 
> 	   blksize, blkwise ? "TRUE" : "FALSE");
>     printf("  TAU=   %11.4e  JDTOL=  %11.4e  STRATEGY= %8d\n", 
> 	   tau, jdtol, strategy);
>     printf("  OPTYPE=%12s\n", 
> 	   optype == JDSYM_OP_UNSYM ? "UNSYM" : "SYM");
>     printf("  LINITMAX=    %5d  EPS_TR=  %10.3e  TOLDECAY=%9.2e\n", 
> 	   linitmax, eps_tr, toldecay);
>     printf("\n");
>   }
> 
>   /* validate input parameters */
>   assert(0 < jdtol);
>   assert(0 < kmax && kmax <= n);
>   assert(0 < jmax && jmax <= n);
>   assert(0 < jmin && jmin < jmax);
>   assert(0 <= itmax);
>   assert(blksize <= jmin);
>   assert(blksize <= jmax - jmin);
>   assert(0 < blksize && blksize <= kmax);
>   assert(blkwise == 0 || blkwise == 1);
>   assert(optype == JDSYM_OP_UNSYM || optype == JDSYM_OP_SYM);
>   assert(0 <= linitmax);
>   assert(0.0 <= eps_tr);
>   assert(1.0 < toldecay);
>   
>   /* Get hardware-dependent values:
>    * Opt size of workspace for DSYEV is (NB+2)*j, where NB is the opt.
>    * block size... */
>   eigworklen = (2 + F77(ilaenv)(&ONE, "dsytrd", "vu", &jmax, &MONE, &MONE, &MONE, 6, 2)) * jmax;
> 
>   /*
>    * Allocate memory
>    */
> 
>   V = (double *)malloc(n * jmax * sizeof(double));
>   U = (double *)malloc(jmax * jmax * sizeof(double));
>   s = (double *)malloc(jmax * sizeof(double));
>   Res = (double *)malloc(n * blksize * sizeof(double));
>   resnrm = (double *)malloc(blksize * sizeof(double));
>   M = (double *)malloc(jmax * jmax * sizeof(double));
>   Vtmp = (double *)malloc(jmax * jmax * sizeof(double));
>   idx1 = (int *)malloc(jmax * sizeof(int));
>   idx2 = (int *)malloc(jmax * sizeof(int));
>   convind = (int *)malloc(blksize * sizeof(int));
>   keepind = (int *)malloc(blksize * sizeof(int));
>   solvestep = (int *)malloc(blksize * sizeof(int));
>   actcorrits = (int *)malloc(blksize * sizeof(int));
>   eigwork = (double *)malloc(eigworklen * sizeof(double));
>   temp1 = (double *)malloc(n * sizeof(double));
>   temp2 = (double *)malloc(n * sizeof(double));
> 
>   if (!(V && U && s && Res && resnrm && M && Vtmp && idx1 && idx2 && convind && 
> 	keepind && solvestep && actcorrits && eigwork && temp1 && temp2)) {
>     PyErr_NoMemory();
>     goto fail;
>   }
>     
>   /* Allocate matrices H, Y and G only if necessary */
>   if (prec) {
>     H = (double *)malloc(kmax * kmax * sizeof(double));
>     Hlu = (double *)malloc(kmax * kmax * sizeof(double));
>     Hpiv = (int *)malloc(kmax * sizeof(int));
>     Y = (double *)malloc(n * kmax * sizeof(double));
>     if (!(H && Hlu && Hpiv && Y)) {
>       PyErr_NoMemory();
>       goto fail;
>     }
>   }
>   
>   /* Analogous for Qm only if necessary */
>   if (mmat) { 
>     Qm = (double *)malloc(n * kmax * sizeof(double));
>     if (!Qm) {
>       PyErr_NoMemory();
>       goto fail;
>     }
>   }
> 
>   /* Create CorrEqObject */
>   correq = (CorrEqObject *)newCorrEqObject(optype, n, 
> 					   amat, mmat, prec,
> 					   Q, Qm, Y, Hpiv, Hlu, kmax);
>   if (!correq)
>     goto fail;
> 
>   /**************************************************************************
>    *                                                                        *
>    * Generate initial search subspace V. Vectors are taken from V0 and if   *
>    * necessary randomly generated.                                          *
>    *                                                                        *
>    **************************************************************************/
> 
>   /* copy V0 to V */
>   if (V0 != NULL) {
>     if (V0->nd == 1) {
>       j = 1;
>       for (i = 0; i < n; i ++)
> 	V[i] = *(double *)(V0->data + i*V0->strides[0]);
>     }
>     else {
>       j = V0->dimensions[1];
>       if (j > jmax)
> 	j = jmax;
>       for (k = 0; k < j; k ++)
> 	for (i = 0; i < n; i ++)
> 	  V[n*k + i] = *(double *)(V0->data + i*V0->strides[0] + k*V0->strides[1]);
>     }
>   } else
>     j = 0;
>   
>   /* if j < blksize: generate additional random vectors */
>   if (j < blksize) {
>     idummy = (blksize - j)*n; /* nof random numbers */
>     F77(dlarnv)(&IDIST, ISEED, &idummy, V + j*n);
>     j = blksize;
>   }
>   /* Project into user subspace */
>   if (proj)
>     for (cnt = 0; cnt < j; cnt ++)
>       Jdsym_Proj(proj, n, V + cnt*n);
>   /* (M-)orthogonalize columns of V */
>   if (!mmat) {
>     for (cnt = 0; cnt < j; cnt ++) {
>       mgs(V + cnt*n, n, cnt, V);
>       alpha = 1.0 / F77(dnrm2)(&n, V + cnt*n, &ONE);
>       F77(dscal)(&n, &alpha, V + cnt*n, &ONE);
>     }
>   }
>   else {
>     for (cnt = 0; cnt < j; cnt ++) {
>       icgsm(V + cnt*n, &alpha, n, cnt, V, mmat, temp1, temp2);
>       alpha = 1.0/alpha;
>       assert(alpha > 0.0);
>       F77(dscal)(&n, &alpha, V + cnt*n, &ONE);
>     }
>   }
>   
>   /* Generate interaction matrix M = V'*A*V. Only the upper triangle
>      is computed. */
>   for (cnt = 0; cnt < j; cnt++){
>     ret = SpMatrix_Matvec(amat, n, V+cnt*n, n, temp1);
>     assert(ret == 0);
>     idummy = cnt+1;
>     F77(dgemv)("t", &n, &idummy, &DONE, V, &n, temp1, &ONE, 
> 	       &DZER, M+cnt*jmax, &ONE, 1);
>   }
> 
>   /* Other initializations */
>   k = 0; *it = 0;
>   actblksize = blksize; 
>   for(act = 0; act < blksize; act ++)
>     solvestep[act] = 1;
> 
> 
>   /****************************************************************************
>    *                                                                          *
>    * Main JD-iteration loop                                                   *
>    *                                                                          *
>    ****************************************************************************/
> 
>   while(*it < itmax) {
> 
>     /****************************************************************************
>      *                                                                          *
>      * Solving the projected eigenproblem                                       *
>      *                                                                          *
>      * M*u = V'*A*V*u = s*u                                                     *
>      * M is symmetric, only the upper triangle is stored                        *
>      *                                                                          *
>      ****************************************************************************/
> 
>     F77(dlacpy)("u", &j, &j, M, &jmax, U, &jmax, 1);
>     F77(dsyev)("v", "u", &j, U, &jmax, s, eigwork, &eigworklen, &info, 1, 1);
>     if (info != 0) {
>       printf("jdsym: error solving the projected eigenproblem.");
>       printf(" dsyev: info = %d\n", info);
>     }
>     assert(info == 0);
>   
>     /* sort eigenpairs, such that |S(i)-tau| <= |S(i+1)-tau| for i=1..j-1 */
>     sorteig(j, s, U, jmax, tau, temp1, idx1, idx2, strategy);
> 
>     /****************************************************************************
>      *                                                                          *
>      * Convergence/Restart Check                                                *
>      *                                                                          *
>      * In case of convergence, strip off a whole block or just the converged    *
>      * ones and put 'em into Q.  Update the matrices Q, V, U, s and if          *
>      * necessary Qm, Y, and H.                                                  *
>      *                                                                          *
>      * In case of a restart update the V, U and M matrices and recompute the    *
>      * Eigenvectors                                                             *
>      *                                                                          *
>      ****************************************************************************/
> 
>     found = 1;
>     while(found) {
> 
>       /* conv/keep = Number of converged/non-converged Approximations */
>       conv = 0; keep = 0;
> 
>       for(act=0; act < actblksize; act++) {
> 
> 	/* Setting pointers for single vectors */
> 	q = Q + (act+k)*n; 
> 	u = U + act*jmax; 
> 	r = Res + act*n; 
> 	qm = Qm + (act+k)*n; 
> 	y = Y + (act+k)*n;
> 	
> 	/* Compute Ritz-Vector Q[:,k+cnt1]=V*U[:,cnt1] */
> 	theta = s[act];
> 	F77(dgemv)("n", &n, &j, &DONE, V, &n, u, &ONE, &DZER, q, &ONE, 1);
> 
> 	/* Compute the residual and update the matrix Qm if necessary. */
> 	if (!mmat){ 
> 	  /* M is Identity */
> 	  SpMatrix_Matvec(amat, n, q, n, r);
> 	  theta = -theta;
> 	  F77(daxpy)(&n, &theta, q, &ONE, r, &ONE);
> 	}
> 	else{ 
> 	  /* M is NOT Identity */
> 	  SpMatrix_Matvec(mmat, n, q, n, qm);
> 	  SpMatrix_Matvec(amat, n, q, n, r);
> 	  theta = -theta;
> 	  F77(daxpy)(&n, &theta, qm, &ONE, r, &ONE);
> 	}
> 
> 	/* Finally update matrices H, Y  if necessary */
> 	if (prec){ 
> 	  
> 	  if (mmat) {
> 	    matdummy = Qm; vecdummy = qm;    /* If M exists, then also Qm does */
> 	  }
> 	  else {
> 	    matdummy = Q; vecdummy = q;      /* Without M, no Qm */
> 	  }
> 
> 	  /* Calculate y = inv(K)*qm */
> 	  SpMatrix_Precon(prec, n, vecdummy, y);
> 
> 	  /* update H, starting with the column ... */
> 	  idummy=k+act+1;
> 	  F77(dgemv)("t", &n, &idummy, &DONE, matdummy, &n, y, &ONE, &DZER, 
> 		     H+(k+act)*kmax, &ONE, 1);
> 
> 	  /* ... and then the row */
> 	  F77(dgemv)("t", &n, &idummy, &DONE, Y, &n, vecdummy, &ONE, &DZER, 
> 		     H+(k+act), &kmax, 1);
> 	}
> 
> 	/* Compute norm of the residual and update arrays convind/keepind*/
> 	resnrm[act] = F77(dnrm2)(&n, r, &ONE);
> 	if (resnrm[act] < jdtol)
> 	  { convind[conv] = act; conv = conv + 1; }
> 	else
> 	  { keepind[keep] = act; keep = keep + 1; }
> 	
>       }  /* for(act = 0; act < actblksize; act ++) */
> 
>       /* Check whether the blkwise-mode is chosen and ALL the
> 	 approximations converged, or whether the strip-off mode is
> 	 active and SOME of the approximations converged */
> 
>       found = ((blkwise==1 && conv==actblksize) || (blkwise==0 && conv!=0)) 
> 	&& (j > actblksize || k == kmax - actblksize);
>       
>       /***************************************************************************
> 	*                                                                        *
> 	* Convergence Case                                                       *
> 	*                                                                        *
> 	* In case of convergence, strip off a whole block or just the converged  *
> 	* ones and put 'em into Q.  Update the matrices Q, V, U, s and if        *
> 	* necessary Qm, Y, and H.                                                *
> 	*                                                                        *
> 	**************************************************************************/
> 
>       if (found) {
> 
> 	/* Store Eigenvalues */
> 	for(act = 0; act < conv; act++)
> 	  lambda[k+act] = s[convind[act]];
> 	 
> 	/* Re-use non approximated Ritz-Values */
> 	for(act = 0; act < keep; act++)
> 	  s[act] = s[keepind[act]];
> 
> 	/* Shift the others in the right position */
> 	for(act = 0; act < (j-actblksize); act ++)
> 	  s[act+keep] = s[act+actblksize];
> 
> 	/* Update V. Re-use the V-Vectors not looked at yet. */
> 	idummy = j - actblksize;
> 	for (act = 0; act < n; act = act + jmax) {
> 	  cnt = act + jmax > n ? n-act : jmax;
> 	  F77(dlacpy)("a", &cnt, &j, V+act, &n, Vtmp, &jmax, 1);
> 	  F77(dgemm)("n", "n", &cnt, &idummy, &j, &DONE, Vtmp, 
> 		     &jmax, U+actblksize*jmax, &jmax, &DZER, V+act+keep*n, &n, 1, 1);
> 	}
> 
> 	/* Insert the not converged approximations as first columns in V */
> 	for(act = 0; act < keep; act++){
> 	  F77(dlacpy)("a",&n,&ONE,Q+(k+keepind[act])*n,&n,V+act*n,&n,1);
> 	}
> 
> 	/* Store Eigenvectors */
> 	for(act = 0; act < conv; act++)
> 	  F77(dlacpy)("a",&n,&ONE,Q+(k+convind[act])*n,&n,Q+(k+act)*n,&n,1);
> 
> 	/* Update Qm if necessary */
> 	if (mmat){
> 	  for(act = 0; act < conv; act++)
> 	    F77(dlacpy)("a",&n,&ONE,Qm+(k+convind[act])*n,&n,Qm+(k+act)*n,&n,1);
> 	}
> 
> 	/* Update H and Y if necessary */
> 	if (prec){
> 	  for(act = 0; act < conv; act++)   /* Y */
> 	    F77(dlacpy)("a",&n,&ONE,Y+(k+convind[act])*n,&n,Y+(k+act)*n,&n,1);
> 
> 	  for(act=0; act < conv; act++){   /* H */
> 	    idummy = k + act;
> 	    /* Copy column ... */
> 	    F77(dlacpy)("a",&idummy,&ONE,H+(k+convind[act])*kmax,&kmax,H+idummy*kmax,&kmax,1);
> 	    /* ... diagonalelement ... */
> 	    H[idummy*(kmax+1)]=H[(k+convind[act])*(kmax+1)];
> 	    /* ... and row */
> 	    F77(dlacpy)("a",&ONE,&idummy,H+(k+convind[act]),&kmax,H+idummy,&kmax,1);
> 	  }
> 	}
> 
> 	/* Update SearchSpaceSize j */
> 	j = j - conv;
> 
> 	/* Let M become a diagonal matrix with the Ritzvalues as entries ... */ 
> 	F77(dlaset)("u", &j, &j, &DZER, &DZER, M, &jmax, 1);
> 	for (act = 0; act < j; act++)
> 	  M[act*jmax + act] = s[act];
> 	
> 	/* ... and U the Identity(jnew,jnew) */
> 	F77(dlaset)("a", &j, &j, &DZER, &DONE, U, &jmax, 1);
> 
> 	/* Avoid computation of zero eigenvalues:
> 
> 	   If STRATEGY == 1: set tau to the largest of the now
> 	   converged eigenvalues.
> 
> 	   Warning: This may not work well if BLKSIZE > 1. */
> 	if (strategy == 1)
> 	  for(act = 0; act < conv; act ++)
> 	    if (lambda[k+act] > tau)
> 	      tau = lambda[k+act];
> 
> 	/* Update Converged-Eigenpair-counter and Pro_k */
> 	k = k + conv;
> 
> 	/* Update the new blocksize */
> 	actblksize = blksize < kmax-k ? blksize : kmax-k;
> 
> 	/* Exit main iteration loop when kmax eigenpairs have been
>            approximated */
> 	if (k == kmax)
> 	  goto end;
> 
> 	/* Counter for the linear-solver-accuracy */
> 	for(act = 0; act < keep; act++)
> 	  solvestep[act] = solvestep[keepind[act]];
> 
> 	for(act = keep; act < blksize; act++)
> 	  solvestep[act] = 1;
> 
>       } /* if(found) */
>       
>       /**************************************************************************
>        *                                                                        *
>        * Restart                                                                *
>        *                                                                        *
>        * The Eigenvector-Aproximations corresponding to the first jmin          *
>        * Petrov-Vectors are kept.  if (j+actblksize > jmax) {                   *
>        *                                                                        *
>        **************************************************************************/
>       if (j+actblksize > jmax) {
> 
> 	idummy = j; j = jmin;
> 
> 	for (act = 0; act < n; act = act + jmax) { /* V = V * U(:,1:j) */
> 	  cnt = act+jmax > n ? n-act : jmax;
> 	  F77(dlacpy)("a", &cnt, &idummy, V+act, &n, Vtmp, &jmax, 1);
> 	  F77(dgemm)("n", "n", &cnt, &j, &idummy, &DONE, Vtmp, 
> 		     &jmax, U, &jmax, &DZER, V+act, &n, 1, 1);
> 	}
> 	  
> 	F77(dlaset)("a", &j, &j, &DZER, &DONE, U, &jmax, 1);
> 	F77(dlaset)("u", &j, &j, &DZER, &DZER, M, &jmax, 1);
> 	for (act = 0; act < j; act++)
> 	  M[act*jmax + act] = s[act];
>       }
> 
>     } /* while(found) */    
> 
> 
>     /****************************************************************************
>      *                                                                          *
>      * Solving the correction equations                                         *
>      *                                                                          *
>      * Depending on the input-arguments we choose an appropriate lin.solver.    *
>      *                                                                          *
>      ****************************************************************************/
> 
> 
>     /* calculate Hlu (LU-factorization), if necessary */
>     if (prec){
>       idummy = k + actblksize;
>       F77(dlacpy)("a", &idummy, &idummy, H, &kmax, Hlu, &kmax, 1); 
>       F77(dgetrf)(&idummy, &idummy, Hlu, &kmax, Hpiv, &info);
>       if (info != 0)
> 	printf("jdsym: factorization of H failed: info=%d\n", info);
>       assert(info == 0);
>     }
> 
>     /* Solve actblksize times the correction equation ... */
>     for (act = 0; act < actblksize; act ++) {      
> 
>       /* Setting start-value for vector v as zeros(n,1). Guarantees
>          (M-)orthogonality */
>       v = V + j*n;
>       for (cnt = 0; cnt < n; cnt ++) 
> 	v[cnt] = 0.0;
> 
>       /* Adaptive accuracy and shift for the lin.solver. In case the
> 	 residual is big, we don't need a too precise solution for the
> 	 correction equation, since even in exact arithmetic the
> 	 solution wouldn't be too useful for the Eigenproblem. */
>       r = Res + act*n;
> 
>       if (resnrm[act] < eps_tr)
> 	correq->update(correq, k + actblksize, s[act]);
>       else
> 	correq->update(correq, k + actblksize, tau);
>       
>       it_tol = pow(toldecay, (double)(-solvestep[act]));
>       solvestep[act] = solvestep[act] + 1;
> 
>       /* Form the right hand side of the correction equation */
>       correq->right(correq, r);
>       
>       /* Solve the correction equation ... */
>       ret = ItSolvers_Solve(linsolver, (PyObject *)correq, n, 
> 			    r, v, it_tol, linitmax, (PyObject *)correq, 
> 			    &info, &linit, &linres);
>       if (ret == -1)
> 	goto fail;
>       
>       /* Actualizing profiling data */
> /*#warning error check after iteative solver?*/
>       nof_ce ++;
>       nof_ce_its += linit;
>       actcorrits[act] = linit;
> 
>       /* (M-)orthonormalize v to Q, project into user subspace and
>          finally (M-)orthonormalize to V
> 
> 	 (M-)orthonormalize v to Q is necessary, because the implicit
> 	 orthogonalization in the solvers may be too inaccurate.
> 	 IteratedCGS is used to prevent numerical breakdown */
>       if (mmat) {
> 	mgsm(v, n, k+actblksize, Q, Qm);
> 	if (proj) 
> 	  Jdsym_Proj(proj, n, v);
> 	icgsm(v, &alpha, n, j, V, mmat, temp1, temp2);
>       }
>       else {
> 	mgs(v, n, k+actblksize, Q);
> 	if (proj) 
> 	  Jdsym_Proj(proj, n, v);
> 	icgs(v, &alpha, n, j, V, temp1);
>       }
> 
>       alpha = 1.0 / alpha;
>       F77(dscal)(&n, &alpha, v, &ONE);
>       
>       /* update interaction matrix M */
>       SpMatrix_Matvec(amat, n, v, n, temp1);
>       idummy = j+1;
>       F77(dgemv)("t", &n, &idummy, &DONE, V, &n, temp1, &ONE, 
> 		 &DZER, M+j*jmax, &ONE, 1);
>       
>       /* Increasing SearchSpaceSize j */
>       j ++;
>     }   /* for (act = 0;act < actblksize; act ++) */    
> 
>     /* Print information line */
>     print_status(clvl, *it, k, j - blksize, kmax, blksize, actblksize, 
> 		 s, resnrm, actcorrits);    
> 
>     /* Increase iteration-counter for outer loop  */
>     (*it) ++;
> 
>   } /* Main iteration loop */
>   
>  end:
> 
>   /******************************************************************
>    *                                                                *
>    * Eigensolutions converged or iteration limit reached            *
>    *                                                                *
>    * Print statistics. Free memory. Return.                         *
>    *                                                                *
>    ******************************************************************/
> 
>   *k_conv = k;
>   *it_inner = nof_ce_its;
>   if (clvl >= 1) {
>     printf("\nJDSYM execution statistics\n\n");
>     printf("IT_OUTER=%d   IT_INNER_TOT=%d   IT_INNER_AVG=%8.2f   IT_INNER_PER_OUTER=%8.2f\n",
> 	   (*it), nof_ce_its, (double)nof_ce_its/(*it), (double)nof_ce_its/nof_ce);
>     printf("\nConverged eigensolutions in order of convergence:\n");
>     printf("\n  I              LAMBDA(I)      RES(I)\n");
>     printf("---------------------------------------\n");
>     
>     for (act = 0; act < *k_conv; act ++) {
>       /* Compute the residual for solution act */
>       q = Q + act*n; qm = Qm + act*n;
>       theta = -lambda[act];
>       ret = SpMatrix_Matvec(amat, n, q, n, r);
>       assert(ret == 0);
>       if (!mmat)
> 	F77(daxpy)(&n, &theta, q, &ONE, r, &ONE);
>       else { 
> 	ret = SpMatrix_Matvec(mmat, n, q, n, qm);
> 	assert(ret == 0);
> 	F77(daxpy)(&n, &theta, qm, &ONE, r, &ONE);
>       }
>       printf("%3d %22.15e %12.5e\n", act+1, lambda[act],
> 	     F77(dnrm2)(&n, r, &ONE));
>     }
>     printf("\n");
>   }
> 
>   free(V); free(Vtmp); free(U); free(Qm); free(Y); 
>   free(s); free(Res); free(resnrm); 
>   free(M); free(H); free(Hlu); 
>   free(eigwork); free(temp1); free(temp2);
>   free(Hpiv); free(idx1); free(idx2); 
>   free(convind); free(keepind); free(solvestep); free(actcorrits);
>   Py_DECREF(correq);
>   return 0;
> 
>  fail:
>   free(V); free(Vtmp); free(U); free(Qm); free(Y); 
>   free(s); free(Res); free(resnrm); 
>   free(M); free(H); free(Hlu); 
>   free(eigwork); free(temp1); free(temp2);
>   free(Hpiv); free(idx1); free(idx2); 
>   free(convind); free(keepind); free(solvestep); free(actcorrits);
>   Py_XDECREF(correq);
>   return -1;
> } /* jdsym(.....) */
> 
> 
> /****************************************************************************
>  *                                                                          *
>  * Supporting functions                                                     *
>  *                                                                          *
>  ****************************************************************************/
> 
> /* PRINT_STATUS - print status line (called for each outer iteration)
>  */
> static void print_status(int clvl, int it, int k, int j, int kmax, 
> 			 int blksize, int actblksize,
> 			 double *s, double *resnrm, int *actcorrits) {
>   const int max_vals = 5;
> 
>   int i, idummy;
> 
>   if (clvl >= 1) {
>     if (blksize == 1) {
>       if (it == 0) {
> 	printf("  IT   K   J       RES CGIT RITZVALS(1:5)\n");
> 	idummy = 27 + ( 13 > max_vals*10 ? 13 : max_vals*10);
> 	for (i = 0; i < idummy; i ++)
> 	  putchar('-');
> 	printf("\n");
>       }
>       printf("%4d %3d %3d %9.2e %4d", it + 1, k, j, resnrm[0], actcorrits[0]);
>       for (i = 0; i < (j < max_vals ? j : max_vals); i ++)
> 	printf(" %9.2e", s[i]);
>       printf("\n");
>     }
>     else {			/* blksize > 1 */
>       if (it == 0) {
> 	printf("  IT   K   J RITZVALS ");
> 	for (i = 1; i < actblksize; i ++)
> 	  printf("          ");
> 	printf("   RES      ");
> 	for (i = 1; i < actblksize; i ++)
> 	  printf("          ");
> 	printf("   CGIT\n");
> 	idummy = 12 + 4 + blksize*(10 + 10 + 5);
> 	for (i = 0; i < idummy; i ++)
> 	  putchar('-');
> 	printf("\n");
>       }
>       printf("%4d %3d %3d", it + 1, k, j);
>       for (i = 0; i < blksize; i ++)
> 	if (i < actblksize)
> 	  printf(" %9.2e", s[i]);
> 	else
> 	  printf("          ");
>       printf("  ");
>       for (i = 0; i < blksize; i ++)
> 	if (i < actblksize)
> 	  printf(" %9.2e", resnrm[i]);
> 	else
> 	  printf("          ");
>       printf("  ");
>       for (i = 0; i < blksize; i ++)
> 	if (i < actblksize)
> 	  printf(" %4d", actcorrits[i]);
> 	else
> 	  printf("     ");
>       printf("\n");
>     }
>   }
> }
> 
> /*
>  * SORTEIG
>  *
>  * Default behaviour (strategy == 0):
>  *
>  *   Sort eigenpairs (S(i),U(:,i)), such that 
>  *
>  *       |S(i) - tau| <= |S(i+1) -tau| for i=1..j-1.
>  *
>  *     j  : dimension of S
>  *     ldu: leading dimension of U
>  *   dtemp: double array of length j
>  *     idx: int array of length j
>  *
>  * Alternate behaviour (strategy == 1):
>  *
>  *   Same as above but put all S(i) < tau to the end. This is used to
>  *   avoid computation of zero eigenvalues.
>  */
> 
> static void sorteig(int j, double S[], double U[], int ldu, double tau,
> 		    double dtemp[], int idx1[], int idx2[], int strategy)
> {
>   int i;
> 
>   /* setup vector to be sorted and index vector */
>   switch (strategy) {
>   case 0:
>     for (i = 0; i < j; i ++)
>       dtemp[i] = fabs(S[i] - tau);
>     break;
>   case 1:
>     for (i = 0; i < j; i ++)
>       if (S[i] < tau)
> 	dtemp[i] = DBL_MAX;
>       else
> 	dtemp[i] = fabs(S[i] - tau);
>     break;
>   default:
>     assert(0);
>   }
>   for (i = 0; i < j; i ++)
>     idx1[i] = i;
> 
>   /* sort dtemp in ascending order carrying itemp along */
>   quicksort(j, dtemp, idx1);
> 
>   /* compute 'inverse' index vector */
>   for (i = 0; i < j; i ++)
>     idx2[idx1[i]] = i;
> 
>   /* sort eigenvalues */
>   memcpy(dtemp, S, j * sizeof(double));
>   for (i = 0; i < j; i ++)
>     S[i] = dtemp[idx1[i]];
> 
>   /* sort eigenvectors (in place) */
>   for (i = 0; i < j; i ++) {
>     if (i != idx1[i]) {
>       memcpy(dtemp, U+i*ldu, j*sizeof(double));
>       memcpy(U+i*ldu, U+idx1[i]*ldu, j*sizeof(double));
>       memcpy(U+idx1[i]*ldu, dtemp, j*sizeof(double));
>       idx1[idx2[i]] = idx1[i];
>       idx2[idx1[i]] = idx2[i];
>     }
>   }
> }
> 
> 
> /* 
>  * QUICKSORT 
>  *
>  * Sorts a double array using a non-recursive quicksort algorithm in
>  * ascending order carrying along an int array.
>  *  
>  */
> 
> static void quicksort(int n, double arr[], int idx[])
> {
>   double v, td;
>   int i, j, l, r, ti, tos, stack[32];
>   
>   l = 0; r = n-1; tos = -1;
>   for (;;)
>     {
>       while (r > l)
> 	{ 
> 	  v = arr[r]; i = l; j = r-1;
> 	  for (;;)
> 	    { 
> 	      while (arr[i] < v) i ++;
> 	      /* j > l prevents underflow */
> 	      while (arr[j] >= v && j > l) j --;
> 	      if (i >= j) break;
> 	      td = arr[i]; arr[i] = arr[j]; arr[j] = td;
> 	      ti = idx[i]; idx[i] = idx[j]; idx[j] = ti;
> 	    }
> 	  td = arr[i]; arr[i] = arr[r]; arr[r] = td;
> 	  ti = idx[i]; idx[i] = idx[r]; idx[r] = ti;
> 	  if (i-l > r-i)
> 	    { stack[++tos] = l; stack[++tos] = i-1; l = i+1; }
> 	  else
> 	    { stack[++tos] = i+1; stack[++tos] = r; r = i-1; }
> 	  assert(tos < 32);
> 	} 
>       if (tos == -1) break;
>       r = stack[tos--]; l = stack[tos--]; 
>     }
> }
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/eigen/src/orthopack.c pysparse/pysparse/eigen/src/orthopack.c
0a1,155
> /**************************************************************************
> *                                                                         *
> *               Swiss Federal Institute of Technology (ETH),              *
> *                       CH-8092 Zuerich, Switzerland                      *
> *                                                                         *
> *                       (C) 1999 All Rights Reserved                      *
> *                                                                         *
> *                                NOTICE                                   *
> *                                                                         *
> *  Permission to use, copy, modify, and distribute this software and      *
> *  its documentation for any purpose and without fee is hereby granted    *
> *  provided that the above copyright notice appear in all copies and      *
> *  that both the copyright notice and this permission notice appear in    *
> *  supporting documentation.                                              *
> *                                                                         *
> *  Neither the Swiss Federal Institute of Technology nor the author make  *
> *  any representations about the suitability of this software for any     *
> *  purpose.  This software is provided ``as is'' without express or       *
> *  implied warranty.                                                      *
> *                                                                         *
> ***************************************************************************
> *
> *  Routines for Orthogonalization and B-Orthogonalization
> *
> *  $Id$
> *
> *
> **************************************************************************/
> 
> 
> /******************************************************************************
>  *                                                                            *
>  * ICGS -- Iterated Classical Gram-Schmidt Orthogonalization                  *
>  *                                                                            *
>  * Orthogonalizes u against the columns of Q.                                 *
>  *                                                                            *
>  ******************************************************************************/
> 
> static void
> icgs(double *u, double *unrm, int n, int m, double *A, 
>      double *um) {
> 
>   const int maxcgsit = 5;
>   const double alpha = 0.5;
> 
>   double unrm_old;
>   int i, isorth = 0;
> 
>   *unrm = F77(dnrm2)(&n, u, &ONE);
> 
>   if (m == 0)
>     return;
> 
>   for (i = 0; !isorth && i < maxcgsit; i ++) {
>     
>     F77(dgemv)("t", &n, &m,  &DONE, A, &n, u, &ONE, &DZER, um, &ONE, 1);
>     F77(dgemv)("n", &n, &m, &DMONE, A, &n, um, &ONE, &DONE, u, &ONE, 1);
>     
>     unrm_old = (*unrm);
>     *unrm = F77(dnrm2)(&n, u, &ONE);
>     
>     isorth=((*unrm) > alpha*unrm_old);
>   }
>   if (i >= maxcgsit) {
>     printf("warning: loss of orthogonality. ");
>     printf("icgs() not converged after %d steps.\n", maxcgsit);
>   }
> }
> 
> /******************************************************************************
>  *                                                                            *
>  * ICGSM -- Iterated Classical M-orthogonal Gram-Schmidt                      *
>  *                                                                            *
>  * M-orthogonalizes u against the columns of Q.                               *
>  *                                                                            *
>  ******************************************************************************/
> 
> static void 
> icgsm(double *u, double *unrm, int n, int m, double *Q, 
>       PyObject *mmat,
>       double *um, double *temp) {
> 
>   const int maxcgsit = 5;
>   const double alpha = 0.5;
> 
>   double unrm_old;
>   int ret, i, isorth = 0;
> 
>   ret = SpMatrix_Matvec(mmat, n, u, n, um);
>   assert(ret == 0);
>   *unrm = sqrt(F77(ddot)(&n, u, &ONE, um, &ONE));
> 
>   if (m == 0)
>     return;
> 	  
>   for (i = 0; !isorth && i < maxcgsit; i ++) {
> 
>     F77(dgemv)("t", &n, &m,  &DONE, Q, &n, um, &ONE, &DZER, temp, &ONE, 1);
>     F77(dgemv)("n", &n, &m, &DMONE, Q, &n, temp, &ONE, &DONE, u, &ONE, 1);
> 
>     ret = SpMatrix_Matvec(mmat, n, u, n, um);
>     assert(ret == 0);
> 
>     unrm_old = (*unrm);
>     *unrm = sqrt(F77(ddot)(&n, u, &ONE, um, &ONE));
> 
>     isorth=((*unrm) > alpha*unrm_old);
>   }
>   if (i >= maxcgsit) {
>     printf("warning: loss of orthogonality. ");
>     printf("icgsm() not converged after %d steps.\n", maxcgsit);
>   }
> }
> 
> 
> 
> /******************************************************************************
>  *                                                                            *
>  * MGS -- Modified Gram-Schmidt                                               *
>  *                                                                            *
>  * Orthogonlaizes v with respect to span{A[:,1:m]}                            *
>  *                                                                            *
>  ******************************************************************************/
> 
> static void 
> mgs(double *u, int n, int m, double *Q) {
> 
>   int i;
>   double s;
>   
>   for (i = 0; i < m; i ++) {
>     s = - F77(ddot)(&n, Q+i*n, &ONE, u, &ONE);
>     F77(daxpy)(&n, &s, Q+i*n, &ONE, u, &ONE);
>   }
> }
> 
> /******************************************************************************
>  *                                                                            *
>  * MGSM -- Modified M-orthogonal GramSchmidt                                  *
>  *                                                                            *
>  * M-Orthogonalizes u against the columns of Q.                               *
>  *                                                                            *
>  ******************************************************************************/
> 
> static void 
> mgsm(double *u, int n, int m, double *Q, double *QM) {
> 
>   int i;
>   double s;
> 
>   for (i = 0; i < m; i ++) {
>     s = - F77(ddot)(&n, QM+i*n, &ONE, u, &ONE);
>     F77(daxpy)(&n, &s, Q+i*n, &ONE, u, &ONE);
>   }
> }
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/include/bicgstab.h pysparse/pysparse/include/bicgstab.h
0a1,18
> #ifndef BICGSTAB_H
> #define BICGSTAB_H
> 
> #include "Python.h"
> 
> int Itsolvers_bicgstab_kernel(int n, 
> 			      double *x, 
> 			      double *b,
> 			      double tol, 
> 			      int maxit,
> 			      int clvl,
> 			      int *iter, 
> 			      double *relres, 
> 			      int *flag,
> 			      double *work,
> 			      PyObject *mat_obj,
> 			      PyObject *prec_obj);
> #endif
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/include/blas.h pysparse/pysparse/include/blas.h
0a1,371
> #ifndef _BLAS_H
> #define _BLAS_H
> 
> #include "fortran.h"
> 
> #define integer                     int
> #define real                        float
> #define doublereal                  double
> #define character                   char
> #define logical                     int
> #define ftnlen                      int
> typedef struct { real r, i; } complex;
> typedef struct { doublereal r, i; } doublecomplex;
> 
> 
> complex              F77(cdotc)(integer *,complex *,integer *,complex *,integer *),
>                      F77(cdotu)(integer *,complex *,integer *,complex *,integer *);
> void                 F77(caxpy)(integer *,complex *,complex *,integer *,complex *,
>                            integer *),
>                      F77(ccopy)(integer *,complex *,integer *,complex *,integer *),
>                      F77(cgbmv)(character *,integer *,integer *,integer *,integer *,
>                            complex *, complex *,integer *,complex *,integer *,
>                            complex *,complex *,integer *,ftnlen),
>                      F77(cgemm)(character *,character *,integer *,integer *,
>                            integer *,complex *,complex *,integer *,complex *,
>                            integer *,complex *,complex *,integer *,ftnlen,
>                            ftnlen),
>                      F77(cgemv)(character *,integer *,integer *,complex *,complex *,
>                            integer *,complex *,integer *,complex *,complex *,
>                            integer *,ftnlen),
>                      F77(cgerc)(integer *,integer *,complex *,complex *,integer *,
>                            complex *,integer *,complex *,integer *),
>                      F77(cgeru)(integer *,integer *,complex *,complex *,integer *,
>                            complex *,integer *,complex *,integer *),
>                      F77(chbmv)(character *,integer *,integer *,complex *,complex *,
>                            integer *,complex *,integer *,complex *,complex *,
>                            integer *,ftnlen),
>                      F77(chemm)(character *,character *,integer *,integer *,
>                            complex *,complex *,integer *,complex *,integer *,
>                            complex *,complex *,integer *,ftnlen,ftnlen),
>                      F77(chemv)(character *,integer *,complex *,complex *,integer *,
>                            complex *,integer *,complex *,complex *,integer *,
>                            ftnlen),
>                      F77(cher)(character *,integer *,real *,complex *,integer *,
>                           complex *,integer *,ftnlen),
>                      F77(cher2)(character *,integer *,complex *,complex *,integer *,
>                            complex *,integer *,complex *,integer *,ftnlen),
>                      F77(cher2k)(character *,character *,integer *,integer *,
>                             complex *,complex *,integer *,complex *,integer *,
>                             real *,complex *,integer *,ftnlen,ftnlen),
>                      F77(cherk)(character *,character *,integer *,integer *,real *,
>                            complex *,integer *,real *,complex *,integer *,
>                            ftnlen,ftnlen),
>                      F77(chpmv)(character *,integer *,complex *,complex *,complex *,
>                            integer *,complex *,complex *,integer *,ftnlen),
>                      F77(chpr)(character *,integer *,real *,complex *,integer *,
>                           complex *,ftnlen),
>                      F77(chpr2)(character *,integer *,complex *,complex *,integer *,
>                            complex *,integer *,complex *,ftnlen),
>                      F77(crotg)(complex *,complex *,real *,complex *),
>                      F77(cscal)(integer *,complex *,complex *,integer *),
>                      F77(csscal)(integer *,real *,complex *,integer *),
>                      F77(cswap)(integer *,complex *,integer *,complex *,integer *),
>                      F77(csymm)(character *,character *,integer *,integer *,
>                            complex *,complex *,integer *,complex *,integer *,
>                            complex *,complex *,integer *,ftnlen,ftnlen),
>                      F77(csyr2k)(character *,character *,integer *,integer *,
>                             complex *,complex *,integer *,complex *,integer *,
>                             complex *,complex *,integer *,ftnlen,ftnlen),
>                      F77(csyrk)(character *,character *,integer *,integer *,
>                            complex *,complex *,integer *,complex *,complex *,
>                            integer *,ftnlen,ftnlen),
>                      F77(ctbmv)(character *,character *,character *,integer *,
>                            integer *,complex *,integer *,complex *,integer *,
>                            ftnlen,ftnlen,ftnlen),
>                      F77(ctbsv)(character *,character *,character *,integer *,
>                            integer *,complex *,integer *,complex *,integer *,
>                            ftnlen,ftnlen,ftnlen),
>                      F77(ctpmv)(character *,character *,character *,integer *,
>                            complex *,complex *,integer *,ftnlen,ftnlen,ftnlen),
>                      F77(ctpsv)(character *,character *,character *,integer *,
>                            complex *,complex *,integer *,ftnlen,ftnlen,ftnlen),
>                      F77(ctrmm)(character *,character *,character *,character *,
>                            integer *,integer *,complex *,complex *,integer *,
>                            complex *,integer *,ftnlen,ftnlen,ftnlen,ftnlen),
>                      F77(ctrmv)(character *,character *,character *,integer *,
>                            complex *,integer *,complex *,integer *,ftnlen,
>                            ftnlen,ftnlen),
>                      F77(ctrsm)(character *,character *,character *,character *,
>                            integer *,integer *,complex *,complex *,integer *,
>                            complex *,integer *,ftnlen,ftnlen,ftnlen,ftnlen),
>                      F77(ctrsv)(character *,character *,character *,integer *,
>                            complex *,integer *,complex *,integer *,ftnlen,
>                            ftnlen,ftnlen);
> 
> doublereal           F77(dasum)(integer *,doublereal *,integer *);
> void                 F77(daxpy)(integer *,doublereal *,doublereal *,integer *,
>                            doublereal *,integer *);
> doublereal           F77(dcabs1)(doublecomplex *);
> void                 F77(dcopy)(integer *,doublereal *,integer *,doublereal *,
>                            integer *);
> doublereal           F77(ddot)(integer *,doublereal *,integer *,doublereal *,
>                           integer *);
> void                 F77(dgbmv)(character *,integer *,integer *,integer *,integer *,
>                            doublereal *,doublereal *,integer *,doublereal *,
>                            integer *,doublereal *,doublereal *,integer *,
>                            ftnlen),
>                      F77(dgemm)(character *,character *,integer *,integer *,
>                            integer *,doublereal *,doublereal *,integer *,
>                            doublereal *,integer *,doublereal *,doublereal *,
>                            integer *,ftnlen,ftnlen),
>                      F77(dgemv)(character *,integer *,integer *,doublereal *,
>                            doublereal *,integer *,doublereal *,integer *,
>                            doublereal *,doublereal *,integer *,ftnlen),
>                      F77(dger)(integer *,integer *,doublereal *,doublereal *,
>                           integer *,doublereal *,integer *,doublereal *,
>                           integer *);
> doublereal           F77(dnrm2)(integer *,doublereal *,integer *);
> void                 F77(drot)(integer *,doublereal *,integer *,doublereal *,
>                           integer *,doublereal *,doublereal *),
>                      F77(drotg)(doublereal *,doublereal *,doublereal *,
>                            doublereal *),
>                      F77(dsbmv)(character *,integer *,integer *,doublereal *,
>                            doublereal *,integer *,doublereal *,integer *,
>                            doublereal *,doublereal *,integer *,ftnlen),
>                      F77(dscal)(integer *,doublereal *,doublereal *,integer *),
>                      F77(dspmv)(character *,integer *,doublereal *,doublereal *,
>                            doublereal *,integer *,doublereal *,doublereal *,
>                            integer *,ftnlen),
>                      F77(dspr)(character *,integer *,doublereal *,doublereal *,
>                           integer *,doublereal *,ftnlen),
>                      F77(dspr2)(character *,integer *,doublereal *,doublereal *,
>                            integer *,doublereal *,integer *,doublereal *,
>                            ftnlen),
>                      F77(dswap)(integer *n,doublereal *,integer *,doublereal *,
>                            integer *),
>                      F77(dsymm)(character *,character *,integer *,integer *,
>                            doublereal *,doublereal *,integer *,doublereal *,
>                            integer *,doublereal *,doublereal *,integer *,
>                            ftnlen,ftnlen),
>                      F77(dsymv)(character *,integer *,doublereal *,doublereal *,
>                            integer *,doublereal *,integer *,doublereal *,
>                            doublereal *,integer *,ftnlen),
>                      F77(dsyr)(character *,integer *,doublereal *,doublereal *,
>                           integer *,doublereal *,integer *,ftnlen),
>                      F77(dsyr2)(character *,integer *,doublereal *,doublereal *,
>                            integer *,doublereal *,integer *,doublereal *,
>                            integer *,ftnlen),
>                      F77(dsyr2k)(character *,character *,integer *,integer *,
>                             doublereal *,doublereal *,integer *,doublereal *,
>                             integer *,doublereal *,doublereal *,integer *,
>                             ftnlen,ftnlen),
>                      F77(dsyrk)(character *,character *,integer *,integer *,
>                            doublereal *,doublereal *,integer *,doublereal *,
>                            doublereal *,integer *,ftnlen,ftnlen),
>                      F77(dtbmv)(character *,character *,character *,integer *,
>                            integer *,doublereal *,integer *,doublereal *,
>                            integer *,ftnlen,ftnlen,ftnlen),
>                      F77(dtbsv)(character *,character *,character *,integer *,
>                            integer *,doublereal *,integer *,doublereal *,
>                            integer *,ftnlen,ftnlen,ftnlen),
>                      F77(dtpmv)(character *,character *,character *,integer *,
>                            doublereal *,doublereal *,integer *,ftnlen,ftnlen,
>                            ftnlen),
>                      F77(dtpsv)(character *,character *,character *,integer *,
>                            doublereal *,doublereal *,integer *,ftnlen,ftnlen,
>                            ftnlen),
>                      F77(dtrmm)(character *,character *,character *,character *,
>                            integer *,integer *,doublereal *,doublereal *,
>                            integer *,doublereal *,integer *,ftnlen,ftnlen,
>                            ftnlen,ftnlen),
>                      F77(dtrmv)(character *,character *,character *,integer *,
>                            doublereal *,integer *,doublereal *,integer *,
>                            ftnlen,ftnlen,ftnlen),
>                      F77(dtrsm)(character *,character *,character *,character *,
>                            integer *,integer *,doublereal *,doublereal *,
>                            integer *,doublereal *,integer *,ftnlen,ftnlen,
>                            ftnlen,ftnlen),
>                      F77(dtrsv)(character *,character *,character *,integer *,
>                            doublereal *,integer *,doublereal *,integer *,
>                            ftnlen,ftnlen,ftnlen);
> doublereal           F77(dzasum)(integer *,doublecomplex *,integer *),
>                      F77(dznrm2)(integer *, doublecomplex *,integer *);
> 
> real                 F77(sasum)(integer *,real *,integer *),
>                      F77(scasum)(integer *,complex *,integer *),
>                      F77(snrm2)(integer *,real *,integer *),
>                      F77(scnrm2)(integer *,complex *,integer *),
>                      F77(sdot)(integer *,real *,integer *,real *,integer *);
> extern void          F77(sgemm)(character *,character *,integer *,integer *, 
>                            integer *,real *,real *,integer *,real *,integer *,
>                            real *,real *,integer *,ftnlen,ftnlen),
>                      F77(sscal)(integer *,real *,real *,integer *),
>                      F77(ssyr)(character *,integer *,real *,real *,integer *,real *,
>                           integer *,ftnlen),
>                      F77(stpsv)(character *,character *,character *,integer *, 
>                            real *,real *,integer *,ftnlen,ftnlen,ftnlen),
>                      F77(saxpy)(integer *,real *,real *,integer *,real *,integer *),
>                      F77(sgemv)(character *,integer *,integer *,real *,real *,
>                            integer *,real *,integer *,real *,real *,integer *,
>                            ftnlen),
>                      F77(sspmv)(character *,integer *,real *,real *,real *,
>                            integer *,real *,real *,integer *,ftnlen),
>                      F77(ssyr2)(character *,integer *,real *,real *,integer *,
>                            real *,integer *,real *,integer *,ftnlen),
>                      F77(strmm)(character *,character *,character *,character *, 
>                            integer *,integer *,real *,real *,integer *,real *, 
>                            integer *,ftnlen,ftnlen,ftnlen,ftnlen),
>                      F77(sger)(integer *,integer *,real *,real *,integer *,real *,
>                           integer *,real *,integer *),
>                      F77(sspr)(character *,integer *,real *,real *,integer *,real *,
>                           ftnlen),
>                      F77(ssyr2k)(character *u,character *,integer *,integer *, 
>                             real *,real *,integer *,real *,integer *,real *,
>                             real *,integer *,ftnlen,ftnlen),
>                      F77(strmv)(character *,character *,character *,integer *,
>                            real *,integer *,real *,integer *,ftnlen,ftnlen, 
>                            ftnlen),
>                      F77(sspr2)(character *,integer *,real *,real *,integer *,
>                            real *,integer *,real *,ftnlen),
>                      F77(ssyrk)(character *,character *,integer *,integer *,real *,
>                            real *,integer *,real *,real *,integer *,ftnlen,
>                            ftnlen),
>                      F77(strsm)(character *,character *,character *,character *, 
>                            integer *,integer *,real *,real *,integer *,real *, 
>                            integer *,ftnlen,ftnlen,ftnlen,ftnlen),
>                      F77(scopy)(integer *,real *,integer *,real *,integer *),
>                      F77(srot)(integer *,real *,integer *,real *,integer *,real *,
>                           real *),
>                      F77(sswap)(integer *,real *,integer *,real *,integer *),
>                      F77(stbmv)(character *,character *,character *,integer *n, 
>                            integer *,real *,integer *,real *,integer *,ftnlen, 
>                            ftnlen,ftnlen),
>                      F77(strsv)(character *,character *,character *,integer *, 
>                            real *,integer *,real *,integer *,ftnlen,ftnlen, 
>                            ftnlen),
>                      F77(srotg)(real *,real *,real *,real *),
>                      F77(ssymm)(character *,character *,integer *,integer *,real *,
>                            real *,integer *,real *,integer *,real *,real *, 
>                            integer *,ftnlen,ftnlen),
>                      F77(stbsv)(character *,character *,character *,integer *, 
>                            integer *,real *,integer *,real *,integer *,ftnlen,
>                            ftnlen,ftnlen),
>                      F77(sgbmv)(character *,integer *,integer *,integer *,integer *,
>                            real *,real *,integer *,real *,integer *,real *, 
>                            real *,integer *,ftnlen),
>                      F77(ssbmv)(character *,integer *,integer *,real *,real *, 
>                            integer *,real *,integer *,real *,real *,integer *,
>                            ftnlen),
>                      F77(ssymv)(character *,integer *,real *,real *,integer *,
>                            real *,integer *,real *,real *,integer *, ftnlen),
>                      F77(stpmv)(character *,character *,character *,integer *, 
>                            real *,real *,integer *,ftnlen,ftnlen,ftnlen);
> 
> doublecomplex        F77(zdotc)(doublecomplex *,integer *,doublecomplex *,integer *,
>                            doublecomplex *,integer *),
>                      F77(zdotu)(doublecomplex *,integer *,doublecomplex *,integer *,
>                            doublecomplex *,integer *);
> void                 F77(zaxpy)(integer *,doublecomplex *,doublecomplex *,integer *,
>                            doublecomplex *,integer *),
>                      F77(zgemv)(character *,integer *,integer *,doublecomplex *,
>                            doublecomplex *,integer *,doublecomplex *,integer *,
>                            doublecomplex *,doublecomplex *,integer *,ftnlen),
>                      F77(zher2)(character *,integer *,doublecomplex *,
>                            doublecomplex *,integer *,doublecomplex *,integer *,
>                            doublecomplex *,integer *,ftnlen),
>                      F77(zscal)(integer *,doublecomplex *,doublecomplex *,
>                            integer *),
>                      F77(ztpmv)(character *,character *,character *,integer *,
>                            doublecomplex *,doublecomplex *,integer *,ftnlen,
>                            ftnlen,ftnlen),
>                      F77(zcopy)(integer *,doublecomplex *,integer *,doublecomplex *,
>                            integer *),
>                      F77(zgerc)(integer *,integer *,doublecomplex *,doublecomplex *,
>                            integer *,doublecomplex *,integer *,doublecomplex *,
>                            integer *),
>                      F77(zher2k)(character *,character *,integer *,integer *, 
>                             doublecomplex *,doublecomplex *,integer *, 
>                             doublecomplex *,integer *,doublereal *, 
>                             doublecomplex *,integer *,ftnlen,ftnlen),
>                      F77(zswap)(integer *,doublecomplex *,integer *,doublecomplex *,
>                            integer *),
>                      F77(ztpsv)(character *,character *,character *,integer *, 
>                            doublecomplex *,doublecomplex *,integer *,ftnlen, 
>                            ftnlen,ftnlen),
>                      F77(zgeru)(integer *,integer *,doublecomplex *,doublecomplex *,
>                            integer *,doublecomplex *,integer *,doublecomplex *,
>                            integer *),
>                      F77(zherk)(character *,character *,integer *,integer *, 
>                            doublereal *,doublecomplex *,integer *,doublereal *,
>                            doublecomplex *,integer *,ftnlen,ftnlen),
>                      F77(zsymm)(character *,character *,integer *,integer *, 
>                            doublecomplex *,doublecomplex *,integer *, 
>                            doublecomplex *,integer *,doublecomplex *, 
>                            doublecomplex *,integer *,ftnlen,ftnlen),
>                      F77(ztrmm)(character *,character *,character *,character *, 
>                            integer *,integer *,doublecomplex *,doublecomplex *,
>                            integer *,doublecomplex *,integer *,ftnlen,ftnlen,
>                            ftnlen,ftnlen),
>                      F77(zhbmv)(character *,integer *,integer *,doublecomplex *, 
>                            doublecomplex *,integer *,doublecomplex *,integer *,
>                            doublecomplex *,doublecomplex *,integer *,ftnlen),
>                      F77(zhpmv)(character *,integer *,doublecomplex *, 
>                            doublecomplex *,doublecomplex *,integer *, 
>                            doublecomplex *,doublecomplex *,integer *,ftnlen),
>                      F77(zsyr2k)(character *,character *,integer *,integer *, 
>                             doublecomplex *,doublecomplex *,integer *,
>                             doublecomplex *,integer *,doublecomplex *, 
>                             doublecomplex *,integer *,ftnlen,ftnlen),
>                      F77(ztrmv)(character *,character *,character *,integer *, 
>                            doublecomplex *,integer *,doublecomplex *,integer *,
>                            ftnlen,ftnlen,ftnlen),
>                      F77(zdscal)(integer *,doublecomplex *,doublecomplex *,
>                             integer *),
>                      F77(zhemm)(character *,character *,integer *,integer *, 
>                            doublecomplex *,doublecomplex *,integer *, 
>                            doublecomplex *,integer *,doublecomplex *, 
>                            doublecomplex *,integer *,ftnlen,ftnlen),
>                      F77(zhpr)(character *,integer *,doublereal *,doublecomplex *,
>                           integer *,doublecomplex *,ftnlen),
>                      F77(zsyrk)(character *,character *,integer *,integer *, 
>                            doublecomplex *,doublecomplex *,integer *,
>                            doublecomplex *,doublecomplex *,integer *,ftnlen,
>                            ftnlen),
>                      F77(ztrsm)(character *,character *,character *,character *, 
>                            integer *,integer *,doublecomplex *,doublecomplex *,
>                            integer *,doublecomplex *,integer *,ftnlen,ftnlen,
>                            ftnlen,ftnlen),
>                      F77(zgbmv)(character *,integer *,integer *,integer *,integer *,
>                            doublecomplex *,doublecomplex *,integer *, 
>                            doublecomplex *,integer *,doublecomplex *, 
>                            doublecomplex *,integer *,ftnlen),
>                      F77(zhemv)(character *,integer *,doublecomplex *, 
>                            doublecomplex *,integer *,doublecomplex *,integer *,
>                            doublecomplex *,doublecomplex *,integer *,ftnlen),
>                      F77(zhpr2)(character *,integer *,doublecomplex *, 
>                            doublecomplex *,integer *,doublecomplex *,integer *,
>                            doublecomplex *,ftnlen),
>                      F77(ztbmv)(character *,character *,character *,integer *, 
>                            integer *,doublecomplex *,integer *,doublecomplex *,
>                            integer *,ftnlen,ftnlen,ftnlen),
>                      F77(ztrsv)(character *,character *,character *,integer *, 
>                            doublecomplex *,integer *,doublecomplex *,integer *,
>                            ftnlen,ftnlen,ftnlen),
>                      F77(zgemm)(character *,character *,integer *,integer *,
>                            integer *,doublecomplex *,doublecomplex *,integer *,
>                            doublecomplex *,integer *,doublecomplex *,
>                            doublecomplex *,integer *,ftnlen,ftnlen),
>                      F77(zher)(character *,integer *,doublereal *,doublecomplex *,
>                           integer *,doublecomplex *,integer *,ftnlen),
>                      F77(zrotg)(doublecomplex *,doublecomplex *,doublereal *,
>                            doublecomplex *),
>                      F77(ztbsv)(character *,character *,character *,integer *, 
>                            integer *,doublecomplex *,integer *,doublecomplex *,
>                            integer *,ftnlen,ftnlen,ftnlen);
> 
> integer              F77(icamax)(integer *,complex *,integer *),
>                      F77(idamax)(integer *,doublereal *,integer *),
>                      F77(isamax)(integer *,real *,integer *),
>                      F77(izamax)(integer *,doublecomplex *,integer *),
>                      F77(lsame)(character *,character *,ftnlen,ftnlen);
> void                 F77(xerbla)(character *,integer *,ftnlen);
>  
> #undef integer   
> #undef real      
> #undef doublereal
> #undef character 
> #undef logical   
> #undef ftnlen    
> 
> #endif /* _BLAS_H */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/include/cgs.h pysparse/pysparse/include/cgs.h
0a1,17
> #ifndef CGS_H
> #define CGS_H
> 
> #include <Python.h>
> 
> int Itsolvers_cgs_kernel(int n, 
> 			 double *b, 
> 			 double *x, 
> 			 int maxit, 
> 			 double tol,
> 			 double *work,
> 			 int *iter,
> 			 double *res,
> 			 PyObject *mat_obj,
> 			 PyObject *prec_obj);
> 
> #endif
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/include/csr_mat.h pysparse/pysparse/include/csr_mat.h
0a1,21
> #ifndef CSR_MAT_H
> #define CSR_MAT_H
> 
> #include "Python.h"
> 
> typedef struct {
>   PyObject_VAR_HEAD
>   int dim[2];			/* array dimension */
>   int nnz;			/* number of stored items */
>   double *val;			/* pointer to array of values */
>   int *col;			/* pointer to array of indices */
>   int *ind;			/* pointer to array of indices */
> } CSRMatObject;
> 
> #ifdef SPMATRIX_MODULE
> /* forward declarations */
> static PyTypeObject CSRMatType;	
> static PyObject *newCSRMatObject(int dim[], int nnz);
> #endif
> 
> #endif
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/include/dsp_defs.h pysparse/pysparse/include/dsp_defs.h
0a1,249
> 
> 
> /*
>  * -- SuperLU routine (version 2.0) --
>  * Univ. of California Berkeley, Xerox Palo Alto Research Center,
>  * and Lawrence Berkeley National Lab.
>  * November 15, 1997
>  *
>  */
> #ifndef __SUPERLU_dSP_DEFS /* allow multiple inclusions */
> #define __SUPERLU_dSP_DEFS
> 
> /*
>  * File name:		dsp_defs.h
>  * Purpose:             Sparse matrix types and function prototypes
>  * History:
>  */
> #ifdef _CRAY
> #include <fortran.h>
> #include <string.h>
> #endif
> #include "Cnames.h"
> #include "supermatrix.h"
> 
> 
> /* No of marker arrays used in the symbolic factorization,
>    each of size n */
> #define NO_MARKER     3
> #define NUM_TEMPV(m,w,t,b)  ( MAX(m, (t + b)*w) )
> 
> typedef enum {LUSUP, UCOL, LSUB, USUB} MemType;
> typedef enum {HEAD, TAIL}              stack_end_t;
> typedef enum {SYSTEM, USER}            LU_space_t;
> 
> /*
>  * Global data structures used in LU factorization -
>  * 
>  *   nsuper: #supernodes = nsuper + 1, numbered [0, nsuper].
>  *   (xsup,supno): supno[i] is the supernode no to which i belongs;
>  *	xsup(s) points to the beginning of the s-th supernode.
>  *	e.g.   supno 0 1 2 2 3 3 3 4 4 4 4 4   (n=12)
>  *	        xsup 0 1 2 4 7 12
>  *	Note: dfs will be performed on supernode rep. relative to the new 
>  *	      row pivoting ordering
>  *
>  *   (xlsub,lsub): lsub[*] contains the compressed subscript of
>  *	rectangular supernodes; xlsub[j] points to the starting
>  *	location of the j-th column in lsub[*]. Note that xlsub 
>  *	is indexed by column.
>  *	Storage: original row subscripts
>  *
>  *      During the course of sparse LU factorization, we also use
>  *	(xlsub,lsub) for the purpose of symmetric pruning. For each
>  *	supernode {s,s+1,...,t=s+r} with first column s and last
>  *	column t, the subscript set
>  *		lsub[j], j=xlsub[s], .., xlsub[s+1]-1
>  *	is the structure of column s (i.e. structure of this supernode).
>  *	It is used for the storage of numerical values.
>  *	Furthermore,
>  *		lsub[j], j=xlsub[t], .., xlsub[t+1]-1
>  *	is the structure of the last column t of this supernode.
>  *	It is for the purpose of symmetric pruning. Therefore, the
>  *	structural subscripts can be rearranged without making physical
>  *	interchanges among the numerical values.
>  *
>  *	However, if the supernode has only one column, then we
>  *	only keep one set of subscripts. For any subscript interchange
>  *	performed, similar interchange must be done on the numerical
>  *	values.
>  *
>  *	The last column structures (for pruning) will be removed
>  *	after the numercial LU factorization phase.
>  *
>  *   (xlusup,lusup): lusup[*] contains the numerical values of the
>  *	rectangular supernodes; xlusup[j] points to the starting
>  *	location of the j-th column in storage vector lusup[*]
>  *	Note: xlusup is indexed by column.
>  *	Each rectangular supernode is stored by column-major
>  *	scheme, consistent with Fortran 2-dim array storage.
>  *
>  *   (xusub,ucol,usub): ucol[*] stores the numerical values of
>  *	U-columns outside the rectangular supernodes. The row
>  *	subscript of nonzero ucol[k] is stored in usub[k].
>  *	xusub[i] points to the starting location of column i in ucol.
>  *	Storage: new row subscripts; that is subscripts of PA.
>  */
> typedef struct {
>     int     *xsup;    /* supernode and column mapping */
>     int     *supno;   
>     int     *lsub;    /* compressed L subscripts */
>     int	    *xlsub;
>     double  *lusup;   /* L supernodes */
>     int     *xlusup;
>     double  *ucol;    /* U columns */
>     int     *usub;
>     int	    *xusub;
>     int     nzlmax;   /* current max size of lsub */
>     int     nzumax;   /*    "    "    "      ucol */
>     int     nzlumax;  /*    "    "    "     lusup */
>     int     n;        /* number of columns in the matrix */
>     LU_space_t MemModel; /* 0 - system malloc'd; 1 - user provided */
> } GlobalLU_t;
> 
> typedef struct {
>     int panel_size;
>     int relax;
>     double diag_pivot_thresh;
>     double drop_tol;
> } factor_param_t;
> 
> typedef struct {
>     float for_lu;
>     float total_needed;
>     int   expansions;
> } mem_usage_t;
> 
> #ifdef __cplusplus
> extern "C" {
> #endif
> 
> /* Driver routines */
> extern void
> dgssv(SuperMatrix *, int *, int *, SuperMatrix *, SuperMatrix *, 
> 	SuperMatrix *, int *);
> extern void
> dgssvx(char *, char *, char *, SuperMatrix *, factor_param_t *,
>        int *, int *, int *, char *, double *, double *,
>        SuperMatrix *, SuperMatrix *, void *, int, SuperMatrix *, 
>        SuperMatrix *, double *, double *, double *,
>        double *, mem_usage_t *, int *);
> 
> /* Supernodal LU factor related */
> extern void
> dCreate_CompCol_Matrix(SuperMatrix *, int, int, int, double *,
> 		       int *, int *, Stype_t, Dtype_t, Mtype_t);
> extern void
> dCopy_CompCol_Matrix(SuperMatrix *, SuperMatrix *);
> extern void
> dCreate_Dense_Matrix(SuperMatrix *, int, int, double *, int,
> 		     Stype_t, Dtype_t, Mtype_t);
> extern void
> dCreate_SuperNode_Matrix(SuperMatrix *, int, int, int, double *, 
> 		         int *, int *, int *, int *, int *,
> 			 Stype_t, Dtype_t, Mtype_t);
> extern void
> dCopy_Dense_Matrix(int, int, double *, int, double *, int);
> 
> extern void    Destroy_SuperMatrix_Store(SuperMatrix *);
> extern void    Destroy_CompCol_Matrix(SuperMatrix *);
> extern void    Destroy_SuperNode_Matrix(SuperMatrix *);
> extern void    Destroy_CompCol_Permuted(SuperMatrix *);
> extern void    Destroy_Dense_Matrix(SuperMatrix *);
> extern void    get_perm_c(int, SuperMatrix *, int *);
> extern void    sp_preorder (char*, SuperMatrix*, int*, int*, SuperMatrix*);
> extern void    countnz (const int, int *, int *, int *, GlobalLU_t *);
> extern void    fixupL (const int, const int *, GlobalLU_t *);
> 
> extern void    dallocateA (int, int, double **, int **, int **);
> extern void    dgstrf (char*, SuperMatrix*, double, double, int, int, int*,
> 			void *, int, int *, int *, 
>                         SuperMatrix *, SuperMatrix *, int *);
> extern int     dsnode_dfs (const int, const int, const int *, const int *,
> 			     const int *, int *, int *, GlobalLU_t *);
> extern int     dsnode_bmod (const int, const int, const int, double *,
>                               double *, GlobalLU_t *);
> extern void    dpanel_dfs (const int, const int, const int, SuperMatrix *,
> 			   int *, int *, double *, int *, int *, int *,
> 			   int *, int *, int *, int *, GlobalLU_t *);
> extern void    dpanel_bmod (const int, const int, const int, const int,
>                            double *, double *, int *, int *,
> 			   GlobalLU_t *);
> extern int     dcolumn_dfs (const int, const int, int *, int *, int *, int *,
> 			   int *, int *, int *, int *, int *, GlobalLU_t *);
> extern int     dcolumn_bmod (const int, const int, double *,
> 			   double *, int *, int *, int, GlobalLU_t *);
> extern int     dcopy_to_ucol (int, int, int *, int *, int *,
>                               double *, GlobalLU_t *);         
> extern int     dpivotL (const int, const double, int *, int *, 
>                               int *, int *, int *, GlobalLU_t *);
> extern void    dpruneL (const int, const int *, const int, const int,
> 			     const int *, const int *, int *, GlobalLU_t *);
> extern void    dreadmt (int *, int *, int *, double **, int **, int **);
> extern void    dGenXtrue (int, int, double *, int);
> extern void    dFillRHS (char *, int, double *, int, SuperMatrix *,
> 			SuperMatrix *);
> extern void    dgstrs (char *, SuperMatrix *, SuperMatrix *, int *, int *,
> 			SuperMatrix *, int *);
> 
> 
> /* Driver related */
> 
> extern void    dgsequ (SuperMatrix *, double *, double *, double *,
> 			     double *, double *, int *);
> extern void    dlaqgs (SuperMatrix *, double *, double *, double,
>                              double, double, char *);
> extern void    dgscon (char *, SuperMatrix *, SuperMatrix *,
> 			double, double *, int *);
> extern double  dPivotGrowth(int, SuperMatrix *, int *, 
>                             SuperMatrix *, SuperMatrix *);
> extern void    dgsrfs (char *, SuperMatrix *, SuperMatrix *, 
> 			SuperMatrix *, int *, int *, char *, double *,
> 			double *, SuperMatrix *, SuperMatrix *, 
> 			double *, double *, int *);
> 
> extern int     sp_dtrsv (char *, char *, char *, SuperMatrix *,
> 			SuperMatrix *, double *, int *);
> extern int     sp_dgemv (char *, double, SuperMatrix *, double *,
> 			int, double, double *, int);
> 
> extern int     sp_dgemm (char *, char *, int, int, int, double,
> 			SuperMatrix *, double *, int, double, 
> 			double *, int);
> 
> /* Memory-related */
> extern int     dLUMemInit (char *, void *, int, int, int, int, int,
> 			     SuperMatrix *, SuperMatrix *,
> 			     GlobalLU_t *, int **, double **);
> extern void    dSetRWork (int, int, double *, double **, double **);
> extern void    dLUWorkFree (int *, double *, GlobalLU_t *);
> extern int     dLUMemXpand (int, int, MemType, int *, GlobalLU_t *);
> 
> extern double  *doubleMalloc(int);
> extern double  *doubleCalloc(int);
> extern int     dmemory_usage(const int, const int, const int, const int);
> extern int     dQuerySpace (SuperMatrix *, SuperMatrix *, int,
> 				mem_usage_t *);
> 
> /* Auxiliary routines */
> extern void    dreadhb(int *, int *, int *, double **, int **, int **);
> extern void    dCompRow_to_CompCol(int, int, int, double*, int*, int*,
> 		                   double **, int **, int **);
> extern void    dfill (double *, int, double);
> extern void    dinf_norm_error (int, SuperMatrix *, double *);
> extern void    PrintPerf (SuperMatrix *, SuperMatrix *, mem_usage_t *,
> 			 double, double, double *, double *, char *);
> 
> /* Routines for debugging */
> extern void    dPrint_CompCol_Matrix(char *, SuperMatrix *);
> extern void    dPrint_SuperNode_Matrix(char *, SuperMatrix *);
> extern void    dPrint_Dense_Matrix(char *, SuperMatrix *);
> extern void    print_lu_col(char *, int, int, int *, GlobalLU_t *);
> extern void    check_tempv(int, double *);
> 
> #ifdef __cplusplus
>   }
> #endif
> 
> #endif /* __SUPERLU_dSP_DEFS */
> 
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/include/fortran.h pysparse/pysparse/include/fortran.h
0a1,27
> #ifndef FORTRAN_H
> #define FORTRAN_H
> 
> #if defined(NOF77UNDERSCORE)
> #define F77(s) s
> #elif defined (F77UPPERCASE)
> #define F77(s) s
> #define dgemv DGEMV
> #define dgetrf DGETRF
> #define dgetrs DGETRS
> #define dscal DSCAL
> #define ilaenv ILAENV
> #define dsyev DSYEV
> #define dgemm DGEMM
> #define daxpy DAXPY
> #define dnrm2 DNRM2
> #define dcopy DCOPY
> #define ddot DDOT
> #define dlaset DLASET
> #define dlacpy DLACPY
> #define dlarnv DLARNV
> #else
> #define F77(s) s##_
> #endif
> 
> #endif
> 
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/include/gmres.h pysparse/pysparse/include/gmres.h
0a1,34
> /**************************************************************************
> *                                                                         *
> *               Swiss Federal Institute of Technology (ETH),              *
> *                       CH-8092 Zuerich, Switzerland                      *
> *                                                                         *
> *                       (C) 1999 All Rights Reserved                      *
> *                                                                         *
> *                                NOTICE                                   *
> *                                                                         *
> *  Permission to use, copy, modify, and distribute this software and      *
> *  its documentation for any purpose and without fee is hereby granted    *
> *  provided that the above copyright notice appear in all copies and      *
> *  that both the copyright notice and this permission notice appear in    *
> *  supporting documentation.                                              *
> *                                                                         *
> *  Neither the Swiss Federal Institute of Technology nor the author make  *
> *  any representations about the suitability of this software for any     *
> *  purpose.  This software is provided ``as is'' without express or       *
> *  implied warranty.                                                      *
> *                                                                         *
> **************************************************************************/
> 
> #ifndef GMRES_H
> #define GMRES_H
> 
> #include "Python.h"
> 
> int Itsolvers_gmres_kernel(int n, double errtol, int it_max,
> 			    int *it, double *relres, int dim,
> 			    double *x, double *b, double *work,
> 			    PyObject *mat_obj,
> 			    PyObject *prec_obj);
> 
> #endif
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/include/lapack.h pysparse/pysparse/include/lapack.h
0a1,1989
> #ifndef LAPACK_H
> #define LAPACK_H
> 
> #include "fortran.h"
> 
> /* typedefs for the FORTRAN COMPLEX*8 and COMPLEX*16 data types */
> 
> /* COMPLEX*8  type */
> 
> #ifndef __COMPLEX8_T
> #define __COMPLEX8_T 1
>     typedef struct {
> 	float  re, im;
>     } complex8_t;
> #endif
> 
> /* COMPLEX*16 type */
> 
> #ifndef __COMPLEX16_T
> #define __COMPLEX16_T 1
>     typedef struct {
> 	double re, im;
>     } complex16_t;
> #endif
> 
> extern void F77(cgbcon)(char* norm, int* n, int* kl, int* ku,
>         complex8_t ab[], int* ldab, int ipiv[], float* anorm,
>         float* rcond, complex8_t work[], float rwork[], int* info,
>         int len_norm);
> 
> extern void F77(cgbsv)(int* n, int* kl, int* ku, int* nrhs, complex8_t ab[],
>         int* ldab, int ipiv[], complex8_t b[], int* ldb, int* info);
> 
> extern void F77(cgbsvx)(char* fact, char* trans, int* n, int* kl, int* ku,
>         int* nrhs, complex8_t ab[], int* ldab, complex8_t afb[],
>         int* ldafb, int ipiv[], char* equed, float r[], float c[],
>         complex8_t b[], int* ldb, complex8_t x[], int* ldx,
>         float* rcond, float ferr[], float berr[], complex8_t work[],
>         float rwork[], int* info, int len_fact, int len_trans,
>         int len_equed);
> 
> extern void F77(cgbtrf)(int* m, int* n, int* kl, int* ku, complex8_t ab[],
>         int* ldab, int ipiv[], int* info);
> 
> extern void F77(cgbtrs)(char* trans, int* n, int* kl, int* ku, int* nrhs,
>         complex8_t ab[], int* ldab, int ipiv[], complex8_t b[],
>         int* ldb, int* info, int len_trans);
> 
> extern void F77(cgecon)(char* norm, int* n, complex8_t a[], int* lda,
>         float* anorm, float* rcond, complex8_t work[], float rwork[],
>         int* info, int len_norm);
> 
> extern void F77(cgees)(char* jobvs, char* sort, int (*select)(), int* n,
>         complex8_t a[], int* lda, int* sdim, complex8_t w[],
>         complex8_t vs[], int* ldvs, complex8_t work[], int* lwork,
>         float rwork[], int bwork[], int* info, int len_jobvs,
>         int len_sort);
> 
> extern void F77(cgeesx)(char* jobvs, char* sort, int (*select)(),
>         char* sense, int* n, complex8_t a[], int* lda, int* sdim,
>         complex8_t w[], complex8_t vs[], int* ldvs, float* rconde,
>         float* rcondv, complex8_t work[], int* lwork, float rwork[],
>         int bwork[], int* info, int len_jobvs, int len_sort,
>         int len_sense);
> 
> extern void F77(cgeev)(char* jobvl, char* jobvr, int* n, complex8_t a[],
>         int* lda, complex8_t w[], complex8_t vl[], int* ldvl,
>         complex8_t vr[], int* ldvr, complex8_t work[], int* lwork,
>         float rwork[], int* info, int len_jobvl, int len_jobvr);
> 
> extern void F77(cgeevx)(char* balanc, char* jobvl, char* jobvr, char* sense,
>         int* n, complex8_t a[], int* lda, complex8_t w[],
>         complex8_t vl[], int* ldvl, complex8_t vr[], int* ldvr,
>         int* ilo, int* ihi, float scale[], float* abnrm, float rconde[],
>         float rcondv[], complex8_t work[], int* lwork, float rwork[],
>         int* info, int len_balanc, int len_jobvl, int len_jobvr,
>         int len_sense);
> 
> extern void F77(cgegs)(char* jobvsl, char* jobvsr, int* n, complex8_t a[],
>         int* lda, complex8_t b[], int* ldb, complex8_t alpha[],
>         complex8_t beta[], complex8_t vsl[], int* ldvsl,
>         complex8_t vsr[], int* ldvsr, complex8_t work[], int* lwork,
>         float rwork[], int* info, int len_jobvsl, int len_jobvsr);
> 
> extern void F77(cgegv)(char* jobvl, char* jobvr, int* n, complex8_t a[],
>         int* lda, complex8_t b[], int* ldb, complex8_t alpha[],
>         complex8_t beta[], complex8_t vl[], int* ldvl, complex8_t vr[],
>         int* ldvr, complex8_t work[], int* lwork, float rwork[],
>         int* info, int len_jobvl, int len_jobvr);
> 
> extern void F77(cgelqf)(int* m, int* n, complex8_t a[], int* lda,
>         complex8_t tau[], complex8_t work[], int* lwork, int* info);
> 
> extern void F77(cgels)(char* trans, int* m, int* n, int* nrhs,
>         complex8_t a[], int* lda, complex8_t b[], int* ldb,
>         complex8_t work[], int* lwork, int* info, int len_trans);
> 
> extern void F77(cgelss)(int* m, int* n, int* nrhs, complex8_t a[], int* lda,
>         complex8_t b[], int* ldb, float s[], float* rcond, int* rank,
>         complex8_t work[], int* lwork, float rwork[], int* info);
> 
> extern void F77(cgelsx)(int* m, int* n, int* nrhs, complex8_t a[], int* lda,
>         complex8_t b[], int* ldb, int jpvt[], float* rcond, int* rank,
>         complex8_t work[], float rwork[], int* info);
> 
> extern void F77(cgeqlf)(int* m, int* n, complex8_t a[], int* lda,
>         complex8_t tau[], complex8_t work[], int* lwork, int* info);
> 
> extern void F77(cgeqpf)(int* m, int* n, complex8_t a[], int* lda,
>         int jpvt[], complex8_t tau[], complex8_t work[], float rwork[],
>         int* info);
> 
> extern void F77(cgeqrf)(int* m, int* n, complex8_t a[], int* lda,
>         complex8_t tau[], complex8_t work[], int* lwork, int* info);
> 
> extern void F77(cgerqf)(int* m, int* n, complex8_t a[], int* lda,
>         complex8_t tau[], complex8_t work[], int* lwork, int* info);
> 
> extern void F77(cgesv)(int* n, int* nrhs, complex8_t a[], int* lda,
>         int ipiv[], complex8_t b[], int* ldb, int* info);
> 
> extern void F77(cgesvd)(char* jobu, char* jobvt, int* m, int* n,
>         complex8_t a[], int* lda, float s[], complex8_t u[], int* ldu,
>         complex8_t vt[], int* ldvt, complex8_t work[], int* lwork,
>         float rwork[], int* info, int len_jobu, int len_jobvt);
> 
> extern void F77(cgesvx)(char* fact, char* trans, int* n, int* nrhs,
>         complex8_t a[], int* lda, complex8_t af[], int* ldaf,
>         int ipiv[], char* equed, float r[], float c[], complex8_t b[],
>         int* ldb, complex8_t x[], int* ldx, float* rcond, float ferr[],
>         float berr[], complex8_t work[], float rwork[], int* info,
>         int len_fact, int len_trans, int len_equed);
> 
> extern void F77(cgetrf)(int* m, int* n, complex8_t a[], int* lda,
>         int ipiv[], int* info);
> 
> extern void F77(cgetri)(int* n, complex8_t a[], int* lda, int ipiv[],
>         complex8_t work[], int* lwork, int* info);
> 
> extern void F77(cgetrs)(char* trans, int* n, int* nrhs, complex8_t a[],
>         int* lda, int ipiv[], complex8_t b[], int* ldb, int* info,
>         int len_trans);
> 
> extern void F77(cggglm)(int* n, int* m, int* p, complex8_t a[], int* lda,
>         complex8_t b[], int* ldb, complex8_t d[], complex8_t x[],
>         complex8_t y[], complex8_t work[], int* lwork, int* info);
> 
> extern void F77(cgglse)(int* m, int* n, int* p, complex8_t a[], int* lda,
>         complex8_t b[], int* ldb, complex8_t c[], complex8_t d[],
>         complex8_t x[], complex8_t work[], int* lwork, int* info);
> 
> extern void F77(cggqrf)(int* m, int* n, int* p, complex8_t a[], int* lda,
>         complex8_t taua[], complex8_t b[], int* ldb, complex8_t taub[],
>         complex8_t work[], int* lwork, int* info);
> 
> extern void F77(cggrqf)(int* m, int* n, int* p, complex8_t a[], int* lda,
>         complex8_t taua[], complex8_t b[], int* ldb, complex8_t taub[],
>         complex8_t work[], int* lwork, int* info);
> 
> extern void F77(cggsvd)(char* jobu, char* jobv, char* jobq, int* m, int* n,
>         int* p, int* k, int* l, complex8_t a[], int* lda,
>         complex8_t b[], int* ldb, float alpha[], float beta[],
>         complex8_t u[], int* ldu, complex8_t v[], int* ldv,
>         complex8_t q[], int* ldq, complex8_t work[], float rwork[],
>         int iwork[], int* info, int len_jobu, int len_jobv,
>         int len_jobq);
> 
> extern void F77(cgtcon)(char* norm, int* n, complex8_t dl[], complex8_t d[],
>         complex8_t du[], complex8_t du2[], int ipiv[], float* anorm,
>         float* rcond, complex8_t work[], int* info, int len_norm);
> 
> extern void F77(cgtsv)(int* n, int* nrhs, complex8_t dl[], complex8_t d[],
>         complex8_t du[], complex8_t b[], int* ldb, int* info);
> 
> extern void F77(cgtsvx)(char* fact, char* trans, int* n, int* nrhs,
>         complex8_t dl[], complex8_t d[], complex8_t du[],
>         complex8_t dlf[], complex8_t df[], complex8_t duf[],
>         complex8_t du2[], int ipiv[], complex8_t b[], int* ldb,
>         complex8_t x[], int* ldx, float* rcond, float ferr[],
>         float berr[], complex8_t work[], float rwork[], int* info,
>         int len_fact, int len_trans);
> 
> extern void F77(cgttrf)(int* n, complex8_t dl[], complex8_t d[],
>         complex8_t du[], complex8_t du2[], int ipiv[], int* info);
> 
> extern void F77(cgttrs)(char* trans, int* n, int* nrhs, complex8_t dl[],
>         complex8_t d[], complex8_t du[], complex8_t du2[], int ipiv[],
>         complex8_t b[], int* ldb, int* info, int len_trans);
> 
> extern void F77(chbev)(char* jobz, char* uplo, int* n, int* kd,
>         complex8_t ab[], int* ldab, float w[], complex8_t z[], int* ldz,
>         complex8_t work[], float rwork[], int* info, int len_jobz,
>         int len_uplo);
> 
> extern void F77(chbevd)(char* jobz, char* uplo, int* n, int* kd,
>         complex8_t ab[], int* ldab, float w[], complex8_t z[], int* ldz,
>         complex8_t work[], int* lwork, float rwork[], int* lrwork,
>         int iwork[], int* liwork, int* info, int len_jobz,
>         int len_uplo);
> 
> extern void F77(chbevx)(char* jobz, char* range, char* uplo, int* n,
>         int* kd, complex8_t ab[], int* ldab, complex8_t q[], int* ldq,
>         float* vl, float* vu, int* il, int* iu, float* abstol, int* m,
>         float w[], complex8_t z[], int* ldz, complex8_t work[],
>         float rwork[], int iwork[], int ifail[], int* info,
>         int len_jobz, int len_range, int len_uplo);
> 
> extern void F77(chbgv)(char* jobz, char* uplo, int* n, int* ka, int* kb,
>         complex8_t ab[], int* ldab, complex8_t bb[], int* ldbb,
>         float w[], complex8_t z[], int* ldz, complex8_t work[],
>         float rwork[], int* info, int len_jobz, int len_uplo);
> 
> extern void F77(checon)(char* uplo, int* n, complex8_t a[], int* lda,
>         int ipiv[], float* anorm, float* rcond, complex8_t work[],
>         int* info, int len_uplo);
> 
> extern void F77(cheev)(char* jobz, char* uplo, int* n, complex8_t a[],
>         int* lda, float w[], complex8_t work[], int* lwork,
>         float rwork[], int* info, int len_jobz, int len_uplo);
> 
> extern void F77(cheevd)(char* jobz, char* uplo, int* n, complex8_t a[],
>         int* lda, float w[], complex8_t work[], int* lwork,
>         float rwork[], int* lrwork, int iwork[], int* liwork, int* info,
>         int len_jobz, int len_uplo);
> 
> extern void F77(cheevx)(char* jobz, char* range, char* uplo, int* n,
>         complex8_t a[], int* lda, float* vl, float* vu, int* il,
>         int* iu, float* abstol, int* m, float w[], complex8_t z[],
>         int* ldz, complex8_t work[], int* lwork, float rwork[],
>         int iwork[], int ifail[], int* info, int len_jobz,
>         int len_range, int len_uplo);
> 
> extern void F77(chegv)(int* itype, char* jobz, char* uplo, int* n,
>         complex8_t a[], int* lda, complex8_t b[], int* ldb, float w[],
>         complex8_t work[], int* lwork, float rwork[], int* info,
>         int len_jobz, int len_uplo);
> 
> extern void F77(chesv)(char* uplo, int* n, int* nrhs, complex8_t a[],
>         int* lda, int ipiv[], complex8_t b[], int* ldb,
>         complex8_t work[], int* lwork, int* info, int len_uplo);
> 
> extern void F77(chesvx)(char* fact, char* uplo, int* n, int* nrhs,
>         complex8_t a[], int* lda, complex8_t af[], int* ldaf,
>         int ipiv[], complex8_t b[], int* ldb, complex8_t x[], int* ldx,
>         float* rcond, float ferr[], float berr[], complex8_t work[],
>         int* lwork, float rwork[], int* info, int len_fact,
>         int len_uplo);
> 
> extern void F77(chetrf)(char* uplo, int* n, complex8_t a[], int* lda,
>         int ipiv[], complex8_t work[], int* lwork, int* info,
>         int len_uplo);
> 
> extern void F77(chetri)(char* uplo, int* n, complex8_t a[], int* lda,
>         int ipiv[], complex8_t work[], int* info, int len_uplo);
> 
> extern void F77(chetrs)(char* uplo, int* n, int* nrhs, complex8_t a[],
>         int* lda, int ipiv[], complex8_t b[], int* ldb, int* info,
>         int len_uplo);
> 
> extern void F77(chpcon)(char* uplo, int* n, complex8_t ap[], int ipiv[],
>         float* anorm, float* rcond, complex8_t work[], int* info,
>         int len_uplo);
> 
> extern void F77(chpev)(char* jobz, char* uplo, int* n, complex8_t ap[],
>         float w[], complex8_t z[], int* ldz, complex8_t work[],
>         float rwork[], int* info, int len_jobz, int len_uplo);
> 
> extern void F77(chpevd)(char* jobz, char* uplo, int* n, complex8_t ap[],
>         float w[], complex8_t z[], int* ldz, complex8_t work[],
>         int* lwork, float rwork[], int* lrwork, int iwork[],
>         int* liwork, int* info, int len_jobz, int len_uplo);
> 
> extern void F77(chpevx)(char* jobz, char* range, char* uplo, int* n,
>         complex8_t ap[], float* vl, float* vu, int* il, int* iu,
>         float* abstol, int* m, float w[], complex8_t z[], int* ldz,
>         complex8_t work[], float rwork[], int iwork[], int ifail[],
>         int* info, int len_jobz, int len_range, int len_uplo);
> 
> extern void F77(chpgv)(int* itype, char* jobz, char* uplo, int* n,
>         complex8_t ap[], complex8_t bp[], float w[], complex8_t z[],
>         int* ldz, complex8_t work[], float rwork[], int* info,
>         int len_jobz, int len_uplo);
> 
> extern void F77(chpsv)(char* uplo, int* n, int* nrhs, complex8_t ap[],
>         int ipiv[], complex8_t b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(chpsvx)(char* fact, char* uplo, int* n, int* nrhs,
>         complex8_t ap[], complex8_t afp[], int ipiv[], complex8_t b[],
>         int* ldb, complex8_t x[], int* ldx, float* rcond, float ferr[],
>         float berr[], complex8_t work[], float rwork[], int* info,
>         int len_fact, int len_uplo);
> 
> extern void F77(chptrf)(char* uplo, int* n, complex8_t ap[], int ipiv[],
>         int* info, int len_uplo);
> 
> extern void F77(chptri)(char* uplo, int* n, complex8_t ap[], int ipiv[],
>         complex8_t work[], int* info, int len_uplo);
> 
> extern void F77(chptrs)(char* uplo, int* n, int* nrhs, complex8_t ap[],
>         int ipiv[], complex8_t b[], int* ldb, int* info, int len_uplo);
> 
> extern float F77(clangb)(char* norm, int* n, int* kl, int* ku,
>         complex8_t ab[], int* ldab, float rwork[], int len_norm);
> 
> extern float F77(clange)(char* norm, int* m, int* n, complex8_t a[],
>         int* lda, float rwork[], int len_norm);
> 
> extern float F77(clangt)(char* norm, int* n, complex8_t dl[],
>         complex8_t d[], complex8_t du[], int len_norm);
> 
> extern float F77(clanhb)(char* norm, char* uplo, int* n, int* kd,
>         complex8_t ab[], int* ldab, float rwork[], int len_norm,
>         int len_uplo);
> 
> extern float F77(clanhe)(char* norm, char* uplo, int* n, complex8_t a[],
>         int* lda, float rwork[], int len_norm, int len_uplo);
> 
> extern float F77(clanhp)(char* norm, char* uplo, int* n, complex8_t ap[],
>         float rwork[], int len_norm, int len_uplo);
> 
> extern float F77(clanht)(char* norm, int* n, float d[], complex8_t e[],
>         int len_norm);
> 
> extern float F77(clansb)(char* norm, char* uplo, int* n, int* kd,
>         complex8_t ab[], int* ldab, float rwork[], int len_norm,
>         int len_uplo);
> 
> extern float F77(clansp)(char* norm, char* uplo, int* n, complex8_t ap[],
>         float rwork[], int len_norm, int len_uplo);
> 
> extern float F77(clansy)(char* norm, char* uplo, int* n, complex8_t a[],
>         int* lda, float rwork[], int len_norm, int len_uplo);
> 
> extern void F77(cpbcon)(char* uplo, int* n, int* kd, complex8_t ab[],
>         int* ldab, float* anorm, float* rcond, complex8_t work[],
>         float rwork[], int* info, int len_uplo);
> 
> extern void F77(cpbsv)(char* uplo, int* n, int* kd, int* nrhs,
>         complex8_t ab[], int* ldab, complex8_t b[], int* ldb, int* info,
>         int len_uplo);
> 
> extern void F77(cpbsvx)(char* fact, char* uplo, int* n, int* kd, int* nrhs,
>         complex8_t ab[], int* ldab, complex8_t afb[], int* ldafb,
>         char* equed, float s[], complex8_t b[], int* ldb,
>         complex8_t x[], int* ldx, float* rcond, float ferr[],
>         float berr[], complex8_t work[], float rwork[], int* info,
>         int len_fact, int len_uplo, int len_equed);
> 
> extern void F77(cpbtrf)(char* uplo, int* n, int* kd, complex8_t ab[],
>         int* ldab, int* info, int len_uplo);
> 
> extern void F77(cpbtrs)(char* uplo, int* n, int* kd, int* nrhs,
>         complex8_t ab[], int* ldab, complex8_t b[], int* ldb, int* info,
>         int len_uplo);
> 
> extern void F77(cpocon)(char* uplo, int* n, complex8_t a[], int* lda,
>         float* anorm, float* rcond, complex8_t work[], float rwork[],
>         int* info, int len_uplo);
> 
> extern void F77(cposv)(char* uplo, int* n, int* nrhs, complex8_t a[],
>         int* lda, complex8_t b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(cposvx)(char* fact, char* uplo, int* n, int* nrhs,
>         complex8_t a[], int* lda, complex8_t af[], int* ldaf,
>         char* equed, float s[], complex8_t b[], int* ldb,
>         complex8_t x[], int* ldx, float* rcond, float ferr[],
>         float berr[], complex8_t work[], float rwork[], int* info,
>         int len_fact, int len_uplo, int len_equed);
> 
> extern void F77(cpotrf)(char* uplo, int* n, complex8_t a[], int* lda,
>         int* info, int len_uplo);
> 
> extern void F77(cpotri)(char* uplo, int* n, complex8_t a[], int* lda,
>         int* info, int len_uplo);
> 
> extern void F77(cpotrs)(char* uplo, int* n, int* nrhs, complex8_t a[],
>         int* lda, complex8_t b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(cppcon)(char* uplo, int* n, complex8_t ap[], float* anorm,
>         float* rcond, complex8_t work[], float rwork[], int* info,
>         int len_uplo);
> 
> extern void F77(cppsv)(char* uplo, int* n, int* nrhs, complex8_t ap[],
>         complex8_t b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(cppsvx)(char* fact, char* uplo, int* n, int* nrhs,
>         complex8_t ap[], complex8_t afp[], char* equed, float s[],
>         complex8_t b[], int* ldb, complex8_t x[], int* ldx,
>         float* rcond, float ferr[], float berr[], complex8_t work[],
>         float rwork[], int* info, int len_fact, int len_uplo,
>         int len_equed);
> 
> extern void F77(cpptrf)(char* uplo, int* n, complex8_t ap[], int* info,
>         int len_uplo);
> 
> extern void F77(cpptri)(char* uplo, int* n, complex8_t ap[], int* info,
>         int len_uplo);
> 
> extern void F77(cpptrs)(char* uplo, int* n, int* nrhs, complex8_t ap[],
>         complex8_t b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(cptcon)(int* n, float d[], complex8_t e[], float* anorm,
>         float* rcond, float rwork[], int* info);
> 
> extern void F77(cptsv)(int* n, int* nrhs, float d[], complex8_t e[],
>         complex8_t b[], int* ldb, int* info);
> 
> extern void F77(cptsvx)(char* fact, int* n, int* nrhs, float d[],
>         complex8_t e[], float df[], complex8_t ef[], complex8_t b[],
>         int* ldb, complex8_t x[], int* ldx, float* rcond, float ferr[],
>         float berr[], complex8_t work[], float rwork[], int* info,
>         int len_fact);
> 
> extern void F77(cpttrf)(int* n, float d[], complex8_t e[], int* info);
> 
> extern void F77(cpttrs)(char* uplo, int* n, int* nrhs, float d[],
>         complex8_t e[], complex8_t b[], int* ldb, int* info,
>         int len_uplo);
> 
> extern float F77(cputime)(float* tzero);
> 
> extern void F77(cspcon)(char* uplo, int* n, complex8_t ap[], int ipiv[],
>         float* anorm, float* rcond, complex8_t work[], int* info,
>         int len_uplo);
> 
> extern void F77(cspsv)(char* uplo, int* n, int* nrhs, complex8_t ap[],
>         int ipiv[], complex8_t b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(cspsvx)(char* fact, char* uplo, int* n, int* nrhs,
>         complex8_t ap[], complex8_t afp[], int ipiv[], complex8_t b[],
>         int* ldb, complex8_t x[], int* ldx, float* rcond, float ferr[],
>         float berr[], complex8_t work[], float rwork[], int* info,
>         int len_fact, int len_uplo);
> 
> extern void F77(csptrf)(char* uplo, int* n, complex8_t ap[], int ipiv[],
>         int* info, int len_uplo);
> 
> extern void F77(csptri)(char* uplo, int* n, complex8_t ap[], int ipiv[],
>         complex8_t work[], int* info, int len_uplo);
> 
> extern void F77(csptrs)(char* uplo, int* n, int* nrhs, complex8_t ap[],
>         int ipiv[], complex8_t b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(cstedc)(char* jobz, int* n, float d[], float e[],
>         complex8_t z[], int* ldz, complex8_t work[], int* lwork,
>         float rwork[], int* lrwork, int iwork[], int* liwork, int* info,
>         int len_jobz);
> 
> extern void F77(csteqr)(char* jobz, int* n, float d[], float e[],
>         complex8_t z[], int* ldz, float work[], int* info,
>         int len_jobz);
> 
> extern void F77(csycon)(char* uplo, int* n, complex8_t a[], int* lda,
>         int ipiv[], float* anorm, float* rcond, complex8_t work[],
>         int* info, int len_uplo);
> 
> extern void F77(csysv)(char* uplo, int* n, int* nrhs, complex8_t a[],
>         int* lda, int ipiv[], complex8_t b[], int* ldb,
>         complex8_t work[], int* lwork, int* info, int len_uplo);
> 
> extern void F77(csysvx)(char* fact, char* uplo, int* n, int* nrhs,
>         complex8_t a[], int* lda, complex8_t af[], int* ldaf,
>         int ipiv[], complex8_t b[], int* ldb, complex8_t x[], int* ldx,
>         float* rcond, float ferr[], float berr[], complex8_t work[],
>         int* lwork, float rwork[], int* info, int len_fact,
>         int len_uplo);
> 
> extern void F77(csytrf)(char* uplo, int* n, complex8_t a[], int* lda,
>         int ipiv[], complex8_t work[], int* lwork, int* info,
>         int len_uplo);
> 
> extern void F77(csytri)(char* uplo, int* n, complex8_t a[], int* lda,
>         int ipiv[], complex8_t work[], int* info, int len_uplo);
> 
> extern void F77(csytrs)(char* uplo, int* n, int* nrhs, complex8_t a[],
>         int* lda, int ipiv[], complex8_t b[], int* ldb, int* info,
>         int len_uplo);
> 
> extern void F77(ctbcon)(char* norm, char* uplo, char* diag, int* n, int* kd,
>         complex8_t ab[], int* ldab, float* rcond, complex8_t work[],
>         float rwork[], int* info, int len_norm, int len_uplo,
>         int len_diag);
> 
> extern void F77(ctbtrs)(char* uplo, char* trans, char* diag, int* n,
>         int* kd, int* nrhs, complex8_t ab[], int* ldab, complex8_t b[],
>         int* ldb, int* info, int len_uplo, int len_trans, int len_diag);
> 
> extern void F77(ctpcon)(char* norm, char* uplo, char* diag, int* n,
>         complex8_t ap[], float* rcond, complex8_t work[], float rwork[],
>         int* info, int len_norm, int len_uplo, int len_diag);
> 
> extern void F77(ctptri)(char* uplo, char* diag, int* n, complex8_t ap[],
>         int* info, int len_uplo, int len_diag);
> 
> extern void F77(ctptrs)(char* uplo, char* trans, char* diag, int* n,
>         int* nrhs, complex8_t ap[], complex8_t b[], int* ldb, int* info,
>         int len_uplo, int len_trans, int len_diag);
> 
> extern void F77(ctrcon)(char* norm, char* uplo, char* diag, int* n,
>         complex8_t a[], int* lda, float* rcond, complex8_t work[],
>         float rwork[], int* info, int len_norm, int len_uplo,
>         int len_diag);
> 
> extern void F77(ctrtri)(char* uplo, char* diag, int* n, complex8_t a[],
>         int* lda, int* info, int len_uplo, int len_diag);
> 
> extern void F77(ctrtrs)(char* uplo, char* trans, char* diag, int* n,
>         int* nrhs, complex8_t a[], int* lda, complex8_t b[], int* ldb,
>         int* info, int len_uplo, int len_trans, int len_diag);
> 
> extern void F77(ctzrqf)(int* m, int* n, complex8_t a[], int* lda,
>         complex8_t tau[], int* info);
> 
> extern void F77(cunglq)(int* m, int* n, int* k, complex8_t a[], int* lda,
>         complex8_t tau[], complex8_t work[], int* lwork, int* info);
> 
> extern void F77(cungql)(int* m, int* n, int* k, complex8_t a[], int* lda,
>         complex8_t tau[], complex8_t work[], int* lwork, int* info);
> 
> extern void F77(cungqr)(int* m, int* n, int* k, complex8_t a[], int* lda,
>         complex8_t tau[], complex8_t work[], int* lwork, int* info);
> 
> extern void F77(cungrq)(int* m, int* n, int* k, complex8_t a[], int* lda,
>         complex8_t tau[], complex8_t work[], int* lwork, int* info);
> 
> extern void F77(cunmlq)(char* side, char* trans, int* m, int* n, int* k,
>         complex8_t a[], int* lda, complex8_t tau[], complex8_t c[],
>         int* ldc, complex8_t work[], int* lwork, int* info,
>         int len_side, int len_trans);
> 
> extern void F77(cunmql)(char* side, char* trans, int* m, int* n, int* k,
>         complex8_t a[], int* lda, complex8_t tau[], complex8_t c[],
>         int* ldc, complex8_t work[], int* lwork, int* info,
>         int len_side, int len_trans);
> 
> extern void F77(cunmqr)(char* side, char* trans, int* m, int* n, int* k,
>         complex8_t a[], int* lda, complex8_t tau[], complex8_t c[],
>         int* ldc, complex8_t work[], int* lwork, int* info,
>         int len_side, int len_trans);
> 
> extern void F77(cunmrq)(char* side, char* trans, int* m, int* n, int* k,
>         complex8_t a[], int* lda, complex8_t tau[], complex8_t c[],
>         int* ldc, complex8_t work[], int* lwork, int* info,
>         int len_side, int len_trans);
> 
> extern void F77(dgbcon)(char* norm, int* n, int* kl, int* ku, double ab[],
>         int* ldab, int ipiv[], double* anorm, double* rcond,
>         double work[], int iwork[], int* info, int len_norm);
> 
> extern void F77(dgbsv)(int* n, int* kl, int* ku, int* nrhs, double ab[],
>         int* ldab, int ipiv[], double b[], int* ldb, int* info);
> 
> extern void F77(dgbsvx)(char* fact, char* trans, int* n, int* kl, int* ku,
>         int* nrhs, double ab[], int* ldab, double afb[], int* ldafb,
>         int ipiv[], char* equed, double r[], double c[], double b[],
>         int* ldb, double x[], int* ldx, double* rcond, double ferr[],
>         double berr[], double work[], int iwork[], int* info,
>         int len_fact, int len_trans, int len_equed);
> 
> extern void F77(dgbtrf)(int* m, int* n, int* kl, int* ku, double ab[],
>         int* ldab, int ipiv[], int* info);
> 
> extern void F77(dgbtrs)(char* trans, int* n, int* kl, int* ku, int* nrhs,
>         double ab[], int* ldab, int ipiv[], double b[], int* ldb,
>         int* info, int len_trans);
> 
> extern void F77(dgecon)(char* norm, int* n, double a[], int* lda,
>         double* anorm, double* rcond, double work[], int iwork[],
>         int* info, int len_norm);
> 
> extern void F77(dgees)(char* jobvs, char* sort, int (*select)(), int* n,
>         double a[], int* lda, int* sdim, double wr[], double wi[],
>         double vs[], int* ldvs, double work[], int* lwork, int bwork[],
>         int* info, int len_jobvs, int len_sort);
> 
> extern void F77(dgeesx)(char* jobvs, char* sort, int (*select)(),
>         char* sense, int* n, double a[], int* lda, int* sdim,
>         double wr[], double wi[], double vs[], int* ldvs,
>         double* rconde, double* rcondv, double work[], int* lwork,
>         int iwork[], int* liwork, int bwork[], int* info, int len_jobvs,
>         int len_sort, int len_sense);
> 
> extern void F77(dgeev)(char* jobvl, char* jobvr, int* n, double a[],
>         int* lda, double wr[], double wi[], double vl[], int* ldvl,
>         double vr[], int* ldvr, double work[], int* lwork, int* info,
>         int len_jobvl, int len_jobvr);
> 
> extern void F77(dgeevx)(char* balanc, char* jobvl, char* jobvr, char* sense,
>         int* n, double a[], int* lda, double wr[], double wi[],
>         double vl[], int* ldvl, double vr[], int* ldvr, int* ilo,
>         int* ihi, double scale[], double* abnrm, double rconde[],
>         double rcondv[], double work[], int* lwork, int iwork[],
>         int* info, int len_balanc, int len_jobvl, int len_jobvr,
>         int len_sense);
> 
> extern void F77(dgegs)(char* jobvsl, char* jobvsr, int* n, double a[],
>         int* lda, double b[], int* ldb, double alphar[],
>         double alphai[], double beta[], double vsl[], int* ldvsl,
>         double vsr[], int* ldvsr, double work[], int* lwork, int* info,
>         int len_jobvsl, int len_jobvsr);
> 
> extern void F77(dgegv)(char* jobvl, char* jobvr, int* n, double a[],
>         int* lda, double b[], int* ldb, double alphar[],
>         double alphai[], double beta[], double vl[], int* ldvl,
>         double vr[], int* ldvr, double work[], int* lwork, int* info,
>         int len_jobvl, int len_jobvr);
> 
> extern void F77(dgelqf)(int* m, int* n, double a[], int* lda, double tau[],
>         double work[], int* lwork, int* info);
> 
> extern void F77(dgels)(char* trans, int* m, int* n, int* nrhs, double a[],
>         int* lda, double b[], int* ldb, double work[], int* lwork,
>         int* info, int len_trans);
> 
> extern void F77(dgelss)(int* m, int* n, int* nrhs, double a[], int* lda,
>         double b[], int* ldb, double s[], double* rcond, int* rank,
>         double work[], int* lwork, int* info);
> 
> extern void F77(dgelsx)(int* m, int* n, int* nrhs, double a[], int* lda,
>         double b[], int* ldb, int jpvt[], double* rcond, int* rank,
>         double work[], int* info);
> 
> extern void F77(dgeqlf)(int* m, int* n, double a[], int* lda, double tau[],
>         double work[], int* lwork, int* info);
> 
> extern void F77(dgeqpf)(int* m, int* n, double a[], int* lda, int jpvt[],
>         double tau[], double work[], int* info);
> 
> extern void F77(dgeqrf)(int* m, int* n, double a[], int* lda, double tau[],
>         double work[], int* lwork, int* info);
> 
> extern void F77(dgerqf)(int* m, int* n, double a[], int* lda, double tau[],
>         double work[], int* lwork, int* info);
> 
> extern void F77(dgesv)(int* n, int* nrhs, double a[], int* lda, int ipiv[],
>         double b[], int* ldb, int* info);
> 
> extern void F77(dgesvd)(char* jobu, char* jobvt, int* m, int* n, double a[],
>         int* lda, double s[], double u[], int* ldu, double vt[],
>         int* ldvt, double work[], int* lwork, int* info, int len_jobu,
>         int len_jobvt);
> 
> extern void F77(dgesvx)(char* fact, char* trans, int* n, int* nrhs,
>         double a[], int* lda, double af[], int* ldaf, int ipiv[],
>         char* equed, double r[], double c[], double b[], int* ldb,
>         double x[], int* ldx, double* rcond, double ferr[],
>         double berr[], double work[], int iwork[], int* info,
>         int len_fact, int len_trans, int len_equed);
> 
> extern void F77(dgetrf)(int* m, int* n, double a[], int* lda, int ipiv[],
>         int* info);
> 
> extern void F77(dgetri)(int* n, double a[], int* lda, int ipiv[],
>         double work[], int* lwork, int* info);
> 
> extern void F77(dgetrs)(char* trans, int* n, int* nrhs, double a[],
>         int* lda, int ipiv[], double b[], int* ldb, int* info,
>         int len_trans);
> 
> extern void F77(dggglm)(int* n, int* m, int* p, double a[], int* lda,
>         double b[], int* ldb, double d[], double x[], double y[],
>         double work[], int* lwork, int* info);
> 
> extern void F77(dgglse)(int* m, int* n, int* p, double a[], int* lda,
>         double b[], int* ldb, double c[], double d[], double x[],
>         double work[], int* lwork, int* info);
> 
> extern void F77(dggqrf)(int* m, int* n, int* p, double a[], int* lda,
>         double taua[], double b[], int* ldb, double taub[],
>         double work[], int* lwork, int* info);
> 
> extern void F77(dggrqf)(int* m, int* n, int* p, double a[], int* lda,
>         double taua[], double b[], int* ldb, double taub[],
>         double work[], int* lwork, int* info);
> 
> extern void F77(dggsvd)(char* jobu, char* jobv, char* jobq, int* m, int* n,
>         int* p, int* k, int* l, double a[], int* lda, double b[],
>         int* ldb, double alpha[], double beta[], double u[], int* ldu,
>         double v[], int* ldv, double q[], int* ldq, double work[],
>         int iwork[], int* info, int len_jobu, int len_jobv,
>         int len_jobq);
> 
> extern void F77(dgtcon)(char* norm, int* n, double dl[], double d[],
>         double du[], double du2[], int ipiv[], double* anorm,
>         double* rcond, double work[], int iwork[], int* info,
>         int len_norm);
> 
> extern void F77(dgtsv)(int* n, int* nrhs, double dl[], double d[],
>         double du[], double b[], int* ldb, int* info);
> 
> extern void F77(dgtsvx)(char* fact, char* trans, int* n, int* nrhs,
>         double dl[], double d[], double du[], double dlf[], double df[],
>         double duf[], double du2[], int ipiv[], double b[], int* ldb,
>         double x[], int* ldx, double* rcond, double ferr[],
>         double berr[], double work[], int iwork[], int* info,
>         int len_fact, int len_trans);
> 
> extern void F77(dgttrf)(int* n, double dl[], double d[], double du[],
>         double du2[], int ipiv[], int* info);
> 
> extern void F77(dgttrs)(char* trans, int* n, int* nrhs, double dl[],
>         double d[], double du[], double du2[], int ipiv[], double b[],
>         int* ldb, int* info, int len_trans);
> 
> extern double F77(dlamch)(char* name, int len_name);
> 
> extern double F77(dlangb)(char* norm, int* n, int* kl, int* ku, double ab[],
>         int* ldab, double work[], int len_norm);
> 
> extern double F77(dlange)(char* norm, int* m, int* n, double a[], int* lda,
>         double work[], int len_norm);
> 
> extern double F77(dlangt)(char* norm, int* n, double dl[], double d[],
>         double du[], int len_norm);
> 
> extern double F77(dlansb)(char* norm, char* uplo, int* n, int* kd,
>         double ab[], int* ldab, double work[], int len_norm,
>         int len_uplo);
> 
> extern double F77(dlansp)(char* norm, char* uplo, int* n, double ap[],
>         double work[], int len_norm, int len_uplo);
> 
> extern double F77(dlanst)(char* norm, int* n, double d[], double e[],
>         int len_norm);
> 
> extern double F77(dlansy)(char* norm, char* uplo, int* n, double a[],
>         int* lda, double work[], int len_norm, int len_uplo);
> 
> extern void F77(dorglq)(int* m, int* n, int* k, double a[], int* lda,
>         double tau[], double work[], int* lwork, int* info);
> 
> extern void F77(dorgql)(int* m, int* n, int* k, double a[], int* lda,
>         double tau[], double work[], int* lwork, int* info);
> 
> extern void F77(dorgqr)(int* m, int* n, int* k, double a[], int* lda,
>         double tau[], double work[], int* lwork, int* info);
> 
> extern void F77(dorgrq)(int* m, int* n, int* k, double a[], int* lda,
>         double tau[], double work[], int* lwork, int* info);
> 
> extern void F77(dormlq)(char* side, char* trans, int* m, int* n, int* k,
>         double a[], int* lda, double tau[], double c[], int* ldc,
>         double work[], int* lwork, int* info, int len_side,
>         int len_trans);
> 
> extern void F77(dormql)(char* side, char* trans, int* m, int* n, int* k,
>         double a[], int* lda, double tau[], double c[], int* ldc,
>         double work[], int* lwork, int* info, int len_side,
>         int len_trans);
> 
> extern void F77(dormqr)(char* side, char* trans, int* m, int* n, int* k,
>         double a[], int* lda, double tau[], double c[], int* ldc,
>         double work[], int* lwork, int* info, int len_side,
>         int len_trans);
> 
> extern void F77(dormrq)(char* side, char* trans, int* m, int* n, int* k,
>         double a[], int* lda, double tau[], double c[], int* ldc,
>         double work[], int* lwork, int* info, int len_side,
>         int len_trans);
> 
> extern void F77(dpbcon)(char* uplo, int* n, int* kd, double ab[], int* ldab,
>         double* anorm, double* rcond, double work[], int iwork[],
>         int* info, int len_uplo);
> 
> extern void F77(dpbsv)(char* uplo, int* n, int* kd, int* nrhs, double ab[],
>         int* ldab, double b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(dpbsvx)(char* fact, char* uplo, int* n, int* kd, int* nrhs,
>         double ab[], int* ldab, double afb[], int* ldafb, char* equed,
>         double s[], double b[], int* ldb, double x[], int* ldx,
>         double* rcond, double ferr[], double berr[], double work[],
>         int iwork[], int* info, int len_fact, int len_uplo,
>         int len_equed);
> 
> extern void F77(dpbtrf)(char* uplo, int* n, int* kd, double ab[], int* ldab,
>         int* info, int len_uplo);
> 
> extern void F77(dpbtrs)(char* uplo, int* n, int* kd, int* nrhs, double ab[],
>         int* ldab, double b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(dpocon)(char* uplo, int* n, double a[], int* lda,
>         double* anorm, double* rcond, double work[], int iwork[],
>         int* info, int len_uplo);
> 
> extern void F77(dposv)(char* uplo, int* n, int* nrhs, double a[], int* lda,
>         double b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(dposvx)(char* fact, char* uplo, int* n, int* nrhs,
>         double a[], int* lda, double af[], int* ldaf, char* equed,
>         double s[], double b[], int* ldb, double x[], int* ldx,
>         double* rcond, double ferr[], double berr[], double work[],
>         int iwork[], int* info, int len_fact, int len_uplo,
>         int len_equed);
> 
> extern void F77(dpotrf)(char* uplo, int* n, double a[], int* lda, int* info,
>         int len_uplo);
> 
> extern void F77(dpotri)(char* uplo, int* n, double a[], int* lda, int* info,
>         int len_uplo);
> 
> extern void F77(dpotrs)(char* uplo, int* n, int* nrhs, double a[], int* lda,
>         double b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(dppcon)(char* uplo, int* n, double ap[], double* anorm,
>         double* rcond, double work[], int iwork[], int* info,
>         int len_uplo);
> 
> extern void F77(dppsv)(char* uplo, int* n, int* nrhs, double ap[],
>         double b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(dppsvx)(char* fact, char* uplo, int* n, int* nrhs,
>         double ap[], double afp[], char* equed, double s[], double b[],
>         int* ldb, double x[], int* ldx, double* rcond, double ferr[],
>         double berr[], double work[], int iwork[], int* info,
>         int len_fact, int len_uplo, int len_equed);
> 
> extern void F77(dpptrf)(char* uplo, int* n, double ap[], int* info,
>         int len_uplo);
> 
> extern void F77(dpptri)(char* uplo, int* n, double ap[], int* info,
>         int len_uplo);
> 
> extern void F77(dpptrs)(char* uplo, int* n, int* nrhs, double ap[],
>         double b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(dptcon)(int* n, double d[], double e[], double* anorm,
>         double* rcond, double work[], int* info);
> 
> extern void F77(dptsv)(int* n, int* nrhs, double d[], double e[],
>         double b[], int* ldb, int* info);
> 
> extern void F77(dptsvx)(char* fact, int* n, int* nrhs, double d[],
>         double e[], double df[], double ef[], double b[], int* ldb,
>         double x[], int* ldx, double* rcond, double ferr[],
>         double berr[], double work[], int* info, int len_fact);
> 
> extern void F77(dpttrf)(int* n, double d[], double e[], int* info);
> 
> extern void F77(dpttrs)(int* n, int* nrhs, double d[], double e[],
>         double b[], int* ldb, int* info);
> 
> extern void F77(dsbev)(char* jobz, char* uplo, int* n, int* kd, double ab[],
>         int* ldab, double w[], double z[], int* ldz, double work[],
>         int* info, int len_jobz, int len_uplo);
> 
> extern void F77(dsbevd)(char* jobz, char* uplo, int* n, int* kd,
>         double ab[], int* ldab, double w[], double z[], int* ldz,
>         double work[], int* lwork, int iwork[], int* liwork, int* info,
>         int len_jobz, int len_uplo);
> 
> extern void F77(dsbevx)(char* jobz, char* range, char* uplo, int* n,
>         int* kd, double ab[], int* ldab, double q[], int* ldq,
>         double* vl, double* vu, int* il, int* iu, double* abstol,
>         int* m, double w[], double z[], int* ldz, double work[],
>         int iwork[], int ifail[], int* info, int len_jobz,
>         int len_range, int len_uplo);
> 
> extern void F77(dsbgv)(char* jobz, char* uplo, int* n, int* ka, int* kb,
>         double ab[], int* ldab, double bb[], int* ldbb, double w[],
>         double z[], int* ldz, double work[], int* info, int len_jobz,
>         int len_uplo);
> 
> extern void F77(dspcon)(char* uplo, int* n, double ap[], int ipiv[],
>         double* anorm, double* rcond, double work[], int iwork[],
>         int* info, int len_uplo);
> 
> extern void F77(dspev)(char* jobz, char* uplo, int* n, double ap[],
>         double w[], double z[], int* ldz, double work[], int* info,
>         int len_jobz, int len_uplo);
> 
> extern void F77(dspevd)(char* jobz, char* uplo, int* n, double ap[],
>         double w[], double z[], int* ldz, double work[], int* lwork,
>         int iwork[], int* liwork, int* info, int len_jobz,
>         int len_uplo);
> 
> extern void F77(dspevx)(char* jobz, char* range, char* uplo, int* n,
>         double ap[], double* vl, double* vu, int* il, int* iu,
>         double* abstol, int* m, double w[], double z[], int* ldz,
>         double work[], int iwork[], int ifail[], int* info,
>         int len_jobz, int len_range, int len_uplo);
> 
> extern void F77(dspgv)(int* itype, char* jobz, char* uplo, int* n,
>         double ap[], double bp[], double w[], double z[], int* ldz,
>         double work[], int* info, int len_jobz, int len_uplo);
> 
> extern void F77(dspsv)(char* uplo, int* n, int* nrhs, double ap[],
>         int ipiv[], double b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(dspsvx)(char* fact, char* uplo, int* n, int* nrhs,
>         double ap[], double afp[], int ipiv[], double b[], int* ldb,
>         double x[], int* ldx, double* rcond, double ferr[],
>         double berr[], double work[], int iwork[], int* info,
>         int len_fact, int len_uplo);
> 
> extern void F77(dsptrf)(char* uplo, int* n, double ap[], int ipiv[],
>         int* info, int len_uplo);
> 
> extern void F77(dsptri)(char* uplo, int* n, double ap[], int ipiv[],
>         double work[], int* info, int len_uplo);
> 
> extern void F77(dsptrs)(char* uplo, int* n, int* nrhs, double ap[],
>         int ipiv[], double b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(dstedc)(char* jobz, int* n, double d[], double e[],
>         double z[], int* ldz, double work[], int* lwork, int iwork[],
>         int* liwork, int* info, int len_jobz);
> 
> extern void F77(dsteqr)(char* jobz, int* n, double d[], double e[],
>         double z[], int* ldz, double work[], int* info, int len_jobz);
> 
> extern void F77(dstev)(char* jobz, int* n, double d[], double e[],
>         double z[], int* ldz, double work[], int* info, int len_jobz);
> 
> extern void F77(dstevd)(char* jobz, int* n, double d[], double e[],
>         double z[], int* ldz, double work[], int* lwork, int iwork[],
>         int* liwork, int* info, int len_jobz);
> 
> extern void F77(dstevx)(char* jobz, char* range, int* n, double d[],
>         double e[], double* vl, double* vu, int* il, int* iu,
>         double* abstol, int* m, double w[], double z[], int* ldz,
>         double work[], int iwork[], int ifail[], int* info,
>         int len_jobz, int len_range);
> 
> extern void F77(dsycon)(char* uplo, int* n, double a[], int* lda,
>         int ipiv[], double* anorm, double* rcond, double work[],
>         int iwork[], int* info, int len_uplo);
> 
> extern void F77(dsyev)(char* jobz, char* uplo, int* n, double a[], int* lda,
>         double w[], double work[], int* lwork, int* info, int len_jobz,
>         int len_uplo);
> 
> extern void F77(dsyevd)(char* jobz, char* uplo, int* n, double a[],
>         int* lda, double w[], double work[], int* lwork, int iwork[],
>         int* liwork, int* info, int len_jobz, int len_uplo);
> 
> extern void F77(dsyevx)(char* jobz, char* range, char* uplo, int* n,
>         double a[], int* lda, double* vl, double* vu, int* il, int* iu,
>         double* abstol, int* m, double w[], double z[], int* ldz,
>         double work[], int* lwork, int iwork[], int ifail[], int* info,
>         int len_jobz, int len_range, int len_uplo);
> 
> extern void F77(dsygv)(int* itype, char* jobz, char* uplo, int* n,
>         double a[], int* lda, double b[], int* ldb, double w[],
>         double work[], int* lwork, int* info, int len_jobz,
>         int len_uplo);
> 
> extern void F77(dsysv)(char* uplo, int* n, int* nrhs, double a[], int* lda,
>         int ipiv[], double b[], int* ldb, double work[], int* lwork,
>         int* info, int len_uplo);
> 
> extern void F77(dsysvx)(char* fact, char* uplo, int* n, int* nrhs,
>         double a[], int* lda, double af[], int* ldaf, int ipiv[],
>         double b[], int* ldb, double x[], int* ldx, double* rcond,
>         double ferr[], double berr[], double work[], int* lwork,
>         int iwork[], int* info, int len_fact, int len_uplo);
> 
> extern void F77(dsytrf)(char* uplo, int* n, double a[], int* lda,
>         int ipiv[], double work[], int* lwork, int* info, int len_uplo);
> 
> extern void F77(dsytri)(char* uplo, int* n, double a[], int* lda,
>         int ipiv[], double work[], int* info, int len_uplo);
> 
> extern void F77(dsytrs)(char* uplo, int* n, int* nrhs, double a[], int* lda,
>         int ipiv[], double b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(dtbcon)(char* norm, char* uplo, char* diag, int* n, int* kd,
>         double ab[], int* ldab, double* rcond, double work[],
>         int iwork[], int* info, int len_norm, int len_uplo,
>         int len_diag);
> 
> extern void F77(dtbtrs)(char* uplo, char* trans, char* diag, int* n,
>         int* kd, int* nrhs, double ab[], int* ldab, double b[],
>         int* ldb, int* info, int len_uplo, int len_trans, int len_diag);
> 
> extern void F77(dtpcon)(char* norm, char* uplo, char* diag, int* n,
>         double ap[], double* rcond, double work[], int iwork[],
>         int* info, int len_norm, int len_uplo, int len_diag);
> 
> extern void F77(dtptri)(char* uplo, char* diag, int* n, double ap[],
>         int* info, int len_uplo, int len_diag);
> 
> extern void F77(dtptrs)(char* uplo, char* trans, char* diag, int* n,
>         int* nrhs, double ap[], double b[], int* ldb, int* info,
>         int len_uplo, int len_trans, int len_diag);
> 
> extern void F77(dtrcon)(char* norm, char* uplo, char* diag, int* n,
>         double a[], int* lda, double* rcond, double work[], int iwork[],
>         int* info, int len_norm, int len_uplo, int len_diag);
> 
> extern void F77(dtrtri)(char* uplo, char* diag, int* n, double a[],
>         int* lda, int* info, int len_uplo, int len_diag);
> 
> extern void F77(dtrtrs)(char* uplo, char* trans, char* diag, int* n,
>         int* nrhs, double a[], int* lda, double b[], int* ldb,
>         int* info, int len_uplo, int len_trans, int len_diag);
> 
> extern void F77(dtzrqf)(int* m, int* n, double a[], int* lda, double tau[],
>         int* info);
> 
> extern int F77(ilaenv)(int* ispec, char* name, char* opts, int* n1, int* n2,
>         int* n3, int* n4, int len_name, int len_opts);
> 
> extern void F77(sgbcon)(char* norm, int* n, int* kl, int* ku, float ab[],
>         int* ldab, int ipiv[], float* anorm, float* rcond, float work[],
>         int iwork[], int* info, int len_norm);
> 
> extern void F77(sgbsv)(int* n, int* kl, int* ku, int* nrhs, float ab[],
>         int* ldab, int ipiv[], float b[], int* ldb, int* info);
> 
> extern void F77(sgbsvx)(char* fact, char* trans, int* n, int* kl, int* ku,
>         int* nrhs, float ab[], int* ldab, float afb[], int* ldafb,
>         int ipiv[], char* equed, float r[], float c[], float b[],
>         int* ldb, float x[], int* ldx, float* rcond, float ferr[],
>         float berr[], float work[], int iwork[], int* info,
>         int len_fact, int len_trans, int len_equed);
> 
> extern void F77(sgbtrf)(int* m, int* n, int* kl, int* ku, float ab[],
>         int* ldab, int ipiv[], int* info);
> 
> extern void F77(sgbtrs)(char* trans, int* n, int* kl, int* ku, int* nrhs,
>         float ab[], int* ldab, int ipiv[], float b[], int* ldb,
>         int* info, int len_trans);
> 
> extern void F77(sgecon)(char* norm, int* n, float a[], int* lda,
>         float* anorm, float* rcond, float work[], int iwork[],
>         int* info, int len_norm);
> 
> extern void F77(sgees)(char* jobvs, char* sort, int (*select)(), int* n,
>         float a[], int* lda, int* sdim, float wr[], float wi[],
>         float vs[], int* ldvs, float work[], int* lwork, int bwork[],
>         int* info, int len_jobvs, int len_sort);
> 
> extern void F77(sgeesx)(char* jobvs, char* sort, int (*select)(),
>         char* sense, int* n, float a[], int* lda, int* sdim, float wr[],
>         float wi[], float vs[], int* ldvs, float* rconde, float* rcondv,
>         float work[], int* lwork, int iwork[], int* liwork, int bwork[],
>         int* info, int len_jobvs, int len_sort, int len_sense);
> 
> extern void F77(sgeev)(char* jobvl, char* jobvr, int* n, float a[],
>         int* lda, float wr[], float wi[], float vl[], int* ldvl,
>         float vr[], int* ldvr, float work[], int* lwork, int* info,
>         int len_jobvl, int len_jobvr);
> 
> extern void F77(sgeevx)(char* balanc, char* jobvl, char* jobvr, char* sense,
>         int* n, float a[], int* lda, float wr[], float wi[], float vl[],
>         int* ldvl, float vr[], int* ldvr, int* ilo, int* ihi,
>         float scale[], float* abnrm, float rconde[], float rcondv[],
>         float work[], int* lwork, int iwork[], int* info,
>         int len_balanc, int len_jobvl, int len_jobvr, int len_sense);
> 
> extern void F77(sgegs)(char* jobvsl, char* jobvsr, int* n, float a[],
>         int* lda, float b[], int* ldb, float alphar[], float alphai[],
>         float beta[], float vsl[], int* ldvsl, float vsr[], int* ldvsr,
>         float work[], int* lwork, int* info, int len_jobvsl,
>         int len_jobvsr);
> 
> extern void F77(sgegv)(char* jobvl, char* jobvr, int* n, float a[],
>         int* lda, float b[], int* ldb, float alphar[], float alphai[],
>         float beta[], float vl[], int* ldvl, float vr[], int* ldvr,
>         float work[], int* lwork, int* info, int len_jobvl,
>         int len_jobvr);
> 
> extern void F77(sgelqf)(int* m, int* n, float a[], int* lda, float tau[],
>         float work[], int* lwork, int* info);
> 
> extern void F77(sgels)(char* trans, int* m, int* n, int* nrhs, float a[],
>         int* lda, float b[], int* ldb, float work[], int* lwork,
>         int* info, int len_trans);
> 
> extern void F77(sgelss)(int* m, int* n, int* nrhs, float a[], int* lda,
>         float b[], int* ldb, float s[], float* rcond, int* rank,
>         float work[], int* lwork, int* info);
> 
> extern void F77(sgelsx)(int* m, int* n, int* nrhs, float a[], int* lda,
>         float b[], int* ldb, int jpvt[], float* rcond, int* rank,
>         float work[], int* info);
> 
> extern void F77(sgeqlf)(int* m, int* n, float a[], int* lda, float tau[],
>         float work[], int* lwork, int* info);
> 
> extern void F77(sgeqpf)(int* m, int* n, float a[], int* lda, int jpvt[],
>         float tau[], float work[], int* info);
> 
> extern void F77(sgeqrf)(int* m, int* n, float a[], int* lda, float tau[],
>         float work[], int* lwork, int* info);
> 
> extern void F77(sgerqf)(int* m, int* n, float a[], int* lda, float tau[],
>         float work[], int* lwork, int* info);
> 
> extern void F77(sgesv)(int* n, int* nrhs, float a[], int* lda, int ipiv[],
>         float b[], int* ldb, int* info);
> 
> extern void F77(sgesvd)(char* jobu, char* jobvt, int* m, int* n, float a[],
>         int* lda, float s[], float u[], int* ldu, float vt[], int* ldvt,
>         float work[], int* lwork, int* info, int len_jobu,
>         int len_jobvt);
> 
> extern void F77(sgesvx)(char* fact, char* trans, int* n, int* nrhs,
>         float a[], int* lda, float af[], int* ldaf, int ipiv[],
>         char* equed, float r[], float c[], float b[], int* ldb,
>         float x[], int* ldx, float* rcond, float ferr[], float berr[],
>         float work[], int iwork[], int* info, int len_fact,
>         int len_trans, int len_equed);
> 
> extern void F77(sgetrf)(int* m, int* n, float a[], int* lda, int ipiv[],
>         int* info);
> 
> extern void F77(sgetri)(int* n, float a[], int* lda, int ipiv[],
>         float work[], int* lwork, int* info);
> 
> extern void F77(sgetrs)(char* trans, int* n, int* nrhs, float a[], int* lda,
>         int ipiv[], float b[], int* ldb, int* info, int len_trans);
> 
> extern void F77(sggglm)(int* n, int* m, int* p, float a[], int* lda,
>         float b[], int* ldb, float d[], float x[], float y[],
>         float work[], int* lwork, int* info);
> 
> extern void F77(sgglse)(int* m, int* n, int* p, float a[], int* lda,
>         float b[], int* ldb, float c[], float d[], float x[],
>         float work[], int* lwork, int* info);
> 
> extern void F77(sggqrf)(int* m, int* n, int* p, float a[], int* lda,
>         float taua[], float b[], int* ldb, float taub[], float work[],
>         int* lwork, int* info);
> 
> extern void F77(sggrqf)(int* m, int* n, int* p, float a[], int* lda,
>         float taua[], float b[], int* ldb, float taub[], float work[],
>         int* lwork, int* info);
> 
> extern void F77(sggsvd)(char* jobu, char* jobv, char* jobq, int* m, int* n,
>         int* p, int* k, int* l, float a[], int* lda, float b[],
>         int* ldb, float alpha[], float beta[], float u[], int* ldu,
>         float v[], int* ldv, float q[], int* ldq, float work[],
>         int iwork[], int* info, int len_jobu, int len_jobv,
>         int len_jobq);
> 
> extern void F77(sgtcon)(char* norm, int* n, float dl[], float d[],
>         float du[], float du2[], int ipiv[], float* anorm, float* rcond,
>         float work[], int iwork[], int* info, int len_norm);
> 
> extern void F77(sgtsv)(int* n, int* nrhs, float dl[], float d[], float du[],
>         float b[], int* ldb, int* info);
> 
> extern void F77(sgtsvx)(char* fact, char* trans, int* n, int* nrhs,
>         float dl[], float d[], float du[], float dlf[], float df[],
>         float duf[], float du2[], int ipiv[], float b[], int* ldb,
>         float x[], int* ldx, float* rcond, float ferr[], float berr[],
>         float work[], int iwork[], int* info, int len_fact,
>         int len_trans);
> 
> extern void F77(sgttrf)(int* n, float dl[], float d[], float du[],
>         float du2[], int ipiv[], int* info);
> 
> extern void F77(sgttrs)(char* trans, int* n, int* nrhs, float dl[],
>         float d[], float du[], float du2[], int ipiv[], float b[],
>         int* ldb, int* info, int len_trans);
> 
> extern float F77(slamch)(char* name, int len_name);
> 
> extern float F77(slangb)(char* norm, int* n, int* kl, int* ku, float ab[],
>         int* ldab, float work[], int len_norm);
> 
> extern float F77(slange)(char* norm, int* m, int* n, float a[], int* lda,
>         float work[], int len_norm);
> 
> extern float F77(slangt)(char* norm, int* n, float dl[], float d[],
>         float du[], int len_norm);
> 
> extern float F77(slansb)(char* norm, char* uplo, int* n, int* kd,
>         float ab[], int* ldab, float work[], int len_norm,
>         int len_uplo);
> 
> extern float F77(slansp)(char* norm, char* uplo, int* n, float ap[],
>         float work[], int len_norm, int len_uplo);
> 
> extern float F77(slanst)(char* norm, int* n, float d[], float e[],
>         int len_norm);
> 
> extern float F77(slansy)(char* norm, char* uplo, int* n, float a[],
>         int* lda, float work[], int len_norm, int len_uplo);
> 
> extern void F77(sorglq)(int* m, int* n, int* k, float a[], int* lda,
>         float tau[], float work[], int* lwork, int* info);
> 
> extern void F77(sorgql)(int* m, int* n, int* k, float a[], int* lda,
>         float tau[], float work[], int* lwork, int* info);
> 
> extern void F77(sorgqr)(int* m, int* n, int* k, float a[], int* lda,
>         float tau[], float work[], int* lwork, int* info);
> 
> extern void F77(sorgrq)(int* m, int* n, int* k, float a[], int* lda,
>         float tau[], float work[], int* lwork, int* info);
> 
> extern void F77(sormlq)(char* side, char* trans, int* m, int* n, int* k,
>         float a[], int* lda, float tau[], float c[], int* ldc,
>         float work[], int* lwork, int* info, int len_side,
>         int len_trans);
> 
> extern void F77(sormql)(char* side, char* trans, int* m, int* n, int* k,
>         float a[], int* lda, float tau[], float c[], int* ldc,
>         float work[], int* lwork, int* info, int len_side,
>         int len_trans);
> 
> extern void F77(sormqr)(char* side, char* trans, int* m, int* n, int* k,
>         float a[], int* lda, float tau[], float c[], int* ldc,
>         float work[], int* lwork, int* info, int len_side,
>         int len_trans);
> 
> extern void F77(sormrq)(char* side, char* trans, int* m, int* n, int* k,
>         float a[], int* lda, float tau[], float c[], int* ldc,
>         float work[], int* lwork, int* info, int len_side,
>         int len_trans);
> 
> extern void F77(spbcon)(char* uplo, int* n, int* kd, float ab[], int* ldab,
>         float* anorm, float* rcond, float work[], int iwork[],
>         int* info, int len_uplo);
> 
> extern void F77(spbsv)(char* uplo, int* n, int* kd, int* nrhs, float ab[],
>         int* ldab, float b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(spbsvx)(char* fact, char* uplo, int* n, int* kd, int* nrhs,
>         float ab[], int* ldab, float afb[], int* ldafb, char* equed,
>         float s[], float b[], int* ldb, float x[], int* ldx,
>         float* rcond, float ferr[], float berr[], float work[],
>         int iwork[], int* info, int len_fact, int len_uplo,
>         int len_equed);
> 
> extern void F77(spbtrf)(char* uplo, int* n, int* kd, float ab[], int* ldab,
>         int* info, int len_uplo);
> 
> extern void F77(spbtrs)(char* uplo, int* n, int* kd, int* nrhs, float ab[],
>         int* ldab, float b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(spocon)(char* uplo, int* n, float a[], int* lda,
>         float* anorm, float* rcond, float work[], int iwork[],
>         int* info, int len_uplo);
> 
> extern void F77(sposv)(char* uplo, int* n, int* nrhs, float a[], int* lda,
>         float b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(sposvx)(char* fact, char* uplo, int* n, int* nrhs,
>         float a[], int* lda, float af[], int* ldaf, char* equed,
>         float s[], float b[], int* ldb, float x[], int* ldx,
>         float* rcond, float ferr[], float berr[], float work[],
>         int iwork[], int* info, int len_fact, int len_uplo,
>         int len_equed);
> 
> extern void F77(spotrf)(char* uplo, int* n, float a[], int* lda, int* info,
>         int len_uplo);
> 
> extern void F77(spotri)(char* uplo, int* n, float a[], int* lda, int* info,
>         int len_uplo);
> 
> extern void F77(spotrs)(char* uplo, int* n, int* nrhs, float a[], int* lda,
>         float b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(sppcon)(char* uplo, int* n, float ap[], float* anorm,
>         float* rcond, float work[], int iwork[], int* info,
>         int len_uplo);
> 
> extern void F77(sppsv)(char* uplo, int* n, int* nrhs, float ap[], float b[],
>         int* ldb, int* info, int len_uplo);
> 
> extern void F77(sppsvx)(char* fact, char* uplo, int* n, int* nrhs,
>         float ap[], float afp[], char* equed, float s[], float b[],
>         int* ldb, float x[], int* ldx, float* rcond, float ferr[],
>         float berr[], float work[], int iwork[], int* info,
>         int len_fact, int len_uplo, int len_equed);
> 
> extern void F77(spptrf)(char* uplo, int* n, float ap[], int* info,
>         int len_uplo);
> 
> extern void F77(spptri)(char* uplo, int* n, float ap[], int* info,
>         int len_uplo);
> 
> extern void F77(spptrs)(char* uplo, int* n, int* nrhs, float ap[],
>         float b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(sptcon)(int* n, float d[], float e[], float* anorm,
>         float* rcond, float work[], int* info);
> 
> extern void F77(sptsv)(int* n, int* nrhs, float d[], float e[], float b[],
>         int* ldb, int* info);
> 
> extern void F77(sptsvx)(char* fact, int* n, int* nrhs, float d[], float e[],
>         float df[], float ef[], float b[], int* ldb, float x[],
>         int* ldx, float* rcond, float ferr[], float berr[],
>         float work[], int* info, int len_fact);
> 
> extern void F77(spttrf)(int* n, float d[], float e[], int* info);
> 
> extern void F77(spttrs)(int* n, int* nrhs, float d[], float e[], float b[],
>         int* ldb, int* info);
> 
> extern void F77(ssbev)(char* jobz, char* uplo, int* n, int* kd, float ab[],
>         int* ldab, float w[], float z[], int* ldz, float work[],
>         int* info, int len_jobz, int len_uplo);
> 
> extern void F77(ssbevd)(char* jobz, char* uplo, int* n, int* kd, float ab[],
>         int* ldab, float w[], float z[], int* ldz, float work[],
>         int* lwork, int iwork[], int* liwork, int* info, int len_jobz,
>         int len_uplo);
> 
> extern void F77(ssbevx)(char* jobz, char* range, char* uplo, int* n,
>         int* kd, float ab[], int* ldab, float q[], int* ldq, float* vl,
>         float* vu, int* il, int* iu, float* abstol, int* m, float w[],
>         float z[], int* ldz, float work[], int iwork[], int ifail[],
>         int* info, int len_jobz, int len_range, int len_uplo);
> 
> extern void F77(ssbgv)(char* jobz, char* uplo, int* n, int* ka, int* kb,
>         float ab[], int* ldab, float bb[], int* ldbb, float w[],
>         float z[], int* ldz, float work[], int* info, int len_jobz,
>         int len_uplo);
> 
> extern void F77(sspcon)(char* uplo, int* n, float ap[], int ipiv[],
>         float* anorm, float* rcond, float work[], int iwork[],
>         int* info, int len_uplo);
> 
> extern void F77(sspev)(char* jobz, char* uplo, int* n, float ap[],
>         float w[], float z[], int* ldz, float work[], int* info,
>         int len_jobz, int len_uplo);
> 
> extern void F77(sspevd)(char* jobz, char* uplo, int* n, float ap[],
>         float w[], float z[], int* ldz, float work[], int* lwork,
>         int iwork[], int* liwork, int* info, int len_jobz,
>         int len_uplo);
> 
> extern void F77(sspevx)(char* jobz, char* range, char* uplo, int* n,
>         float ap[], float* vl, float* vu, int* il, int* iu,
>         float* abstol, int* m, float w[], float z[], int* ldz,
>         float work[], int iwork[], int ifail[], int* info, int len_jobz,
>         int len_range, int len_uplo);
> 
> extern void F77(sspgv)(int* itype, char* jobz, char* uplo, int* n,
>         float ap[], float bp[], float w[], float z[], int* ldz,
>         float work[], int* info, int len_jobz, int len_uplo);
> 
> extern void F77(sspsv)(char* uplo, int* n, int* nrhs, float ap[],
>         int ipiv[], float b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(sspsvx)(char* fact, char* uplo, int* n, int* nrhs,
>         float ap[], float afp[], int ipiv[], float b[], int* ldb,
>         float x[], int* ldx, float* rcond, float ferr[], float berr[],
>         float work[], int iwork[], int* info, int len_fact,
>         int len_uplo);
> 
> extern void F77(ssptrf)(char* uplo, int* n, float ap[], int ipiv[],
>         int* info, int len_uplo);
> 
> extern void F77(ssptri)(char* uplo, int* n, float ap[], int ipiv[],
>         float work[], int* info, int len_uplo);
> 
> extern void F77(ssptrs)(char* uplo, int* n, int* nrhs, float ap[],
>         int ipiv[], float b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(sstedc)(char* jobz, int* n, float d[], float e[], float z[],
>         int* ldz, float work[], int* lwork, int iwork[], int* liwork,
>         int* info, int len_jobz);
> 
> extern void F77(ssteqr)(char* jobz, int* n, float d[], float e[], float z[],
>         int* ldz, float work[], int* info, int len_jobz);
> 
> extern void F77(sstev)(char* jobz, int* n, float d[], float e[], float z[],
>         int* ldz, float work[], int* info, int len_jobz);
> 
> extern void F77(sstevd)(char* jobz, int* n, float d[], float e[], float z[],
>         int* ldz, float work[], int* lwork, int iwork[], int* liwork,
>         int* info, int len_jobz);
> 
> extern void F77(sstevx)(char* jobz, char* range, int* n, float d[],
>         float e[], float* vl, float* vu, int* il, int* iu,
>         float* abstol, int* m, float w[], float z[], int* ldz,
>         float work[], int iwork[], int ifail[], int* info, int len_jobz,
>         int len_range);
> 
> extern void F77(ssycon)(char* uplo, int* n, float a[], int* lda, int ipiv[],
>         float* anorm, float* rcond, float work[], int iwork[],
>         int* info, int len_uplo);
> 
> extern void F77(ssyev)(char* jobz, char* uplo, int* n, float a[], int* lda,
>         float w[], float work[], int* lwork, int* info, int len_jobz,
>         int len_uplo);
> 
> extern void F77(ssyevd)(char* jobz, char* uplo, int* n, float a[], int* lda,
>         float w[], float work[], int* lwork, int iwork[], int* liwork,
>         int* info, int len_jobz, int len_uplo);
> 
> extern void F77(ssyevx)(char* jobz, char* range, char* uplo, int* n,
>         float a[], int* lda, float* vl, float* vu, int* il, int* iu,
>         float* abstol, int* m, float w[], float z[], int* ldz,
>         float work[], int* lwork, int iwork[], int ifail[], int* info,
>         int len_jobz, int len_range, int len_uplo);
> 
> extern void F77(ssygv)(int* itype, char* jobz, char* uplo, int* n,
>         float a[], int* lda, float b[], int* ldb, float w[],
>         float work[], int* lwork, int* info, int len_jobz,
>         int len_uplo);
> 
> extern void F77(ssysv)(char* uplo, int* n, int* nrhs, float a[], int* lda,
>         int ipiv[], float b[], int* ldb, float work[], int* lwork,
>         int* info, int len_uplo);
> 
> extern void F77(ssysvx)(char* fact, char* uplo, int* n, int* nrhs,
>         float a[], int* lda, float af[], int* ldaf, int ipiv[],
>         float b[], int* ldb, float x[], int* ldx, float* rcond,
>         float ferr[], float berr[], float work[], int* lwork,
>         int iwork[], int* info, int len_fact, int len_uplo);
> 
> extern void F77(ssytrf)(char* uplo, int* n, float a[], int* lda, int ipiv[],
>         float work[], int* lwork, int* info, int len_uplo);
> 
> extern void F77(ssytri)(char* uplo, int* n, float a[], int* lda, int ipiv[],
>         float work[], int* info, int len_uplo);
> 
> extern void F77(ssytrs)(char* uplo, int* n, int* nrhs, float a[], int* lda,
>         int ipiv[], float b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(stbcon)(char* norm, char* uplo, char* diag, int* n, int* kd,
>         float ab[], int* ldab, float* rcond, float work[], int iwork[],
>         int* info, int len_norm, int len_uplo, int len_diag);
> 
> extern void F77(stbtrs)(char* uplo, char* trans, char* diag, int* n,
>         int* kd, int* nrhs, float ab[], int* ldab, float b[], int* ldb,
>         int* info, int len_uplo, int len_trans, int len_diag);
> 
> extern void F77(stpcon)(char* norm, char* uplo, char* diag, int* n,
>         float ap[], float* rcond, float work[], int iwork[], int* info,
>         int len_norm, int len_uplo, int len_diag);
> 
> extern void F77(stptri)(char* uplo, char* diag, int* n, float ap[],
>         int* info, int len_uplo, int len_diag);
> 
> extern void F77(stptrs)(char* uplo, char* trans, char* diag, int* n,
>         int* nrhs, float ap[], float b[], int* ldb, int* info,
>         int len_uplo, int len_trans, int len_diag);
> 
> extern void F77(strcon)(char* norm, char* uplo, char* diag, int* n,
>         float a[], int* lda, float* rcond, float work[], int iwork[],
>         int* info, int len_norm, int len_uplo, int len_diag);
> 
> extern void F77(strtri)(char* uplo, char* diag, int* n, float a[], int* lda,
>         int* info, int len_uplo, int len_diag);
> 
> extern void F77(strtrs)(char* uplo, char* trans, char* diag, int* n,
>         int* nrhs, float a[], int* lda, float b[], int* ldb, int* info,
>         int len_uplo, int len_trans, int len_diag);
> 
> extern void F77(stzrqf)(int* m, int* n, float a[], int* lda, float tau[],
>         int* info);
> 
> extern float F77(walltime)(float* tzero);
> 
> extern void F77(xerbla)(char* name, int* iarg, int len_name);
> 
> extern void F77(zgbcon)(char* norm, int* n, int* kl, int* ku,
>         complex16_t ab[], int* ldab, int ipiv[], double* anorm,
>         double* rcond, complex16_t work[], double rwork[], int* info,
>         int len_norm);
> 
> extern void F77(zgbsv)(int* n, int* kl, int* ku, int* nrhs,
>         complex16_t ab[], int* ldab, int ipiv[], complex16_t b[],
>         int* ldb, int* info);
> 
> extern void F77(zgbsvx)(char* fact, char* trans, int* n, int* kl, int* ku,
>         int* nrhs, complex16_t ab[], int* ldab, complex16_t afb[],
>         int* ldafb, int ipiv[], char* equed, double r[], double c[],
>         complex16_t b[], int* ldb, complex16_t x[], int* ldx,
>         double* rcond, double ferr[], double berr[], complex16_t work[],
>         double rwork[], int* info, int len_fact, int len_trans,
>         int len_equed);
> 
> extern void F77(zgbtrf)(int* m, int* n, int* kl, int* ku, complex16_t ab[],
>         int* ldab, int ipiv[], int* info);
> 
> extern void F77(zgbtrs)(char* trans, int* n, int* kl, int* ku, int* nrhs,
>         complex16_t ab[], int* ldab, int ipiv[], complex16_t b[],
>         int* ldb, int* info, int len_trans);
> 
> extern void F77(zgecon)(char* norm, int* n, complex16_t a[], int* lda,
>         double* anorm, double* rcond, complex16_t work[],
>         double rwork[], int* info, int len_norm);
> 
> extern void F77(zgees)(char* jobvs, char* sort, int (*select)(), int* n,
>         complex16_t a[], int* lda, int* sdim, complex16_t w[],
>         complex16_t vs[], int* ldvs, complex16_t work[], int* lwork,
>         double rwork[], int bwork[], int* info, int len_jobvs,
>         int len_sort);
> 
> extern void F77(zgeesx)(char* jobvs, char* sort, int (*select)(),
>         char* sense, int* n, complex16_t a[], int* lda, int* sdim,
>         complex16_t w[], complex16_t vs[], int* ldvs, double* rconde,
>         double* rcondv, complex16_t work[], int* lwork, double rwork[],
>         int bwork[], int* info, int len_jobvs, int len_sort,
>         int len_sense);
> 
> extern void F77(zgeev)(char* jobvl, char* jobvr, int* n, complex16_t a[],
>         int* lda, complex16_t w[], complex16_t vl[], int* ldvl,
>         complex16_t vr[], int* ldvr, complex16_t work[], int* lwork,
>         double rwork[], int* info, int len_jobvl, int len_jobvr);
> 
> extern void F77(zgeevx)(char* balanc, char* jobvl, char* jobvr, char* sense,
>         int* n, complex16_t a[], int* lda, complex16_t w[],
>         complex16_t vl[], int* ldvl, complex16_t vr[], int* ldvr,
>         int* ilo, int* ihi, double scale[], double* abnrm,
>         double rconde[], double rcondv[], complex16_t work[],
>         int* lwork, double rwork[], int* info, int len_balanc,
>         int len_jobvl, int len_jobvr, int len_sense);
> 
> extern void F77(zgegs)(char* jobvsl, char* jobvsr, int* n, complex16_t a[],
>         int* lda, complex16_t b[], int* ldb, complex16_t alpha[],
>         complex16_t beta[], complex16_t vsl[], int* ldvsl,
>         complex16_t vsr[], int* ldvsr, complex16_t work[], int* lwork,
>         double rwork[], int* info, int len_jobvsl, int len_jobvsr);
> 
> extern void F77(zgegv)(char* jobvl, char* jobvr, int* n, complex16_t a[],
>         int* lda, complex16_t b[], int* ldb, complex16_t alpha[],
>         complex16_t beta[], complex16_t vl[], int* ldvl,
>         complex16_t vr[], int* ldvr, complex16_t work[], int* lwork,
>         double rwork[], int* info, int len_jobvl, int len_jobvr);
> 
> extern void F77(zgelqf)(int* m, int* n, complex16_t a[], int* lda,
>         complex16_t tau[], complex16_t work[], int* lwork, int* info);
> 
> extern void F77(zgels)(char* trans, int* m, int* n, int* nrhs,
>         complex16_t a[], int* lda, complex16_t b[], int* ldb,
>         complex16_t work[], int* lwork, int* info, int len_trans);
> 
> extern void F77(zgelss)(int* m, int* n, int* nrhs, complex16_t a[],
>         int* lda, complex16_t b[], int* ldb, double s[], double* rcond,
>         int* rank, complex16_t work[], int* lwork, double rwork[],
>         int* info);
> 
> extern void F77(zgelsx)(int* m, int* n, int* nrhs, complex16_t a[],
>         int* lda, complex16_t b[], int* ldb, int jpvt[], double* rcond,
>         int* rank, complex16_t work[], double rwork[], int* info);
> 
> extern void F77(zgeqlf)(int* m, int* n, complex16_t a[], int* lda,
>         complex16_t tau[], complex16_t work[], int* lwork, int* info);
> 
> extern void F77(zgeqpf)(int* m, int* n, complex16_t a[], int* lda,
>         int jpvt[], complex16_t tau[], complex16_t work[],
>         double rwork[], int* info);
> 
> extern void F77(zgeqrf)(int* m, int* n, complex16_t a[], int* lda,
>         complex16_t tau[], complex16_t work[], int* lwork, int* info);
> 
> extern void F77(zgerqf)(int* m, int* n, complex16_t a[], int* lda,
>         complex16_t tau[], complex16_t work[], int* lwork, int* info);
> 
> extern void F77(zgesv)(int* n, int* nrhs, complex16_t a[], int* lda,
>         int ipiv[], complex16_t b[], int* ldb, int* info);
> 
> extern void F77(zgesvd)(char* jobu, char* jobvt, int* m, int* n,
>         complex16_t a[], int* lda, double s[], complex16_t u[],
>         int* ldu, complex16_t vt[], int* ldvt, complex16_t work[],
>         int* lwork, double rwork[], int* info, int len_jobu,
>         int len_jobvt);
> 
> extern void F77(zgesvx)(char* fact, char* trans, int* n, int* nrhs,
>         complex16_t a[], int* lda, complex16_t af[], int* ldaf,
>         int ipiv[], char* equed, double r[], double c[],
>         complex16_t b[], int* ldb, complex16_t x[], int* ldx,
>         double* rcond, double ferr[], double berr[], complex16_t work[],
>         double rwork[], int* info, int len_fact, int len_trans,
>         int len_equed);
> 
> extern void F77(zgetrf)(int* m, int* n, complex16_t a[], int* lda,
>         int ipiv[], int* info);
> 
> extern void F77(zgetri)(int* n, complex16_t a[], int* lda, int ipiv[],
>         complex16_t work[], int* lwork, int* info);
> 
> extern void F77(zgetrs)(char* trans, int* n, int* nrhs, complex16_t a[],
>         int* lda, int ipiv[], complex16_t b[], int* ldb, int* info,
>         int len_trans);
> 
> extern void F77(zggglm)(int* n, int* m, int* p, complex16_t a[], int* lda,
>         complex16_t b[], int* ldb, complex16_t d[], complex16_t x[],
>         complex16_t y[], complex16_t work[], int* lwork, int* info);
> 
> extern void F77(zgglse)(int* m, int* n, int* p, complex16_t a[], int* lda,
>         complex16_t b[], int* ldb, complex16_t c[], complex16_t d[],
>         complex16_t x[], complex16_t work[], int* lwork, int* info);
> 
> extern void F77(zggqrf)(int* m, int* n, int* p, complex16_t a[], int* lda,
>         complex16_t taua[], complex16_t b[], int* ldb,
>         complex16_t taub[], complex16_t work[], int* lwork, int* info);
> 
> extern void F77(zggrqf)(int* m, int* n, int* p, complex16_t a[], int* lda,
>         complex16_t taua[], complex16_t b[], int* ldb,
>         complex16_t taub[], complex16_t work[], int* lwork, int* info);
> 
> extern void F77(zggsvd)(char* jobu, char* jobv, char* jobq, int* m, int* n,
>         int* p, int* k, int* l, complex16_t a[], int* lda,
>         complex16_t b[], int* ldb, double alpha[], double beta[],
>         complex16_t u[], int* ldu, complex16_t v[], int* ldv,
>         complex16_t q[], int* ldq, complex16_t work[], double rwork[],
>         int iwork[], int* info, int len_jobu, int len_jobv,
>         int len_jobq);
> 
> extern void F77(zgtcon)(char* norm, int* n, complex16_t dl[],
>         complex16_t d[], complex16_t du[], complex16_t du2[],
>         int ipiv[], double* anorm, double* rcond, complex16_t work[],
>         int* info, int len_norm);
> 
> extern void F77(zgtsv)(int* n, int* nrhs, complex16_t dl[], complex16_t d[],
>         complex16_t du[], complex16_t b[], int* ldb, int* info);
> 
> extern void F77(zgtsvx)(char* fact, char* trans, int* n, int* nrhs,
>         complex16_t dl[], complex16_t d[], complex16_t du[],
>         complex16_t dlf[], complex16_t df[], complex16_t duf[],
>         complex16_t du2[], int ipiv[], complex16_t b[], int* ldb,
>         complex16_t x[], int* ldx, double* rcond, double ferr[],
>         double berr[], complex16_t work[], double rwork[], int* info,
>         int len_fact, int len_trans);
> 
> extern void F77(zgttrf)(int* n, complex16_t dl[], complex16_t d[],
>         complex16_t du[], complex16_t du2[], int ipiv[], int* info);
> 
> extern void F77(zgttrs)(char* trans, int* n, int* nrhs, complex16_t dl[],
>         complex16_t d[], complex16_t du[], complex16_t du2[],
>         int ipiv[], complex16_t b[], int* ldb, int* info,
>         int len_trans);
> 
> extern void F77(zhbev)(char* jobz, char* uplo, int* n, int* kd,
>         complex16_t ab[], int* ldab, double w[], complex16_t z[],
>         int* ldz, complex16_t work[], double rwork[], int* info,
>         int len_jobz, int len_uplo);
> 
> extern void F77(zhbevd)(char* jobz, char* uplo, int* n, int* kd,
>         complex16_t ab[], int* ldab, double w[], complex16_t z[],
>         int* ldz, complex16_t work[], int* lwork, double rwork[],
>         int* lrwork, int iwork[], int* liwork, int* info, int len_jobz,
>         int len_uplo);
> 
> extern void F77(zhbevx)(char* jobz, char* range, char* uplo, int* n,
>         int* kd, complex16_t ab[], int* ldab, complex16_t q[], int* ldq,
>         double* vl, double* vu, int* il, int* iu, double* abstol,
>         int* m, double w[], complex16_t z[], int* ldz,
>         complex16_t work[], double rwork[], int iwork[], int ifail[],
>         int* info, int len_jobz, int len_range, int len_uplo);
> 
> extern void F77(zhbgv)(char* jobz, char* uplo, int* n, int* ka, int* kb,
>         complex16_t ab[], int* ldab, complex16_t bb[], int* ldbb,
>         double w[], complex16_t z[], int* ldz, complex16_t work[],
>         double rwork[], int* info, int len_jobz, int len_uplo);
> 
> extern void F77(zhecon)(char* uplo, int* n, complex16_t a[], int* lda,
>         int ipiv[], double* anorm, double* rcond, complex16_t work[],
>         int* info, int len_uplo);
> 
> extern void F77(zheev)(char* jobz, char* uplo, int* n, complex16_t a[],
>         int* lda, double w[], complex16_t work[], int* lwork,
>         double rwork[], int* info, int len_jobz, int len_uplo);
> 
> extern void F77(zheevd)(char* jobz, char* uplo, int* n, complex16_t a[],
>         int* lda, double w[], complex16_t work[], int* lwork,
>         double rwork[], int* lrwork, int iwork[], int* liwork,
>         int* info, int len_jobz, int len_uplo);
> 
> extern void F77(zheevx)(char* jobz, char* range, char* uplo, int* n,
>         complex16_t a[], int* lda, double* vl, double* vu, int* il,
>         int* iu, double* abstol, int* m, double w[], complex16_t z[],
>         int* ldz, complex16_t work[], int* lwork, double rwork[],
>         int iwork[], int ifail[], int* info, int len_jobz,
>         int len_range, int len_uplo);
> 
> extern void F77(zhegv)(int* itype, char* jobz, char* uplo, int* n,
>         complex16_t a[], int* lda, complex16_t b[], int* ldb,
>         double w[], complex16_t work[], int* lwork, double rwork[],
>         int* info, int len_jobz, int len_uplo);
> 
> extern void F77(zhesv)(char* uplo, int* n, int* nrhs, complex16_t a[],
>         int* lda, int ipiv[], complex16_t b[], int* ldb,
>         complex16_t work[], int* lwork, int* info, int len_uplo);
> 
> extern void F77(zhesvx)(char* fact, char* uplo, int* n, int* nrhs,
>         complex16_t a[], int* lda, complex16_t af[], int* ldaf,
>         int ipiv[], complex16_t b[], int* ldb, complex16_t x[],
>         int* ldx, double* rcond, double ferr[], double berr[],
>         complex16_t work[], int* lwork, double rwork[], int* info,
>         int len_fact, int len_uplo);
> 
> extern void F77(zhetrf)(char* uplo, int* n, complex16_t a[], int* lda,
>         int ipiv[], complex16_t work[], int* lwork, int* info,
>         int len_uplo);
> 
> extern void F77(zhetri)(char* uplo, int* n, complex16_t a[], int* lda,
>         int ipiv[], complex16_t work[], int* info, int len_uplo);
> 
> extern void F77(zhetrs)(char* uplo, int* n, int* nrhs, complex16_t a[],
>         int* lda, int ipiv[], complex16_t b[], int* ldb, int* info,
>         int len_uplo);
> 
> extern void F77(zhpcon)(char* uplo, int* n, complex16_t ap[], int ipiv[],
>         double* anorm, double* rcond, complex16_t work[], int* info,
>         int len_uplo);
> 
> extern void F77(zhpev)(char* jobz, char* uplo, int* n, complex16_t ap[],
>         double w[], complex16_t z[], int* ldz, complex16_t work[],
>         double rwork[], int* info, int len_jobz, int len_uplo);
> 
> extern void F77(zhpevd)(char* jobz, char* uplo, int* n, complex16_t ap[],
>         double w[], complex16_t z[], int* ldz, complex16_t work[],
>         int* lwork, double rwork[], int* lrwork, int iwork[],
>         int* liwork, int* info, int len_jobz, int len_uplo);
> 
> extern void F77(zhpevx)(char* jobz, char* range, char* uplo, int* n,
>         complex16_t ap[], double* vl, double* vu, int* il, int* iu,
>         double* abstol, int* m, double w[], complex16_t z[], int* ldz,
>         complex16_t work[], double rwork[], int iwork[], int ifail[],
>         int* info, int len_jobz, int len_range, int len_uplo);
> 
> extern void F77(zhpgv)(int* itype, char* jobz, char* uplo, int* n,
>         complex16_t ap[], complex16_t bp[], double w[], complex16_t z[],
>         int* ldz, complex16_t work[], double rwork[], int* info,
>         int len_jobz, int len_uplo);
> 
> extern void F77(zhpsv)(char* uplo, int* n, int* nrhs, complex16_t ap[],
>         int ipiv[], complex16_t b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(zhpsvx)(char* fact, char* uplo, int* n, int* nrhs,
>         complex16_t ap[], complex16_t afp[], int ipiv[],
>         complex16_t b[], int* ldb, complex16_t x[], int* ldx,
>         double* rcond, double ferr[], double berr[], complex16_t work[],
>         double rwork[], int* info, int len_fact, int len_uplo);
> 
> extern void F77(zhptrf)(char* uplo, int* n, complex16_t ap[], int ipiv[],
>         int* info, int len_uplo);
> 
> extern void F77(zhptri)(char* uplo, int* n, complex16_t ap[], int ipiv[],
>         complex16_t work[], int* info, int len_uplo);
> 
> extern void F77(zhptrs)(char* uplo, int* n, int* nrhs, complex16_t ap[],
>         int ipiv[], complex16_t b[], int* ldb, int* info, int len_uplo);
> 
> extern double F77(zlangb)(char* norm, int* n, int* kl, int* ku,
>         complex16_t ab[], int* ldab, double rwork[], int len_norm);
> 
> extern double F77(zlange)(char* norm, int* m, int* n, complex16_t a[],
>         int* lda, double rwork[], int len_norm);
> 
> extern double F77(zlangt)(char* norm, int* n, complex16_t dl[],
>         complex16_t d[], complex16_t du[], int len_norm);
> 
> extern double F77(zlanhb)(char* norm, char* uplo, int* n, int* kd,
>         complex16_t ab[], int* ldab, double rwork[], int len_norm,
>         int len_uplo);
> 
> extern double F77(zlanhe)(char* norm, char* uplo, int* n, complex16_t a[],
>         int* lda, double rwork[], int len_norm, int len_uplo);
> 
> extern double F77(zlanhp)(char* norm, char* uplo, int* n, complex16_t ap[],
>         double rwork[], int len_norm, int len_uplo);
> 
> extern double F77(zlanht)(char* norm, int* n, double d[], complex16_t e[],
>         int len_norm);
> 
> extern double F77(zlansb)(char* norm, char* uplo, int* n, int* kd,
>         complex16_t ab[], int* ldab, double rwork[], int len_norm,
>         int len_uplo);
> 
> extern double F77(zlansp)(char* norm, char* uplo, int* n, complex16_t ap[],
>         double rwork[], int len_norm, int len_uplo);
> 
> extern double F77(zlansy)(char* norm, char* uplo, int* n, complex16_t a[],
>         int* lda, double rwork[], int len_norm, int len_uplo);
> 
> extern void F77(zpbcon)(char* uplo, int* n, int* kd, complex16_t ab[],
>         int* ldab, double* anorm, double* rcond, complex16_t work[],
>         double rwork[], int* info, int len_uplo);
> 
> extern void F77(zpbsv)(char* uplo, int* n, int* kd, int* nrhs,
>         complex16_t ab[], int* ldab, complex16_t b[], int* ldb,
>         int* info, int len_uplo);
> 
> extern void F77(zpbsvx)(char* fact, char* uplo, int* n, int* kd, int* nrhs,
>         complex16_t ab[], int* ldab, complex16_t afb[], int* ldafb,
>         char* equed, double s[], complex16_t b[], int* ldb,
>         complex16_t x[], int* ldx, double* rcond, double ferr[],
>         double berr[], complex16_t work[], double rwork[], int* info,
>         int len_fact, int len_uplo, int len_equed);
> 
> extern void F77(zpbtrf)(char* uplo, int* n, int* kd, complex16_t ab[],
>         int* ldab, int* info, int len_uplo);
> 
> extern void F77(zpbtrs)(char* uplo, int* n, int* kd, int* nrhs,
>         complex16_t ab[], int* ldab, complex16_t b[], int* ldb,
>         int* info, int len_uplo);
> 
> extern void F77(zpocon)(char* uplo, int* n, complex16_t a[], int* lda,
>         double* anorm, double* rcond, complex16_t work[],
>         double rwork[], int* info, int len_uplo);
> 
> extern void F77(zposv)(char* uplo, int* n, int* nrhs, complex16_t a[],
>         int* lda, complex16_t b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(zposvx)(char* fact, char* uplo, int* n, int* nrhs,
>         complex16_t a[], int* lda, complex16_t af[], int* ldaf,
>         char* equed, double s[], complex16_t b[], int* ldb,
>         complex16_t x[], int* ldx, double* rcond, double ferr[],
>         double berr[], complex16_t work[], double rwork[], int* info,
>         int len_fact, int len_uplo, int len_equed);
> 
> extern void F77(zpotrf)(char* uplo, int* n, complex16_t a[], int* lda,
>         int* info, int len_uplo);
> 
> extern void F77(zpotri)(char* uplo, int* n, complex16_t a[], int* lda,
>         int* info, int len_uplo);
> 
> extern void F77(zpotrs)(char* uplo, int* n, int* nrhs, complex16_t a[],
>         int* lda, complex16_t b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(zppcon)(char* uplo, int* n, complex16_t ap[], double* anorm,
>         double* rcond, complex16_t work[], double rwork[], int* info,
>         int len_uplo);
> 
> extern void F77(zppsv)(char* uplo, int* n, int* nrhs, complex16_t ap[],
>         complex16_t b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(zppsvx)(char* fact, char* uplo, int* n, int* nrhs,
>         complex16_t ap[], complex16_t afp[], char* equed, double s[],
>         complex16_t b[], int* ldb, complex16_t x[], int* ldx,
>         double* rcond, double ferr[], double berr[], complex16_t work[],
>         double rwork[], int* info, int len_fact, int len_uplo,
>         int len_equed);
> 
> extern void F77(zpptrf)(char* uplo, int* n, complex16_t ap[], int* info,
>         int len_uplo);
> 
> extern void F77(zpptri)(char* uplo, int* n, complex16_t ap[], int* info,
>         int len_uplo);
> 
> extern void F77(zpptrs)(char* uplo, int* n, int* nrhs, complex16_t ap[],
>         complex16_t b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(zptcon)(int* n, double d[], complex16_t e[], double* anorm,
>         double* rcond, double rwork[], int* info);
> 
> extern void F77(zptsv)(int* n, int* nrhs, double d[], complex16_t e[],
>         complex16_t b[], int* ldb, int* info);
> 
> extern void F77(zptsvx)(char* fact, int* n, int* nrhs, double d[],
>         complex16_t e[], double df[], complex16_t ef[], complex16_t b[],
>         int* ldb, complex16_t x[], int* ldx, double* rcond,
>         double ferr[], double berr[], complex16_t work[],
>         double rwork[], int* info, int len_fact);
> 
> extern void F77(zpttrf)(int* n, double d[], complex16_t e[], int* info);
> 
> extern void F77(zpttrs)(char* uplo, int* n, int* nrhs, double d[],
>         complex16_t e[], complex16_t b[], int* ldb, int* info,
>         int len_uplo);
> 
> extern void F77(zspcon)(char* uplo, int* n, complex16_t ap[], int ipiv[],
>         double* anorm, double* rcond, complex16_t work[], int* info,
>         int len_uplo);
> 
> extern void F77(zspsv)(char* uplo, int* n, int* nrhs, complex16_t ap[],
>         int ipiv[], complex16_t b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(zspsvx)(char* fact, char* uplo, int* n, int* nrhs,
>         complex16_t ap[], complex16_t afp[], int ipiv[],
>         complex16_t b[], int* ldb, complex16_t x[], int* ldx,
>         double* rcond, double ferr[], double berr[], complex16_t work[],
>         double rwork[], int* info, int len_fact, int len_uplo);
> 
> extern void F77(zsptrf)(char* uplo, int* n, complex16_t ap[], int ipiv[],
>         int* info, int len_uplo);
> 
> extern void F77(zsptri)(char* uplo, int* n, complex16_t ap[], int ipiv[],
>         complex16_t work[], int* info, int len_uplo);
> 
> extern void F77(zsptrs)(char* uplo, int* n, int* nrhs, complex16_t ap[],
>         int ipiv[], complex16_t b[], int* ldb, int* info, int len_uplo);
> 
> extern void F77(zstedc)(char* jobz, int* n, double d[], double e[],
>         complex16_t z[], int* ldz, complex16_t work[], int* lwork,
>         double rwork[], int* lrwork, int iwork[], int* liwork,
>         int* info, int len_jobz);
> 
> extern void F77(zsteqr)(char* jobz, int* n, double d[], double e[],
>         complex16_t z[], int* ldz, double work[], int* info,
>         int len_jobz);
> 
> extern void F77(zsycon)(char* uplo, int* n, complex16_t a[], int* lda,
>         int ipiv[], double* anorm, double* rcond, complex16_t work[],
>         int* info, int len_uplo);
> 
> extern void F77(zsysv)(char* uplo, int* n, int* nrhs, complex16_t a[],
>         int* lda, int ipiv[], complex16_t b[], int* ldb,
>         complex16_t work[], int* lwork, int* info, int len_uplo);
> 
> extern void F77(zsysvx)(char* fact, char* uplo, int* n, int* nrhs,
>         complex16_t a[], int* lda, complex16_t af[], int* ldaf,
>         int ipiv[], complex16_t b[], int* ldb, complex16_t x[],
>         int* ldx, double* rcond, double ferr[], double berr[],
>         complex16_t work[], int* lwork, double rwork[], int* info,
>         int len_fact, int len_uplo);
> 
> extern void F77(zsytrf)(char* uplo, int* n, complex16_t a[], int* lda,
>         int ipiv[], complex16_t work[], int* lwork, int* info,
>         int len_uplo);
> 
> extern void F77(zsytri)(char* uplo, int* n, complex16_t a[], int* lda,
>         int ipiv[], complex16_t work[], int* info, int len_uplo);
> 
> extern void F77(zsytrs)(char* uplo, int* n, int* nrhs, complex16_t a[],
>         int* lda, int ipiv[], complex16_t b[], int* ldb, int* info,
>         int len_uplo);
> 
> extern void F77(ztbcon)(char* norm, char* uplo, char* diag, int* n, int* kd,
>         complex16_t ab[], int* ldab, double* rcond, complex16_t work[],
>         double rwork[], int* info, int len_norm, int len_uplo,
>         int len_diag);
> 
> extern void F77(ztbtrs)(char* uplo, char* trans, char* diag, int* n,
>         int* kd, int* nrhs, complex16_t ab[], int* ldab,
>         complex16_t b[], int* ldb, int* info, int len_uplo,
>         int len_trans, int len_diag);
> 
> extern void F77(ztpcon)(char* norm, char* uplo, char* diag, int* n,
>         complex16_t ap[], double* rcond, complex16_t work[],
>         double rwork[], int* info, int len_norm, int len_uplo,
>         int len_diag);
> 
> extern void F77(ztptri)(char* uplo, char* diag, int* n, complex16_t ap[],
>         int* info, int len_uplo, int len_diag);
> 
> extern void F77(ztptrs)(char* uplo, char* trans, char* diag, int* n,
>         int* nrhs, complex16_t ap[], complex16_t b[], int* ldb,
>         int* info, int len_uplo, int len_trans, int len_diag);
> 
> extern void F77(ztrcon)(char* norm, char* uplo, char* diag, int* n,
>         complex16_t a[], int* lda, double* rcond, complex16_t work[],
>         double rwork[], int* info, int len_norm, int len_uplo,
>         int len_diag);
> 
> extern void F77(ztrtri)(char* uplo, char* diag, int* n, complex16_t a[],
>         int* lda, int* info, int len_uplo, int len_diag);
> 
> extern void F77(ztrtrs)(char* uplo, char* trans, char* diag, int* n,
>         int* nrhs, complex16_t a[], int* lda, complex16_t b[], int* ldb,
>         int* info, int len_uplo, int len_trans, int len_diag);
> 
> extern void F77(ztzrqf)(int* m, int* n, complex16_t a[], int* lda,
>         complex16_t tau[], int* info);
> 
> extern void F77(zunglq)(int* m, int* n, int* k, complex16_t a[], int* lda,
>         complex16_t tau[], complex16_t work[], int* lwork, int* info);
> 
> extern void F77(zungql)(int* m, int* n, int* k, complex16_t a[], int* lda,
>         complex16_t tau[], complex16_t work[], int* lwork, int* info);
> 
> extern void F77(zungqr)(int* m, int* n, int* k, complex16_t a[], int* lda,
>         complex16_t tau[], complex16_t work[], int* lwork, int* info);
> 
> extern void F77(zungrq)(int* m, int* n, int* k, complex16_t a[], int* lda,
>         complex16_t tau[], complex16_t work[], int* lwork, int* info);
> 
> extern void F77(zunmlq)(char* side, char* trans, int* m, int* n, int* k,
>         complex16_t a[], int* lda, complex16_t tau[], complex16_t c[],
>         int* ldc, complex16_t work[], int* lwork, int* info,
>         int len_side, int len_trans);
> 
> extern void F77(zunmql)(char* side, char* trans, int* m, int* n, int* k,
>         complex16_t a[], int* lda, complex16_t tau[], complex16_t c[],
>         int* ldc, complex16_t work[], int* lwork, int* info,
>         int len_side, int len_trans);
> 
> extern void F77(zunmqr)(char* side, char* trans, int* m, int* n, int* k,
>         complex16_t a[], int* lda, complex16_t tau[], complex16_t c[],
>         int* ldc, complex16_t work[], int* lwork, int* info,
>         int len_side, int len_trans);
> 
> extern void F77(zunmrq)(char* side, char* trans, int* m, int* n, int* k,
>         complex16_t a[], int* lda, complex16_t tau[], complex16_t c[],
>         int* ldc, complex16_t work[], int* lwork, int* info,
>         int len_side, int len_trans);
> 
> extern void F77(dlacpy)(char *UPLO, int *M, int *N, double *A, int *LDA, 
>                         double *B, int *LDB, int len_uplo);
> 
> extern void F77(dlaset)(char *UPLO, int *M, int *N, double *ALPHA, 
>                         double *BETA, double *A, int *LDA, int len_uplo );
> 
> extern void F77(dlarnv)(int *IDIST, int *ISEED, int *N, double *X);
> 
> #endif
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/include/ll_mat.h pysparse/pysparse/include/ll_mat.h
0a1,42
> #ifndef LL_MAT_H
> #define LL_MAT_H
> 
> #include "Python.h"
> 
> typedef struct {
>   PyObject_VAR_HEAD
>   int dim[2];         /* array dimension */
>   int issym;          /* non-zero, if obj represents a symmetric matrix */
>   int storeZeros;     /* whether to store zero values */
>   int nnz;            /* number of stored items */
>   int nalloc;         /* allocated size of value and index arrays */
>   int free;           /* index to first element in free chain */
>   double *val;        /* pointer to array of values */
>   int *col;           /* pointer to array of indices */
>   int *link;          /* pointer to array of indices */
>   int *root;          /* pointer to array of indices */
> } LLMatObject;
> 
> /******************************************************************************
>  *                                                                            *
>  * llColIndexlinked -- list data structure which links the entries of         *
>  *                     each column of a llmat matrix                          *
>  *                                                                            *
>  ******************************************************************************/
> 
> struct llColIndex{
>   int *root;          /* ptr to array storing first element of each column */
>   int *row;           /* ptr to array of row indices */
>   int *link;          /* ptr to array storing index of next element in column */
>   int nzLo;           /* number of non-zero entries in lower triangle */
>   int nzDiag;         /* number of non-zero entries on diagonal */
>   int nzUp;           /* number of non-zero entries in upper triangle */
> };
> 
> 
> #ifdef SPMATRIX_MODULE
> /* forward declarations */
> static PyTypeObject LLMatType;  /* forward declaration */
> #endif
> 
> #endif
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/include/minres.h pysparse/pysparse/include/minres.h
0a1,34
> /**************************************************************************
> *                                                                         *
> *               Swiss Federal Institute of Technology (ETH),              *
> *                       CH-8092 Zuerich, Switzerland                      *
> *                                                                         *
> *                       (C) 1999 All Rights Reserved                      *
> *                                                                         *
> *                                NOTICE                                   *
> *                                                                         *
> *  Permission to use, copy, modify, and distribute this software and      *
> *  its documentation for any purpose and without fee is hereby granted    *
> *  provided that the above copyright notice appear in all copies and      *
> *  that both the copyright notice and this permission notice appear in    *
> *  supporting documentation.                                              *
> *                                                                         *
> *  Neither the Swiss Federal Institute of Technology nor the author make  *
> *  any representations about the suitability of this software for any     *
> *  purpose.  This software is provided ``as is'' without express or       *
> *  implied warranty.                                                      *
> *                                                                         *
> **************************************************************************/
> 
> #ifndef MINRES_H
> #define MINRES_H
> 
> #include "Python.h"
> 
> int Itsolvers_minres_kernel(int n, double errtol, int it_max,
> 			    int *it, double *nrm_res, int clvl,
> 			    double *x, double *b, double *work,
> 			    PyObject *mat_obj,
> 			    PyObject *prec_obj);
> 
> #endif
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/include/mmio.h pysparse/pysparse/include/mmio.h
0a1,133
> /* 
> *   Matrix Market I/O library for ANSI C
> *
> *   See http://math.nist.gov/MatrixMarket for details.
> *
> *
> */
> 
> #ifndef MM_IO_H
> #define MM_IO_H
> 
> #define MM_MAX_LINE_LENGTH 1025
> #define MatrixMarketBanner "%%MatrixMarket"
> #define MM_MAX_TOKEN_LENGTH 64
> 
> typedef char MM_typecode[4];
> 
> char *mm_typecode_to_str(MM_typecode matcode);
> 
> int mm_read_banner(FILE *f, MM_typecode matcode);
> int mm_read_mtx_crd_size(FILE *f, int *M, int *N, int *nz);
> int mm_read_mtx_array_size(FILE *f, int *M, int *N);
> 
> int mm_write_banner(FILE *f, MM_typecode matcode);
> int mm_write_mtx_crd_size(FILE *f, int M, int N, int nz);
> int mm_write_mtx_array_size(FILE *f, int M, int N);
> 
> 
> /********************* MM_typecode query fucntions ***************************/
> 
> #define mm_is_matrix(typecode)	((typecode)[0]=='M')
> 
> #define mm_is_sparse(typecode)	((typecode)[1]=='C')
> #define mm_is_coordinate(typecode)((typecode)[1]=='C')
> #define mm_is_dense(typecode)	((typecode)[1]=='A')
> #define mm_is_array(typecode)	((typecode)[1]=='A')
> 
> #define mm_is_complex(typecode)	((typecode)[2]=='C')
> #define mm_is_real(typecode)		((typecode)[2]=='R')
> #define mm_is_pattern(typecode)	((typecode)[2]=='P')
> #define mm_is_integer(typecode) ((typecode)[2]=='I')
> 
> #define mm_is_symmetric(typecode)((typecode)[3]=='S')
> #define mm_is_general(typecode)	((typecode)[3]=='G')
> #define mm_is_skew(typecode)	((typecode)[3]=='K')
> #define mm_is_hermitian(typecode)((typecode)[3]=='H')
> 
> int mm_is_valid(MM_typecode matcode);		/* too complex for a macro */
> 
> 
> /********************* MM_typecode modify fucntions ***************************/
> 
> #define mm_set_matrix(typecode)	((typecode)[0]='M')
> #define mm_set_coordinate(typecode)	((typecode)[1]='C')
> #define mm_set_array(typecode)	((typecode)[1]='A')
> #define mm_set_dense(typecode)	mm_set_array(typecode)
> #define mm_set_sparse(typecode)	mm_set_coordinate(typecode)
> 
> #define mm_set_complex(typecode)((typecode)[2]='C')
> #define mm_set_real(typecode)	((typecode)[2]='R')
> #define mm_set_pattern(typecode)((typecode)[2]='P')
> #define mm_set_integer(typecode)((typecode)[2]='I')
> 
> 
> #define mm_set_symmetric(typecode)((typecode)[3]='S')
> #define mm_set_general(typecode)((typecode)[3]='G')
> #define mm_set_skew(typecode)	((typecode)[3]='K')
> #define mm_set_hermitian(typecode)((typecode)[3]='H')
> 
> #define mm_clear_typecode(typecode) ((typecode)[0]=(typecode)[1]= \
> 									(typecode)[2]=' ',(typecode)[3]='G')
> 
> #define mm_initialize_typecode(typecode) mm_clear_typecode(typecode)
> 
> 
> /********************* Matrix Market error codes ***************************/
> 
> 
> #define MM_COULD_NOT_READ_FILE	11
> #define MM_PREMATURE_EOF		12
> #define MM_NOT_MTX				13
> #define MM_NO_HEADER			14
> #define MM_UNSUPPORTED_TYPE		15
> #define MM_LINE_TOO_LONG		16
> #define MM_COULD_NOT_WRITE_FILE	17
> 
> 
> /******************** Matrix Market internal definitions ********************
> 
>    MM_matrix_typecode: 4-character sequence
> 
> 				    ojbect 		sparse/   	data        storage 
> 						  		dense     	type        scheme
> 
>    string position:	 [0]        [1]			[2]         [3]
> 
>    Matrix typecode:  M(atrix)  C(oord)		R(eal)   	G(eneral)
> 						        A(array)	C(omplex)   H(ermitian)
> 											P(attern)   S(ymmetric)
> 								    		I(nteger)	K(kew)
> 
>  ***********************************************************************/
> 
> #define MM_MTX_STR		"matrix"
> #define MM_ARRAY_STR	"array"
> #define MM_DENSE_STR	"array"
> #define MM_COORDINATE_STR "coordinate" 
> #define MM_SPARSE_STR	"coordinate"
> #define MM_COMPLEX_STR	"complex"
> #define MM_REAL_STR		"real"
> #define MM_INT_STR		"integer"
> #define MM_GENERAL_STR  "general"
> #define MM_SYMM_STR		"symmetric"
> #define MM_HERM_STR		"hermitian"
> #define MM_SKEW_STR		"skew-symmetric"
> #define MM_PATTERN_STR  "pattern"
> 
> 
> /*  high level routines */
> 
> int mm_write_mtx_crd(char fname[], int M, int N, int nz, int I[], int J[],
> 		 double val[], MM_typecode matcode);
> int mm_read_mtx_crd_data(FILE *f, int M, int N, int nz, int I[], int J[],
> 		double val[], MM_typecode matcode);
> int mm_read_mtx_crd_entry(FILE *f, int *I, int *J, double *real, double *img,
> 			MM_typecode matcode);
> 
> int mm_read_unsymmetric_sparse(const char *fname, int *M_, int *N_, int *nz_,
>                 double **val_, int **I_, int **J_);
> 
> 
> 
> #endif
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/include/pcg.h pysparse/pysparse/include/pcg.h
0a1,18
> #ifndef PCG_H
> #define PCG_H
> 
> #include "Python.h"
> 
> int Itsolvers_pcg_kernel(int n, 
> 			 double *x, 
> 			 double *b,
> 			 double tol, 
> 			 int maxit,
> 			 int clvl,
> 			 int *iter, 
> 			 double *relres, 
> 			 int *flag,
> 			 double *work,
> 			 PyObject *mat_obj,
> 			 PyObject *prec_obj);
> #endif
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/include/qmrs.h pysparse/pysparse/include/qmrs.h
0a1,17
> #ifndef QMRS_H
> #define QMRS_H
> 
> #include "fortran.h"
> #include "Python.h"
> 
> int Itsolvers_qmrs_kernel(int n, 
> 			  double *b, 
> 			  double *x, 
> 			  double *work, 
> 			  double tol, 
> 			  int maxitera, 
> 			  int *itera, 
> 			  double *err,
> 			  PyObject *mat_obj,
> 			  PyObject *prec_obj);
> #endif
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/include/spmatrix.h pysparse/pysparse/include/spmatrix.h
0a1,73
> #ifndef SPMATRIX_H
> #define SPMATRIX_H
> 
> #include "ll_mat.h"
> #include "csr_mat.h"
> #include "sss_mat.h"
> 
> #include "spmatrix_api.h"
> 
> /*
>  * Macro definitions
>  */
> 
> /** SPMATRIX_PARSE_ARGS_ARR_ARR
>  * 
>  * Macro for parsing arguments for matvec and precon type operations
>  */
> #define SPMATRIX_PARSE_ARGS_ARR_ARR(args, arg1, arg2, n1, n2) \
>   if (!PyArg_ParseTuple((args), "O!O!", &PyArray_Type, &(arg1), &PyArray_Type, &(arg2))) \
>     return NULL; \
>   \
>   if ((arg1)->nd != 1 || \
>       (arg1)->descr->type_num != PyArray_DOUBLE || \
>       (arg1)->dimensions[0] != (n1) || \
>       !((arg1)->flags & CONTIGUOUS)) { \
>     PyErr_SetString(PyExc_ValueError, "arg 1 must be a contiguous 1-dimensional double array of appropriate size."); \
>     return NULL; \
>   } \
>   \
>   if ((arg2)->nd != 1 || \
>       (arg2)->descr->type_num != PyArray_DOUBLE || \
>       (arg2)->dimensions[0] != (n2) || \
>       !((arg2)->flags & CONTIGUOUS)) { \
>     PyErr_SetString(PyExc_ValueError, "arg 2 must be a contiguous 1-dimensional double array of appropriate size."); \
>     return NULL; \
>   }
> 
> #define SPMATRIX_PARSE_ARGS_ARR_ARR_STRIDE(args, arg1, arg2, n1, n2) \
>   if (!PyArg_ParseTuple((args), "O!O!", &PyArray_Type, &(arg1), &PyArray_Type, &(arg2))) \
>     return NULL; \
>   \
>   if ((arg1)->nd != 1 || \
>       (arg1)->descr->type_num != PyArray_DOUBLE || \
>       (arg1)->dimensions[0] != (n1)) { \
>     PyErr_SetString(PyExc_ValueError, "arg 1 must be a 1-dimensional double array of appropriate size."); \
>     return NULL; \
>   } \
>   \
>   if ((arg2)->nd != 1 || \
>       (arg2)->descr->type_num != PyArray_DOUBLE || \
>       (arg2)->dimensions[0] != (n2)) { \
>     PyErr_SetString(PyExc_ValueError, "arg 2 must be a 1-dimensional double array of appropriate size."); \
>     return NULL; \
>   }
> 
> /** SPMATRIX_CHECK_ARR_DIM_SIZE
>  * 
>  * Macro for checking the type and size of vector arguments
>  */
> #define SPMATRIX_CHECK_ARR_DIM_SIZE(arr, dim, size) \
>   if ((arr)->nd != (dim) || \
>       (arr)->descr->type_num != PyArray_DOUBLE || \
>       (arr)->dimensions[0] != (size) || \
>       !((arr)->flags & CONTIGUOUS)) { \
>     PyErr_SetString(PyExc_ValueError, "argument must be a contiguous 1-dimensional double array of appropriate size."); \
>     return NULL; \
>   }
> 
> #ifdef SPMATRIX_MODULE
> extern PyObject *SpMatrix_ErrorObject;
> #endif
> 
> #endif
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/include/spmatrix_api.h pysparse/pysparse/include/spmatrix_api.h
0a1,212
> #ifndef SPMATRIX_API_H
> #define SPMATRIX_API_H
> 
> /*
>  * C API
>  */
> 
> /* Type definitions */
> 
> #define LLMatType_NUM 0
> #define CSRMatType_NUM 1
> #define SSSMatType_NUM 2
> 
> /* Function definitions */
> 
> #define SpMatrix_ParseVecOpArgs_NUM 3
> #define SpMatrix_ParseVecOpArgs_RET int
> #define SpMatrix_ParseVecOpArgs_PROTO (PyObject *args, double **x_data, double **y_data, int n)
> 
> #define SpMatrix_GetShape_NUM 4
> #define SpMatrix_GetShape_RET int
> #define SpMatrix_GetShape_PROTO (PyObject *, int[])
> 
> #define SpMatrix_GetOrder_NUM 5
> #define SpMatrix_GetOrder_RET int
> #define SpMatrix_GetOrder_PROTO (PyObject *, int*)
> 
> #define SpMatrix_GetItem_NUM 6
> #define SpMatrix_GetItem_RET double
> #define SpMatrix_GetItem_PROTO (PyObject *, int, int)
> 
> #define SpMatrix_Matvec_NUM 7
> #define SpMatrix_Matvec_RET int
> #define SpMatrix_Matvec_PROTO (PyObject *matrix, int nx, double *x, int ny, double *y)
> 
> #define SpMatrix_Precon_NUM 8
> #define SpMatrix_Precon_RET int
> #define SpMatrix_Precon_PROTO (PyObject *repc, int n, double *x, double *y)
> 
> #define SpMatrix_NewLLMatObject_NUM 9
> #define SpMatrix_NewLLMatObject_RET PyObject *
> #define SpMatrix_NewLLMatObject_PROTO (int dim[], int sym, int sizeHint, int storeZeros)
> 
> #define SpMatrix_LLMatGetItem_NUM 10
> #define SpMatrix_LLMatGetItem_RET double
> #define SpMatrix_LLMatGetItem_PROTO (LLMatObject *a, int i, int j)
> 
> #define SpMatrix_LLMatSetItem_NUM 11
> #define SpMatrix_LLMatSetItem_RET int
> #define SpMatrix_LLMatSetItem_PROTO (LLMatObject *a, int i, int j, double x)
> 
> #define SpMatrix_LLMatUpdateItemAdd_NUM 12
> #define SpMatrix_LLMatUpdateItemAdd_RET int
> #define SpMatrix_LLMatUpdateItemAdd_PROTO (LLMatObject *a, int i, int j, double x)
> 
> #define SpMatrix_LLMatBuildColIndex_NUM 13
> #define SpMatrix_LLMatBuildColIndex_RET int
> #define SpMatrix_LLMatBuildColIndex_PROTO (struct llColIndex **idx, LLMatObject *self, int includeDiagonal)
> 
> #define SpMatrix_LLMatDestroyColIndex_NUM 14
> #define SpMatrix_LLMatDestroyColIndex_RET void
> #define SpMatrix_LLMatDestroyColIndex_PROTO (struct llColIndex **idx)
> 
> #define ItSolvers_Solve_NUM 15
> #define ItSolvers_Solve_RET int
> #define ItSolvers_Solve_PROTO (PyObject *linsolver, PyObject *A, int n, \
>                 double *b, double *x, double tol, int itmax, PyObject *K, \
>                 int *info, int *iter, double *relres)
> 
> 
> /* Total number of C API pointers */
> #define SpMatrix_API_pointers 16 
> 
> #ifdef SPMATRIX_MODULE
> 
> static SpMatrix_ParseVecOpArgs_RET SpMatrix_ParseVecOpArgs SpMatrix_ParseVecOpArgs_PROTO;
> static SpMatrix_GetShape_RET SpMatrix_GetShape SpMatrix_GetShape_PROTO;
> static SpMatrix_GetOrder_RET SpMatrix_GetOrder SpMatrix_GetOrder_PROTO;
> static SpMatrix_GetItem_RET SpMatrix_GetItem SpMatrix_GetItem_PROTO;
> static SpMatrix_Matvec_RET SpMatrix_Matvec SpMatrix_Matvec_PROTO;
> static SpMatrix_Precon_RET SpMatrix_Precon SpMatrix_Precon_PROTO;
> static SpMatrix_NewLLMatObject_RET SpMatrix_NewLLMatObject SpMatrix_NewLLMatObject_PROTO;
> static SpMatrix_LLMatGetItem_RET SpMatrix_LLMatGetItem SpMatrix_LLMatGetItem_PROTO;
> static SpMatrix_LLMatSetItem_RET SpMatrix_LLMatSetItem SpMatrix_LLMatSetItem_PROTO;
> static SpMatrix_LLMatUpdateItemAdd_RET SpMatrix_LLMatUpdateItemAdd SpMatrix_LLMatUpdateItemAdd_PROTO;
> static SpMatrix_LLMatBuildColIndex_RET SpMatrix_LLMatBuildColIndex SpMatrix_LLMatBuildColIndex_PROTO;
> static SpMatrix_LLMatDestroyColIndex_RET SpMatrix_LLMatDestroyColIndex SpMatrix_LLMatDestroyColIndex_PROTO;
> static ItSolvers_Solve_RET ItSolvers_Solve ItSolvers_Solve_PROTO;
> 
> #define init_c_api(MODULE_DICT) \
> { \
>   static void *SpMatrix_API[SpMatrix_API_pointers]; \
>   PyObject *c_api_object; \
> \
>   /* initialize C API pointer array */ \
>   SpMatrix_API[LLMatType_NUM] = (void *) &LLMatType; \
>   SpMatrix_API[CSRMatType_NUM] = (void *) &CSRMatType; \
>   SpMatrix_API[SSSMatType_NUM] = (void *) &SSSMatType; \
>   SpMatrix_API[SpMatrix_ParseVecOpArgs_NUM] = (void *) SpMatrix_ParseVecOpArgs; \
>   SpMatrix_API[SpMatrix_GetShape_NUM] = (void *) SpMatrix_GetShape; \
>   SpMatrix_API[SpMatrix_GetOrder_NUM] = (void *) SpMatrix_GetOrder; \
>   SpMatrix_API[SpMatrix_GetItem_NUM] = (void *) SpMatrix_GetItem; \
>   SpMatrix_API[SpMatrix_Matvec_NUM] = (void *) SpMatrix_Matvec; \
>   SpMatrix_API[SpMatrix_Precon_NUM] = (void *) SpMatrix_Precon; \
>   SpMatrix_API[SpMatrix_NewLLMatObject_NUM] = (void *) SpMatrix_NewLLMatObject; \
>   SpMatrix_API[SpMatrix_LLMatGetItem_NUM] = (void *) SpMatrix_LLMatGetItem; \
>   SpMatrix_API[SpMatrix_LLMatSetItem_NUM] = (void *) SpMatrix_LLMatSetItem; \
>   SpMatrix_API[SpMatrix_LLMatUpdateItemAdd_NUM] = (void *) SpMatrix_LLMatUpdateItemAdd; \
>   SpMatrix_API[SpMatrix_LLMatBuildColIndex_NUM] = (void *) SpMatrix_LLMatBuildColIndex; \
>   SpMatrix_API[SpMatrix_LLMatDestroyColIndex_NUM] = (void *) SpMatrix_LLMatDestroyColIndex; \
>   SpMatrix_API[ItSolvers_Solve_NUM] = (void *) ItSolvers_Solve; \
> \
>   /* Create a CObject containing the API pointer array s address */ \
>   c_api_object = PyCObject_FromVoidPtr((void *)SpMatrix_API, NULL); \
> \
>   /* create a name for this object in the module's namespace */ \
>   if (c_api_object != NULL) { \
>     PyDict_SetItemString((MODULE_DICT), "_C_API", c_api_object); \
>     Py_DECREF(c_api_object); \
>   } \
> }
> 
> #else
> 
> #ifdef SPMATRIX_UNIQUE_SYMBOL
> #define SpMatrix_API SPMATRIX_UNIQUE_SYMBOL
> #endif
> 
> /* C API address pointer */
> #ifdef NO_IMPORT_SPMATRIX
> extern void **SpMatrix_API;
> #else
> #ifdef SPMATRIX_UNIQUE_SYMBOL
> extern void **SpMatrix_API;
> #else
> static void **SpMatrix_API;
> #endif
> #endif
> 
> #define LLMatType *(PyTypeObject *)SpMatrix_API[LLMatType_NUM]
> #define CSRMatType *(PyTypeObject *)SpMatrix_API[CSRMatType_NUM]
> #define SSSMatType *(PyTypeObject *)SpMatrix_API[SSSMatType_NUM]
> 
> #define SpMatrix_ParseVecOpArgs \
>   (*(SpMatrix_ParseVecOpArgs_RET (*)SpMatrix_ParseVecOpArgs_PROTO) \
>   SpMatrix_API[SpMatrix_ParseVecOpArgs_NUM])
>   
> #define SpMatrix_GetShape \
>   (*(SpMatrix_GetShape_RET (*)SpMatrix_GetShape_PROTO) \
>   SpMatrix_API[SpMatrix_GetShape_NUM])
>   
> #define SpMatrix_GetOrder \
>   (*(SpMatrix_GetOrder_RET (*)SpMatrix_GetOrder_PROTO) \
>   SpMatrix_API[SpMatrix_GetOrder_NUM])
>   
> #define SpMatrix_GetItem \
>   (*(SpMatrix_GetItem_RET (*)SpMatrix_GetItem_PROTO) \
>   SpMatrix_API[SpMatrix_GetItem_NUM])
>   
> #define SpMatrix_Matvec \
>   (*(SpMatrix_Matvec_RET (*)SpMatrix_Matvec_PROTO) \
>   SpMatrix_API[SpMatrix_Matvec_NUM])
>   
> #define SpMatrix_Precon \
>   (*(SpMatrix_Precon_RET (*)SpMatrix_Precon_PROTO) \
>   SpMatrix_API[SpMatrix_Precon_NUM])
>   
> #define SpMatrix_NewLLMatObject \
>   (*(SpMatrix_NewLLMatObject_RET (*)SpMatrix_NewLLMatObject_PROTO) \
>   SpMatrix_API[SpMatrix_NewLLMatObject_NUM])
>   
> #define SpMatrix_LLMatGetItem \
>   (*(SpMatrix_LLMatGetItem_RET (*)SpMatrix_LLMatGetItem_PROTO) \
>   SpMatrix_API[SpMatrix_LLMatGetItem_NUM])
>   
> #define SpMatrix_LLMatSetItem \
>   (*(SpMatrix_LLMatSetItem_RET (*)SpMatrix_LLMatSetItem_PROTO) \
>   SpMatrix_API[SpMatrix_LLMatSetItem_NUM])
>   
> #define SpMatrix_LLMatUpdateItemAdd \
>   (*(SpMatrix_LLMatUpdateItemAdd_RET (*)SpMatrix_LLMatUpdateItemAdd_PROTO) \
>   SpMatrix_API[SpMatrix_LLMatUpdateItemAdd_NUM])
>   
> #define SpMatrix_LLMatBuildColIndex \
>   (*(SpMatrix_LLMatBuildColIndex_RET (*)SpMatrix_LLMatBuildColIndex_PROTO) \
>   SpMatrix_API[SpMatrix_LLMatBuildColIndex_NUM])
>   
> #define SpMatrix_LLMatDestroyColIndex \
>   (*(SpMatrix_LLMatDestroyColIndex_RET (*)SpMatrix_LLMatDestroyColIndex_PROTO) \
>   SpMatrix_API[SpMatrix_LLMatDestroyColIndex_NUM])
>   
> #define ItSolvers_Solve \
>   (*(ItSolvers_Solve_RET (*)ItSolvers_Solve_PROTO) \
>   SpMatrix_API[ItSolvers_Solve_NUM])
>   
> #define import_spmatrix() \
> { \
>   PyObject *spmatrix = PyImport_ImportModule("pysparse.sparse.spmatrix"); \
>   if (spmatrix != NULL) { \
>     PyObject *module_dict = PyModule_GetDict(spmatrix); \
>     PyObject *c_api_object = PyDict_GetItemString(module_dict, "_C_API"); \
>     if (PyCObject_Check(c_api_object)) { \
>       SpMatrix_API = (void **)PyCObject_AsVoidPtr(c_api_object); \
>     } \
>   } \
>   assert(SpMatrix_API != NULL); \
> }
> 
> #endif
> 
> #endif
> 
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/include/sss_mat.h pysparse/pysparse/include/sss_mat.h
0a1,22
> #ifndef SSS_MAT_H
> #define SSS_MAT_H
> 
> #include "Python.h"
> 
> typedef struct {
>   PyObject_VAR_HEAD
>   int n;			/* array dimension */
>   int nnz;			/* number of stored items */
>   double *val;			/* pointer to array of values */
>   double *diag;			/* pointer to diagonal elements */
>   int *col;			/* pointer to array of indices */
>   int *ind;			/* pointer to array of indices */
> } SSSMatObject;
> 
> #ifdef SPMATRIX_MODULE
> /* forward declarations */
> static PyTypeObject SSSMatType;	
> static PyObject *newSSSMatObject(int n, int nnz);
> #endif
> 
> #endif
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/include/util.h pysparse/pysparse/include/util.h
0a1,116
> #ifndef __SUPERLU_UTIL /* allow multiple inclusions */
> #define __SUPERLU_UTIL
> 
> #include <stdio.h>
> #include <stdlib.h>
> #include <string.h>
> #include <assert.h>
> 
> /* Macros */
> #ifndef USER_ABORT
> #define USER_ABORT(msg) superlu_abort_and_exit(msg)
> #endif
> 
> #define ABORT(err_msg) \
>  { char msg[256];\
>    sprintf(msg,"%s at line %d in file %s\n",err_msg,__LINE__, __FILE__);\
>    USER_ABORT(msg); }
> 
> 
> #ifndef USER_MALLOC
> #define USER_MALLOC(size) superlu_malloc(size)
> #endif
> 
> #define SUPERLU_MALLOC(size) USER_MALLOC(size)
> 
> #ifndef USER_FREE
> #define USER_FREE(addr) superlu_free(addr)
> #endif
> 
> #define SUPERLU_FREE(addr) USER_FREE(addr)
> 
> 
> #define MAX(x, y) 	( (x) > (y) ? (x) : (y) )
> #define MIN(x, y) 	( (x) < (y) ? (x) : (y) )
> 
> /* 
>  * Constants 
>  */
> #define EMPTY	(-1)
> #define NO	(-1)
> #define FALSE	0
> #define TRUE	1
> 
> /*
>  * Type definitions
>  */
> typedef float    flops_t;
> typedef unsigned char Logical;
> 
> /* 
>  * The following enumerate type is used by the statistics variable 
>  * SuperLUStat, to keep track of flop count and time spent at various stages.
>  *
>  * Note that not all of the fields are disjoint.
>  */
> typedef enum {
>     COLPERM, /* find a column ordering that minimizes fills */
>     RELAX,   /* find artificial supernodes */
>     ETREE,   /* compute column etree */
>     EQUIL,   /* equilibrate the original matrix */
>     FACT,    /* perform LU factorization */
>     RCOND,   /* estimate reciprocal condition number */
>     SOLVE,   /* forward and back solves */
>     REFINE,  /* perform iterative refinement */
>     FLOAT,   /* time spent in floating-point operations */
>     TRSV,    /* fraction of FACT spent in xTRSV */
>     GEMV,    /* fraction of FACT spent in xGEMV */
>     FERR,    /* estimate error bounds after iterative refinement */
>     NPHASES  /* total number of phases */
> } PhaseType;
> 
> typedef struct {
>     int     *panel_histo; /* histogram of panel size distribution */
>     double  *utime;       /* running time at various phases */
>     flops_t *ops;         /* operation count at various phases */
> } SuperLUStat_t;
> 
> /* Macros */
> #define FIRSTCOL_OF_SNODE(i)	(xsup[i])
> 
> 
> #ifdef __cplusplus
> extern "C" {
> #endif
> 
> extern void    superlu_abort_and_exit(char*);
> extern void    *superlu_malloc (int);
> extern int     *intMalloc (int);
> extern int     *intCalloc (int);
> extern void    superlu_free (void*);
> extern void    SetIWork (int, int, int, int *, int **, int **, int **,
>                          int **, int **, int **, int **);
> extern void    StatInit(int, int);
> extern void    StatFree();
> extern int     sp_coletree (int *, int *, int *, int, int, int *);
> extern void    relax_snode (const int, int *, const int, int *, int *);
> extern void    resetrep_col (const int, const int *, int *);
> extern int     spcoletree (int *, int *, int *, int, int, int *);
> extern int     *TreePostorder (int, int *);
> extern double  SuperLU_timer_ ();
> extern int     sp_ienv (int);
> extern int     lsame_ (char *, char *);
> extern int     xerbla_ (char *, int *);
> extern void    ifill (int *, int, int);
> extern void    snode_profile (int, int *);
> extern void    super_stats (int, int *);
> extern void    PrintSumm (char *, int, int, int);
> extern void    PrintStat (SuperLUStat_t *);
> extern void    print_panel_seg(int, int, int, int, int *, int *);
> extern void    check_repfnz(int, int, int, int *);
> 
> #ifdef __cplusplus
>   }
> #endif
> 
> #endif /* __SUPERLU_UTIL */
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/sparse/setup.py pysparse/pysparse/sparse/setup.py
5a6
>     #import sys
9a11,15
>     # Read relevant PySparse-specific configuration options.
>     #pysparse_config = ConfigParser.SafeConfigParser()
>     #pysparse_config.read(os.path.join(top_path, 'site.cfg'))
>     #hsl_dir = pysparse_config.get('HSL', 'hsl_dir')
> 
26c32
<         include_dirs=['src', os.path.join(config.top_path,'pysparse','include')],
---
>         include_dirs=['src'],
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/sparse/src/csr_mat.c pysparse/pysparse/sparse/src/csr_mat.c
0a1,296
> #include "Python.h"
> 
> #define SPMATRIX_MODULE
> #include "spmatrix.h"
> 
> #define PY_ARRAY_UNIQUE_SYMBOL spmatrix
> 
> #include "numpy/arrayobject.h"
> #include "numpy/noprefix.h"
> 
> #define UNROLL_LOOPS 0
> 
> /*********************************************************************** 
>  * CSRMatObject methods
>  */
> 
> static void
> csr_matvec_kernel(int m, double *x, double *y,
> 		  double *va, int *ja, int *ia) {
>   double s;
>   int i, k;
>   
> #if UNROLL_LOOPS
>   int k1, *ja_ptr;
> 
>   ja_ptr = ja;
>   k = ia[0];
>   for (i = 0; i < m; i ++) {
>     s = 0.0;
>     k1 = ia[i+1];
>     for (; k+10 < k1; k += 10) {
>       s += va[k+9]*x[ja_ptr[9]] +
>         va[k+8]*x[ja_ptr[8]] +
>         va[k+7]*x[ja_ptr[7]] +
>         va[k+6]*x[ja_ptr[6]] +
>         va[k+5]*x[ja_ptr[5]] +
>         va[k+4]*x[ja_ptr[4]] +
>         va[k+3]*x[ja_ptr[3]] +
>         va[k+2]*x[ja_ptr[2]] +
>         va[k+1]*x[ja_ptr[1]] +
>         va[k]*x[*ja_ptr];
>       ja_ptr += 10;
>     }
>     for (; k < ia[i+1]; k ++)
>       s += va[k]*x[*ja_ptr++];
>     y[i] = s;
>   }
> #else
>   for (i = 0; i < m; i ++) {
>     s = 0.0;
>     for (k = ia[i]; k < ia[i+1]; k ++)
>       s += va[k] * x[ja[k]];
>     y[i] = s;
>   }
> #endif
> }
> 
> static void
> csr_matvec_kernel_stride(int m, 
> 			 double *x, int incx, 
> 			 double *y, int incy,
> 			 double *va, int *ja, int *ia) {
>   double s;
>   int i, k;
>   
>   for (i = 0; i < m; i ++) {
>     s = 0.0;
>     for (k = ia[i]; k < ia[i+1]; k ++)
>       s += va[k] * x[ja[k]*incx];
>     y[i*incy] = s;
>   }
> }
> 
> static void
> csr_matvec_transp_kernel(int m, int n, double *x, double *y,
> 			 double *va, int *ja, int *ia) {
>   double xi;
>   int i, k;
>   
>   for (i = 0; i < n; i ++)
>     y[i] = 0.0;
>   
>   for (i = 0; i < m; i ++) {
>     xi = x[i];
>     for (k = ia[i];  k < ia[i+1]; k ++)
>       y[ja[k]] += va[k] * xi;
>   }
> }
> 
> static void
> csr_matvec_transp_kernel_stride(int m, int n, 
> 				double *x, int incx, 
> 				double *y, int incy,
> 				double *va, int *ja, int *ia) {
>   double xi;
>   int i, k;
>   
>   for (i = 0; i < n; i ++)
>     y[i*incy] = 0.0;
>   
>   for (i = 0; i < m; i ++) {
>     xi = x[i*incx];
>     for (k = ia[i];  k < ia[i+1]; k ++)
>       y[ja[k]*incy] += va[k] * xi;
>   }
> }
> 
> static char matvec_transp_doc[] = "a.matvec_transp(x, y)\n\
> \n\
> compute the sparse matrix-vector product y := a^T * x. \n\
> a^T is the transpose of a, which is a d1 by d2 sparse matrix.\n\
> x and y are two 1-dimensional Numeric arrays of appropriate size.";
> 
> static PyObject *
> CSRMat_matvec_transp(CSRMatObject *self, PyObject *args)
> {
>   PyArrayObject *xp, *yp;
> 
>   SPMATRIX_PARSE_ARGS_ARR_ARR_STRIDE(args, xp, yp, self->dim[0], self->dim[1]);
>   
>   if (xp->flags & CONTIGUOUS &&  yp->flags & CONTIGUOUS)
>     csr_matvec_transp_kernel(self->dim[0], self->dim[1], (double *)(xp->data), (double *)(yp->data), 
> 			     self->val, self->col, self->ind);
>   else {
>     csr_matvec_transp_kernel_stride(self->dim[0], self->dim[1], 
> 				    (double *)(xp->data), xp->strides[0] / sizeof(double),
> 				    (double *)(yp->data), yp->strides[0] / sizeof(double),
> 				    self->val, self->col, self->ind);
>   }
> 
>   Py_INCREF(Py_None); 
>   return Py_None;
> }
> 
> static char matvec_doc[] = "a.matvec(x, y)\n\
> \n\
> compute the sparse matrix-vector product y := a * x. \n\
> a is a d1 by d2 sparse matrix.\n\
> x and y are two 1-dimensional Numeric arrays of appropriate size.";
> 
> static PyObject *
> CSRMat_matvec(CSRMatObject *self, PyObject *args)
> {
>   PyArrayObject *xp, *yp;
> 
>   SPMATRIX_PARSE_ARGS_ARR_ARR_STRIDE(args, xp, yp, self->dim[1], self->dim[0]);
>      
>   if (xp->flags & CONTIGUOUS &&  yp->flags & CONTIGUOUS)
>     csr_matvec_kernel(self->dim[0], (double *)(xp->data), (double *)(yp->data), 
> 		      self->val, self->col, self->ind);
>   else {
>     int incx = xp->strides[0] / sizeof(double);
>     int incy = yp->strides[0] / sizeof(double);
>     
>     csr_matvec_kernel_stride(self->dim[0], 
> 			     (double *)(xp->data), incx, 
> 			     (double *)(yp->data), incy,
> 			     self->val, self->col, self->ind);
>   }
> 
>   Py_INCREF(Py_None); 
>   return Py_None;
> }
> 
> /** table of object methods
>  */
> PyMethodDef CSRMat_methods[] = {
>   {"matvec", (PyCFunction)CSRMat_matvec, METH_VARARGS, matvec_doc},
>   {"matvec_transp", (PyCFunction)CSRMat_matvec_transp, METH_VARARGS, matvec_transp_doc},
>   {NULL, NULL}			/* sentinel */
> };
> 
> /*********************************************************************** 
>  * CSRMatType methods
>  */
> 
> static void
> CSRMatType_dealloc(CSRMatObject *a)
> {
>   PyMem_DEL(a->ind);
>   PyMem_DEL(a->val);
>   PyMem_DEL(a->col);
>   PyObject_Del(a);
> }
> 
> static int
> CSRMatType_print(CSRMatObject *a, FILE *fp, int flags)
> {
>   int i, k, first = 1;
> 
>   if (a->nnz == 0) {
>     fprintf(fp, "csr_mat([%d,%d])", a->dim[0], a->dim[1]);
>     return 0;
>   }
>   fprintf(fp, "csr_mat([%d,%d], [", a->dim[0], a->dim[1]);
>   for (i = 0; i < a->dim[0]; i ++) {
>     for (k = a->ind[i]; k < a->ind[i+1]; k ++) {
>       if (!first)
> 	fprintf(fp, ", ");
>       first = 0;
>       fprintf(fp, "(%d,%d): %g", i, a->col[k], a->val[k]);
>     }
>   }
>   fprintf(fp, "])");
>   return 0;
> }
> 
> static PyObject *
> CSRMatType_getattr(CSRMatObject *self, char *name)
> {
>   if (strcmp(name, "shape") == 0)
>     return Py_BuildValue("(i,i)", self->dim[0], self->dim[1]);
>   if (strcmp(name, "nnz") == 0)
>     return PyInt_FromLong(self->nnz);
>   if (strcmp(name, "__members__") == 0) {
>     char *members[] = {"shape", "nnz"};
>     int i;
> 
>     PyObject *list = PyList_New(sizeof(members)/sizeof(char *));
>     if (list != NULL) {
>       for (i = 0; i < sizeof(members)/sizeof(char *); i ++)
> 	PyList_SetItem(list, i, PyString_FromString(members[i]));
>       if (PyErr_Occurred()) {
> 	Py_DECREF(list);
> 	list = NULL;
>       }
>     }
>     return list;
>   }
>   return Py_FindMethod(CSRMat_methods, (PyObject *)self, name);
> }
> 
> /***********************************************************************
>  * CSRMatType structure
>  */
> 
> static PyTypeObject CSRMatType = {
>   PyObject_HEAD_INIT(NULL)
>   0,
>   "csr_mat",
>   sizeof(CSRMatObject),
>   0,
>   (destructor)CSRMatType_dealloc, /* tp_dealloc */
>   (printfunc)CSRMatType_print,	/* tp_print */
>   (getattrfunc)CSRMatType_getattr, /* tp_getattr */
>   0,				/* tp_setattr */
>   0,				/* tp_compare */
>   0,				/* tp_repr */
>   0,				/* tp_as_number*/
>   0,				/* tp_as_sequence*/
>   0,				/* tp_as_mapping*/
>   0,				/* tp_hash */
> };
> 
> /** newCSRMatObject -- allocate a new CSRMatObject instance
>  *
>  *    a newly allocated, uninitialized CSRMatObject is returned
>  */
> static PyObject *
> newCSRMatObject(int dim[], int nnz) {
>   CSRMatObject *op;
> 
>   /* create new SparseArrayt object */
>   op = PyObject_New(CSRMatObject, &CSRMatType);
>   if (op == NULL)
>     PyErr_NoMemory();
> 
>   op->val = NULL;
>   op->ind = NULL;
>   op->col = NULL;
> 
>   /* allocate arrays */
>   op->ind = PyMem_New(int, dim[0] + 1);
>   if (op->ind == NULL)
>     goto fail;
>   op->val = PyMem_New(double, nnz);
>   if (op->val == NULL)
>     goto fail;
>   op->col = PyMem_New(int, nnz);
>   if (op->col == NULL)
>     goto fail;
> 
>   /* initialize rest of fields */
>   op->dim[0] = dim[0];
>   op->dim[1] = dim[1];
>   op->nnz = nnz;
> 
>   return (PyObject *) op;
> 
>  fail:
>     PyMem_Del(op->ind);    
>     PyMem_Del(op->val);    
>     PyMem_Del(op->col);    
>     PyObject_Del(op);
>     return PyErr_NoMemory();
> }
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/sparse/src/ll_mat.c pysparse/pysparse/sparse/src/ll_mat.c
0a1,3806
> #include "Python.h"
> #include <math.h>
> #include "mmio.h"
> #include "ll_mat.h"
> #include "csr_mat.h"
> #include "sss_mat.h"
> 
> #define SPMATRIX_MODULE
> 
> #include "numpy/arrayobject.h"
> #include "numpy/noprefix.h"
> 
> #define PY_ARRAY_UNIQUE_SYMBOL spmatrix
> 
> #define INCREASE_FACTOR   1.5 // increase rate for reallocation of ll_mat arrays
> #define PPRINT_ROW_THRESH 500 // row threshold for choosing print format
> #define PPRINT_COL_THRESH 20  // column threshold for choosing print format
> #define OPT_MATMATMUL     1   // enable optimised matrix-matrix-multiplication
> 
> #define PYSP_MAX(A,B) ( (A) > (B) ? (A) : (B) )
> 
> // Iterator object
> #define SLICE 0
> #define LIST  1
> #define ARRAY 2
> typedef struct PysparseIterator {
> 
>   int type;                        // Slice, list or array
>   PyObject *object;                // Python slice, list or Numpy array
>   int (*init)(void *);             // Iterator initialization function
>   int (*notDone)(void *);          // Determines whether iterations are finished
>   void (*next)(void *);            // Move to next iteration
>   PyObject* (*data)(void *);       // Get current iteration data
>   long (*size)(void *);            // Get total number of iterations
>   long counter;
>   long length;
>   long start;
>   long step;
>   long stop;
> 
> } PysparseIterator;
> 
> // Prototypes
> 
> static PyObject *LLMat_Find(LLMatObject *self, PyObject *args);
> PysparseIterator* PysparseIterator_Create( int type, PyObject *object );
> void PysparseIterator_Destroy( PysparseIterator **iterator );
> int PysparseIterator_List_Init( void *self );
> int PysparseIterator_List_NotDone( void *self );
> void PysparseIterator_List_Next( void *self );
> PyObject *PysparseIterator_List_Data( void *self );
> long PysparseIterator_List_Size( void *self );
> 
> // Iterator creation function: No argument check for now
> PysparseIterator* PysparseIterator_Create( int type, PyObject *object ) {
>   PysparseIterator *iterator;
>   iterator = calloc( 1, sizeof(PysparseIterator) );
>   if( iterator == NULL ) return NULL;
>   iterator->type = type;
>   iterator->object = object;
>   iterator->init = PysparseIterator_List_Init;
>   iterator->notDone = PysparseIterator_List_NotDone;
>   iterator->next = PysparseIterator_List_Next;
>   iterator->data = PysparseIterator_List_Data;
>   iterator->size = PysparseIterator_List_Size;
>   return iterator;
> }
> 
> // Iterator destruction function: Let garbage collector take care of PyObjects
> // Call as: PysparseIterator_Destroy( &iterator );
> void PysparseIterator_Destroy( PysparseIterator **iterator ) {
>   if( *iterator ) {
>     free(*iterator);
>     *iterator = NULL;
>   }
>   return;
> }
> 
> // Initialization of an iterator around a Python list
> int PysparseIterator_List_Init( void *self ) {
> 
>   PysparseIterator *iterator = (PysparseIterator *)self;
>   if( !PyList_Check( iterator->object ) ) return -1;
>   iterator->counter = 0;
>   iterator->length = (long)PyList_Size( (PyObject *)(iterator->object) );
>   iterator->start = 0;
>   iterator->step = 1;
>   iterator->stop = iterator->length;
>   return 0;
> }
> 
> // Define iterator functions for a Python list
> int PysparseIterator_List_NotDone( void *self ) {
>   PysparseIterator *iterator = (PysparseIterator *)self;
>   return (iterator->counter < iterator->length);
> }
> 
> void PysparseIterator_List_Next( void *self ) {
>   PysparseIterator *iterator = (PysparseIterator *)self;
>   iterator->counter++;
>   return;
> }
> 
> PyObject *PysparseIterator_List_Data( void *self ) {
>   PysparseIterator *iterator = (PysparseIterator *)self;
>   return (PyObject *)PyList_GetItem(iterator->object,
>                                     (Py_ssize_t)(iterator->counter));
> }
> 
> long PysparseIterator_List_Size( void *self ) {
>   PysparseIterator *iterator = (PysparseIterator *)self;
>   return iterator->length;
> }
> 
> // Define iterator functions for a Numpy array
> 
> 
> 
> 
> /******************************************************************************/
> /*  Routines for building data structure for  columnwise traversal of ll_mat  */
> /*  sparse matrix objects.                                                    */
> /******************************************************************************/
> 
> /*
>  *  SpMatrix_LLMatBuildColIndex: build data structure for columnwise traversal
>  *
>  *    build a (root,row,link) linked-list data structure which links the
>  *    entries of each column of self.
>  *
>  *    if includeDiagonal is zero the diagonal elements of self are
>  *    not included in the linked-list data structure.
>  */
> 
> static int
> SpMatrix_LLMatBuildColIndex(struct llColIndex **idx, LLMatObject *self,
>                             int includeDiagonal) {
> 
>   int i, j, k;
> 
>   if(!(*idx = (struct llColIndex*)malloc(sizeof(struct llColIndex)))) goto fail;
> 
>   /* Allocate (link,row,root) arrays. Can we do better than nalloc ??? */
>   if( !( (*idx)->link = PyMem_New(int, self->nalloc) ) ) goto fail;
>   if( !( (*idx)->row  = PyMem_New(int, self->nalloc) ) ) goto fail;
>   if( !( (*idx)->root = PyMem_New(int, self->dim[1]) ) ) goto fail;
> 
>   /* Initialize root arrays */
>   for (i = 0; i < self->dim[1]; i ++) (*idx)->root[i] = -1;
> 
>   /* Scan matrix from bottom up so the resulting lists
>    * are sorted by ascending row */
>   (*idx)->nzLo = 0; (*idx)->nzDiag = 0; (*idx)->nzUp = 0;
>   for (i = self->dim[0] - 1; i >= 0; i--) {
>     k = self->root[i];
>     while (k != -1) {
>       j = self->col[k];
>       if (i > j)
>     (*idx)->nzLo++;
>       else if (i == j)
>     (*idx)->nzDiag++;
>       else
>     (*idx)->nzUp++;
>       if (includeDiagonal || i != j) {
>     (*idx)->link[k] = (*idx)->root[j];
>     (*idx)->root[j] = k;
>     (*idx)->row[k] = i;
>       }
>       k = self->link[k];
>     }
>   }
>   return 0;
> 
>  fail:
>   if (*idx != NULL) {
>     PyMem_Del((*idx)->link);
>     PyMem_Del((*idx)->row);
>     PyMem_Del((*idx)->root);
>     free(*idx);
>     *idx = NULL;
>   }
>   PyErr_NoMemory();
>   return 1;
> }
> 
> /*
>  *  Free memory of (root,row,link) linked-list data
>  */
> 
> static void
> SpMatrix_LLMatDestroyColIndex(struct llColIndex **idx) {
> 
>   if (*idx != NULL) {
>     PyMem_Del((*idx)->link);
>     PyMem_Del((*idx)->row);
>     PyMem_Del((*idx)->root);
>     free(*idx);
>     *idx = NULL;
>   }
> }
> 
> /******************************************************************************/
> /*  Routines for setting, updating and reading entries of ll_mat objects      */
> /******************************************************************************/
> 
> /*
>  *  Return matrix entry a[i,j] as a double value
>  */
> 
> static double
> SpMatrix_LLMatGetItem(LLMatObject *a, int i, int j) {
> 
>   int k, t;
> 
>   /*
>   while( i < 0 )
>     i += a->dim[0];
> 
>   while( j < 0 )
>     j += a->dim[1];
> 
>   if( i >= a->dim[0] || j >= a->dim[1] ) {
>     PyErr_SetString(PyExc_IndexError, "Index out of bounds");
>     return 0.0;
>   }
> pwd  */
> 
>   if(i < 0 || i >= a->dim[0] || j < 0 || j >= a->dim[1]) {
>     PyErr_SetString(PyExc_IndexError, "indices out of range");
>     return 0.0;
>   }
> 
>   if (a->issym && i < j) {
>     t = i; i = j; j = t;
>   }
> 
>   k = a->root[i];
>   while (k != -1) {
>     if (a->col[k] == j)
>       return a->val[k];
>     k = a->link[k];
>   }
>   return 0.0;
> }
> 
> /*
>  *  Set matrix entry: a[i,j] = x
>  */
> 
> static int
> SpMatrix_LLMatSetItem(LLMatObject *a, int i, int j, double x) {
> 
>   void *temp;
>   int k, new_elem, last, col;
> 
>   if (a->issym && i < j) {
>     PyErr_SetString(PyExc_IndexError, //SpMatrix_ErrorObject,
>             "write operation to upper triangle of symmetric matrix");
>     return -1;
>   }
> 
>   //printf("LLMatSetItem: matrix dimensions=(%d,%d)\n", a->dim[0], a->dim[1]);
>   //printf("LLMatSetItem: receiving row=%d, col=%d, val=%g\n", i, j, x);
> 
>   if(i < 0 || i >= a->dim[0] || j < 0 || j >= a->dim[1]) {
>     PyErr_SetString(PyExc_IndexError, "indices out of range");
>     return -1;
>   }
> 
>   /* Find element to be set (or removed) */
>   col = last = -1;
>   k = a->root[i];
>   while (k != -1) {
>     col = a->col[k];
>     if (col >= j)
>       break;
>     last = k;
>     k = a->link[k];
>   }
> 
>   if ((x != 0.0) || (a->storeZeros == 1)) {
> 
>     if (col == j) {
> 
>       /* element already exist */
>       a->val[k] = x;
> 
>     } else {
>       /* new element */
> 
>       /* find location for new element */
>       if (a->free != -1) {
> 
>     /* use element from the free chain */
>     new_elem = a->free;
>     a->free = a->link[new_elem];
> 
>       } else {
> 
>     /* append new element to the end */
>     new_elem = a->nnz;
> 
>     /* test if there is space for a new element */
>     if (a->nnz == a->nalloc) {
>       int nalloc_new;
> 
>       /* increase size of idx, val and link arrays */
>       nalloc_new = (int)((double)INCREASE_FACTOR * a->nalloc) + 1;
>       if ((temp = PyMem_Resize(a->col, int, nalloc_new)) == NULL)
>         goto fail;
>       else
>         a->col = temp;
>       if ((temp = PyMem_Resize(a->link, int, nalloc_new)) == NULL)
>         goto fail;
>       else
>         a->link = temp;
>       if ((temp = PyMem_Resize(a->val, double, nalloc_new)) == NULL)
>         goto fail;
>       else
>         a->val = temp;
>       a->nalloc = nalloc_new;
>     }
>       }
> 
>       a->val[new_elem] = x;
>       a->col[new_elem] = j;
>       a->link[new_elem] = k;
>       if (last == -1)
>     a->root[i] = new_elem;
>       else
>     a->link[last] = new_elem;
> 
>       a->nnz ++;
>     }
> 
>   } else { /* x == 0.0 */
> 
>     if (col == j) {
>       /* relink row i */
>       if (last == -1)
>     a->root[i] = a->link[k];
>       else
>     a->link[last] = a->link[k];
>       /* add element to free list */
>       a->link[k] = a->free;
>       a->free = k;
> 
>       a->nnz --;
>     }
>   }
>   return 0;
> 
>  fail:
>   PyErr_NoMemory();
>   return -1;
> }
> 
> /*
>  *  Update-add matrix entry: a[i,j] += x
>  */
> 
> static int
> SpMatrix_LLMatUpdateItemAdd(LLMatObject *a, int i, int j, double x) {
> 
>   void *temp;
>   int k, new_elem, col, last;
> 
>   if (a->issym && i < j) {
>     PyErr_SetString(PyExc_IndexError, //SpMatrix_ErrorObject,
>             "write operation to upper triangle of symmetric matrix");
>     return -1;
>   }
> 
>   if ((a->storeZeros == 0) && (x == 0.0))
>     return 0;
> 
>   /* Find element to be updated */
>   col = last = -1;
>   k = a->root[i];
>   while (k != -1) {
>     col = a->col[k];
>     if (col >= j)
>       break;
>     last = k;
>     k = a->link[k];
>   }
>   if (col == j) {
>     /* element already exists: compute updated value */
>     x += a->val[k];
> 
>     if ((a->storeZeros == 0) && (x == 0.0)) {
>       /* the updated element is zero and must be removed */
> 
>       /* relink row i */
>       if (last == -1)
>     a->root[i] = a->link[k];
>       else
>     a->link[last] = a->link[k];
>       /* add element to free list */
>       a->link[k] = a->free;
>       a->free = k;
> 
>       a->nnz --;
>     } else {
>       a->val[k] = x;
>     }
> 
>   } else {
>     /* new item */
>     if (a->free != -1) {
> 
>       /* use element from the free chain */
>       new_elem = a->free;
>       a->free = a->link[new_elem];
> 
>     } else {
> 
>       /* append new element to the end */
>       new_elem = a->nnz;
> 
>       /* test if there is space for a new element */
>       if (a->nnz == a->nalloc) {
>     int nalloc_new;
> 
>     /* increase size of idx, val and link arrays */
>     nalloc_new = (int)((double)INCREASE_FACTOR * a->nalloc) + 1;
>     if ((temp = PyMem_Resize(a->col, int, nalloc_new)) == NULL)
>       goto fail;
>     else
>       a->col = temp;
>     if ((temp = PyMem_Resize(a->link, int, nalloc_new)) == NULL)
>       goto fail;
>     else
>       a->link = temp;
>     if ((temp = PyMem_Resize(a->val, double, nalloc_new)) == NULL)
>       goto fail;
>     else
>       a->val = temp;
>     a->nalloc = nalloc_new;
>       }
>     }
> 
>     a->val[new_elem] = x;
>     a->col[new_elem] = j;
>     a->link[new_elem] = k;
>     if (last == -1)
>       a->root[i] = new_elem;
>     else
>       a->link[last] = new_elem;
>     a->nnz ++;
>   }
>   return 0;
> 
>  fail:
>   PyErr_NoMemory();
>   return -1;
> }
> 
> /*
>  *  Shrink val, col and link arrays of matrix to minimal size
>  */
> 
> static int
> LLMat_Compress(LLMatObject *self, int *nofFreed) {
> 
>   double *val;
>   int *col, *link;
>   int i, k, k_next, k_last, k_new, nalloc_new;
> 
>   nalloc_new = self->nnz;   /* new size for val, col and link arrays */
> 
>   /* remove entries with k >= nalloc_new from free list */
>   k_last = -1;
>   k = self->free;
>   while (k != -1) {
>     k_next =  self->link[k];
>     if (k >= nalloc_new) {
>       if (k_last == -1)
>     self->free = k_next;
>       else
>     self->link[k_last] = k_next;
>     } else
>       k_last = k;
>     k = k_next;
>   }
>   /* reposition matrix entries with k >= nalloc_new */
>   for (i = 0; i < self->dim[0]; i ++) {
>     k_last = -1;
>     for (k = self->root[i]; k != -1; k = self->link[k]) {
>       if (k >= nalloc_new) {
>     k_new = self->free;
>     if (k_last == -1)
>       self->root[i] = k_new;
>     else
>       self->link[k_last] = k_new;
>     self->free = self->link[k_new];
>     self->val[k_new] = self->val[k];
>     self->col[k_new] = self->col[k];
>     self->link[k_new] = self->link[k];
>     k_last = k_new;
>       } else
>     k_last = k;
>     }
>   }
>   /* shrink arrays */
>   if( !(col = PyMem_Resize(self->col, int, nalloc_new)) ) goto fail;
>   self->col = col;
>   if( !(link = PyMem_Resize(self->link, int, nalloc_new)) ) goto fail;
>   self->link = link;
>   if( !(val = PyMem_Resize(self->val, double, nalloc_new)) ) goto fail;
>   self->val = val;
> 
>   *nofFreed = self->nalloc - nalloc_new;
>   self->nalloc = nalloc_new;
>   return 0;
> 
>  fail:
>   PyErr_NoMemory();
>   return -1;
> }
> 
> /***********************************************************************/
> /*  R o u t i n e s   f o r   h a n d l i n g   s u b m a t r i c e s  */
> /***********************************************************************/
> 
> /* Create a index array from a Python list or slice */
> 
> long* create_indexlist(long *len, long maxlen, PyObject *A) {
>   long *index;
>   long  i, j;
>   Py_ssize_t start, stop, step, length;
>   PyObject *val;
> 
>   /* Integer */
>   if( PyInt_Check(A) ) {
>     i = PyInt_AS_LONG(A);
>     if( (index = calloc(1, sizeof(long))) ) index[0] = i;
>     *len = 1;
>     return index;
>   }
> 
>   /* Slice */
>   if( PySlice_Check(A) ) {
> 
>     if( PySlice_GetIndicesEx((PySliceObject*)A, maxlen,
>                              &start, &stop, &step, &length) < 0) return NULL;
> 
>     if( (index = calloc(length, sizeof(long))) )
>       for( i=start, j=0; j<length; i += step, j++) index[j] = i;
> 
>     *len = (int)length;
>     return index;
>   }
> 
>   /* List */
>   if( PyList_Check(A) ) {
>     length = PyList_Size(A);
>     if( !(index = calloc(length, sizeof(long))) ) return NULL;
>     for( i=0; i<length; i++ ) {
>       val = PyList_GetItem(A, (Py_ssize_t)i);
>       if( PyInt_Check(val) )
>         index[i] = PyInt_AS_LONG(val);
>       else {
>         free(index);
>         PyErr_SetString(PyExc_ValueError, "Index must be a list of integers");
>         return NULL;
>       }
>     }
>     *len = (int)length;
>     return index;
>   }
> 
>   /* Numpy array */
>   if( PyArray_Check(A) ) {
>     npy_intp length0 = PyArray_DIM(A, 0);
>     PyObject *iterator0 = PyArray_IterNew(A);
> 
>     if( !(index = calloc(length0, sizeof(long))) ) {
>       Py_XDECREF(iterator0);
>       return NULL;
>     }
> 
>     PyArray_ITER_RESET(iterator0);
>     i = 0;
> 
>     while( PyArray_ITER_NOTDONE(iterator0) ) {
>       index[i] = *(long*)PyArray_ITER_DATA(iterator0);
>       PyArray_ITER_NEXT(iterator0);
>       i++;
>     }
>     *len = (int)length0;
>     Py_DECREF(iterator0);
>     return index;
>   }
> 
>   PyErr_SetString(PyExc_TypeError, "Invalid index type");
>   return NULL;
> }
> 
> /*
>  *  Copy submatrix src[start0:stop0,start1:stop1] into a newly allocated matrix.
>  *  If transpose is non-zero, the transposed submatrix is copied.
>  *
>  *  Helper routine for get_submatrix
>  */
> 
> static int copySubMatrix_FromList(LLMatObject *src, LLMatObject *dst,
>                                   long *irow, int nrow, long *jcol, int ncol) {
> 
>   // Transfer elements (i,j) in irow X jcol from src to dst.
>   // In Python notation: dst = src[irow,jcol].
> 
>   int i, j, row, col;
>   double val;
> 
>   // Move elements over one by one
>   for( i = 0; i < nrow; i++ ) {
>     row = irow[i];
>     for( j = 0; j < ncol; j++ ) {
>       col = jcol[j];
>       val = SpMatrix_LLMatGetItem(src, row, col);
>       // Element (row,col) in src goes to location (i,j) in dst
>       if( SpMatrix_LLMatSetItem(dst, i, j, val) ) {
>         PyErr_SetString(PyExc_ValueError, "SpMatrix_LLMatSetItem failed");
>         return -1;
>       }
>     }
>   }
>   return 0;
> }
> 
> static PyObject *getSubMatrix_FromList(LLMatObject *self,
>                                        PyObject *index0, PyObject *index1) {
> 
>   LLMatObject *dst;           // Destination matrix
>   int dim[2];                 // Destination matrix shape
>   int symmetric = 0;          // For now, always return a general matrix
>   int res;
> 
>   // Both index sets are a single integer
>   if( PyInt_Check(index0) && PyInt_Check(index1) ) {
>     long row = PyInt_AS_LONG(index0);
>     long col = PyInt_AS_LONG(index1);
>     while( row < 0 ) row += self->dim[0];
>     while( col < 0 ) col += self->dim[1];
>     if( row >= self->dim[0] || col >= self->dim[1] ) {
>       PyErr_SetString(PyExc_IndexError, "Index ouf of bounds");
>       return NULL;
>     }
>     return PyFloat_FromDouble( SpMatrix_LLMatGetItem(self, row, col) );
>   }
> 
>   // Both index sets are Python slices
>   if( PySlice_Check(index0) && PySlice_Check(index1) ) {
> 
>     int i, j, k, row, col, t, inslice1;
>     Py_ssize_t start0, stop0, step0, length0;
>     Py_ssize_t start1, stop1, step1, length1;
>     double val;
> 
>     if( PySlice_GetIndicesEx((PySliceObject*)index0, self->dim[0],
>                              &start0, &stop0, &step0, &length0) < 0)
>       return NULL;
> 
>     if( PySlice_GetIndicesEx((PySliceObject*)index1, self->dim[1],
>                              &start1, &stop1, &step1, &length1) < 0)
>       return NULL;
> 
>     dim[0] = length0; dim[1] = length1;
>     dst = (LLMatObject *)SpMatrix_NewLLMatObject(dim, symmetric, self->nnz, self->storeZeros);
>     if( !dst ) return NULL;
> 
>     row = start0;
>     i = 0;    // Set row index of first element to be output
> 
>     // Scan each row in turn
>     while( (step0 > 0 && row < stop0) || (step0 < 0 && row > stop0) ) {
> 
>       // Scan current row
>       for( k = self->root[row]; k != -1; k = self->link[k] ) {
> 
>         col = self->col[k]; // Col index of current nonzero element
>         inslice1 = 0;
>         if( step1 > 0 && col >= start1 && col < stop1 )
>           inslice1 = (col % step1 == 0);
>         else if( step1 < 0 && col <= start1 && col > stop1 )
>           inslice1 = (col % step1 == 0);
> 
>         if( inslice1 ) {    // Want this element
> 
>           if( self->issym && row < col ) {  // Swap row and col
>             t = col; col = row; row = t;
>           }
> 
>           val = SpMatrix_LLMatGetItem(self, row, col);
> 
>           j = (long)((col - start1)/step1); // Col index of element in output
> 
>           if( SpMatrix_LLMatSetItem(dst, i, j, val) ) {
>             Py_DECREF(dst);
>             PyErr_SetString(PyExc_ValueError, "SpMatrix_LLMatSetItem failed");
>             return NULL;
>           }
> 
>         }
>       }
> 
>       row += step0;  // Move to next row
>       i++;
>     }
> 
>     /* Here is another version of slicing which is less efficient since
>      * it scans the whole slices and extracts every single element in the
>      * slices, including all the potentially zero elements. */
>     /*
>     row = start0;
>     i = 0;
>     while( (step0 > 0 && row < stop0) || (step0 < 0 && row > stop0) ) {
>       col = start1;
>       j = 0;
>       while( (step1 > 0 && col < stop1) || (step1 < 0 && col > stop1) ) {
>         val = SpMatrix_LLMatGetItem(self, row, col);
>         if( SpMatrix_LLMatSetItem(dst, i, j, val) ) {
>           Py_DECREF(dst);
>           PyErr_SetString(PyExc_ValueError, "SpMatrix_LLMatSetItem failed");
>           return NULL;
>         }
>         col += step1;
>         j++;
>       }
>       row += step0;
>       i++;
>     }
>     */
> 
>     /* A third version of slicing would be to build a column index for the
>      * input matrix, scan both the row and column linked lists and retain
>      * only common elements.
>      */
> 
>     return (PyObject *)dst;
>   }
> 
>   // Both index sets are Python lists
>   if( PyList_Check(index0) && PyList_Check(index1) ) {
> 
>     int i, j;
>     long row, col;
>     Py_ssize_t length0 = PyList_Size(index0);
>     Py_ssize_t length1 = PyList_Size(index1);
>     PyObject *ind;
>     double val;
> 
>     dim[0] = length0; dim[1] = length1;
>     dst = (LLMatObject *)SpMatrix_NewLLMatObject(dim, symmetric, self->nnz, self->storeZeros);
>     if( !dst ) return NULL;
> 
>     for( i = 0; i < length0; i++ ) {
>       ind = PyList_GetItem(index0, (Py_ssize_t)i);
>       if( PyInt_Check(ind) )
>         row = PyInt_AS_LONG(ind);
>       else {
>         Py_DECREF(dst);
>         PyErr_SetString(PyExc_ValueError, "Invalid list item");
>         return NULL;
>       }
>       for( j = 0; j < length1; j++ ) {
>         ind = PyList_GetItem(index1, (Py_ssize_t)j);
>         if( PyInt_Check(ind) )
>           col = PyInt_AS_LONG(ind);
>         else {
>           Py_DECREF(dst);
>           PyErr_SetString(PyExc_ValueError, "Invalid list item");
>           return NULL;
>         }
> 
>         val = SpMatrix_LLMatGetItem(self, row, col);
>         if( SpMatrix_LLMatSetItem(dst, i, j, val) ) {
>           Py_DECREF(dst);
>           PyErr_SetString(PyExc_ValueError, "SpMatrix_LLMatSetItem failed");
>           return NULL;
>         }
>       }
>     }
> 
>     return (PyObject *)dst;
>   }
> 
>   // Both index sets are Numpy arrays
>   if( PyArray_Check(index0) && PyArray_Check(index1) ) {
> 
>     int i, j;
>     long row, col;
>     double val;
>     PyObject *iterator0 = PyArray_IterNew(index0);  // Use iterators because may
>     PyObject *iterator1 = PyArray_IterNew(index1);  // not be contiguous
>     npy_intp length0 = PyArray_DIM(index0, 0);
>     npy_intp length1 = PyArray_DIM(index1, 0);
> 
>     dim[0] = length0; dim[1] = length1;
>     dst = (LLMatObject *)SpMatrix_NewLLMatObject(dim, symmetric, self->nnz, self->storeZeros);
>     if( !dst ) {
>       Py_XDECREF(iterator0);
>       Py_XDECREF(iterator1);
>       return NULL;
>     }
> 
>     PyArray_ITER_RESET(iterator0);
>     i = 0;
> 
>     while( PyArray_ITER_NOTDONE(iterator0) ) {
> 
>       row = *(long*)PyArray_ITER_DATA(iterator0);
> 
>       PyArray_ITER_RESET(iterator1);
>       j = 0;
> 
>       while( PyArray_ITER_NOTDONE(iterator1) ) {
> 
>         col = *(long*)PyArray_ITER_DATA(iterator1);
>         val = SpMatrix_LLMatGetItem(self, row, col);
> 
>         if( SpMatrix_LLMatSetItem(dst, i, j, val) ) {
>           Py_DECREF(dst);
>           Py_DECREF(iterator0);
>           Py_DECREF(iterator1);
>           PyErr_SetString(PyExc_ValueError, "SpMatrix_LLMatSetItem failed");
>           return NULL;
>         }
> 
>         PyArray_ITER_NEXT(iterator1);
>         j++;
>       }
> 
>       PyArray_ITER_NEXT(iterator0);
>       i++;
>     }
> 
>     Py_DECREF(iterator0);
>     Py_DECREF(iterator1);
>     return (PyObject *)dst;
>   }
> 
>   // If we have a mixture of index sets, gather both sets into arrays.
>   {
>       long *irow, *jcol;
>       long  nrow,  ncol;
> 
>       // Create index list from first index
>       if( !(irow = create_indexlist(&nrow, self->dim[0], index0)) ) {
>         PyErr_SetString(PyExc_IndexError, "Error creating first index list");
>         // Py_INCREF(Py_None);
>         // return Py_None;
>         return NULL;
>       }
> 
>       // Create index list from second index
>       if( !(jcol = create_indexlist(&ncol, self->dim[1], index1)) ) {
>         free(irow);
>         PyErr_SetString(PyExc_IndexError, "Error creating second index list");
>         // Py_INCREF(Py_None);
>         // return Py_None;
>         return NULL;
>       }
> 
>       dim[0] = nrow; dim[1] = ncol;
>       dst = (LLMatObject *)SpMatrix_NewLLMatObject(dim, symmetric, self->nnz, self->storeZeros);
>       if( !dst ) {
>         free(irow);
>         free(jcol);
>         return NULL;
>       }
> 
>       res = copySubMatrix_FromList(self, (LLMatObject*)dst, irow, nrow, jcol, ncol);
>       free(irow);
>       free(jcol);
>       if( res ) {
>         Py_DECREF(dst);
>         return NULL;
>       }
>       return (PyObject *)dst;
>   }
> 
> }
> 
> /*
>  *  Delete all non-zero entries from slice self[start0:stop0, start1:stop1]
>  */
> 
> static int
> clear_submatrix(LLMatObject *self,
>                 int start0, int stop0, int start1, int stop1) {
> 
>   int i, j, k, next, last;
> 
>   for (i = start0; i < stop0; i ++) {
>     last = -1;
>     k = self->root[i];
>     while (k != -1) {
>       j = self->col[k];
>       next = self->link[k];
>       if (start1 <= j && j < stop1) {
>     /* remove element */
>     if (last == -1)
>       self->root[i] = next;
>     else
>       self->link[last] = next;
>     /* add element to free list */
>     self->link[k] = self->free;
>     self->free = k;
>     self->nnz--;
>       } else
>     last = k;
>       k = next;
>     }
>   }
>   return 0;
> }
> 
> /*
>  *  Assign slice self[irow,jcol] = other.
>  */
> 
> //static int setSubMatrix_FromList(LLMatObject *self, LLMatObject *other,
> //                                 long *irow, int nrow, long *jcol, int ncol) {
> static void //int
> setSubMatrix_FromList(LLMatObject *self, PyObject *other,
>               PyObject *index0, PyObject *index1) {
> 
>   LLMatObject *mat = NULL;
>   int other_is_num = 0, other_is_sym;
>   double val = 0.0;
> 
>   if( PyInt_Check(other) ) {
>     val = (double)PyInt_AsLong(other);
>     other_is_num = 1;
>   } else if( PyFloat_Check(other) ) {
>     val = PyFloat_AsDouble(other);
>     other_is_num = 1;
>   }
> 
>   //other_is_num = PyArg_Parse(other, "d;array item must be float", &val);
> 
>   // Both index sets are a single integer
>   if( PyInt_Check(index0) && PyInt_Check(index1) ) {
> 
>     long row = PyInt_AS_LONG(index0);
>     long col = PyInt_AS_LONG(index1);
> 
>     if( !other_is_num ) { //return -1;
>       PyErr_SetString(PyExc_ValueError, "Value must be double");
>       return;
>     }
>     //return SpMatrix_LLMatSetItem(self, row, col, val);
>     while( row < 0 ) row += self->dim[0];
>     while( col < 0 ) col += self->dim[1];
>     if( row >= self->dim[0] || col >= self->dim[1] ) {
>       PyErr_SetString(PyExc_IndexError, "Index out of bounds");
>       return;
>     }
>     SpMatrix_LLMatSetItem(self, row, col, val);
>     return;
>   }
> 
>   if( !other_is_num ) {
>     mat = (LLMatObject *)other;
>     other_is_sym = mat->issym;
>   } else
>     other_is_sym = 0;
> 
>   // Both index sets are Python slices
>   if( PySlice_Check(index0) && PySlice_Check(index1) ) {
> 
>     long i, j, k, row, col, t;
>     Py_ssize_t start0, stop0, step0, length0;
>     Py_ssize_t start1, stop1, step1, length1;
> 
>     //printf("PySparse:: we have two slices...\n");
> 
>     if( PySlice_GetIndicesEx((PySliceObject*)index0, self->dim[0],
>                              &start0, &stop0, &step0, &length0) < 0) {
>       PyErr_SetString(PyExc_IndexError, "Erroneous indices");
>       return;
>       //return -1;
>     }
> 
>     if( PySlice_GetIndicesEx((PySliceObject*)index1, self->dim[1],
>                              &start1, &stop1, &step1, &length1) < 0) {
>       PyErr_SetString(PyExc_IndexError, "Erroneous indices");
>       return;
>       //return -1;
>     }
> 
>     //printf("New block of size (%ld,%ld)\n", length0, length1);
> 
>     if( other_is_num) {
> 
>       // Special case for A[slice,slice] = scalar
>       row = start0;
>       while( (step0 > 0 && row < stop0) || (step0 < 0 && row > stop0) ) {
>         col = start1;
>         while( (step1 > 0 && col < stop1) || (step1 < 0 && col > stop1) ) {
>           if( self->issym && row < col ) {
>             PyErr_SetString(PyExc_IndexError,  //SpMatrix_ErrorObject,
>                             "Writing to upper triangle of symmetric matrix");
>             return; // -1;
>           }
>           if( SpMatrix_LLMatSetItem(self, row, col, val) ) {
>             PyErr_SetString(PyExc_ValueError, "SpMatrix_LLMatSetItem failed");
>             return; // -1;
>           }
>           col += step1;
>         }
>         row += step0;
>       }
> 
>     } else {
> 
>       if( mat->dim[0] != length0 || mat->dim[1] != length1 ) {
>         printf("In LHS=RHS, RHS has shape (%d,%d), LHS has shape (%d,%d)\n",
>                mat->dim[0], mat->dim[1], (int)length0, (int)length1);
>         PyErr_SetString(PyExc_ValueError, "Matrix shapes are different");
>         return; // -1;
>       }
> 
>       row = start0;
>       i = 0;    // Set row index of first element to be assigned
> 
>       // Scan each row in turn
>       while( (step0 > 0 && row < stop0) || (step0 < 0 && row > stop0) ) {
> 
>         // Scan current row in matrix to be assigned
>         for( k = mat->root[i]; k != -1; k = mat->link[k] ) {
> 
>           j = mat->col[k]; // Col index of current nonzero element
>           col = start1 + j * step1; // Col index to be assigned to
> 
>           if( mat->issym && row < col ) {  // Swap row and col
>             t = col; col = row; row = t;
>           }
> 
>           // Ensure write operation is permitted
>           if( self->issym && row < col ) {
>             PyErr_SetString(PyExc_IndexError, //SpMatrix_ErrorObject,
>                             "Writing to upper triangle of symmetric matrix");
>             return; // -1;
>           }
> 
>           val = SpMatrix_LLMatGetItem(mat, i, j);
>           //printf("  (%ld,%ld) -> (%ld,%ld). Val = %g\n", i,j,row,col,val);
> 
>           if( SpMatrix_LLMatSetItem(self, row, col, val) ) {
>             PyErr_SetString(PyExc_ValueError, "SpMatrix_LLMatSetItem failed");
>             return; // -1;
>           }
>         }
> 
>         row += step0;  // Move to next row
>         i++;
>       }
>     }
>     return; // 0;
>   }
> 
>   // Both index sets are Python lists
>   if( PyList_Check(index0) && PyList_Check(index1) ) {
> 
>     //printf("PySparse:: We have two lists...\n");
> 
>     long i, j, row, col, t;
>     Py_ssize_t length0 = PyList_Size(index0);
>     Py_ssize_t length1 = PyList_Size(index1);
>     PyObject *ind;
> 
>     if( !other_is_num )
>       if( mat->dim[0] != length0 || mat->dim[1] != length1 ) {
>         PyErr_SetString(PyExc_ValueError, "Matrix shapes are different");
>         return; // -1;
>       }
> 
>     for( i = 0; i < length0; i++ ) {
>       ind = PyList_GetItem(index0, (Py_ssize_t)i);
>       if( PyInt_Check(ind) )
>         row = PyInt_AS_LONG(ind);
>       else {
>         PyErr_SetString(PyExc_IndexError, "Invalid list item");
>         return; // -1;
>       }
>       for( j = 0; j < length1; j++ ) {
>         ind = PyList_GetItem(index1, (Py_ssize_t)j);
>         if( PyInt_Check(ind) )
>           col = PyInt_AS_LONG(ind);
>         else {
>           PyErr_SetString(PyExc_IndexError, "Invalid list item");
>           return; // -1;
>         }
> 
>         if( !other_is_num )
>           val = SpMatrix_LLMatGetItem(mat, i, j);
> 
>         if( other_is_sym && row < col ) {
>           t = col;
>           col = row;
>           row = t;
>         }
> 
>         //printf("Val = %g goes to position (%ld,%ld)\n", val, row, col);
> 
>         // Ensure write operation is permitted
>         if( self->issym && row < col ) {
>           PyErr_SetString(PyExc_IndexError, //SpMatrix_ErrorObject,
>                           "Writing to upper triangle of symmetric matrix");
>           return; // -1;
>         }
> 
>         if( SpMatrix_LLMatSetItem(self, row, col, val) ) {
>           PyErr_SetString(PyExc_ValueError, "SpMatrix_LLMatSetItem failed");
>           return; // -1;
>         }
>       }
>     }
> 
>     return; // 0;
>   }
> 
>   // Both index sets are Numpy arrays
>   if( PyArray_Check(index0) && PyArray_Check(index1) ) {
> 
>     long i, j, row, col, t;
>     PyObject *iterator0 = PyArray_IterNew(index0);  // Use iterators because may
>     PyObject *iterator1 = PyArray_IterNew(index1);  // not be contiguous
>     npy_intp length0 = PyArray_DIM(index0, 0);
>     npy_intp length1 = PyArray_DIM(index1, 0);
> 
>     if( !other_is_num )
>       if( mat->dim[0] != length0 || mat->dim[1] != length1 ) {
>         Py_DECREF(iterator0);
>         Py_DECREF(iterator1);
>         PyErr_SetString(PyExc_ValueError, "Matrix shapes are different");
>         return; // -1;
>       }
> 
>     PyArray_ITER_RESET(iterator0);
>     i = 0;
> 
>     while( PyArray_ITER_NOTDONE(iterator0) ) {
> 
>       row = *(long*)PyArray_ITER_DATA(iterator0);
> 
>       PyArray_ITER_RESET(iterator1);
>       j = 0;
> 
>       while( PyArray_ITER_NOTDONE(iterator1) ) {
> 
>         col = *(long*)PyArray_ITER_DATA(iterator1);
> 
>         if( !other_is_num )
>           val = SpMatrix_LLMatGetItem(mat, i, j);
> 
>         if( other_is_sym && row < col ) {
>           t = col;
>           col = row;
>           row = t;
>         }
> 
>         // Ensure write operation is permitted
>         if( self->issym && row < col ) {
>           Py_DECREF(iterator0);
>           Py_DECREF(iterator1);
>           PyErr_SetString(PyExc_IndexError, //SpMatrix_ErrorObject,
>                           "Writing to upper triangle of symmetric matrix");
>           return; // -1;
>         }
> 
>         if( SpMatrix_LLMatSetItem(self, row, col, val) ) {
>           Py_DECREF(iterator0);
>           Py_DECREF(iterator1);
>           PyErr_SetString(PyExc_ValueError, "SpMatrix_LLMatSetItem failed");
>           return; // -1;
>         }
> 
>         PyArray_ITER_NEXT(iterator1);
>         j++;
>       }
> 
>       PyArray_ITER_NEXT(iterator0);
>       i++;
>     }
> 
>     Py_DECREF(iterator0);
>     Py_DECREF(iterator1);
>     return; // 0;
>   }
> 
>   // If we have a mixture of index sets, gather both sets into arrays.
>   {
>     long *irow, *jcol;
>     long  i, j, nrow,  ncol, row, col;
> 
>     // Create index list from first index
>     if( !(irow = create_indexlist(&nrow, self->dim[0], index0)) ) {
>       PyErr_SetString(PyExc_IndexError, "Error creating first index list");
>       return; // -1;
>     }
> 
>     // Create index list from second index
>     if( !(jcol = create_indexlist(&ncol, self->dim[1], index1)) ) {
>       PyErr_SetString(PyExc_IndexError, "Error creating second index list");
>       free(irow);
>       return; // -1;
>     }
> 
>     if( !other_is_num )
>       if( mat->dim[0] != nrow || mat->dim[1] != ncol ) {
>         PyErr_SetString(PyExc_ValueError, "Matrix shapes are different");
>         free(irow);
>         free(jcol);
>         return; // -1;
>       }
> 
>     for( i = 0; i < nrow; i++ ) {
>       row = irow[i];
>       for( j = 0; j < ncol; j++ ) {
>         col = jcol[j];
> 
>         if( other_is_sym && row < col ) {
>           col = row;
>           row = jcol[j];
>         }
> 
>         // Ensure write operation is permitted
>         if( self->issym && row < col ) {
>           PyErr_SetString(PyExc_IndexError, //SpMatrix_ErrorObject,
>                           "Writing to upper triangle of symmetric matrix");
>           free(irow);
>           free(jcol);
>           return; // -1;
>         }
> 
>         // Insert element into self
>         if( !other_is_num )
>           val = SpMatrix_LLMatGetItem(mat, i, j);
> 
>         if( SpMatrix_LLMatSetItem(self, row, col, val) ) {
>           PyErr_SetString(PyExc_ValueError, "SpMatrix_LLMatSetItem failed");
>           free(irow);
>           free(jcol);
>           return; // -1;
>         }
>       }
>     }
>     free(irow);
>     free(jcol);
>     return; // 0;
>   }
> }
> 
> /*****************************************************************************/
> /*  M a t r i x - v e c t o r   m u l t i p l i c a t i o n   k e r n e l s  */
> /*****************************************************************************/
> 
> static void
> ll_matvec_kernel(int m, double *x, double *y,
>          double *val, int *col, int *link, int *root) {
>   double s;
>   int i, k;
> 
>   for (i = 0; i < m; i ++) {
>     s = 0.0;
>     k = root[i];
>     while (k != -1) {
>       s += val[k] * x[col[k]];
>       k = link[k];
>     }
>     y[i] = s;
>   }
> }
> 
> static void
> ll_matvec_kernel_stride(int m,
>             double *x, int incx,
>             double *y, int incy,
>             double *val, int *col, int *link, int *root) {
>   double s;
>   int i, k;
> 
>   for (i = 0; i < m; i ++) {
>     s = 0.0;
>     k = root[i];
>     while (k != -1) {
>       s += val[k] * x[col[k]*incx];
>       k = link[k];
>     }
>     y[i*incy] = s;
>   }
> }
> 
> static void
> ll_matvec_kernel_sym(int m, double *x, double *y,
>              double *val, int *col, int *link, int *root) {
>   double s, v, xi;
>   int i, j, k;
> 
>   for (i = 0; i < m; i ++) {
>     xi = x[i];
>     s = 0.0;
>     k = root[i];
>     while (k != -1) {
>       j = col[k];
>       v = val[k];
>       s += v * x[j];
>       if (i != j)
>     y[j] += v * xi;
>       k = link[k];
>     }
>     y[i] = s;
>   }
> }
> 
> static void
> ll_matvec_kernel_stride_sym(int m,
>                 double *x, int incx,
>                 double *y, int incy,
>                 double *val, int *col, int *link, int *root) {
>   double s, v, xi;
>   int i, j, k;
> 
>   for (i = 0; i < m; i ++) {
>     xi = x[i*incx];
>     s = 0.0;
>     k = root[i];
>     while (k != -1) {
>       j = col[k];
>       v = val[k];
>       s += v * x[j*incx];
>       if (i != j)
>     y[j*incy] += v * xi;
>       k = link[k];
>     }
>     y[i*incy] = s;
>   }
> }
> 
> static void
> ll_matvec_transp_kernel(int m, int n, double *x, double *y,
>                 double *val, int *col, int *link, int *root) {
>   double xi;
>   int i, k;
> 
>   for (i = 0; i < n; i ++)
>     y[i] = 0.0;
> 
>   for (i = 0; i < m; i ++) {
>     xi = x[i];
>     k = root[i];
>     while (k != -1) {
>       y[col[k]] += val[k] * xi;
>       k = link[k];
>     }
>   }
> }
> 
> static void
> ll_matvec_transp_kernel_stride(int m, int n,
>                    double *x, int incx,
>                    double *y, int incy,
>                    double *val, int *col, int *link, int *root) {
>   double xi;
>   int i, k;
> 
>   for (i = 0; i < n; i ++)
>     y[i*incy] = 0.0;
> 
>   for (i = 0; i < m; i ++) {
>     xi = x[i*incx];
>     k = root[i];
>     while (k != -1) {
>       y[col[k]*incy] += val[k] * xi;
>       k = link[k];
>     }
>   }
> }
> 
> /*********************************************/
> /*  L L M a t   o b j e c t   m e t h o d s  */
> /*********************************************/
> 
> static char LLMat_matvec_transp_doc[] = "A.matvec_transp(x, y)\n\
> \n\
> compute the sparse matrix-vector product y := A^T * x. \n\
> A^T is the transpose of A, which is a d1 by d2 sparse matrix.\n\
> x and y are two 1-dimensional Numpy arrays of appropriate size.";
> 
> static PyObject *
> LLMat_matvec_transp(LLMatObject *self, PyObject *args)
> {
>   PyArrayObject *xp, *yp;
>   size_t sd = sizeof(double);
> 
>   SPMATRIX_PARSE_ARGS_ARR_ARR_STRIDE(args, xp, yp, self->dim[0], self->dim[1]);
> 
>   if (xp->flags & CONTIGUOUS &&  yp->flags & CONTIGUOUS)
>     if (self->issym)
>       ll_matvec_kernel_sym(self->dim[0],
>                            (double *)(xp->data), (double *)(yp->data),
>                self->val, self->col, self->link, self->root);
>     else
>       ll_matvec_transp_kernel(self->dim[0], self->dim[1],
>                               (double *)(xp->data), (double *)(yp->data),
>                   self->val, self->col, self->link, self->root);
>   else
>     if (self->issym)
>       ll_matvec_kernel_stride_sym(self->dim[0],
>                   (double *)(xp->data), xp->strides[0] / sd,
>                   (double *)(yp->data), yp->strides[0] / sd,
>                   self->val, self->col, self->link, self->root);
>     else
>       ll_matvec_transp_kernel_stride(self->dim[0], self->dim[1],
>                      (double *)(xp->data), xp->strides[0] / sd,
>                      (double *)(yp->data), yp->strides[0] / sd,
>                      self->val, self->col, self->link,
>                                      self->root);
> 
>   Py_INCREF(Py_None);
>   return Py_None;
> }
> 
> static char LLMat_matvec_doc[] = "A.matvec(x, y)\n\
> \n\
> compute the sparse matrix-vector product y := A * x. \n\
> A is a d1 by d2 sparse matrix.\n\
> x and y are two 1-dimensional Numpy arrays of appropriate size.";
> 
> static PyObject *
> LLMat_matvec(LLMatObject *self, PyObject *args)
> {
>   PyArrayObject *xp, *yp;
>   size_t sd = sizeof(double);
> 
>   SPMATRIX_PARSE_ARGS_ARR_ARR_STRIDE(args, xp, yp, self->dim[1], self->dim[0]);
> 
>   if (xp->flags & CONTIGUOUS &&  yp->flags & CONTIGUOUS)
>     if (self->issym)
>       ll_matvec_kernel_sym(self->dim[0],
>                            (double *)(xp->data), (double *)(yp->data),
>                self->val, self->col, self->link, self->root);
>     else
>       ll_matvec_kernel(self->dim[0],
>                        (double *)(xp->data), (double *)(yp->data),
>                self->val, self->col, self->link, self->root);
>   else
>     if (self->issym)
>       ll_matvec_kernel_stride_sym(self->dim[0],
>                   (double *)(xp->data), xp->strides[0] / sd,
>                   (double *)(yp->data), yp->strides[0] / sd,
>                   self->val, self->col, self->link, self->root);
>     else
>       ll_matvec_kernel_stride(self->dim[0],
>                   (double *)(xp->data), xp->strides[0] / sd,
>                   (double *)(yp->data), yp->strides[0] / sd,
>                   self->val, self->col, self->link, self->root);
> 
>   Py_INCREF(Py_None);
>   return Py_None;
> }
> 
> /* Apply in-place column scaling to a matrix of type LL_Mat */
> 
> static char col_scale_doc[] = "A.col_scale(v)\n\
> \n\
> Scale the i-th column of A by v[i] in place for i=0, ..., ncol-1.";
> 
> static PyObject *
> LLMat_col_scale(LLMatObject *self, PyObject *args) {
> 
>   PyObject *vIn;
>   PyArrayObject *v = NULL;
>   struct llColIndex *colIdx;
>   double val;
>   int j, k;
> 
>   // Read scale vector v.
>   if( !PyArg_ParseTuple(args, "O", &vIn) ) {
>     PyErr_SetString(SpMatrix_ErrorObject, "Cannot read input vector.");
>     return NULL;
>   }
>   v = (PyArrayObject *)PyArray_ContiguousFromObject(vIn, PyArray_DOUBLE, 1, 1);
>   if( v == NULL ) {
>     PyErr_SetString(SpMatrix_ErrorObject, "Supply scaling vector as input.");
>     return NULL;
>   }
> 
>   // Check for dimensions mismatch.
>   if( v->dimensions[0] != self->dim[1] ) {
>     PyErr_SetString(SpMatrix_ErrorObject,
>                     "Column scaling vector has wrong dimension.");
>     return NULL;
>   }
> 
>   // Build column index.
>   if( SpMatrix_LLMatBuildColIndex(&colIdx, self, 1) ) {
>     PyErr_SetString(SpMatrix_ErrorObject, "Cannot build column index.");
>     return NULL;
>   }
> 
>   // Process each column in turn
>   for( j = 0; j < self->dim[1] ; j++ ) {
>     val = ((double *)v->data)[j];
> 
>     // Scan column j.
>     k = colIdx->root[j];
>     while( k != -1 ) {
>       self->val[k] *= val;
>       k = colIdx->link[k];
>     }
>   }
> 
>   SpMatrix_LLMatDestroyColIndex(&colIdx);
> 
>   Py_INCREF(Py_None);
>   return Py_None;
> }
> 
> /* Apply in-place row scaling to a matrix of type LL_Mat */
> 
> static char row_scale_doc[] = "A.row_scale(v)\n\
> \n\
> Scale the i-th row of A by v[i] in place for i=0, ..., nrow-1.";
> 
> static PyObject *
> LLMat_row_scale(LLMatObject *self, PyObject *args) {
> 
>   double val;
>   int i, k;
>   PyObject *vIn;
>   PyArrayObject *v = NULL;
> 
>   // Read scale vector v.
>   if( !PyArg_ParseTuple(args, "O", &vIn) ) {
>     PyErr_SetString(SpMatrix_ErrorObject, "Cannot read input vector.");
>     return NULL;
>   }
>   v = (PyArrayObject *)PyArray_ContiguousFromObject(vIn, PyArray_DOUBLE, 1, 1);
>   if( v == NULL ) {
>     PyErr_SetString(SpMatrix_ErrorObject, "Supply scaling vector as input.");
>     return NULL;
>   }
> 
>   // Check for dimensions mismatch.
>   if( v->dimensions[0] != self->dim[0] ) {
>     PyErr_SetString(SpMatrix_ErrorObject,
>                     "Row scaling vector has wrong dimension.");
>     return NULL;
>   }
> 
>   // Process each row in turn.
>   for( i = 0; i < self->dim[0]; i++ ) {
>     val = ((double *)v->data)[i];
> 
>     // Scan row i.
>     k = self->root[i];
>     while( k != -1 ) {
>       self->val[k] *= val;
>       k = self->link[k];
>     }
>   }
> 
>   Py_INCREF(Py_None);
>   return Py_None;
> }
> 
> 
> static char to_csr_doc[] = "A.to_csr()\n\
> \n\
> return a new CSRMatObject constructed from data of A";
> 
> static PyObject *
> LLMat_to_csr(LLMatObject *self, PyObject *args)
> {
>   CSRMatObject *op;
>   int i, j, k, r;
> 
>   if (!PyArg_ParseTuple(args, ""))
>     return NULL;
> 
>   if (self->issym) {  /* Symmetric case */
>     struct llColIndex *colIdx;
> 
>     if (SpMatrix_LLMatBuildColIndex(&colIdx, self, 0)) return NULL;
>     assert(colIdx->nzUp == 0);
> 
>     op = (CSRMatObject *)newCSRMatObject(self->dim,
>                                          2*colIdx->nzLo + colIdx->nzDiag);
>     if (op == NULL) {
>       SpMatrix_LLMatDestroyColIndex(&colIdx);
>       return NULL;
>     }
> 
>     r = 0;
>     op->ind[0] = 0;
>     for (i = 0; i < self->dim[0]; i ++) {
> 
>       /* store self[0:i+1,i] in op[0:i+1,i] */
>       k = self->root[i];
>       while (k != -1) {
>     op->val[r] = self->val[k];
>     op->col[r] = self->col[k];
>     r ++;
>     k = self->link[k];
>       }
> 
>       /* store self[i,i+1:n] in op[i+1:n,i] */
>       k = colIdx->root[i];
>       while (k != -1) {
>     j = colIdx->row[k];
>     op->val[r] = self->val[k];
>     op->col[r] = j;
>     r ++;
>     k = colIdx->link[k];
>       }
> 
>       op->ind[i+1] = r;
>     }
> 
>     SpMatrix_LLMatDestroyColIndex(&colIdx);
> 
>   } else {  /* Unsymmetric case */
> 
>     op = (CSRMatObject *)newCSRMatObject(self->dim, self->nnz);
>     if (op == NULL)
>       return NULL;
> 
>     r = 0;
>     op->ind[0] = 0;
>     for (i = 0; i < self->dim[0]; i ++) {
>       k = self->root[i];
>       while (k != -1) {
>     op->val[r] = self->val[k];
>     op->col[r] = self->col[k];
>     r ++;
>     k = self->link[k];
>       }
>       op->ind[i+1] = r;
>     }
>   }
> 
>   return (PyObject *)op;
> }
> 
> static char to_sss_doc[] = "a.to_sss()\n\
> \n\
> return a new SSSMatObject constructed from the lower triangle of a";
> 
> static PyObject *
> LLMat_to_sss(LLMatObject *self, PyObject *args)
> {
>   SSSMatObject *op;
>   int i, j, k, r, n, nnz;
> 
>   if (!PyArg_ParseTuple(args, ""))
>     return NULL;
> 
>   /* test for square matrix */
>   n = self->dim[0];
>   if (n != self->dim[1]) {
>     PyErr_SetString(PyExc_ValueError, "Matrix must be square");
>     return NULL;
>   }
> 
>   /* 1st pass: compute number of non-zeros in lower triangle */
>   nnz = 0;
>   for (i = 0; i < n; i ++) {
>     k = self->root[i];
>     while (k != -1) {
>       j = self->col[k];
>       if (i > j)
>     nnz ++;
>       k = self->link[k];
>     }
>   }
> 
>   /* allocate new SSS matrix */
>   op = (SSSMatObject *)newSSSMatObject(n, nnz);
>   if (op == NULL)
>     return NULL;
> 
>   /* 2nd pass: fill SSSMatObject */
>   for (i = 0; i < n; i ++)
>     op->diag[i] = 0.0;
>   r = 0;
>   op->ind[0] = 0;
>   for (i = 0; i < n; i ++) {
>     k = self->root[i];
>     while (k != -1) {
>       j = self->col[k];
>       if (i > j) {
>     op->val[r] = self->val[k];
>     op->col[r] = j;
>     r ++;
>       } else if (i == j)
>     op->diag[i] = self->val[k];
>       k = self->link[k];
>     }
>     op->ind[i+1] = r;
>   }
> 
>   return (PyObject *)op;
> }
> 
> static char LLMat_generalize_doc[] = \
> "convert ll_mat object from symmetric to non-symmetric form (in-place).";
> 
> static PyObject *
> LLMat_generalize(LLMatObject *self, PyObject *args) {
>   int i, j, k;
> 
>   if (!PyArg_ParseTuple(args, "")) return NULL;
> 
>   if (self->issym) {
>     self->issym = 0;
>     for (i = 0; i < self->dim[0]; i ++) {
>       /* New elements are inserted into the matrix while it is being traversed.
>      However, this should not be a problem */
>       for (k = self->root[i]; k != -1; k = self->link[k]) {
>     j = self->col[k];
>     if (i > j)
>       if (SpMatrix_LLMatSetItem(self, j, i, self->val[k]))
>         return NULL;
>       }
>     }
>   }
> 
>   Py_INCREF(Py_None);
>   return Py_None;
> }
> 
> static char LLMat_compress_doc[] = "A.compress() frees memory by reclaiming unused space in the data structures of A. Returns number of elements freed.";
> 
> static PyObject *
> LLMat_compress(LLMatObject *self, PyObject *args) {
>   int nofFreed;
> 
>   if (!PyArg_ParseTuple(args, "")) return NULL;
>   if (LLMat_Compress(self, &nofFreed)) return NULL;
>   return PyInt_FromLong(nofFreed);
> }
> 
> static char export_mtx_doc[] = "A.export_mtx(fileName, precision=16)\n\
> \n\
> write matrix in Matrix Market format to fileName.\n\
> \n\
> Parameters:\n\
> \n\
> fileName:  string, name of the file to be created.\n\
> precision: number of significant digits to be written for double values.";
> 
> static PyObject *
> LLMat_export_mtx(LLMatObject *self, PyObject *args) {
> 
>   char *fileName;
>   int precision = 16;
>   MM_typecode matcode;
>   FILE *f;
>   int ret, i, k;
> 
>   if (!PyArg_ParseTuple(args, "s|i", &fileName, &precision)) return NULL;
> 
>   if( !(f = fopen(fileName, "w")) ) return PyErr_SetFromErrno(PyExc_IOError);
> 
>   mm_set_matrix(matcode); mm_set_sparse(matcode); mm_set_real(matcode);
>   self->issym ? mm_set_symmetric(matcode) : mm_set_general(matcode);
> 
>   ret = mm_write_banner(f, matcode);
>   if (ret) {
>     PyErr_SetString(SpMatrix_ErrorObject, "Error writing file header");
>     return NULL;
>   }
> 
>   ret = fprintf(f, "%% file created by pysparse module\n");
>   if (ret < 0) {
>     PyErr_SetString(PyExc_IOError, "Error writing file header");
>     return NULL;
>   }
> 
>   ret = mm_write_mtx_crd_size(f, self->dim[0], self->dim[1], self->nnz);
>   if (ret) {
>     PyErr_SetString(SpMatrix_ErrorObject, "Error writing file header");
>     return NULL;
>   }
> 
>   for (i = 0; i < self->dim[0]; i ++) {
>     k = self->root[i];
>     while (k != -1) {
>       ret = fprintf(f, "%d %d %.*e\n",
>                     i+1, self->col[k]+1, precision-1, self->val[k]);
>       if (ret < 0) {
>     PyErr_SetString(PyExc_IOError, "Error writing matrix data");
>     return NULL;
>       }
>       k = self->link[k];
>     }
>   }
> 
>   ret = fclose(f);
>   if (ret)
>     return PyErr_SetFromErrno(PyExc_IOError);
> 
>   Py_INCREF(Py_None);
>   return Py_None;
> }
> 
> static char copy_doc[] = "A.copy()\n\
> \n\
> return a (deep) copy of the matrix A.";
> 
> static PyObject *
> LLMat_copy(LLMatObject *self, PyObject *args) {
> 
>   LLMatObject *new;
>   int i, k;
> 
>   if (!PyArg_ParseTuple(args, "")) return NULL;
> 
>   new = (LLMatObject *)SpMatrix_NewLLMatObject(self->dim,
>                                                self->issym, self->nnz, self->storeZeros);
>   if (new == NULL) return NULL;
> 
>   for (i = 0; i < self->dim[0]; i++) {
>     k = self->root[i];
>     while (k != -1) {
>       if (SpMatrix_LLMatSetItem(new, i, self->col[k], self->val[k]) == -1) {
>     Py_DECREF(new);
>     return NULL;
>       }
>       k = self->link[k];
>     }
>   }
>   return (PyObject *)new;
> }
> 
> static char update_add_at_doc[] = "A.update_add_at(val,id1,id2)\n\
> \n\
> for i in range(len(val)):\n\
>     A[id1[i],id2[i]] += val[i]";
> 
> static PyObject *
> LLMat_update_add_at(LLMatObject *self, PyObject *args) {
>   PyObject *bIn;
>   PyObject *id1in;
>   PyObject *id2in;
>   PyArrayObject *b = NULL;
>   PyArrayObject *id1 = NULL;
>   PyArrayObject *id2 = NULL;
>   double v;
>   int lenb, i, err;
> 
>   if (!PyArg_ParseTuple(args, "OOO", &bIn, &id1in, &id2in)) return NULL;
> 
>   b = (PyArrayObject *)PyArray_ContiguousFromObject(bIn, PyArray_DOUBLE, 1,1);
>   if (b == NULL) goto fail;
> 
>   lenb = b->dimensions[0];
> 
>   id1 = (PyArrayObject *)PyArray_ContiguousFromObject(id1in, PyArray_LONG, 1,1);
>   if (id1 == NULL) goto fail;
> 
>   id2 = (PyArrayObject *)PyArray_ContiguousFromObject(id2in, PyArray_LONG, 1,1);
>   if (id2 == NULL) goto fail;
> 
>   if (lenb < 0 ) {
>     PyErr_SetString(PyExc_IndexError, "Vector b has a negative size");
>     goto fail;
>   }
> 
>   if (id1->dimensions[0] != lenb ) {
>     PyErr_SetString(PyExc_IndexError, "id1 does not have the same size as b");
>     goto fail;
>   }
> 
>   if (id2->dimensions[0] != lenb ) {
>     PyErr_SetString(PyExc_IndexError, "id2 does not have the same size as b");
>     goto fail;
>   }
> 
>   /* Perform update add operation */
>   for (i = 0; i < lenb; i ++) {
>     v = ((double *)b->data)[i];
>     err = SpMatrix_LLMatUpdateItemAdd(self, ((long *)id1->data)[i],
>                                       ((long *)id2->data)[i], v);
>     if( err == -1 ) goto fail;
>   }
> 
>   Py_XDECREF(b);
>   Py_XDECREF(id1);
>   Py_XDECREF(id2);
>   Py_INCREF(Py_None);
>   return Py_None;
> 
>  fail:
>   if(b)   { Py_XDECREF(b);   }
>   if(id1) { Py_XDECREF(id1); }
>   if(id2) { Py_XDECREF(id2); }
>   return NULL;
> }
> 
> static char LLMat_norm_doc[] = "return p-norm of matrix\n\
> \n\
> A.norm(p) returns the p-norm of matrix A\n\
> \n\
> p is a string identifying the type of norm to be returned\n\
> \n\
>   '1'   -- return the 1-norm of A\n\
>   'inf' -- return the infinity norm of A\n\
>   'fro' -- return the frobenius norm of A";
> 
> static PyObject *
> LLMat_norm(LLMatObject *self, PyObject *args)
> {
>   char *normType;
> 
>   struct llColIndex *colIdx;
>   double norm, s, v;
>   int i, k;
> 
>   if (!PyArg_ParseTuple(args, "s", &normType))
>     return NULL;
> 
>   if (strcmp(normType, "1") == 0) {   /* l1 norm */
> 
>     if (self->issym) {
>       PyErr_SetString(PyExc_NotImplementedError,
>                       "Not implemented for symmetric matrices");
>       return NULL;
>     } else {
> 
>       if (SpMatrix_LLMatBuildColIndex(&colIdx, self, 1))
>         return NULL;
>       for( norm = 0.0, i = 0; i < self->dim[1]; i++ ) {
>     for( s = 0.0, k = colIdx->root[i]; k != -1; k = colIdx->link[k] )
>       s += fabs(self->val[k]);
>         norm = s > norm ? s : norm;
>       }
>       SpMatrix_LLMatDestroyColIndex(&colIdx);
>     }
> 
>   } else if (strcmp(normType, "inf") == 0) {  /* infinity norm */
> 
>     if (self->issym) {
>       PyErr_SetString(PyExc_NotImplementedError,
>                       "Not implemented for symmetric matrices");
>       return NULL;
>     } else {
>       for( norm = 0.0, i = 0; i < self->dim[0]; i++ ) {
>     for( s = 0.0, k = self->root[i]; k != -1; k = self->link[k] )
>       s += fabs(self->val[k]);
>         norm = s > norm ? s : norm;
>       }
>     }
> 
>   } else if (strcmp(normType, "fro") == 0) {  /* Frobenius norm */
> 
>     for( norm = 0.0, i = 0; i < self->dim[0]; i++ )
>       for (k = self->root[i]; k != -1; k = self->link[k]) {
>     v = self->val[k];
>     norm += v*v;
>     if (self->issym && self->col[k] != i) norm += v*v;
>       }
>     norm = sqrt(norm);
> 
>   } else {
>     PyErr_SetString(PyExc_ValueError, "unknown norm type");
>     return NULL;
>   }
> 
>   return Py_BuildValue("d", norm);
> }
> 
> static char shift_doc[] = "A.shift(sigma, B)\n\
> \n\
> shift the matrix:\n\
> compute A = A + sigma * B\n\
> where sigma is a scalar and B is a matrix of compatible size.";
> 
> static PyObject *
> LLMat_shift(LLMatObject *self, PyObject *args) {
>   LLMatObject *mat;
>   double sigma, v;
>   int i, j, k, err;
> 
>   if (!PyArg_ParseTuple(args, "dO!", &sigma, &LLMatType, &mat))
>     return NULL;
>   if (self->dim[0] != mat->dim[0] || self->dim[1] != mat->dim[1]) {
>     PyErr_SetString(PyExc_ValueError, "matrix shapes do not match");
>     return NULL;
>   }
> 
>   if (self->issym == mat->issym) {
>     for (i = 0; i < mat->dim[0]; i ++) {
>       k = mat->root[i];
>       while (k != -1) {
>     err = SpMatrix_LLMatUpdateItemAdd(self, i,
>                                           mat->col[k], sigma * mat->val[k]);
>         if( err == -1 ) return NULL;
>     k = mat->link[k];
>       }
>     }
>   } else if (mat->issym) {
>     for (i = 0; i < mat->dim[0]; i ++) {
>       k = mat->root[i];
>       while (k != -1) {
>     j = mat->col[k];
>     v = sigma * mat->val[k];
>     if (SpMatrix_LLMatUpdateItemAdd(self, i, j, v) == -1)
>       return NULL;
>     if (i != j)
>       if (SpMatrix_LLMatUpdateItemAdd(self, j, i, v) == -1)
>         return NULL;
> 
>     k = mat->link[k];
>       }
>     }
>   } else {
>     PyErr_SetString(PyExc_NotImplementedError,
>             "Cannot shift symmetric matrix by non-symmetric matrix.");
>     return NULL;
>   }
> 
>   Py_INCREF(Py_None);
>   return Py_None;
> }
> 
> 
> static char keys_doc[] = "A.keys()\n\
> \n\
> Return a list of tuples (i,j) of non-zero matrix entries.";
> 
> static PyObject *
> LLMat_keys(LLMatObject *a, PyObject *args) {
>   PyObject *list;             /* the list that will hold the keys */
>   int i, j, k;
>   int pos = 0;                /* position in list */
> 
>   if (!PyArg_ParseTuple(args, "")) return NULL;
> 
>   if (!a->issym) {
> 
>     if ((list = PyList_New(a->nnz)) == NULL) return NULL;
> 
>     for (i = 0; i < a->dim[0]; i ++) {
>       k = a->root[i];
>       while (k != -1) {
>         j = a->col[k];
>         PyList_SET_ITEM(list, pos++, Py_BuildValue("ii", i, j));
>         k = a->link[k];
>       }
>     }
>     return list;
> 
>   } else {
>     PyErr_SetString(PyExc_NotImplementedError,
>                     "keys() doesn't yet support symmetric matrices");
>     return NULL;
>   }
> }
> 
> /*
> static PyObject *
> LLMat_keys(LLMatObject *a, PyObject *args) {
>   PyObject *listi;             /\* the list that will hold keys i *\/
>   PyObject *listj;             /\* the list that will hold keys j *\/
>   PyObject *list;             /\* the list that will hold the keys *\/
>   int i, j, k;
>   int pos = 0;                /\* position in list *\/
> 
>   if (!PyArg_ParseTuple(args, "")) return NULL;
> 
>   if (!a->issym) {
> 
>     if ((list = PyList_New(2)) == NULL) return NULL;
>     if ((listi = PyList_New(a->nnz)) == NULL) return NULL;
>     if ((listj = PyList_New(a->nnz)) == NULL) return NULL;
> 
>     for (i = 0; i < a->dim[0]; i ++) {
>       k = a->root[i];
>       while (k != -1) {
>         j = a->col[k];
>     PyList_SET_ITEM(listi, pos, PyInt_FromLong(i));
>     PyList_SET_ITEM(listj, pos, PyInt_FromLong(j));
>     pos++;
>     k = a->link[k];
>       }
>     }
> 
>     PyList_SET_ITEM(list, 0, listi);
>     PyList_SET_ITEM(list, 1, listj);
> 
>     return list;
> 
>   } else {
>     PyErr_SetString(PyExc_NotImplementedError,
>             "keys() doesn't yet support symmetric matrices");
>     return NULL;
>   }
> }
> */
> 
> static char values_doc[] = "A.values()\n\
> \n\
> Return a list of the non-zero matrix entries as floats.";
> 
> static PyObject *
> LLMat_values(LLMatObject *a, PyObject *args) {
>     PyObject *list;           /* the list that will hold the values */
>     int i, k;
>     int pos = 0;                /* position in list */
> 
>     if (!PyArg_ParseTuple(args, ""))
>         return NULL;
> 
>     if (!a->issym) {
> 
>         if ((list = PyList_New(a->nnz)) == NULL)
>             return NULL;
> 
>         for (i = 0; i < a->dim[0]; i ++) {
>         k = a->root[i];
>         while (k != -1) {
>                 PyList_SET_ITEM(list, pos++, PyFloat_FromDouble(a->val[k]));
>                 k = a->link[k];
>         }
>         }
>         return list;
> 
>     } else {
>         PyErr_SetString(PyExc_NotImplementedError,
>                         "values() doesn't yet support symmetric matrices");
>         return NULL;
>     }
> }
> 
> static char items_doc[] = "A.items()\n\
> \n\
> Return a list of tuples (indices, value) of\n\
> the non-zero matrix entries' keys and values.\n\
> \n\
> The indices are themselves tuples (i,j) of row\n\
> and column values.";
> 
> static PyObject *
> LLMat_items(LLMatObject *a, PyObject *args) {
>   PyObject *list;           /* the list that will hold the values */
>   int i, j, k;
>   int pos = 0;                /* position in list */
>   double val;
> 
>   if (!PyArg_ParseTuple(args, "")) return NULL;
> 
>   if ((list = PyList_New(a->nnz)) == NULL) return NULL;
> 
>   for (i = 0; i < a->dim[0]; i ++) {
>     for( k=a->root[i]; k != -1; k=a->link[k] ) {
>       j = a->col[k];
>       val = a->val[k];
>       PyList_SET_ITEM(list, pos++, Py_BuildValue("((ii)d)", i, j, val));
>     }
>   }
>   return list;
> }
> 
> static char scale_doc[] = "A.scale(sigma)\n\
> \n\
> Scale each element in the matrix by the constant sigma.\n";
> 
> static PyObject *
> LLMat_scale(LLMatObject *self, PyObject *args) {
>   double sigma;
>   int i, k;
> 
>   if (!PyArg_ParseTuple(args, "d", &sigma))
>       return NULL;
> 
>   for (i = 0; i < self->dim[0]; i++)
>     for( k=self->root[i]; k != -1; k=self->link[k] )
>       self->val[k] *= sigma;
> 
>   Py_INCREF(Py_None);
>   return Py_None;
> }
> 
> 
> static char update_add_mask_doc[] = \
> "A.update_add_mask(b, ind0, ind1, mask0, mask1)\n\
> \n\
> Update of global FEM matrix. Equivalent to:\n\
> \n\
> for i in range(len(ind0)):\n\
>     for j in range(len(ind1)):\n\
>         if mask0[i] and mask1[j]:\n\
>             a[ind0[i],ind1[j]] += b[i,j]";
> 
> static PyObject *
> LLMat_update_add_mask(LLMatObject *self, PyObject *args) {
>   PyObject *bIn, *ind0In, *ind1In, *mask0In, *mask1In;
>   PyArrayObject *b, *ind0, *ind1, *mask0, *mask1;
>   double v;
>   int len0, len1, i, j, i1, j1, ldb;
> 
>   if (self->issym) {
>     PyErr_SetString(SpMatrix_ErrorObject,
>                     "Method not allowed for symmetric matrices");
>     return NULL;
>   }
> 
>   if (!PyArg_ParseTuple(args, "OOOOO",
>                         &bIn, &ind0In, &ind1In, &mask0In, &mask1In))
>     return NULL;
> 
>   b = (PyArrayObject *)PyArray_ContiguousFromObject(bIn, PyArray_DOUBLE, 2, 2);
>   ind0 = (PyArrayObject *)PyArray_ContiguousFromObject(ind0In,PyArray_LONG,1,1);
>   ind1 = (PyArrayObject *)PyArray_ContiguousFromObject(ind1In,PyArray_LONG,1,1);
>   mask0 = (PyArrayObject *)PyArray_ContiguousFromObject(mask0In, PyArray_LONG,
>                                                         1, 1);
>   mask1 = (PyArrayObject *)PyArray_ContiguousFromObject(mask1In, PyArray_LONG,
>                                                         1, 1);
> 
>   if (b==NULL || ind0==NULL || ind1==NULL || mask0==NULL || mask1==NULL)
>     goto fail;
> 
>   len0 = ind0->dimensions[0];
>   len1 = ind1->dimensions[0];
> 
>   /* validate array shapes */
>   if (mask0->dimensions[0] != len0 || mask1->dimensions[0] != len1) {
>     PyErr_SetString(PyExc_ValueError,
>                     "Shapes of index and mask array do not match");
>     goto fail;
>   }
>   if (b->dimensions[0] != len0 || b->dimensions[1] != len1) {
>     PyErr_SetString(PyExc_ValueError,
>                     "Shapes of input matrix and index arrays do not match");
>     goto fail;
>   }
> 
>   /* perform update add operation */
>   ldb = b->dimensions[0];
>   for (i = 0; i < len0; i ++) {
>     if (((long *)mask0->data)[i]) {
> 
>       i1 = ((long *)ind0->data)[i];
>       if (i1 < 0)
>     i1 += self->dim[0];
>       if (i1 < 0 || i1 >= self->dim[0]) {
>     PyErr_SetString(PyExc_IndexError, "element of arg 2 out of range");
>     goto fail;
>       }
> 
>       for (j = 0; j < len1; j ++) {
>     if (((long *)mask1->data)[j]) {
> 
>       j1 = ((long *)ind1->data)[j];
>       if (j1 < 0)
>         j1 += self->dim[1];
>       if (j1 < 0 || j1 >= self->dim[1]) {
>         PyErr_SetString(PyExc_IndexError, "element of arg 3 out of range");
>         goto fail;
>       }
> 
>       v = ((double *)b->data)[i + ldb*j];
>       if (SpMatrix_LLMatUpdateItemAdd(self, i1, j1, v) == -1)
>         goto fail;
>     }
>       }
>     }
>   }
> 
>   Py_DECREF(b);
>   Py_DECREF(ind0);
>   Py_DECREF(ind1);
>   Py_DECREF(mask0);
>   Py_DECREF(mask1);
>   Py_INCREF(Py_None);
>   return Py_None;
> 
>  fail:
>   Py_XDECREF(b);
>   Py_XDECREF(ind0);
>   Py_XDECREF(ind1);
>   Py_XDECREF(mask0);
>   Py_XDECREF(mask1);
>   return NULL;
> }
> 
> static char update_add_mask_sym_doc[] = "A.update_add_mask(b, ind, mask)\n\
> \n\
> Symmetric update of global FEM matrix. Equivalent to:\n\
> \n\
> for i in range(len(ind)):\n\
>     for j in range(len(ind)):\n\
>         if mask[i] and mask[i]:\n\
>             i1 = ind[i]; j1 = ind[j]\n\
>             if i >= j:\n\
>                 a[i1,j1] += b[i,j]\n\
> \n\
> Only operates on the lower triangle of A. Used for symmetric matrices.";
> 
> static PyObject *
> LLMat_update_add_mask_sym(LLMatObject *self, PyObject *args) {
>   PyObject *bIn, *indIn, *maskIn;
>   PyArrayObject *b, *ind, *mask;
>   double v;
>   int len, i, j, i1, j1, ldb;
> 
>   if (!PyArg_ParseTuple(args, "OOO", &bIn, &indIn, &maskIn)) return NULL;
> 
>   b = (PyArrayObject *)PyArray_ContiguousFromObject(bIn, PyArray_DOUBLE, 2, 2);
>   ind = (PyArrayObject *)PyArray_ContiguousFromObject(indIn, PyArray_LONG, 1,1);
>   mask = (PyArrayObject *)PyArray_ContiguousFromObject(maskIn,PyArray_LONG,1,1);
> 
>   if (b == NULL || ind == NULL || mask == NULL) goto fail;
> 
>   len = ind->dimensions[0];
> 
>   /* validate array shapes */
>   if (mask->dimensions[0] != len) {
>     PyErr_SetString(PyExc_ValueError,
>                     "Shapes of index and mask array do not match");
>     goto fail;
>   }
>   if (b->dimensions[0] != len || b->dimensions[1] != len) {
>     PyErr_SetString(PyExc_ValueError,
>                     "Shapes of input matrix and index arrays do not match");
>     goto fail;
>   }
> 
>   /* perform update add operation */
>   ldb = b->dimensions[0];
>   for (i = 0; i < len; i ++) {
>     if (((long *)mask->data)[i]) {
> 
>       i1 = ((long *)ind->data)[i];
>       if (i1 < 0)
>     i1 += self->dim[0];
>       if (i1 < 0 || i1 >= self->dim[0]) {
>     PyErr_SetString(PyExc_IndexError, "element of arg 2 out of range");
>     goto fail;
>       }
> 
>       for (j = 0; j <= i; j ++) {
>     if (((long *)mask->data)[j]) {
> 
>       j1 = ((long *)ind->data)[j]; /* index check not necessary here */
>       if (j1 < 0)
>         j1 += self->dim[1];
>       v = ((double *)b->data)[i + ldb*j];
> 
>       if (self->issym) {
>         /* symmetric matrix: update entry in lower triangle */
>         if (i1 > j1) {
>           if (SpMatrix_LLMatUpdateItemAdd(self, i1, j1, v) == -1)
>         goto fail;
>         } else {
>           if (SpMatrix_LLMatUpdateItemAdd(self, j1, i1, v) == -1)
>         goto fail;
>         }
>       } else {
>         /* non-symmetric matrix: update two entries if not on diagonal */
>         if (SpMatrix_LLMatUpdateItemAdd(self, i1, j1, v) == -1)
>           goto fail;
>         if (i1 != j1) {
>           if (SpMatrix_LLMatUpdateItemAdd(self, j1, i1, v) == -1)
>         goto fail;
>         }
>       }
> 
>     }
>       }
>     }
>   }
> 
>   Py_DECREF(b);
>   Py_DECREF(ind);
>   Py_DECREF(mask);
>   Py_INCREF(Py_None);
>   return Py_None;
> 
>  fail:
>   Py_XDECREF(b);
>   Py_XDECREF(ind);
>   Py_XDECREF(mask);
>   return NULL;
> }
> 
> static char LLMat_take_doc[] = "A.take(b,id1,id2)\n\
> \n\
> for i in range(len(b)):\n\
>     b[i] = A[id1[i],id2[i]]";
> 
> static PyObject *
> LLMat_take(LLMatObject *self, PyObject *args) {
>   PyObject *bIn;
>   PyObject *id1in = NULL;
>   PyObject *id2in = NULL;
>   PyArrayObject *b;
>   PyArrayObject *id1 = NULL;
>   PyArrayObject *id2 = NULL;
>   int lenb,i;
> 
>   if (!PyArg_ParseTuple(args, "O|OO", &bIn,&id1in,&id2in)) return NULL;
> 
>   b = (PyArrayObject *)PyArray_ContiguousFromObject(bIn, PyArray_DOUBLE, 1, 1);
>   if (b == NULL)
>     goto fail;
> 
>   lenb = b->dimensions[0];
> 
>   if (id1in) {
>     id1 = (PyArrayObject *)PyArray_ContiguousFromObject(id1in,PyArray_LONG,1,1);
>     if (id1 == NULL) goto fail;
>   }
> 
>   if (id2in) {
>     id2 = (PyArrayObject *)PyArray_ContiguousFromObject(id2in,PyArray_LONG,1,1);
>     if (id2 == NULL) goto fail;
>   }
> 
>   if (lenb < 0 ) {
>     PyErr_SetString(PyExc_IndexError, "vector b has a negative size");
>     goto fail;
>   }
> 
>   if (id1 && id1->dimensions[0] != lenb ) {
>     PyErr_SetString(PyExc_IndexError, "id1 does not have the same size as b");
>     goto fail;
>   }
> 
>   if (id2 && id2->dimensions[0] != lenb ) {
>     PyErr_SetString(PyExc_IndexError, "id2 does not have the same size as b");
>     goto fail;
>   }
> 
>   /*
>   if (id1 != id2 && self->issym) {
>     PyErr_SetString(SpMatrix_ErrorObject,
>                     "Symmetric matrices require identical sets of indices");
>     goto fail;
>   }
>   */
> 
>   /* Perform take operation */
>   for( i = 0; i < lenb; i++ ) {
>     int i1, j1;
>     if( id1 )
>       i1 = ((long *) id1->data)[i];
>     else
>       i1 = i;
> 
>     if( id2 )
>       j1 = ((long *) id2->data)[i];
>     else
>       j1 = i1;
> 
>     if( i1 > j1 || !self->issym ) /* Get entries as given */
>       ((double *)b->data)[i] = SpMatrix_LLMatGetItem(self, i1, j1);
>     else    /* Symmetric matrix: get entries from lower triangle */
>       ((double *)b->data)[i] = SpMatrix_LLMatGetItem(self, j1, i1);
>   }
> 
>   Py_DECREF(b);
>   if (id1) {
>     Py_DECREF(id1);
>   }
>   if (id2) {
>     Py_DECREF(id2);
>   }
>   Py_INCREF(Py_None);
>   return Py_None;
> 
>  fail:
>   Py_XDECREF(b);
>   if (id1) {
>     Py_XDECREF(id1);
>   }
>   if (id2) {
>     Py_XDECREF(id2);
>   }
>   return NULL;
> }
> 
> static char LLMat_put_doc[] = "a.put(b,id1,id2)\n\
> \n\
> for i in range(len(b)):\n\
>     a[id1[i],id2[i]] = b[i]\n\n\
> If b is a scalar, it has the same effect as the list [b, b, ..., b]\n\
> If id1 is omitted, it is considered to be [1, 2, 3, ...].\n\
> If id2 is omitted, it is considered equal to id1.\n";
> 
> static PyObject *
> LLMat_put(LLMatObject *self, PyObject *args) {
> 
>   // For simplicity, we use iterators to parse Numpy arrays. We could gain in
>   // efficiency by checking whether the array is contiguous or not. If it is,
>   // a simple loop over the elements will be faster than the iterator.
> 
>   PyObject *bIn, *ind;
>   PyObject *id1in = NULL;
>   PyObject *id2in = NULL;
>   //PyArrayObject *b = NULL;
>   //PyArrayObject *id1 = NULL;
>   //PyArrayObject *id2 = NULL;
>   long lenb = 0, lenid1 = 0, lenid2 = 0, i;
>   char b_is_scalar = 0, b_is_list = 0, id1_is_list = 0, id2_is_list = 0;
>   double bval = 0.0;
> 
>   PyObject *iterator0 = NULL, *iterator1 = NULL, *iterator2 = NULL;
> 
>   if (!PyArg_ParseTuple(args, "O|OO", &bIn,&id1in,&id2in))
>     return NULL;
> 
>   // Determine nature of value array b
>   if( PyInt_Check(bIn) ) {                // b is an integer
> 
>     //printf("put: b is an Int\n");
>     bval = (double)PyInt_AsLong(bIn);
>     if( PyErr_Occurred() ) {
>       PyErr_SetString(PyExc_TypeError,
>                       "Could not convert int to double");
>       goto fail;
>     }
>     b_is_scalar = 1;
>     lenb = 1;
> 
>   } else if( PyLong_Check(bIn) ) {        // b in a long int
> 
>     bval = PyLong_AsDouble(bIn);
>     b_is_scalar = 1;
>     lenb = 1;
> 
>   } else if( PyFloat_Check(bIn) ) {       // b is a float
> 
>     //printf("put: b is a Float\n");
>     bval = PyFloat_AsDouble(bIn);
>     b_is_scalar = 1;
>     lenb = 1;
> 
>   } else if( PyList_Check(bIn) ) {        // b is a list
> 
>     //printf("put: b is a list\n");
>     lenb = (long)PyList_Size(bIn);
>     b_is_list = 1;
> 
>   } else if( PyArray_Check(bIn) ) {       // b is an array
> 
>     //printf("put: b is an array\n");
>     if( !PyArray_ISINTEGER(bIn) && !PyArray_ISFLOAT(bIn) ) {
>       PyErr_SetString(PyExc_TypeError,
>                       "Value array must be Int, Long or Float");
>       goto fail;
>     }
>     iterator0 = PyArray_IterNew(bIn);
>     lenb = (long)PyArray_DIM(bIn, 0);
>     PyArray_ITER_RESET(iterator0);
> 
>   } else {
> 
>     PyErr_SetString(PyExc_TypeError,
>                     "Values must be Int, Long, Float, list or Numpy array");
>     goto fail;
>   }
> 
>   if (lenb < 0 ) {
>     PyErr_SetString(PyExc_IndexError, "vector b has a negative size");
>     goto fail;
>   }
> 
>   // Determine nature of first index, if given
>   if (id1in) {
> 
>     if( PyList_Check(id1in) ) {           // id1 is a list
> 
>       //printf("put: id1in is a list\n");
>       lenid1 = (long)PyList_Size(id1in);
>       id1_is_list = 1;
> 
>     } else if( PyArray_Check(id1in) ) {   // id1 is a Numpy array
> 
>       //printf("put: id1in is an array\n");
>       iterator1 = PyArray_IterNew(id1in); // id1 may not be contiguous
>       lenid1 = (long)PyArray_DIM(id1in, 0);
>       PyArray_ITER_RESET(iterator1);
> 
>     } else {
> 
>       PyErr_SetString(PyExc_TypeError,
>                       "First index must be list or Numpy array");
>       goto fail;
>     }
> 
>     if( !b_is_scalar )
>       if( lenid1 != lenb ) {
>         PyErr_SetString(PyExc_IndexError,
>                         "Not as many row indices as values");
>         goto fail;
>       }
> 
>     if( b_is_scalar ) lenb = lenid1;
>   }
> 
>   // Determine nature of second index, if given
>   if( id2in ) {
> 
>     if( PyList_Check(id2in) ) {           // id2 is a list
> 
>       //printf("put: id2in is a list\n");
>       lenid2 = (long)PyList_Size(id2in);
>       id2_is_list = 1;
> 
>     } else if( PyArray_Check(id2in) ) {   // id2 is a Numpy array
> 
>       //printf("put: id2in is an array\n");
>       iterator2 = PyArray_IterNew(id2in); // id2 may not be contiguous
>       lenid2 = (long)PyArray_DIM(id2in, 0);
>       PyArray_ITER_RESET(iterator2);
> 
>     } else {
> 
>       PyErr_SetString(PyExc_TypeError,
>                         "Second index must be list or Numpy array");
>       goto fail;
>     }
> 
>     if( !b_is_scalar ) {
>       if( lenid2 != lenb ) {
>         PyErr_SetString(PyExc_IndexError,
>                         "Not as many column indices as values");
>         goto fail;
>       }
>     }
> 
>     if( id1in ) {
>       if( lenid1 != lenid2 ) {
>         PyErr_SetString(PyExc_IndexError,
>                         "Not as many row indices as column indices");
>         goto fail;
>       }
>     }
> 
>     if( b_is_scalar ) lenb = lenid2;
>   }
> 
>   // Perform put operation
>   for( i = 0; i < lenb; i++ ) {
>     long i1, j1;
> 
>     i1 = i;
>     if( id1in ) {
>       if( id1_is_list ) {
>         ind = PyList_GetItem(id1in, (Py_ssize_t)i);
>         if( PyInt_Check(ind) )
>           i1 = PyInt_AS_LONG(ind);
>         else {
>           PyErr_SetString(PyExc_ValueError, "Invalid list item");
>           return NULL;
>         }
>       } else {
>         i1 = *(long*)PyArray_ITER_DATA(iterator1);
>         PyArray_ITER_NEXT(iterator1);
>       }
>     }
> 
>     j1 = i1;
>     if( id2in ) {
>       if( id2_is_list ) {
>         ind = PyList_GetItem(id2in, (Py_ssize_t)i);
>         if( PyInt_Check(ind) )
>           j1 = PyInt_AS_LONG(ind);
>         else {
>           PyErr_SetString(PyExc_ValueError, "Invalid list item");
>           return NULL;
>         }
>       } else {
>         j1 = *(long*)PyArray_ITER_DATA(iterator2);
>         PyArray_ITER_NEXT(iterator2);
>       }
>     }
> 
>     if( !b_is_scalar ) {
>       if( b_is_list ) {
>         ind = PyList_GetItem(bIn, (Py_ssize_t)i);
>         if( PyInt_Check(ind) )
>           bval = (double)PyInt_AS_LONG(ind);
>         else if( PyFloat_Check(ind) )
>           bval = PyFloat_AsDouble(ind);
>         else {
>           PyErr_SetString(PyExc_ValueError, "Invalid list item");
>           return NULL;
>         }
>       } else {
>         // Convert value to double appropriately
>         if( PyArray_ISINTEGER(bIn) )
>           bval = (double)(*(long*)(PyArray_ITER_DATA(iterator0)));
>         else  // float
>           bval = *(double*)(PyArray_ITER_DATA(iterator0));
>         PyArray_ITER_NEXT(iterator0);
>       }
>     }
> 
>     //printf(" %g  --> (%ld,%ld)\n", bval, i1, j1);
> 
>     if (i1 > j1 || !self->issym) { /* Update entries as given */
>       //printf("mat[%d,%d] <- %g\n", i1, j1, bval);
>       if( SpMatrix_LLMatSetItem(self, i1, j1, bval) == -1 )
>         goto fail;
>     } else { /* Symmetric matrix: update entries in lower triangle */
>       if( SpMatrix_LLMatSetItem(self, j1, i1, bval) == -1 )
>         goto fail;
>     }
>   }
> 
>   /*
>     if( !b_is_scalar ) {
>     Py_DECREF(b);
>     }
>     if (id1) {
>     Py_DECREF(id1);
>     }
>     if (id2) {
>     Py_DECREF(id2);
>     }
>   */
>   Py_XDECREF(iterator0);
>   Py_XDECREF(iterator1);
>   Py_XDECREF(iterator2);
>   Py_INCREF(Py_None);
>   return Py_None;
> 
>  fail:
>   /*
>     if( !b_is_scalar ) {
>     Py_XDECREF(b);
>     }
>     if (id1) {
>     Py_XDECREF(id1);
>     }
>     if (id2) {
>     Py_XDECREF(id2);
>     }
>   */
>   Py_XDECREF(iterator0);
>   Py_XDECREF(iterator1);
>   Py_XDECREF(iterator2);
>   return NULL;
> }
> 
> static char LLMat_delete_rows_doc[] =
> "Delete rows from matrix (inplace). The rows to be deleted are specified by the mask array.\n\
> \n\
> Arguments:\n\
> \n\
>   mask: A 1D integer NumPy array. If mask[i] == 0, then row i is deleted,\n\
>         otherwise row i is kept.\n\
> \n\
> This method may not be applied to a matrix in symmetric format.";
> 
> static PyObject*
> LLMat_delete_rows(LLMatObject *self, PyObject* args){
>   PyArrayObject *maskObj;
>   int newm, newnnz;
>   int act, row;
> 
>   if (!PyArg_ParseTuple(args, "O!", &PyArray_Type, &maskObj))
>     return NULL;
>   if (maskObj->nd != 1 || maskObj->descr->type_num != PyArray_LONG || maskObj->dimensions[0] != self->dim[0]) {
>     PyErr_SetString(PyExc_ValueError, "mask must be a 1D integer NumPy array of appropriate length");
>     return NULL;
>   }
>   if (self->issym) {
>     PyErr_SetString(SpMatrix_ErrorObject, "method not allowed for symmetric matrices");
>     return NULL;
>   }
> 
>   /* Delete the rows to be cancelled by rearranging the row */
>   /* array. After having done so, newdim is the new matrix dim. */
>   newm = 0;
>   newnnz = self->nnz;
>   for(row = 0; row < self->dim[0]; row ++){
>     if (*(int *)(maskObj->data + row*maskObj->strides[0]) != 0){ /* This row has to be kept */
>       self->root[newm] = self->root[row];
>       newm ++;
>     } else {            /* row let out; update free list */
>       act = self->root[row];
>       if(act != -1){        /* only do smth. for non-empty rows */
>     newnnz --;
>     while(self->link[act] != -1) { /* Walk to the end of the list */
>       act = self->link[act];
>       newnnz --;
>     }
>     self->link[act] = self->free;   /* Attach end of row to free list */
>     self->free = self->root[row];   /* Start free list where row began */
>       }
>     }
>   }
> 
>   /* Set the new values */
>   self->dim[0] = newm;
>   self->nnz = newnnz;
> 
>   Py_INCREF(Py_None);
>   return Py_None;
> }
> 
> static char LLMat_delete_cols_doc[] =
> "Delete columns from matrix (inplace). The columns to be deleted are\n\
> specified by the mask array.\n\
> \n\
> Arguments:\n\
> \n\
>   mask: A 1D integer NumPy array. If mask[i] == 0, then column i is deleted,\n\
>         otherwise column i is kept.";
> 
> static PyObject*
> LLMat_delete_cols(LLMatObject *self, PyObject* args){
>   PyArrayObject *maskObj;
>   int newn, newnnz;
>   int act, old, col, row;
>   int *shift;
> 
>   if (!PyArg_ParseTuple(args, "O!", &PyArray_Type, &maskObj))
>     return NULL;
>   if (maskObj->nd != 1 || maskObj->descr->type_num != PyArray_LONG || maskObj->dimensions[0] != self->dim[1]) {
>     PyErr_SetString(PyExc_ValueError,
>                     "mask must be a 1D integer NumPy array of appropriate length");
>     return NULL;
>   }
>   if (self->issym) {
>     PyErr_SetString(SpMatrix_ErrorObject,
>                     "method not allowed for symmetric matrices");
>     return NULL;
>   }
> 
> #define MASK(i) *(long *)(maskObj->data + (i)*maskObj->strides[0])
> 
>   /* Allocate column shift vector (after deletion col[i] is at */
>   /* col[i] - shift[i]). */
>   shift = (int*)malloc((self->dim[1])*sizeof(int));
>   newn = self->dim[1];
>   if (MASK(0)) shift[0] = 0; else {shift[0] = 1; newn --;}
>   for (col = 1; col < self->dim[1]; col++){
>     if (MASK(col))
>       shift[col] = shift[col-1];
>     else
>       {shift[col] = shift[col-1]+1; newn --; }
>   }
> 
>   /* Deleteting columns in the remainig rows */
>   newnnz = self->nnz;
>   for(row = 0; row < self->dim[0]; row ++) {
>     old = -1; act = self->root[row];
>     while (act != -1){
>       if (MASK(self->col[act])) {         // Keep this column
>     self->col[act] -= shift[self->col[act]];
>     old = act; act = self->link[act];
>       } else {                    // Drop the column
>     newnnz--;
>     if (self->root[row] == act) {         // Special case: first row element
>       self->root[row] = self->link[act];
>       old = act; act = self->link[act];
>       self->link[old] = self->free;       // Append element into freelist
>       self->free = old;
>     } else {                  // Regular case: element inbetween
>       act = self->link[act];
>       self->link[self->link[old]] = self->free;
>       self->free = self->link[old];
>       self->link[old] = act;          // Append element into freelist
>     }
>       }
>     }
>   }
> 
>   /* Set the new values */
>   self->dim[1] = newn;
>   self->nnz = newnnz;
> 
>   /* clean up */
>   free(shift);
> 
>   Py_INCREF(Py_None);
>   return Py_None;
> 
> #undef MASK
> }
> 
> static char LLMat_delete_rowcols_doc[] =
> "Delete rows and columns from matrix (inplace). The rows and columns to be deleted are\n\
> specified by the mask array.\n\
> \n\
> Arguments:\n\
> \n\
>   mask: A 1D integer NumPy array. If mask[i] == 0, then row and column i are deleted,\n\
>         otherwise row and column i are kept.";
> 
> static PyObject*
> LLMat_delete_rowcols(LLMatObject *self, PyObject* args){
>   PyArrayObject *maskObj;
>   int newn, newm, newnnz;
>   int act, old, col, row;
>   int *shift;
> 
>   if (!PyArg_ParseTuple(args, "O!", &PyArray_Type, &maskObj))
>     return NULL;
>   if (maskObj->nd != 1 || maskObj->descr->type_num != PyArray_LONG || maskObj->dimensions[0] != self->dim[0]) {
>     PyErr_SetString(PyExc_ValueError, "mask must be a 1D integer NumPy array of appropriate length");
>     return NULL;
>   }
>   if (self->dim[0] != self->dim[1]) {
>     PyErr_SetString(SpMatrix_ErrorObject, "method only allowed for square matrices");
>     return NULL;
>   }
> 
> #define MASK(i) *(long *)(maskObj->data + (i)*maskObj->strides[0])
> 
>   /* Delete the rows to be cancelled by rearranging the row */
>   /* array. After having done so, newdim is the new matrix dim. */
>   newm = 0;
>   newnnz = self->nnz;
>   for(row = 0; row < self->dim[0]; row ++){
>     if (MASK(row)){               // This row has to be kept
>       self->root[newm] = self->root[row];
>       newm ++;
>     } else {                      // row let out; update free list
>       act = self->root[row];
>       if(act != -1){                  // only do sth for non-empty rows
>     newnnz --;
>     while(self->link[act] != -1) {        // Walk to the end of the list
>       act = self->link[act];
>       newnnz --;
>     }
>     self->link[act] = self->free;         // Attach end of row to free list
>     self->free = self->root[row];         // Start free list where row began
>       }
>     }
>   }
> 
>   /* Set the new values */
>   self->dim[0] = newm;
>   self->nnz = newnnz;
> 
>   /* Allocate column shift vector (after deletion col[i] is at */
>   /* col[i] - shift[i]). */
>   shift = (int*)malloc((self->dim[1])*sizeof(int));
>   newn = self->dim[1];
>   if (MASK(0)) shift[0] = 0; else {shift[0] = 1; newn --;}
>   for (col = 1; col < self->dim[1]; col++){
>     if (MASK(col))
>       shift[col] = shift[col-1];
>     else
>       {shift[col] = shift[col-1]+1; newn --; }
>   }
> 
>   /* Deleteting columns in the remainig rows */
>   newnnz = self->nnz;
>   for(row = 0; row < self->dim[0]; row ++) {
>     old = -1; act = self->root[row];
>     while (act != -1){
>       if (MASK(self->col[act])) {          /* Keep this column */
>     self->col[act] -= shift[self->col[act]];
>     old = act; act = self->link[act];
>       } else {                     /* Drop the column */
>     newnnz--;
>     if (self->root[row] == act) {         // Special case: first row element
>       self->root[row] = self->link[act];
>       old = act; act = self->link[act];
>       self->link[old] = self->free;       // Append element into freelist
>       self->free = old;
>     } else {                  // Regular case: element inbetween
>       act = self->link[act];
>       self->link[self->link[old]] = self->free;
>       self->free = self->link[old];
>       self->link[old] = act;          // Append element into freelist
>     }
>       }
>     }
>   }
> 
>   /* Set the new values */
>   self->dim[1] = newn;
>   self->nnz = newnnz;
> 
>   /* clean up */
>   free(shift);
> 
>   Py_INCREF(Py_None);
>   return Py_None;
> 
> #undef MASK
> }
> 
> static char LLMat_Find_Doc[] = "Get LL matrix in coord format (val,irow,jcol).";
> 
> static PyObject *LLMat_Find( LLMatObject *self, PyObject *args ) {
> 
>   /* Convert an LL matrix into coordinate format */
> 
>   PyArrayObject *a_row, *a_col, *a_val; /* Matrix in coordinate format */
>   npy_intp       dmat[1];               /* Dimension descriptor */
>   int           *pi, *pj;             /* Intermediate pointers to matrix data */
>   double        *pv;
>   int            i, k, elem;
> 
>   dmat[0] = (npy_intp)(self->nnz);
> 
>   /* Allocate numarrays */
>   a_row = (PyArrayObject *)PyArray_SimpleNew( 1, dmat, NPY_INT );
>   a_col = (PyArrayObject *)PyArray_SimpleNew( 1, dmat, NPY_INT );
>   a_val = (PyArrayObject *)PyArray_SimpleNew( 1, dmat, NPY_DOUBLE );
> 
>   pi = (int *)a_row->data;
>   pj = (int *)a_col->data;
>   pv = (double *)a_val->data;
> 
>   elem = 0;
>   for( i = 0; i < self->dim[0]; i++ ) {
>     for( k = self->root[i]; k != -1; k = self->link[k] ) {
>       pi[ elem ] = i;
>       pj[ elem ] = self->col[k];
>       pv[ elem ] = self->val[k];
>       elem++;
>     }
>   }
> 
>   /* Descriptor 'N' does not increment reference count */
>   return Py_BuildValue( "NNN",
>                         PyArray_Return( a_val ),
>                         PyArray_Return( a_row ),
>                         PyArray_Return( a_col ) );
> }
> 
> /*********************************/
> /*  O b j e c t   m e t h o d s  */
> /*********************************/
> 
> PyMethodDef LLMat_methods[] = {
>   {"matvec",        (PyCFunction)LLMat_matvec,        METH_VARARGS, LLMat_matvec_doc},
>   {"matvec_transp", (PyCFunction)LLMat_matvec_transp, METH_VARARGS, LLMat_matvec_transp_doc},
>   {"to_csr",        (PyCFunction)LLMat_to_csr,        METH_VARARGS, to_csr_doc},
>   {"to_sss",        (PyCFunction)LLMat_to_sss,        METH_VARARGS, to_sss_doc},
>   {"generalize",    (PyCFunction)LLMat_generalize,    METH_VARARGS, LLMat_generalize_doc},
>   {"compress",      (PyCFunction)LLMat_compress,      METH_VARARGS, LLMat_compress_doc},
>   {"export_mtx",    (PyCFunction)LLMat_export_mtx,    METH_VARARGS, export_mtx_doc},
>   {"copy",          (PyCFunction)LLMat_copy,          METH_VARARGS, copy_doc},
>   {"norm",          (PyCFunction)LLMat_norm,          METH_VARARGS, LLMat_norm_doc},
>   {"shift",         (PyCFunction)LLMat_shift,         METH_VARARGS, shift_doc},
>   {"scale",         (PyCFunction)LLMat_scale,         METH_VARARGS, scale_doc},
>   {"col_scale",     (PyCFunction)LLMat_col_scale,     METH_VARARGS, col_scale_doc},
>   {"row_scale",     (PyCFunction)LLMat_row_scale,     METH_VARARGS, row_scale_doc},
>   {"keys",          (PyCFunction)LLMat_keys,          METH_VARARGS, keys_doc},
>   {"values",        (PyCFunction)LLMat_values,        METH_VARARGS, values_doc},
>   {"items",         (PyCFunction)LLMat_items,         METH_VARARGS, items_doc},
>   {"put",           (PyCFunction)LLMat_put,           METH_VARARGS, LLMat_put_doc},
>   {"take",          (PyCFunction)LLMat_take,          METH_VARARGS, LLMat_take_doc},
>   { "find",         (PyCFunction)LLMat_Find, METH_VARARGS, LLMat_Find_Doc  },
>   {"update_add_mask", (PyCFunction)LLMat_update_add_mask, METH_VARARGS, update_add_mask_doc},
>   {"update_add_mask_sym", (PyCFunction)LLMat_update_add_mask_sym, METH_VARARGS, update_add_mask_sym_doc},
>   {"delete_rows",   (PyCFunction)LLMat_delete_rows,     METH_VARARGS, LLMat_delete_rows_doc},
>   {"delete_cols",   (PyCFunction)LLMat_delete_cols,     METH_VARARGS, LLMat_delete_cols_doc},
>   {"delete_rowcols", (PyCFunction)LLMat_delete_rowcols,  METH_VARARGS, LLMat_delete_rowcols_doc},
>   {"update_add_at", (PyCFunction)LLMat_update_add_at,  METH_VARARGS, update_add_at_doc},
> 
>   {NULL, NULL}          /* sentinel */
> };
> 
> /*****************************************/
> /*  L L M a t   t y p e   m e t h o d s  */
> /*****************************************/
> 
> static void
> LLMatType_dealloc(LLMatObject *a)
> {
>   PyMem_DEL(a->root);
>   PyMem_DEL(a->val);
>   PyMem_DEL(a->col);
>   PyMem_DEL(a->link);
>   PyObject_Del(a);
> }
> 
> static int
> LLMatType_print(LLMatObject *a, FILE *fp, int flags)
> {
>   int i, k, first = 1;
>   char *symStr;
> 
>   if (a->issym)
>     symStr = "symmetric";
>   else
>     symStr = "general";
> 
>   if (a->dim[1] <= PPRINT_COL_THRESH && a->dim[0] <= PPRINT_ROW_THRESH) {
>     double *mat;
>     int j;
>     double val;
>     mat = (double *)malloc(a->dim[0]*a->dim[1] * sizeof(double));
>     if (mat == NULL) {
>       PyErr_NoMemory();
>       return -1;
>     }
>     fprintf(fp, "ll_mat(%s, [%d,%d]):\n", symStr, a->dim[0], a->dim[1]);
>     for (i = 0; i < a->dim[0]; i ++) {
>       for (j = 0; j < a->dim[1]; j ++)
>     mat[i*a->dim[1] + j] = 0.0;
>       k = a->root[i];
>       while (k != -1) {
>     mat[(i*a->dim[1])+a->col[k]] = a->val[k];
>     k = a->link[k];
>       }
>     }
> 
>     for (i = 0; i < a->dim[0]; i ++) {
>       for (j = 0; j < a->dim[1]; j ++) {
>     val = mat[(i*a->dim[1])+j];
>     if (val != 0.0) {
>       int exp = (int)log10(fabs(val));
>       if (abs(exp) <= 4) {
>         if (exp < 0)
>           fprintf(fp, "%9.*f ", 6, val);
>         else
>           fprintf(fp, "%9.*f ", 6-exp, val);
>       } else
>         fprintf(fp, "%9.1e ", val);
>     }
>     else
>       if (!(a->issym) || i > j)
>         fprintf(fp, " -------- ");
>       }
>       fprintf(fp, "\n");
>     }
>     free(mat);
> 
>   } else {
> 
>   if (a->nnz == 0) {
>     fprintf(fp, "ll_mat(%s, [%d,%d])", symStr, a->dim[0], a->dim[1]);
>     return 0;
>   }
>   fprintf(fp, "ll_mat(%s, [%d,%d], [", symStr, a->dim[0], a->dim[1]);
>   for (i = 0; i < a->dim[0]; i ++) {
>     k = a->root[i];
>     while (k != -1) {
>       if (!first)
>     fprintf(fp, ", ");
>       first = 0;
>       fprintf(fp, "(%d,%d): %g", i, a->col[k], a->val[k]);
>       k = a->link[k];
>     }
>   }
>   fprintf(fp, "])");
>   }
>   return 0;
> }
> 
> static PyObject *
> LLMatType_getattr(LLMatObject *self, char *name)
> {
>   if (strcmp(name, "shape") == 0)
>     return Py_BuildValue("(i,i)", self->dim[0], self->dim[1]);
>   if (strcmp(name, "nnz") == 0)
>     return PyInt_FromLong(self->nnz);
>   if (strcmp(name, "issym") == 0)
>     return PyInt_FromLong(self->issym);
>   if (strcmp(name, "storeZeros") == 0)
>     return PyInt_FromLong(self->storeZeros);
> 
>   if (strcmp(name, "__members__") == 0) {
>     char *members[] = {"shape", "nnz", "issym", "storeZeros"};
>     int i;
> 
>     PyObject *list = PyList_New(sizeof(members)/sizeof(char *));
>     if (list != NULL) {
>       for (i = 0; i < sizeof(members)/sizeof(char *); i ++)
>     PyList_SetItem(list, i, PyString_FromString(members[i]));
>       if (PyErr_Occurred()) {
>     Py_DECREF(list);
>     list = NULL;
>       }
>     }
>     return list;
>   }
>   return Py_FindMethod(LLMat_methods, (PyObject *)self, name);
> }
> /***********************************************************************
>  * mapping functions
>  */
> 
> /** LLMat_length - number of items in mapping
>  *    == number of matrix entries
>  */
> static int LLMat_length(LLMatObject *self) {
>   return self->dim[0] * self->dim[1];
> }
> 
> /** LLMat_subscript
>  *    Called when treating array object like a mapping. This is used to
>  *    implement two-dimensional idices, e.g. A[i,j] or A[i1:i2:i3,j1:j2]
>  */
> 
> static PyObject *LLMat_subscript(LLMatObject *self, PyObject *index) {
> 
>   PyObject *index0, *index1, *submatrix;
> 
>   // Check that input is a double index
>   if( !PySequence_Check(index) ) {
>     PyErr_SetString(PyExc_IndexError, "Index must be a sequence");
>     // Py_INCREF(Py_None);
>     // return Py_None;
>     return NULL;
>   }
>   if( PySequence_Length(index) != 2 ) {
>     PyErr_SetString(PyExc_IndexError, "There must be exactly two indices");
>     // Py_INCREF(Py_None);
>     // return Py_None;
>     return NULL;
>   }
> 
>   // Parse first index
>   if( !(index0 = PySequence_GetItem(index, 0)) ) {
>     PyErr_SetString(PyExc_IndexError, "First index is invalid");
>     // Py_INCREF(Py_None);
>     // return Py_None;
>     return NULL;
>   }
> 
>   // Parse second index
>   if( !(index1 = PySequence_GetItem(index, 1)) ) {
>     Py_DECREF(index0);
>     PyErr_SetString(PyExc_IndexError, "Second index is invalid");
>     // Py_INCREF(Py_None);
>     // return Py_None;
>     return NULL;
>   }
> 
>   // Return submatrix
>   submatrix = getSubMatrix_FromList(self, index0, index1);
>   Py_DECREF(index0);
>   Py_DECREF(index1);
>   return submatrix;
> }
> 
> /** LLMat_ass_subscript
>  *    Called when treating array object like a mapping. This is used
>  *    implement two-dimensional indices, e.g. A[::2,1:5]
>  */
> 
> static int
> LLMat_ass_subscript(LLMatObject *self, PyObject *index, PyObject *value ) {
> 
>   PyObject *index0, *index1;
> 
>   // Check that input is a double index
>   if( !PySequence_Check(index) ) {
>     PyErr_SetString(PyExc_IndexError, "Index must be a sequence");
>     return -1;
>   }
>   if( PySequence_Length(index) != 2 ) {
>     PyErr_SetString(PyExc_IndexError, "There must be exactly two indices");
>     return -1;
>   }
> 
>   // Parse first index
>   if( !(index0 = PySequence_GetItem(index, 0)) ) {
>     PyErr_SetString(PyExc_IndexError, "First index is invalid");
>     return -1;
>   }
> 
>   // Parse second index
>   if( !(index1 = PySequence_GetItem(index, 1)) ) {
>     Py_DECREF(index0);
>     PyErr_SetString(PyExc_IndexError, "Second index is invalid");
>     return -1;
>   }
> 
>   // Assign a submatrix
>   //return setSubMatrix_FromList(self, value, index0, index1);
>   setSubMatrix_FromList(self, value, index0, index1);
>   Py_DECREF(index0);
>   Py_DECREF(index1);
>   if( PyErr_Occurred() )
>     return -1;
>   return 0;
> }
> 
> static PyMappingMethods LLMat_as_mapping = {
> #ifdef LENFUNC_OK
>   (lenfunc)LLMat_length,              /*mp_length*/
> #else
>   (inquiry)LLMat_length,          /*mp_length*/
> #endif
>   (binaryfunc)LLMat_subscript,        /*mp_subscript*/
>   (objobjargproc)LLMat_ass_subscript, /*mp_ass_subscript*/
> };
> 
> /*************************************/
> /*  L L M a t T y p e   o b j e c t  */
> /*************************************/
> 
> static PyTypeObject LLMatType = {
>   PyObject_HEAD_INIT(NULL)
>   0,                              /* ob_size */
>   "ll_mat",                       /* tp_name */
>   sizeof(LLMatObject),            /* tp_basicsize */
>   0,                              /* tp_itemsize */
>   (destructor)LLMatType_dealloc,  /* tp_dealloc */
>   (printfunc)LLMatType_print,     /* tp_print */
>   (getattrfunc)LLMatType_getattr, /* tp_getattr */
>   0,                  /* tp_setattr */
>   0,                  /* tp_compare */
>   0,                  /* tp_repr */
>   0,                  /* tp_as_number */
>   0,                  /* tp_as_sequence */
>   &LLMat_as_mapping,          /* tp_as_mapping */
>   0,                  /* tp_hash */
>   0,                              /* tp_call */
>   0,                              /* tp_str */
>   0,                              /* tp_getattro */
>   0,                              /* tp_setattro */
>   0,                              /* tp_as_buffer */
>   Py_TPFLAGS_DEFAULT,             /* tp_flags */
>   "LLMat objects",                /* tp_doc */
> };
> 
> /*************************************************/
> /*  M i s c .   h e l p e r   f u n c t i o n s  */
> /*************************************************/
> 
> static PyObject *
> SpMatrix_NewLLMatObject(int dim[], int sym, int sizeHint, int storeZeros) {
>   int i;
>   LLMatObject *op;
> 
>   if (dim[0] < 0 || dim[1] < 0) {
>     PyErr_SetString(PyExc_ValueError, "matrix dimension must be non-negative");
>     return NULL;
>   }
>   if (sizeHint < 1)
>     sizeHint = 1;
> 
>   /* create new SparseArrayt object */
>   op = PyObject_New(LLMatObject, &LLMatType);
>   if (op == NULL)
>     return PyErr_NoMemory();
> 
>   op->root = NULL;
>   op->val = NULL;
>   op->col = NULL;
>   op->link = NULL;
> 
>   /* allocate ob_val and on_idx arrays */
>   op->root = PyMem_New(int, dim[0]);
>   if (op->root == NULL)
>     goto fail;
>   op->val = PyMem_New(double, sizeHint);
>   if (op->val == NULL)
>     goto fail;
>   op->col = PyMem_New(int, sizeHint);
>   if (op->col == NULL)
>     goto fail;
>   op->link = PyMem_New(int, sizeHint);
>   if (op->link == NULL)
>     goto fail;
> 
>   /* initialize rest of fields */
>   for (i = 0; i < dim[0]; i ++)
>     op->root[i] = -1;
>   op->dim[0] = dim[0];
>   op->dim[1] = dim[1];
>   op->issym = sym;
>   op->storeZeros = storeZeros;
>   op->nnz = 0;
>   op->nalloc = sizeHint;
>   op->free = -1;
> 
>   return (PyObject *) op;
> 
>  fail:
>     PyMem_Del(op->link);
>     PyMem_Del(op->col);
>     PyMem_Del(op->val);
>     PyMem_Del(op->root);
>     PyObject_Del(op);
>     return PyErr_NoMemory();
> }
> 
> static PyObject*
> LLMat_from_mtx(PyObject *module, PyObject *args) {
>   LLMatObject *self = NULL;
>   char *fileName;
>   MM_typecode matcode;
>   int dim[2], nz;
>   FILE *f;
>   int ret, i;
>   double val;
>   int row, col;
>   int storeZeros=0;
> 
>   if (!PyArg_ParseTuple(args, "s", &fileName))
>     return NULL;
> 
>   /* open file */
>   f = fopen(fileName, "r");
>   if (f == NULL)
>     return PyErr_SetFromErrno(PyExc_IOError);
> 
>   /* read MTX header */
>   ret = mm_read_banner(f, matcode);
>   if (ret != 0) {
>     PyErr_SetString(PyExc_IOError, "error reading MTX file header");
>     goto fail;
>   }
>   if (!(mm_is_real(matcode) && mm_is_matrix(matcode) &&
>     mm_is_sparse(matcode))) {
>     PyErr_SetString(SpMatrix_ErrorObject, "must be real, sparse matrix");
>     goto fail;
>   }
>   ret = mm_read_mtx_crd_size(f, dim, dim+1, &nz);
>   if (ret != 0) {
>     PyErr_SetString(PyExc_IOError, "error reading MTX file size information");
>     goto fail;
>   }
> 
>   /* allocate matrix object */
>   self = (LLMatObject *)SpMatrix_NewLLMatObject(dim, mm_is_symmetric(matcode), nz, storeZeros);
>   if (self == NULL)
>     goto fail;
> 
>   for (i = 0; i < nz; i ++) {
>     ret = fscanf(f, "%d %d %lg\n", &row, &col, &val);
>     if (ret != 3) {
>       PyErr_SetString(PyExc_IOError, "error reading MTX file data");
>       goto fail;
>     }
>     row --; col --;
>     if (!(0 <= row && row < dim[0] && 0 <= col && col < dim[1])) {
>       PyErr_SetString(PyExc_IndexError, //SpMatrix_ErrorObject,
>                       "matrix indices out of range");
>       fclose(f);
>       return NULL;
>     }
>     ret = SpMatrix_LLMatSetItem(self, row, col, val);
>     if (ret)
>       goto fail;
>   }
>   fclose(f);
>   return (PyObject *)self;
> 
>  fail:
>   fclose(f);
>   Py_XDECREF(self);
>   return NULL;
> }
> 
> char LLMat_matrixmultiply_doc[] = "matrixmultiply(A, B)\n\
> \n\
> Returns a new ll_mat object representing the matrix A*B";
> 
> static PyObject *
> LLMat_matrixmultiply(PyObject *self, PyObject *args)
> {
>   int sizeHint = 1000;
>   int storeZeros = 0;
>   LLMatObject *matA, *matB, *matC;
>   int dimC[2];
>   int symCode, ret;
> 
>   if (!PyArg_ParseTuple(args, "O!O!", &LLMatType, &matA, &LLMatType, &matB))
>     return NULL;
> 
>   /* matrix dimensions
>    */
>   dimC[0] = matA->dim[0];
>   dimC[1] = matB->dim[1];
> 
>   if (matA->dim[1] != matB->dim[0]) {
>     PyErr_SetString(PyExc_ValueError, "matrix dimensions must agree");
>     return NULL;
>   }
> 
>   if ((matA->storeZeros == 1) && (matB->storeZeros == 1))
>     storeZeros = 1;
> 
>   /* create result object
>    */
>   matC = (LLMatObject *)SpMatrix_NewLLMatObject(dimC, 0, sizeHint, storeZeros);
>   if (matC == NULL)
>     return NULL;
> 
>   symCode = matB->issym << 1 | matA->issym;
>   if (symCode == 0) {
>     /* unsym-unsym multiplication
>      */
> 
> #if !OPT_MATMATMUL
>     double valA;
>     int iA, jA, kA, kB;
> 
>     for (iA = 0; iA < matA->dim[0]; iA ++) {
>       kA = matA->root[iA];
>       while (kA != -1) {
>     valA = matA->val[kA];
>     jA = matA->col[kA];
>     kA = matA->link[kA];
> 
>     /* add jA-th row of B to iA-th row of C */
>     kB = matB->root[jA];
>     while (kB != -1) {
>       ret = SpMatrix_LLMatUpdateItemAdd(matC, iA, matB->col[kB], valA*matB->val[kB]);
>       if (ret == -1)
>         goto fail;
>       kB = matB->link[kB];
>     }
>       }
> 
>     }
> #else
>     int *tmpage = NULL;
>     int *tmpind = NULL;
>     int *tmpcol = NULL;
>     double *tmpval = NULL;
>     int tmpsize;
>     int nxttmp;
>     int row;
>     int indA, colA, colB, dummy, indB;
>     double valA;
> 
>     tmpsize = 5; nxttmp = -1;
>     tmpage = (int*)malloc(matB->dim[1] * sizeof(int));
>     tmpind = (int*)malloc(matB->dim[1] * sizeof(int));
>     tmpcol = (int*)malloc(tmpsize * sizeof(int));
>     tmpval = (double*)malloc(tmpsize * sizeof(double));
>     if (tmpage == NULL || tmpind == NULL || tmpcol == NULL ||tmpval == NULL) {
>       PyErr_NoMemory();
>       goto fail_unsym_unsym;
>     }
> 
>     /* main loop */
> 
>     for(row=0; row < matB->dim[1]; row++){ tmpage[row] = -1;}
> 
>     /* Go through each row of A and perform necessary computations */
>     for(row=0; row < matA->dim[0]; row++) {
>       indA = matA->root[row];         // Pick first entry of A[row,:]
>       while(indA != -1){       // As long as there is an element in A[row,:] ...
>     colA = matA->col[indA];       // ... get its column number ...
>     valA = matA->val[indA];       // ... and value ...
> 
>     indB = matB->root[colA];       // colA is equivalent to rowB!
>     while(indB != -1){
>       colB = matB->col[indB];
> 
>       if(tmpage[colB] != row){         // This column never appeared so far
>         nxttmp++;
>         tmpage[colB]  = row;
>         tmpind[colB]  = nxttmp;
> 
>         if(nxttmp >= tmpsize){          // If tmp storage too small, realloc
>           tmpsize = (int)((tmpsize*12)/10)+1;
>           tmpcol = (int*)realloc(tmpcol, tmpsize * sizeof(int));
>           tmpval = (double*)realloc(tmpval, tmpsize * sizeof(double));
>           if (tmpcol == NULL ||tmpval == NULL) {
>         PyErr_NoMemory();
>         goto fail_unsym_unsym;
>           }
>         }
> 
>         tmpcol[nxttmp] = colB;
>         tmpval[nxttmp] = valA * matB->val[indB];
>       }else{                   // This column appeared at least once already
>         dummy = tmpind[colB];
>         tmpval[dummy] += valA * matB->val[indB];
>       }
> 
>       indB = matB->link[indB];
>     }
>     indA = matA->link[indA];
>       }
> 
>       /* All the new values for rowC = rowA have now to be filled in */
>       /* into the matrix C */
>       for(dummy=0; dummy<=nxttmp; dummy++) {
>     if (SpMatrix_LLMatSetItem(matC,row,tmpcol[dummy],tmpval[dummy]))
>       goto fail_unsym_unsym;
>       }
> 
>       nxttmp=-1; /* For the next row of A we need a "fresh" tmp storage */
>     }
>     /* Get the memory back ... */
>     free(tmpage);
>     free(tmpind);
>     free(tmpcol);
>     free(tmpval);
>     return (PyObject *)matC;
> 
>   fail_unsym_unsym:
>     free(tmpage);
>     free(tmpind);
>     free(tmpcol);
>     free(tmpval);
>     goto fail;
> #endif
> 
>   } else if (symCode == 1) {
> 
>     /* sym-unsym multiplication
>      */
>     double valA;
>     int iA, jA, kA, kB;
> 
>     for (iA = 0; iA < matA->dim[0]; iA ++) {
>       kA = matA->root[iA];
>       while (kA != -1) {
>     valA = matA->val[kA];
>     jA = matA->col[kA];
>     kA = matA->link[kA];
> 
>     /* add jA-th row of B to iA-th row of C */
>     kB = matB->root[jA];
>     while (kB != -1) {
>       ret = SpMatrix_LLMatUpdateItemAdd(matC, iA, matB->col[kB], valA*matB->val[kB]);
>       if (ret == -1)
>         goto fail;
>       kB = matB->link[kB];
>     }
> 
>     if (iA == jA)
>       continue;
> 
>     /* add iA-th row of B to jA-th row of C */
>     kB = matB->root[iA];
>     while (kB != -1) {
>       ret = SpMatrix_LLMatUpdateItemAdd(matC, jA, matB->col[kB], valA*matB->val[kB]);
>       if (ret == -1)
>         goto fail;
>       kB = matB->link[kB];
>     }
>       }
>     }
> 
>   } else if (symCode == 2) {
> 
>     /* unsym-sym multiplication
>      */
> 
>     PyErr_SetString(PyExc_NotImplementedError, "multiply of an unsymmetric and a symmetric matrix not supported");
>     goto fail;
> 
>   } else {
> 
>     /* sym-sym multiplication
>      */
> 
>     PyErr_SetString(PyExc_NotImplementedError, "multiply of two symmetric matrices not supported");
>     goto fail;
> 
>   }
> 
>   return (PyObject *)matC;
> 
>  fail:
>   Py_DECREF(matC);
>   return NULL;
> }
> 
> static char LLMat_dot_doc[] = "dot(A, B)\n\
> \n\
> Returns a new ll_mat object representing the matrix transpose(A)*B";
> 
> static PyObject *LLMat_dot(PyObject *self, PyObject *args) {
> 
>   int sizeHint = 1000;
>   int storeZeros = 1;
>   LLMatObject *matA, *matB, *matC;
>   int dimC[2];
>   double valA;
>   int iA, kA, iC, kB, ret;
> 
>   if (!PyArg_ParseTuple(args, "O!O!", &LLMatType, &matA, &LLMatType, &matB))
>     return NULL;
> 
>   dimC[0] = matA->dim[1];
>   dimC[1] = matB->dim[1];
> 
>   if (matA->dim[0] != matB->dim[0]) {
>     PyErr_SetString(PyExc_ValueError, "matrix dimensions must agree");
>     return NULL;
>   }
> 
>   if (matA->issym || matB->issym) {
>     PyErr_SetString(PyExc_NotImplementedError,
>                     "ddot operation with symmetric matrices not supported");
>     return NULL;
>   }
> 
>   if ((matA->storeZeros == 1) && (matB->storeZeros == 1))
>     storeZeros = 1;
> 
>   matC = (LLMatObject *)SpMatrix_NewLLMatObject(dimC, 0, sizeHint, storeZeros);
>   if (matC == NULL)
>     return NULL;
> 
>   for( iA = 0; iA < matA->dim[0]; iA++ ) {
>     for( kA = matA->root[iA]; kA != -1; kA = matA->link[kA] ) {
>       valA = matA->val[kA];
>       iC = matA->col[kA];
>       for( kB = matB->root[iA]; kB != -1; kB = matB->link[kB] ) {
>     ret = SpMatrix_LLMatUpdateItemAdd(matC, iC, matB->col[kB],
>                                           valA*matB->val[kB]);
>     if (ret == -1) goto fail;
>       }
>     }
>   }
>   return (PyObject *)matC;
> 
>  fail:
>   Py_DECREF(matC);
>   return NULL;
> }
> 
> static char LLMat_symdot_doc[] = "symdot(A) or symdot(A,d)\n\
> \n\
> Returns a new symmetric ll_mat object representing the matrix transpose(A)*A\n\
> If the numpy array d is specified, returns a new symmetric ll_mat object\n\
> representing the matrix transpose(A)*D*A, where D=diag(d).";
> 
> static PyObject *LLMat_symdot(PyObject *self, PyObject *args) {
> 
>   int sizeHint = 1000;
>   int storeZeros = 1;
>   PyObject *DIn = NULL;
>   PyArrayObject *D = NULL;
>   LLMatObject *matA, *matC;
>   int dimC[2];
>   double valA;
>   int iA, kA, iC, kA2, ret;
> 
>   if (!PyArg_ParseTuple(args, "O!|O", &LLMatType, &matA, &DIn))
>       return NULL;
> 
>   if (DIn != NULL) {
>     D = (PyArrayObject *)PyArray_ContiguousFromObject(DIn,PyArray_DOUBLE,1,1);
>       if( D == NULL ) {
>         PyErr_SetString(SpMatrix_ErrorObject,
>                         "Could not read scaling vector.");
>         return NULL;
>       }
> 
>       // Check for dimensions mismatch.
>       if( D->dimensions[0] != matA->dim[0] ) {
>         PyErr_SetString(SpMatrix_ErrorObject,
>                         "Scaling vector has wrong dimension.");
>         return NULL;
>       }
>   }
> 
>   dimC[0] = matA->dim[1];
>   dimC[1] = matA->dim[1];
> 
>   if (matA->issym) {
>     PyErr_SetString(PyExc_NotImplementedError,
>                     "symdot operation with symmetric matrices not supported");
>     return NULL;
>   }
> 
>   storeZeros = (matA->storeZeros == 1);
> 
>   matC = (LLMatObject *)SpMatrix_NewLLMatObject(dimC, 1, sizeHint, storeZeros);
>   if (matC == NULL)
>     return NULL;
> 
>   for( iA = 0; iA < matA->dim[0]; iA++ ) {
>     for( kA = matA->root[iA]; kA != -1; kA = matA->link[kA] ) {
>       valA = matA->val[kA];
>       if (D != NULL) // Apply scaling.
>         valA *= ((double *)D->data)[iA];
>       iC = matA->col[kA];
>       for( kA2 = matA->root[iA]; kA2 != -1; kA2 = matA->link[kA2] )
>         if (iC >= matA->col[kA2]) {
>             ret = SpMatrix_LLMatUpdateItemAdd(matC, iC, matA->col[kA2],
>                                               valA*matA->val[kA2]);
>             if (ret == -1) goto fail;
>         }
>     }
>   }
>   return (PyObject *)matC;
> 
>  fail:
>   Py_DECREF(matC);
>   return NULL;
> }
> 
> /* For backward compatibility. This is still called by sss_mat. */
> 
> static int
> LLMat_parse_index(PyObject *op, int dim[],
>           int *start0, int *stop0, int *step0, int *len0,
>           int *start1, int *stop1, int *step1, int *len1) {
> 
> 
>   PyErr_SetString(PyExc_IndexError, "Not yet transitioned to fancy indexing for SSS matrices");
>   return -1;
> }
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/sparse/src/mmio_patched.c pysparse/pysparse/sparse/src/mmio_patched.c
0a1,498
> /* 
> *   Matrix Market I/O library for ANSI C
> *
> *   See http://math.nist.gov/MatrixMarket for details.
> *
> *
> */
> 
> 
> #include <stdio.h>
> #include <string.h>
> #include <stdlib.h>
> #include <ctype.h>
> 
> #include "mmio.h"
> 
> int mm_read_unsymmetric_sparse(const char *fname, int *M_, int *N_, int *nz_,
>                 double **val_, int **I_, int **J_)
> {
>     FILE *f;
>     MM_typecode matcode;
>     int M, N, nz;
>     int i;
>     double *val;
>     int *I, *J;
>  
>     if ((f = fopen(fname, "r")) == NULL)
>             return -1;
>  
>  
>     if (mm_read_banner(f, matcode) != 0)
>     {
>         printf("mm_read_unsymetric: Could not process Matrix Market banner ");
>         printf(" in file [%s]\n", fname);
>         return -1;
>     }
>  
>  
>  
>     if ( !(mm_is_real(matcode) && mm_is_matrix(matcode) &&
>             mm_is_sparse(matcode)))
>     {
>         fprintf(stderr, "Sorry, this application does not support ");
>         fprintf(stderr, "Market Market type: [%s]\n",
>                 mm_typecode_to_str(matcode));
>         return -1;
>     }
>  
>     /* find out size of sparse matrix: M, N, nz .... */
>  
>     if (mm_read_mtx_crd_size(f, &M, &N, &nz) !=0)
>     {
>         fprintf(stderr, "read_unsymmetric_sparse(): could not parse matrix size.\n");
>         return -1;
>     }
>  
>     *M_ = M;
>     *N_ = N;
>     *nz_ = nz;
>  
>     /* reseve memory for matrices */
>  
>     I = (int *) malloc(nz * sizeof(int));
>     J = (int *) malloc(nz * sizeof(int));
>     val = (double *) malloc(nz * sizeof(double));
>  
>     *val_ = val;
>     *I_ = I;
>     *J_ = J;
>  
>     /* NOTE: when reading in doubles, ANSI C requires the use of the "l"  */
>     /*   specifier as in "%lg", "%lf", "%le", otherwise errors will occur */
>     /*  (ANSI C X3.159-1989, Sec. 4.9.6.2, p. 136 lines 13-15)            */
>  
>     for (i=0; i<nz; i++)
>     {
>         fscanf(f, "%d %d %lg\n", &I[i], &J[i], &val[i]);
>         I[i]--;  /* adjust from 1-based to 0-based */
>         J[i]--;
>     }
>     fclose(f);
>  
>     return 0;
> }
> 
> int mm_is_valid(MM_typecode matcode)
> {
>     if (!mm_is_matrix(matcode)) return 0;
>     if (mm_is_dense(matcode) && mm_is_pattern(matcode)) return 0;
>     if (mm_is_real(matcode) && mm_is_hermitian(matcode)) return 0;
>     if (mm_is_pattern(matcode) && (mm_is_hermitian(matcode) || 
>                 mm_is_skew(matcode))) return 0;
>     return 1;
> }
> 
> int mm_read_banner(FILE *f, MM_typecode matcode)
> {
>     char line[MM_MAX_LINE_LENGTH];
>     char banner[MM_MAX_TOKEN_LENGTH];
>     char mtx[MM_MAX_TOKEN_LENGTH]; 
>     char crd[MM_MAX_TOKEN_LENGTH];
>     char data_type[MM_MAX_TOKEN_LENGTH];
>     char storage_scheme[MM_MAX_TOKEN_LENGTH];
>     char *p;
> 
> 
>     mm_clear_typecode(matcode);  
> 
>     if (fgets(line, MM_MAX_LINE_LENGTH, f) == NULL) 
>         return MM_PREMATURE_EOF;
> 
>     if (sscanf(line, "%s %s %s %s %s", banner, mtx, crd, data_type, 
>         storage_scheme) != 5)
>         return MM_PREMATURE_EOF;
> 
>     for (p=mtx; *p!='\0'; *p=tolower(*p),p++);  /* convert to lower case */
>     for (p=crd; *p!='\0'; *p=tolower(*p),p++);  
>     for (p=data_type; *p!='\0'; *p=tolower(*p),p++);
>     for (p=storage_scheme; *p!='\0'; *p=tolower(*p),p++);
> 
>     /* check for banner */
>     if (strncmp(banner, MatrixMarketBanner, strlen(MatrixMarketBanner)) != 0)
>         return MM_NO_HEADER;
> 
>     /* first field should be "mtx" */
>     if (strcmp(mtx, MM_MTX_STR) != 0)
>         return  MM_UNSUPPORTED_TYPE;
>     mm_set_matrix(matcode);
> 
> 
>     /* second field describes whether this is a sparse matrix (in coordinate
>             storgae) or a dense array */
> 
> 
>     if (strcmp(crd, MM_SPARSE_STR) == 0)
>         mm_set_sparse(matcode);
>     else
>     if (strcmp(crd, MM_DENSE_STR) == 0)
>             mm_set_dense(matcode);
>     else
>         return MM_UNSUPPORTED_TYPE;
>     
> 
>     /* third field */
> 
>     if (strcmp(data_type, MM_REAL_STR) == 0)
>         mm_set_real(matcode);
>     else
>     if (strcmp(data_type, MM_COMPLEX_STR) == 0)
>         mm_set_complex(matcode);
>     else
>     if (strcmp(data_type, MM_PATTERN_STR) == 0)
>         mm_set_pattern(matcode);
>     else
>     if (strcmp(data_type, MM_INT_STR) == 0)
>         mm_set_integer(matcode);
>     else
>         return MM_UNSUPPORTED_TYPE;
>     
> 
>     /* fourth field */
> 
>     if (strcmp(storage_scheme, MM_GENERAL_STR) == 0)
>         mm_set_general(matcode);
>     else
>     if (strcmp(storage_scheme, MM_SYMM_STR) == 0)
>         mm_set_symmetric(matcode);
>     else
>     if (strcmp(storage_scheme, MM_HERM_STR) == 0)
>         mm_set_hermitian(matcode);
>     else
>     if (strcmp(storage_scheme, MM_SKEW_STR) == 0)
>         mm_set_skew(matcode);
>     else
>         return MM_UNSUPPORTED_TYPE;
>         
> 
>     return 0;
> }
> 
> int mm_write_mtx_crd_size(FILE *f, int M, int N, int nz)
> {
>     if (fprintf(f, "%d %d %d\n", M, N, nz) < 0)
>         return MM_COULD_NOT_WRITE_FILE;
>     else 
>         return 0;
> }
> 
> int mm_read_mtx_crd_size(FILE *f, int *M, int *N, int *nz )
> {
>     char line[MM_MAX_LINE_LENGTH];
>     int num_items_read;
> 
>     /* set return null parameter values, in case we exit with errors */
>     *M = *N = *nz = 0;
> 
>     /* now continue scanning until you reach the end-of-comments */
>     do 
>     {
>         if (fgets(line,MM_MAX_LINE_LENGTH,f) == NULL) 
>             return MM_PREMATURE_EOF;
>     }while (line[0] == '%');
> 
>     /* line[] is either blank or has M,N, nz */
>     if (sscanf(line, "%d %d %d", M, N, nz) == 3)
>         return 0;
>         
>     else
>     do
>     { 
>         num_items_read = fscanf(f, "%d %d %d", M, N, nz); 
>         if (num_items_read == EOF) return MM_PREMATURE_EOF;
>     }
>     while (num_items_read != 3);
> 
>     return 0;
> }
> 
> 
> int mm_read_mtx_array_size(FILE *f, int *M, int *N)
> {
>     char line[MM_MAX_LINE_LENGTH];
>     int num_items_read;
>     /* set return null parameter values, in case we exit with errors */
>     *M = *N = 0;
> 	
>     /* now continue scanning until you reach the end-of-comments */
>     do 
>     {
>         if (fgets(line,MM_MAX_LINE_LENGTH,f) == NULL) 
>             return MM_PREMATURE_EOF;
>     }while (line[0] == '%');
> 
>     /* line[] is either blank or has M,N, nz */
>     if (sscanf(line, "%d %d", M, N) == 2)
>         return 0;
>         
>     else /* we have a blank line */
>     do
>     { 
>         num_items_read = fscanf(f, "%d %d", M, N); 
>         if (num_items_read == EOF) return MM_PREMATURE_EOF;
>     }
>     while (num_items_read != 2);
> 
>     return 0;
> }
> 
> int mm_write_mtx_array_size(FILE *f, int M, int N)
> {
>     if (fprintf(f, "%d %d\n", M, N) < 0)
>         return MM_COULD_NOT_WRITE_FILE;
>     else 
>         return 0;
> }
> 
> 
> 
> /*-------------------------------------------------------------------------*/
> 
> /******************************************************************/
> /* use when I[], J[], and val[]J, and val[] are already allocated */
> /******************************************************************/
> 
> int mm_read_mtx_crd_data(FILE *f, int M, int N, int nz, int I[], int J[],
>         double val[], MM_typecode matcode)
> {
>     int i;
>     if (mm_is_complex(matcode))
>     {
>         for (i=0; i<nz; i++)
>             if (fscanf(f, "%d %d %lg %lg", &I[i], &J[i], &val[2*i], &val[2*i+1])
>                 != 4) return MM_PREMATURE_EOF;
>     }
>     else if (mm_is_real(matcode))
>     {
>         for (i=0; i<nz; i++)
>         {
>             if (fscanf(f, "%d %d %lg\n", &I[i], &J[i], &val[i])
>                 != 3) return MM_PREMATURE_EOF;
> 
>         }
>     }
> 
>     else if (mm_is_pattern(matcode))
>     {
>         for (i=0; i<nz; i++)
>             if (fscanf(f, "%d %d", &I[i], &J[i])
>                 != 2) return MM_PREMATURE_EOF;
>     }
>     else
>         return MM_UNSUPPORTED_TYPE;
> 
>     return 0;
>         
> }
> 
> int mm_read_mtx_crd_entry(FILE *f, int *I, int *J,
>         double *real, double *imag, MM_typecode matcode)
> {
>     if (mm_is_complex(matcode))
>     {
>             if (fscanf(f, "%d %d %lg %lg", I, J, real, imag)
>                 != 4) return MM_PREMATURE_EOF;
>     }
>     else if (mm_is_real(matcode))
>     {
>             if (fscanf(f, "%d %d %lg\n", I, J, real)
>                 != 3) return MM_PREMATURE_EOF;
> 
>     }
> 
>     else if (mm_is_pattern(matcode))
>     {
>             if (fscanf(f, "%d %d", I, J) != 2) return MM_PREMATURE_EOF;
>     }
>     else
>         return MM_UNSUPPORTED_TYPE;
> 
>     return 0;
>         
> }
> 
> 
> /************************************************************************
>     mm_read_mtx_crd()  fills M, N, nz, array of values, and return
>                         type code, e.g. 'MCRS'
> 
>                         if matrix is complex, values[] is of size 2*nz,
>                             (nz pairs of real/imaginary values)
> ************************************************************************/
> 
> int mm_read_mtx_crd(char *fname, int *M, int *N, int *nz, int **I, int **J, 
>         double **val, MM_typecode matcode)
> {
>     int ret_code;
>     FILE *f;
> 
>     if (strcmp(fname, "stdin") == 0) f=stdin;
>     else
>     if ((f = fopen(fname, "r")) == NULL)
>         return MM_COULD_NOT_READ_FILE;
> 
> 
>     if ((ret_code = mm_read_banner(f, matcode)) != 0)
>         return ret_code;
> 
>     if (!(mm_is_valid(matcode) && mm_is_sparse(matcode) && 
>             mm_is_matrix(matcode)))
>         return MM_UNSUPPORTED_TYPE;
> 
>     if ((ret_code = mm_read_mtx_crd_size(f, M, N, nz)) != 0)
>         return ret_code;
> 
> 
>     *I = (int *)  malloc(*nz * sizeof(int));
>     *J = (int *)  malloc(*nz * sizeof(int));
>     *val = NULL;
> 
>     if (mm_is_complex(matcode))
>     {
>         *val = (double *) malloc(*nz * 2 * sizeof(double));
>         ret_code = mm_read_mtx_crd_data(f, *M, *N, *nz, *I, *J, *val, 
>                 matcode);
>         if (ret_code != 0) return ret_code;
>     }
>     else if (mm_is_real(matcode))
>     {
>         *val = (double *) malloc(*nz * sizeof(double));
>         ret_code = mm_read_mtx_crd_data(f, *M, *N, *nz, *I, *J, *val, 
>                 matcode);
>         if (ret_code != 0) return ret_code;
>     }
> 
>     else if (mm_is_pattern(matcode))
>     {
>         ret_code = mm_read_mtx_crd_data(f, *M, *N, *nz, *I, *J, *val, 
>                 matcode);
>         if (ret_code != 0) return ret_code;
>     }
> 
>     if (f != stdin) fclose(f);
>     return 0;
> }
> 
> int mm_write_banner(FILE *f, MM_typecode matcode)
> {
>     char *str = mm_typecode_to_str(matcode);
>     int ret_code;
> 
>     ret_code = fprintf(f, "%s %s\n", MatrixMarketBanner, str);
>     free(str);
>     if (ret_code < 0)
>         return MM_COULD_NOT_WRITE_FILE;
>     else
>         return 0;
> }
> 
> int mm_write_mtx_crd(char fname[], int M, int N, int nz, int I[], int J[],
>         double val[], MM_typecode matcode)
> {
>     FILE *f;
>     int i;
> 
>     if (strcmp(fname, "stdout") == 0) 
>         f = stdout;
>     else
>     if ((f = fopen(fname, "w")) == NULL)
>         return MM_COULD_NOT_WRITE_FILE;
>     
>     /* print banner followed by typecode */
>     fprintf(f, "%s ", MatrixMarketBanner);
>     fprintf(f, "%s\n", mm_typecode_to_str(matcode));
> 
>     /* print matrix sizes and nonzeros */
>     fprintf(f, "%d %d %d\n", M, N, nz);
> 
>     /* print values */
>     if (mm_is_pattern(matcode))
>         for (i=0; i<nz; i++)
>             fprintf(f, "%d %d\n", I[i], J[i]);
>     else
>     if (mm_is_real(matcode))
>         for (i=0; i<nz; i++)
>             fprintf(f, "%d %d %20.16g\n", I[i], J[i], val[i]);
>     else
>     if (mm_is_complex(matcode))
>         for (i=0; i<nz; i++)
>             fprintf(f, "%d %d %20.16g %20.16g\n", I[i], J[i], val[2*i], 
>                         val[2*i+1]);
>     else
>     {
>         if (f != stdout) fclose(f);
>         return MM_UNSUPPORTED_TYPE;
>     }
> 
>     if (f !=stdout) fclose(f);
> 
>     return 0;
> }
>     
> 
> char  *mm_typecode_to_str(MM_typecode matcode)
> {
>     char buffer[MM_MAX_LINE_LENGTH];
>     char *types[4];
>     int error =0;
> 
>     /* check for MTX type */
>     if (mm_is_matrix(matcode)) 
>         types[0] = MM_MTX_STR;
>     else
>         error=1;
> 
>     /* check for CRD or ARR matrix */
>     if (mm_is_sparse(matcode))
>         types[1] = MM_SPARSE_STR;
>     else
>     if (mm_is_dense(matcode))
>         types[1] = MM_DENSE_STR;
>     else
>         return NULL;
> 
>     /* check for element data type */
>     if (mm_is_real(matcode))
>         types[2] = MM_REAL_STR;
>     else
>     if (mm_is_complex(matcode))
>         types[2] = MM_COMPLEX_STR;
>     else
>     if (mm_is_pattern(matcode))
>         types[2] = MM_PATTERN_STR;
>     else
>     if (mm_is_integer(matcode))
>         types[2] = MM_INT_STR;
>     else
>         return NULL;
> 
> 
>     /* check for symmetry type */
>     if (mm_is_general(matcode))
>         types[3] = MM_GENERAL_STR;
>     else
>     if (mm_is_symmetric(matcode))
>         types[3] = MM_SYMM_STR;
>     else 
>     if (mm_is_hermitian(matcode))
>         types[3] = MM_HERM_STR;
>     else 
>     if (mm_is_skew(matcode))
>         types[3] = MM_SKEW_STR;
>     else
>         return NULL;
> 
>     sprintf(buffer,"%s %s %s %s", types[0], types[1], types[2], types[3]);
>     return strdup(buffer);
> 
> }
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/sparse/src/sss_mat.c pysparse/pysparse/sparse/src/sss_mat.c
0a1,284
> #include "Python.h"
> 
> #define SPMATRIX_MODULE
> #include "spmatrix.h"
> 
> #define PY_ARRAY_UNIQUE_SYMBOL spmatrix
> 
> #include "numpy/arrayobject.h"
> #include "numpy/noprefix.h"
> 
> /** getitem
>  *
>  */
> static PyObject *
> getitem(SSSMatObject *self, int i, int j) {
>   int k, t;
> 
>   if (i == j)
>     return PyFloat_FromDouble(self->diag[i]);
>   if (i < j) {
>     t = i; i = j; j = t;
>   }
>   for (k = self->ind[i]; k < self->ind[i+1]; k ++) {
>     if (self->col[k] == j)
>       return PyFloat_FromDouble(self->val[k]);
>   }
>   return PyFloat_FromDouble(0.0);
> }
> 
> /*********************************************************************** 
>  * SSSMatObject methods
>  */
> 
> static char SSSMat_matvec_doc[] = "a.matvec(x, y)\n\
> \n\
> compute the sparse matrix-vector product y := a * x. \n\
> a is a d1 by d2 sparse matrix.\n\
> x and y are two 1-dimensional Numeric arrays of appropriate size.";
> 
> void sss_matvec(int n, double *x, double *y,
> 		double *va, double *da, int *ja, int *ia) {
>   double s, v, xi;
>   int i, j, k;
>  
>   for (i = 0; i < n; i ++) {
>     xi = x[i];
>     s = 0.0;
>     for (k = ia[i]; k < ia[i+1]; k ++) {
>       j = ja[k];
>       v = va[k];
>       s += v * x[j];
>       y[j] += v * xi;
>     }
>     y[i] = s + da[i]*xi;
>   }
> }
> 
> void sss_matvec_stride(int n, 
> 		       double *x, int incx, 
> 		       double *y, int incy,
> 		       double *va, double *da, int *ja, int *ia) {
>   double s, v, xi;
>   int i, j, k;
>  
>   for (i = 0; i < n; i ++) {
>     xi = x[i * incx];
>     s = 0.0;
>     for (k = ia[i]; k < ia[i+1]; k ++) {
>       j = ja[k];
>       v = va[k];
>       s += v * x[j * incx];
>       y[j * incy] += v * xi;
>     }
>     y[i * incy] = s + da[i]*xi;
>   }
> }
> 
> static PyObject *
> SSSMat_matvec(SSSMatObject *self, PyObject *args)
> {
>   PyArrayObject *xp, *yp;
> 
>   SPMATRIX_PARSE_ARGS_ARR_ARR_STRIDE(args, xp, yp, self->n, self->n);
> 
>   if (xp->flags & CONTIGUOUS &&  yp->flags & CONTIGUOUS) {
>     sss_matvec(self->n, (double *)(xp->data), (double *)(yp->data), 
> 	       self->val, self->diag, self->col, self->ind);
>   } else {
>     sss_matvec_stride(self->n, 
> 		      (double *)(xp->data), xp->strides[0] / sizeof(double),
> 		      (double *)(yp->data), yp->strides[0] / sizeof(double),
> 		      self->val, self->diag, self->col, self->ind);
>   }
>   Py_INCREF(Py_None); 
>   return Py_None;
> }
> 
> static char SSSMat_matvec_transp_doc[] = "a.matvec_transp(x, y)\n\
> \n\
> compute the sparse matrix-vector product y := a^T * x. \n\
> a^T is the transpose of a, which is a d1 by d2 sparse matrix.\n\
> x and y are two 1-dimensional Numeric arrays of appropriate size.";
> 
> /** table of object methods
>  */
> PyMethodDef SSSMat_methods[] = {
>   {"matvec", (PyCFunction)SSSMat_matvec, METH_VARARGS, SSSMat_matvec_doc},
>   {"matvec_transp", (PyCFunction)SSSMat_matvec, METH_VARARGS, SSSMat_matvec_transp_doc},
>   {NULL, NULL}			/* sentinel */
> };
> 
> /*********************************************************************** 
>  * SSSMatType methods
>  */
> 
> static void
> SSSMatType_dealloc(SSSMatObject *self)
> {
>   PyMem_DEL(self->ind);
>   PyMem_DEL(self->val);
>   PyMem_DEL(self->col);
>   PyMem_DEL(self->diag);  
>   PyObject_Del(self);
> }
> 
> static int
> SSSMatType_print(SSSMatObject *a, FILE *fp, int flags)
> {
>   int i, k, first = 1;
> 
>   if (a->nnz == 0) {
>     fprintf(fp, "sss_mat([%d,%d])", a->n, a->n);
>     return 0;
>   }
>   fprintf(fp, "sss_mat([%d,%d], [", a->n, a->n);
>   for (i = 0; i < a->n; i ++) {
>     for (k = a->ind[i]; k < a->ind[i+1]; k ++) {
>       if (!first)
> 	fprintf(fp, ", ");
>       first = 0;
>       fprintf(fp, "(%d,%d): %g", i, a->col[k], a->val[k]);
>     }
>     fprintf(fp, "(%d,%d): %g", i, i, a->diag[i]);
>   }
>   fprintf(fp, "])");
>   return 0;
> }
> 
> static PyObject *
> SSSMatType_getattr(SSSMatObject *self, char *name)
> {
>   if (strcmp(name, "shape") == 0)
>     return Py_BuildValue("(i,i)", self->n, self->n);
>   if (strcmp(name, "nnz") == 0)
>     return PyInt_FromLong(self->nnz + self->n);
>   if (strcmp(name, "__members__") == 0) {
>     char *members[] = {"shape", "nnz"};
>     int i;
> 
>     PyObject *list = PyList_New(sizeof(members)/sizeof(char *));
>     if (list != NULL) {
>       for (i = 0; i < sizeof(members)/sizeof(char *); i ++)
> 	PyList_SetItem(list, i, PyString_FromString(members[i]));
>       if (PyErr_Occurred()) {
> 	Py_DECREF(list);
> 	list = NULL;
>       }
>     }
>     return list;
>   }
>   return Py_FindMethod(SSSMat_methods, (PyObject *)self, name);
> }
> 
> /***********************************************************************
>  * mapping functions
>  */
> 
> /** SSSMat_length - number of items in mapping
>  *    == number of matrix entries
>  */
> static int SSSMat_length(SSSMatObject *self) {
>   return self->n * self->n;
> }
> 
> /** SSSMat_subscript
>  *    Called when treating array object like a mapping. This is used
>  *    implement two-dimensional idices, e.g. A[i,j] or A[i1:i2,j1:j2]
>  */
> static PyObject *
> SSSMat_subscript(SSSMatObject *self, PyObject *idx) {
>   int type, start0, stop0, step0, len0, start1, stop1, step1, len1;
>   int dim[2];
> 
>   dim[0] = dim[1] = self->n;
>   if ((type = LLMat_parse_index(idx, dim,
>                                 &start0, &stop0, &step0, &len0,
>                                 &start1, &stop1, &step1, &len1)) == -1)
>     return NULL;
>   if (type == 1)
>     return getitem(self, start0, start1);
>   else {
>     PyErr_SetString(PyExc_IndexError, "slices not supported");
>     return NULL;
>   }
> }
> 
> static PyMappingMethods SSSMat_as_mapping = {
> #ifdef LENFUNC_OK
>     (lenfunc)SSSMat_length,	/*mp_length*/
> #else
>     (inquiry)SSSMat_length,	/*mp_length*/
> #endif
>     (binaryfunc)SSSMat_subscript, /*mp_subscript*/
>     (objobjargproc)0,
> };
> 
> /***********************************************************************
>  * SSSMatType structure
>  */
> 
> static PyTypeObject SSSMatType = {
>   PyObject_HEAD_INIT(NULL)
>   0,
>   "sss_mat",
>   sizeof(SSSMatObject),
>   0,
>   (destructor)SSSMatType_dealloc, /* tp_dealloc */
>   (printfunc)SSSMatType_print,	/* tp_print */
>   (getattrfunc)SSSMatType_getattr, /* tp_getattr */
>   0,				/* tp_setattr */
>   0,				/* tp_compare */
>   0,				/* tp_repr */
>   0,				/* tp_as_number*/
>   0,				/* tp_as_sequence*/
>   &SSSMat_as_mapping,		/* tp_as_mapping*/
>   0,				/* tp_hash */
> };
> 
> /** newSSSMatObject -- allocate a new SSSMatObject instance
>  *
>  *    a newly allocated, uninitialized SSSMatObject is returned
>  */
> static PyObject *
> newSSSMatObject(int n, int nnz) {
>   SSSMatObject *op;
> 
>   /* create new SparseArrayt object */
>   op = PyObject_New(SSSMatObject, &SSSMatType);
>   if (op == NULL)
>     PyErr_NoMemory();
> 
>   op->val = NULL;
>   op->diag = NULL;
>   op->ind = NULL;
>   op->col = NULL;
> 
>   /* allocate arrays */
>   op->ind = PyMem_New(int, n + 1);
>   if (op->ind == NULL)
>     goto fail;
>   op->diag = PyMem_New(double, n);
>   if (op->diag == NULL)
>     goto fail;
>   op->val = PyMem_New(double, nnz);
>   if (op->val == NULL)
>     goto fail;
>   op->col = PyMem_New(int, nnz);
>   if (op->col == NULL)
>     goto fail;
> 
>   /* initialize rest of fields */
>   op->n = n;
>   op->nnz = nnz;
> 
>   return (PyObject *) op;
> 
>  fail:
>     PyMem_Del(op->ind);    
>     PyMem_Del(op->diag);    
>     PyMem_Del(op->val);    
>     PyMem_Del(op->col);    
>     PyObject_Del(op);
>     return PyErr_NoMemory();
> }
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/tools/poisson.m pysparse/pysparse/tools/poisson.m
0a1,49
> function poisson(n)
> %fprintf('poisson2d      ');
> %tic;
> %  poisson2d(n);
> %toc;
> %fprintf('poisson2d_blk  ');
> %tic;  
> %  poisson2d_blk(n);
> %toc;
> fprintf('poisson2d_kron ');
> tic;
>   poisson2d_kron(n);
> toc;
> return;
> 
> 
> function L = poisson2d(n)
> L = sparse(n*n);
> for i = 1:n
>   for j = 1:n
>     k = i + n*(j-1);
>     L(k,k) = 4;
>     if i > 1, L(k,k-1) = -1; end
>     if i < n, L(k,k+1) = -1; end
>     if j > 1, L(k,k-n) = -1; end
>     if j < n, L(k,k+n) = -1; end
>   end
> end
> return;
> 
> function L = poisson2d_blk(n)
> e = ones(n,1);
> P = spdiags([-e 4*e -e], [-1 0 1], n, n);
> I = -speye(n);
> L = sparse(n*n);
> for i = 1:n:n*n
>   L(i:i+n-1,i:i+n-1) = P;
>   if i > 1, L(i:i+n-1,i-n:i-1) = I; end
>   if i < n*n - n, L(i:i+n-1,i+n:i+2*n-1) = I; end
> end
> return;
> 
> function L = poisson2d_kron(n)
> e = ones(n,1);
> P = spdiags([-e 2*e -e], [-1 0 1], n, n);
> L = kron(P, speye(n)) + kron(speye(n), P);
> return;
> 
> 
diff -X xcld.txt -r -N pysparse-1.3-dev/pysparse/version.py pysparse/pysparse/version.py
1,3d0
< 
< ## THIS FILE IS GENERATED FROM PYSPARSE SETUP.PY
< version = '1.3-dev'
diff -X xcld.txt -r -N pysparse-1.3-dev/requirements.txt pysparse/requirements.txt
0a1,7
> . Numpy (pip install numpy)
> 
> . SuiteSparse (download from
> http://www.cise.ufl.edu/research/sparse/SuiteSparse/ and unpack in a fresh
> directory. No need to install but specify the location in site.cf)
> 
> OSX users using homebrew can simply say "brew install suitesparse".
diff -X xcld.txt -r -N pysparse-1.3-dev/setup.cfg pysparse/setup.cfg
1,5d0
< [egg_info]
< tag_build = 
< tag_date = 0
< tag_svn_revision = 0
< 
diff -X xcld.txt -r -N pysparse-1.3-dev/site.cfg.template pysparse/site.cfg.template
0a1,99
> # This file provides configuration information about non-Python dependencies for
> # PySparse.
> 
> # The format of the file is that of the standard library's ConfigParser module.
> #
> #   http://www.python.org/doc/current/lib/module-ConfigParser.html
> #
> # Each section defines settings that apply to one particular dependency. Some of
> # the settings are general and apply to nearly any section and are defined here.
> # Settings specific to a particular section will be defined near their section.
> #
> #   libraries
> #       Comma-separated list of library names to add to compile the extension
> #       with. Note that these should be just the names, not the filenames. For
> #       example, the file "libfoo.so" would become simply "foo".
> #           libraries = lapack,f77blas,cblas,atlas
> #
> #   library_dirs
> #       List of directories to add to the library search path when compiling
> #       extensions with this dependency. Use the character given by os.pathsep
> #       to separate the items in the list. On UN*X-type systems (Linux, FreeBSD,
> #       OS X):
> #           library_dirs = /usr/lib:/usr/local/lib
> #       On Windows:
> #           library_dirs = c:\mingw\lib,c:\atlas\lib
> #
> #   include_dirs
> #       List of directories to add to the header file earch path.
> #           include_dirs = /usr/include:/usr/local/include
> #
> #   src_dirs
> #       List of directories that contain extracted source code for the
> #       dependency. For some dependencies, numpy.distutils will be able to build
> #       them from source if binaries cannot be found. The FORTRAN BLAS and
> #       LAPACK libraries are one example. However, most dependencies are more
> #       complicated and require actual installation that you need to do
> #       yourself.
> #           src_dirs = /home/rkern/src/BLAS_SRC:/home/rkern/src/LAPACK_SRC
> #
> #   search_static_first
> #       Boolean (one of (0, false, no, off) for False or (1, true, yes, on) for
> #       True) to tell numpy.distutils to prefer static libraries (.a) over
> #       shared libraries (.so). It is turned off by default.
> #           search_static_first = false
> 
> # Defaults
> # ========
> # The settings given here will apply to all other sections if not overridden.
> # This is a good place to add general library and include directories like
> # /usr/local/{lib,include}
> #
> [DEFAULT]
> #library_dirs = /usr/local/lib
> #include_dirs = /usr/local/include
> 
> # Optimized BLAS and LAPACK
> # -------------------------
> # Use the blas_opt and lapack_opt sections to give any settings that are
> # required to link against your chosen BLAS and LAPACK, including the regular
> # FORTRAN reference BLAS and also ATLAS. Some other sections still exist for
> # linking against certain optimized libraries (e.g. [atlas], [lapack_atlas]),
> # however, they are now deprecated and should not be used.
> #
> # These are typical configurations for ATLAS (assuming that the library and
> # include directories have already been set in [DEFAULT]; the include directory
> # is important for the BLAS C interface):
> #
> #[blas_opt]
> #libraries = f77blas, cblas, atlas
> #
> #[lapack_opt]
> #libraries = lapack, f77blas, cblas, atlas
> #
> # If your ATLAS was compiled with pthreads, the names of the libraries might be
> # different:
> #
> #[blas_opt]
> #libraries = ptf77blas, ptcblas, atlas
> #
> #[lapack_opt]
> #libraries = lapack, ptf77blas, ptcblas, atlas
> 
> # UMFPACK
> # -------
> # If the UMFPACK header files and library are in nonstandard locations,
> # specify them here. Comment out this section to use a default version of
> # UMFPACK included with the PySparse source distribution.
> [UMFPACK]
> #suitesparse_libdir = /usr/local/Cellar/suite-sparse-julia/4.0.2/lib:/usr/local/Cellar/metis4/4.0.3/lib
> #suitesparse_include = /usr/local/Cellar/suite-sparse-julia/4.0.2/include
> 
> # SuperLU
> # -------
> # If the SuperLU header files and library are in nonstandard locations,
> # specify it here. Comment out this section to use a default version of
> # SuperLU included with the PySparse distribution.
> [SuperLU]
> #superlu_include = /Users/dpo/local/linalg/SuperLU/SuperLU_3.1/SRC
> #superlu_libdir  = /Users/dpo/local/linalg/SuperLU/SuperLU_3.1/lib
