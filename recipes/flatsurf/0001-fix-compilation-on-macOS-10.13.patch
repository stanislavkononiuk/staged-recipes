From 7603f5cdfb1fdeb74266e0f180b60189eb729b0c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Julian=20R=C3=BCth?= <julian.rueth@fsfe.org>
Date: Sun, 14 Nov 2021 11:58:27 -0600
Subject: [PATCH] fix compilation on macOS < 10.13

---
 .../src/impl/saddle_connections_iterator.impl.hpp  | 13 +++++++++++++
 libflatsurf/src/saddle_connections_iterator.cc     | 14 +++++++-------
 2 files changed, 20 insertions(+), 7 deletions(-)

diff --git a/libflatsurf/src/impl/saddle_connections_iterator.impl.hpp b/libflatsurf/src/impl/saddle_connections_iterator.impl.hpp
index 9cd7a63d..f6a415f3 100644
--- a/libflatsurf/src/impl/saddle_connections_iterator.impl.hpp
+++ b/libflatsurf/src/impl/saddle_connections_iterator.impl.hpp
@@ -30,6 +30,7 @@
 #include "../../flatsurf/ccw.hpp"
 #include "../../flatsurf/half_edge.hpp"
 #include "../../flatsurf/saddle_connections_iterator.hpp"
+#include "../util/assert.ipp"
 
 namespace flatsurf {
 
@@ -91,6 +92,18 @@ class ImplementationOf<SaddleConnectionsIterator<Surface>> {
 
   using Boundary = std::variant<Chain<Surface>, Vector<T>>;
 
+  // A replacement for std::visit() which is not available in macOS < 10.13.
+  template <typename F>
+  static auto visit(F callback, const Boundary& boundary) {
+    if (std::holds_alternative<Chain<Surface>>(boundary)) {
+      return callback(*std::get_if<Chain<Surface>>(&boundary));
+    } else if (std::holds_alternative<Vector<typename Surface::Coordinate>>(boundary)) {
+      return callback(*std::get_if<Vector<typename Surface::Coordinate>>(&boundary));
+    } else {
+      LIBFLATSURF_UNREACHABLE("Boundary must be either a chain or a vector.");
+    }
+  }
+
   static CCW ccw(const Boundary& lhs, const Chain<Surface>& rhs);
   static CCW ccw(const Boundary& lhs, const Boundary& rhs);
   static CCW ccw(const Boundary& lhs, const Vector<T>& rhs);
diff --git a/libflatsurf/src/saddle_connections_iterator.cc b/libflatsurf/src/saddle_connections_iterator.cc
index d1d16b02..9963603f 100644
--- a/libflatsurf/src/saddle_connections_iterator.cc
+++ b/libflatsurf/src/saddle_connections_iterator.cc
@@ -98,7 +98,7 @@ void ImplementationOf<SaddleConnectionsIterator<Surface>>::prepareSearch() {
 
 template <typename Surface>
 CCW ImplementationOf<SaddleConnectionsIterator<Surface>>::ccw(const Boundary& lhs, const Chain<Surface>& rhs) {
-  return std::visit([&](const auto& l) {
+  return visit([&](const auto& l) {
     using B = std::decay_t<decltype(l)>;
     if constexpr (std::is_same_v<B, Chain<Surface>>) {
       auto ccw = static_cast<const Vector<exactreal::Arb>&>(l).ccw(static_cast<const Vector<exactreal::Arb>&>(rhs));
@@ -106,17 +106,17 @@ CCW ImplementationOf<SaddleConnectionsIterator<Surface>>::ccw(const Boundary& lh
     }
     return ccw(lhs, static_cast<const Vector<T>&>(rhs));
   },
-      lhs);
+  lhs);
 }
 
 template <typename Surface>
 CCW ImplementationOf<SaddleConnectionsIterator<Surface>>::ccw(const Boundary& lhs, const Vector<T>& rhs) {
-  return std::visit([&](const auto& b) { return static_cast<const Vector<T>&>(b).ccw(rhs); }, lhs);
+  return visit([&](const auto& b) { return static_cast<const Vector<T>&>(b).ccw(rhs); }, lhs);
 }
 
 template <typename Surface>
 CCW ImplementationOf<SaddleConnectionsIterator<Surface>>::ccw(const Boundary& lhs, const Boundary& rhs) {
-  return std::visit([&](const auto& b) {
+  return visit([&](const auto& b) {
     return ccw(lhs, b);
   },
       rhs);
@@ -255,7 +255,7 @@ bool ImplementationOf<SaddleConnectionsIterator<Surface>>::increment() {
           pushStart(s, beyondRadius);
 
           // Shrink the search sector for the clockwise descent.
-          if (std::holds_alternative<Chain<Surface>>(boundary[1]) || std::get<Vector<T>>(boundary[1]).ccw(nextEdgeEnd) != CCW::COUNTERCLOCKWISE) {
+          if (std::holds_alternative<Chain<Surface>>(boundary[1]) || std::get_if<Vector<T>>(&boundary[1])->ccw(nextEdgeEnd) != CCW::COUNTERCLOCKWISE) {
             tmp.push(std::move(boundary[1]));
             boundary[1] = nextEdgeEnd;
           } else {
@@ -264,7 +264,7 @@ bool ImplementationOf<SaddleConnectionsIterator<Surface>>::increment() {
           // Exclude sectorBegin from future search if this saddle connections
           // hits it exactly so we hide all future vertices that lie on this
           // line.
-          if (std::holds_alternative<Vector<T>>(boundary[0]) && std::get<Vector<T>>(boundary[0]).ccw(nextEdgeEnd) == CCW::COLLINEAR)
+          if (std::holds_alternative<Vector<T>>(boundary[0]) && std::get_if<Vector<T>>(&boundary[0])->ccw(nextEdgeEnd) == CCW::COLLINEAR)
             boundary[0] = nextEdgeEnd;
 
           if (beyondRadius) {
@@ -286,7 +286,7 @@ bool ImplementationOf<SaddleConnectionsIterator<Surface>>::increment() {
       tmp.pop();
       applyMoves();
       // Shrink the search sector for the counter-clockwise descent
-      if (std::holds_alternative<Chain<Surface>>(boundary[0]) || std::get<Vector<T>>(boundary[0]).ccw(nextEdgeEnd) != CCW::CLOCKWISE) {
+      if (std::holds_alternative<Chain<Surface>>(boundary[0]) || std::get_if<Vector<T>>(&boundary[0])->ccw(nextEdgeEnd) != CCW::CLOCKWISE) {
         tmp.push(std::move(boundary[0]));
         boundary[0] = nextEdgeEnd;
       } else {
-- 
2.33.1

