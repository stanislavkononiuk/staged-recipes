{% set name = "cppast" %}
{% set version = "0.1.0" %}

package:
  name: {{ name|lower }}
  version: {{ version }}

source:
  url: https://github.com/foonathan/cppast/archive/refs/tags/v{{ version }}.zip
  sha256: 06f11c7a86263f10187ce45977e78c53b597032b4d24f501cd54f41ceae53721
  patches:
    - 0001-do-not-vendor-external-dependencies.patch
    # Upstreamed at https://github.com/foonathan/cppast/pull/145
    - 0002-install-library-binary.patch
    # Upstreamed also at https://github.com/foonathan/cppast/pull/145
    - 0003-fix-include-search-paths.patch
    - 0004-simplify-cmake.patch

build:
  number: 0
  skip: true  # [win and vc<14]

requirements:
  build:
    - {{ compiler('cxx') }}
    - cmake
    - make  # [not win]
    - ninja  # [win]
  host:
    - boost-cpp
    # Tests are built against catch. It's not needed at runtime.
    - catch2 =2
    - libclang
    # clangdev provides clang header files we build against
    - clangdev
    # llvmdev provides LLVMConfig.cmake needed by the build system
    - llvmdev
    - type_safe
    - tiny-process-library
    - cxxopts
    # We do not need clangxx to build but we want to make sure that a version
    # of libclang is used that will allow for clangxx to be installed at
    # runtime.
    - clangxx
  run:
    - clangxx

test:
  requires:
    # To parse sample.h we need the type_traits headers shipped with the C++ compiler.
    - {{ compiler('cxx') }}
  files:
    - sample.h
  commands:
    - if not exist %LIBRARY_LIB%\cppast.lib exit 1  # [win]
    - if not exist %LIBRARY_BIN%\cppast.dll exit 1  # [win]
    - test -f $PREFIX/lib/libcppast.so              # [linux]
    - test -f $PREFIX/lib/libcppast.dylib           # [osx]
    - cppast sample.h

about:
  home: https://github.com/foonathan/cppast
  license: MIT
  license_family: MIT
  license_file: LICENSE.md
  summary: 'Library interface to the C++ AST'
  description: |
    If you're writing a tool that needs access to the C++ AST (i.e.
    documentation generator, reflection library, …), your only option apart
    from writing your own parser is to use clang. It offers three interfaces
    for tools, but the only one that really works for standalone applications
    is libclang. However, libclang has various limitations and does not expose
    the entire AST.
    So there is no feasible option — except for this library. It was originally
    a part of the standardese documentation generator, but has been extracted
    into an independent library.
  dev_url: https://github.com/foonathan/cppast

extra:
  recipe-maintainers:
    - saraedum
