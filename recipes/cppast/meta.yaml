{% set name = "cppast" %}
{% set version = "0.1.0" %}

package:
  name: {{ name|lower }}
  version: {{ version }}

source:
  url: https://github.com/foonathan/cppast/archive/refs/tags/v{{ version }}.zip
  sha256: 06f11c7a86263f10187ce45977e78c53b597032b4d24f501cd54f41ceae53721
  patches:
    - 0001-do-not-vendor-external-dependencies.patch

build:
  number: 0
  skip: true  # [win and vc<14]
  run_exports:
    # cppast uses semantic versioning
    - {{ pin_subpackage("cppast") }}

requirements:
  build:
    - {{ compiler('cxx') }}
    - cmake
  host:
    - boost-cpp
    - clangdev
    - type_safe
  run:
    - {{ pin_compatible('libclang') }}
    - {{ pin_compatible('clangxx') }}

test:
  files:
    - sample.h
  commands:
    - cppast sample.h
    - if not exist %LIBRARY_LIB%\cppast.lib exit 1  # [win]
    - if not exist %LIBRARY_BIN%\cppast.dll exit 1  # [win]
    - test -f $PREFIX/lib/libcppast.so              # [linux]
    - test -f $PREFIX/lib/libcppast.dylib           # [osx]

about:
  home: https://github.com/foonathan/cppast
  license: MIT
  license_family: MIT
  license_file: LICENSE.md
  summary: 'Library interface to the C++ AST'
  description: |
    If you're writing a tool that needs access to the C++ AST (i.e.
    documentation generator, reflection library, …), your only option apart
    from writing your own parser is to use clang. It offers three interfaces
    for tools, but the only one that really works for standalone applications
    is libclang. However, libclang has various limitations and does not expose
    the entire AST.
    So there is no feasible option — except for this library. It was originally
    a part of the standardese documentation generator, but has been extracted
    into an independent library.
  dev_url: https://github.com/foonathan/cppast

extra:
  recipe-maintainers:
    - saraedum
