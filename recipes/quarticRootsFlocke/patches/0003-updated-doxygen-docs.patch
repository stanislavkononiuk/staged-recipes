From 3e755a4f3c46e3b9a2ee171dd1de87b6a2cb09c5 Mon Sep 17 00:00:00 2001
From: Enrico Bertolazzi <enrico.bertolazzi@unitn.it>
Date: Thu, 6 May 2021 21:53:48 +0200
Subject: [PATCH 03/13] updated doxygen docs

---
 CMakeLists-cflags.txt            |    4 +-
 src/PolynomialRoots-2-Cubic.cc   |    4 +-
 src/PolynomialRoots-3-Quartic.cc |    4 +-
 src/PolynomialRoots.hh           | 1142 +++++++++++++++++++-----------
 4 files changed, 725 insertions(+), 429 deletions(-)

diff --git a/CMakeLists-cflags.txt b/CMakeLists-cflags.txt
index b69fb6f..9ed5880 100644
--- a/CMakeLists-cflags.txt
+++ b/CMakeLists-cflags.txt
@@ -21,8 +21,8 @@ ELSEIF( CMAKE_CXX_COMPILER_ID MATCHES "Clang" )
   SET( CMAKE_CXX_FLAGS_DEBUG   "-fPIC -O0 -gfull -fcolor-diagnostics -DMECHATRONIX_DEBUG -DDEBUG  ${CLANG_WARN}" )
 ELSEIF( CMAKE_CXX_COMPILER_ID MATCHES "MSVC" )
   SET( CMAKE_CXX_FLAGS         "" )
-  SET( CMAKE_CXX_FLAGS_RELEASE "/nologo /GS /W3 /WX- /EHsc /D_WINDOWS /D_SCL_SECURE_NO_WARNINGS /DHAVE_STRING_H /DNO_GETTIMEOFDAY /DYAML_DECLARE_STATIC /DPCRE_STATIC /O2 /MD  ${VS_WARN}" )
-  SET( CMAKE_CXX_FLAGS_DEBUG   "/nologo /GS /W3 /WX- /EHsc /D_WINDOWS /D_SCL_SECURE_NO_WARNINGS /DHAVE_STRING_H /DNO_GETTIMEOFDAY /DYAML_DECLARE_STATIC /DPCRE_STATIC /Od /Ob0 /MDd /RTC1 /guard:cf /Zi /D_DEBUG /DMECHATRONIX_DEBUG  ${VS_WARN}" )
+  SET( CMAKE_CXX_FLAGS_RELEASE "/nologo /GS /W3 /WX- /EHsc /bigobj /D_WINDOWS /D_SCL_SECURE_NO_WARNINGS /DHAVE_STRING_H /DNO_GETTIMEOFDAY /DYAML_DECLARE_STATIC /DPCRE_STATIC /O2 /MD  ${VS_WARN}" )
+  SET( CMAKE_CXX_FLAGS_DEBUG   "/nologo /GS /W3 /WX- /EHsc /bigobj /D_WINDOWS /D_SCL_SECURE_NO_WARNINGS /DHAVE_STRING_H /DNO_GETTIMEOFDAY /DYAML_DECLARE_STATIC /DPCRE_STATIC /Od /Ob0 /MDd /RTC1 /guard:cf /Zi /D_DEBUG /DMECHATRONIX_DEBUG  ${VS_WARN}" )
 ELSE()
   MESSAGE( FATAL_ERROR "Unsupported compiler ${CMAKE_CXX_COMPILER_ID}")
 ENDIF()
diff --git a/src/PolynomialRoots-2-Cubic.cc b/src/PolynomialRoots-2-Cubic.cc
index b6f6c07..6424e50 100644
--- a/src/PolynomialRoots-2-Cubic.cc
+++ b/src/PolynomialRoots-2-Cubic.cc
@@ -23,10 +23,10 @@
 #include <algorithm>
 #include <limits>
 
-#define MAX_ITER_SAFETY 50
-
 #ifndef DOXYGEN_SHOULD_SKIP_THIS
 
+#define MAX_ITER_SAFETY 50
+
 namespace PolynomialRoots {
 
   using std::abs;
diff --git a/src/PolynomialRoots-3-Quartic.cc b/src/PolynomialRoots-3-Quartic.cc
index 0d369b4..3cab920 100644
--- a/src/PolynomialRoots-3-Quartic.cc
+++ b/src/PolynomialRoots-3-Quartic.cc
@@ -23,10 +23,10 @@
 #include <algorithm>
 #include <limits>
 
-#define MAX_ITER_SAFETY 50
-
 #ifndef DOXYGEN_SHOULD_SKIP_THIS
 
+#define MAX_ITER_SAFETY 50
+
 namespace PolynomialRoots {
 
   using std::abs;
diff --git a/src/PolynomialRoots.hh b/src/PolynomialRoots.hh
index 3af760c..3274c2d 100644
--- a/src/PolynomialRoots.hh
+++ b/src/PolynomialRoots.hh
@@ -25,13 +25,31 @@
 #include <complex>
 #include <iostream>
 
-/*!
- *  Implementation of Flocke algorithm for roots 
- *  of 3rd and 4th degree polynomials.
- * 
- *  There are 3 classed for 2nd, 3rd and 4th degree polynomial
- * 
- */
+//!
+//! Implementation of Flocke algorithm for roots 
+//! of 3rd and 4th degree polynomials.
+//!
+//! There are 3 classed for 2nd, 3rd and 4th degree polynomial.
+//! An experimental translation to C++ of a C implementation of
+//! Jenkins--Traub algorithm is available.
+//!
+//! **References**
+//!
+//! \rst
+//!
+//! -  | **N.Flocke**
+//!    | Algorithm 954: An Accurate and Efficient Cubic and Quartic
+//!    | Equation Solver for Physical Applications
+//!    | ACM TOMS, vol 41, n.4, 2015
+//! 
+//! -  | **M.A. Jenkins and J.F.Traub**
+//!    | A Three-Stage Algorithm for Real Polynomials Using Quadratic
+//!      Iteration
+//!    | SIAM Journal on Numerical Analysis
+//!    | Vol. 7, No. 4 (Dec., 1970), pp. 545-566
+//!
+//! \endrst
+//!
 namespace PolynomialRoots {
 
   typedef double valueType;
@@ -103,16 +121,16 @@ namespace PolynomialRoots {
 
   #endif
 
-  /*!
-   * \brief find roots of a generic polynomial using Jenkins-Traub method
-   * 
-   * \param[in]  op     the coefficients of the polynomial
-   * \param[in]  Degree degree of the polynomial
-   * \param[out] zeror  real part of the roots
-   * \param[out] zeroi  imaginary part of the roots
-   * 
-   * \return error code, 0 OK
-   */
+  //! 
+  //! Find roots of a generic polynomial using Jenkins-Traub method
+  //! 
+  //! \param[in]  op     the coefficients of the polynomial
+  //! \param[in]  Degree degree of the polynomial
+  //! \param[out] zeror  real part of the roots
+  //! \param[out] zeroi  imaginary part of the roots
+  //! 
+  //! \return error code, 0 OK
+  //! 
   int
   roots(
     valueType const * op,
@@ -131,63 +149,98 @@ namespace PolynomialRoots {
    |
    |  A * x^2 + B * x + C
   \*/
-  /*! Quadratic polynomial class
-   *
-   * **Constructor**
-   *
-   *      double a = 1;
-   *      double b = 2;
-   *      double c = 3;
-   *      Quadratic q(a,b,c); // build an solve ``a x^2 + b x + c = 0``
-   * 
-   *
-   *      Quadratic q;
-   *      q.setup(a,b,c); // build an solve ``a x^2 + b x + c = 0``
-   * 
-   * **Get kind of solution**
-   * 
-   *      int  nroots = q.numRoots(); 
-   *      bool has_complex_roots = q.complexRoots();
-   *      bool has_a_double_root = q.doubleRoot();
-   *
-   * **Get real roots**
-   * 
-   *      double r_min = 0;
-   *      double r_max = 2;
-   *      double r[2];
-   *      int nroots;
-   *      nroots = p.getRealRoots( r );
-   *      nroots = p.getPositiveRoots( r );
-   *      nroots = p.getNegativeRoots( r );
-   *      nroots = p.getRootsInRange( r_min, r_max, r );
-   *      nroots = p.getRootsInOpenRange( r_min, r_max, r );
-   *
-   * **Get roots**
-   * 
-   *      double r0 = p.real_root0(); 
-   *      double r1 = p.real_root1();
-   *      complexType r0 = p.root0();
-   *      complexType r1 = p.root1();
-   * 
-   *      complexType r;
-   *      double re, im;
-   *      p.getRoot0( re, im );
-   *      p.getRoot0( r );
-   *      p.getRoot1( re, im );
-   *      p.getRoot1( r );
-   * 
-   * **Evaluate polynomial**
-   * 
-   *      {double or complex} v, x; 
-   *      v = p.eval( x );
-   * 
-   *      p.eval( x, p, dp );
-   * 
-   * **Information**
-   * 
-   *      p.info( cout );
-   *      bool ok = p.check( cout );
-   */
+  //! Quadratic polynomial class
+  //! 
+  //! **Constructor**
+  //! 
+  //! \rst
+  //! 
+  //! .. code-block:: cpp
+  //!
+  //!   double a = 1;
+  //!   double b = 2;
+  //!   double c = 3;
+  //!   Quadratic q(a,b,c); // build an solve `a x^2 + b x + c = 0`
+  //!
+  //!   Quadratic q;
+  //!   q.setup(a,b,c); // build an solve `a x^2 + b x + c = 0`
+  //!
+  //! \endrst
+  //! 
+  //! **Get kind of solution**
+  //!
+  //! \rst
+  //! 
+  //! .. code-block:: cpp
+  //!
+  //!   int  nroots            = q.numRoots(); 
+  //!   bool has_complex_roots = q.complexRoots();
+  //!   bool has_a_double_root = q.doubleRoot();
+  //!
+  //! \endrst
+  //! 
+  //! **Get real roots**
+  //! 
+  //! \rst
+  //! 
+  //! .. code-block:: cpp
+  //!
+  //!   double r_min = 0;
+  //!   double r_max = 2;
+  //!   double r[2];
+  //!   int nroots;
+  //!   nroots = p.getRealRoots( r );
+  //!   nroots = p.getPositiveRoots( r );
+  //!   nroots = p.getNegativeRoots( r );
+  //!   nroots = p.getRootsInRange( r_min, r_max, r );
+  //!   nroots = p.getRootsInOpenRange( r_min, r_max, r );
+  //!
+  //! \endrst
+  //! 
+  //! **Get roots**
+  //!
+  //! \rst
+  //! 
+  //! .. code-block:: cpp
+  //!
+  //!   double r0 = p.real_root0(); 
+  //!   double r1 = p.real_root1();
+  //!   complexType r0 = p.root0();
+  //!   complexType r1 = p.root1();
+  //!
+  //!   complexType r;
+  //!   double re, im;
+  //!   p.getRoot0( re, im );
+  //!   p.getRoot0( r );
+  //!   p.getRoot1( re, im );
+  //!   p.getRoot1( r );
+  //!
+  //! \endrst
+  //! 
+  //! **Evaluate polynomial**
+  //!
+  //! \rst
+  //! 
+  //! .. code-block:: cpp
+  //!
+  //!   {double or complex} v, x; 
+  //!   v = p.eval( x );
+  //!
+  //!   p.eval( x, p, dp );
+  //!
+  //! \endrst
+  //! 
+  //! **Information**
+  //!
+  //! \rst
+  //! 
+  //! .. code-block:: cpp
+  //!
+  //!   p.info( cout );
+  //!   bool ok = p.check( cout );
+  //!
+  //! \endrst
+  //! 
   class Quadratic {
     valueType ABC[3];
     valueType r0, r1;
@@ -201,14 +254,16 @@ namespace PolynomialRoots {
 
     Quadratic() : nrts(0), cplx(false), dblx(false) {}
 
-    /*!
-     * Build the object that store the roots of the quadratic polynomial
-     * \f[ q(x) = a x^2 + b x + c \f]
-     * 
-     * \param[in] a leading coefficient of \f$ q(x) \f$
-     * \param[in] b coefficient of \f$ x \f$
-     * \param[in] c coefficient of \f$ x^0 \f$
-     */
+    //! 
+    //! Build the object that store the roots 
+    //! of the quadratic polynomial
+    //!
+    //! \f[ q(x) = a x^2 + b x + c \f]
+    //! 
+    //! \param[in] a leading coefficient of \f$ q(x) \f$
+    //! \param[in] b coefficient of \f$ x \f$
+    //! \param[in] c coefficient of \f$ x^0 \f$
+    //! 
     Quadratic( valueType a, valueType b, valueType c )
     : nrts(0), cplx(false), dblx(false) {
       valueType & A = ABC[0];
@@ -218,14 +273,15 @@ namespace PolynomialRoots {
       findRoots();
     }
 
-    /*!
-     * Setup the object that store the roots of the quadratic polynomial
-     * \f[ q(x) = a x^2 + b x + c \f]
-     * 
-     * \param[in] a leading coefficient of \f$ q(x) \f$
-     * \param[in] b coefficient of \f$ x \f$
-     * \param[in] c coefficient of \f$ x^0 \f$
-     */
+    //! 
+    //! Setup the object that store the roots of the quadratic polynomial
+    //!
+    //! \f[ q(x) = a x^2 + b x + c \f]
+    //! 
+    //! \param[in] a leading coefficient of \f$ q(x) \f$
+    //! \param[in] b coefficient of \f$ x \f$
+    //! \param[in] c coefficient of \f$ x^0 \f$
+    //! 
     void
     setup( valueType a, valueType b, valueType c ) {
       valueType & A = ABC[0];
@@ -235,148 +291,176 @@ namespace PolynomialRoots {
       findRoots();
     }
 
-    /*!
-     * Return the number of computed roots of \f[ q(x) = a x^2 + b x + c \f]
-     * Normally return 2 but if e.g. \f$ a = 0 \f$ return 1 or less depending
-     * on the values of \f$ a, b, c \f$ 
-     * 
-     * \return number of computed roots
-     */
+    //! 
+    //! Return the number of computed roots of
+    //! 
+    //! \f[ q(x) = a x^2 + b x + c \f]
+    //!
+    //! Normally return 2 but if e.g. \f$ a = 0 \f$ 
+    //! return 1 or less depending on the values of \f$ a, b, c \f$ 
+    //! 
+    //! \return number of computed roots
+    //! 
     indexType numRoots() const { return nrts; }
 
-    /*!
-     *  true if roots are complex conjugated
-     */
+    //!
+    //! true if roots are complex conjugated
+    //!
     bool complexRoots() const { return cplx; }
 
-    /*!
-     * true if \f$ p(x) = a x^2 + b x + c = (x-r)^2 \f$
-     */
+    //! 
+    //! true if \f$ p(x) = a x^2 + b x + c = (x-r)^2 \f$
+    //! 
     bool doubleRoot() const { return dblx; }
 
-    /*!
-     * \brief get the real roots
-     *
-     * \param[out] r vector that will be filled with the real roots
-     * \return the total number of real roots, 0, 1 or 2
-     */
+    //! 
+    //! Get the real roots
+    //! 
+    //! \param[out] r vector that will be filled with the real roots
+    //! \return the total number of real roots, 0, 1 or 2
+    //! 
     indexType getRealRoots( valueType r[] ) const;
 
-    /*!
-     * \brief get positive real roots
-     *
-     * \param[out] r vector that will be filled with the real roots
-     * \return the total number of positive real roots, 0, 1 or 2
-     */
+    //! 
+    //! Get positive real roots
+    //! 
+    //! \param[out] r vector that will be filled with the real roots
+    //! \return the total number of positive real roots, 0, 1 or 2
+    //! 
     indexType getPositiveRoots( valueType r[] ) const;
 
-    /*!
-     * \brief get negative real roots
-     *
-     * \param[out] r vector that will be filled with the real roots
-     * \return the total number of negative real roots, 0, 1 or 2
-     */
+    //! 
+    //! Get negative real roots
+    //! 
+    //! \param[out] r vector that will be filled with the real roots
+    //! \return the total number of negative real roots, 0, 1 or 2
+    //! 
     indexType getNegativeRoots( valueType r[] ) const;
 
-    /*!
-     * \brief  get real roots in a range
-     *
-     * \param[in]  a left side of the range
-     * \param[in]  b right side of the range
-     * \param[out] r vector that will be filled with the real roots
-     * \return the total number of real roots in the range \f$ [a,b] \f$ 
-     */
+    //! 
+    //! Get real roots in a closed range
+    //! 
+    //! \param[in]  a left side of the range
+    //! \param[in]  b right side of the range
+    //! \param[out] r vector that will be filled with the real roots
+    //! \return the total number of real roots in the range \f$ [a,b] \f$ 
+    //! 
     indexType getRootsInRange( valueType a, valueType b, valueType r[] ) const;
 
-    /*!
-     * \param[in]  a left side of the range
-     * \param[in]  b right side of the range
-     * \param[out] r vector that will be filled with the real roots
-     * \return the total number of real roots in the open range \f$ (a,b) \f$ 
-     */
+    //! 
+    //! Get real roots in an open range
+    //!
+    //! \param[in]  a left side of the range
+    //! \param[in]  b right side of the range
+    //! \param[out] r vector that will be filled with the real roots
+    //! \return the total number of real roots in the open range \f$ (a,b) \f$ 
+    //! 
     indexType getRootsInOpenRange( valueType a, valueType b, valueType r[] ) const;
 
-    //! the first real root
+    //!
+    //! The first real root
+    //!
     valueType real_root0() const { return r0; } 
 
-    //! the second real root
+    //!
+    //! The second real root
+    //!
     valueType real_root1() const { return r1; }
 
-    //! the first complex root
+    //!
+    //! The first complex root
+    //!
     complexType
     root0() const
     { return cplx ? complexType(r0,r1) : complexType(r0,0); }
 
-    //! the second complex root
+    //!
+    //! The second complex root
+    //!
     complexType
     root1() const
     { return cplx ? complexType(r0,-r1) : complexType(r1,0); }
 
-    /*!
-     * \param[out] re the first complex root, real part
-     * \param[out] im the first complex root, imaginary part
-     */
+    //!
+    //! Get the first root (complex or real) 
+    //!
+    //! \param[out] re the first complex root, real part
+    //! \param[out] im the first complex root, imaginary part
+    //! 
     void
     getRoot0( valueType & re, valueType & im ) const {
       if ( cplx ) { re = r0; im = r1; }
       else        { re = r0; im = 0;  }
     }
 
-    /*!
-     * \param[out] r the first complex root
-     */
+    //!
+    //! Get the first root (complex or real) 
+    //!
+    //! \param[out] r the first complex root
+    //!
     void
     getRoot0( complexType & r ) const
     { r = cplx ? complexType(r0,r1) : complexType(r0,0); }
 
-    /*!
-     * \param[out] re the second complex root, real part
-     * \param[out] im the second complex root, imaginary part
-     */
+    //!
+    //! Get the second root (complex or real) 
+    //!
+    //! \param[out] re the second complex root, real part
+    //! \param[out] im the second complex root, imaginary part
+    //! 
     void
     getRoot1( valueType & re, valueType & im ) const {
       if ( cplx ) { re = r0; im = -r1; }
       else        { re = r1; im = 0;   }
     }
 
-    /*!
-     * \param[out] r the second complex root
-     */
+    //!
+    //! Get the second root (complex or real) 
+    //!
+    //! \param[out] r the second complex root
+    //!
     void
     getRoot1( complexType & r ) const
     { r = cplx ? complexType(r0,-r1) : complexType(r1,0); }
 
-    //! evalute the quadratic polynomial
-    /*!
-     * \param x  value where compute \f$ p(x) \f$
-     * \return   the value \f$ p(x) \f$
-     */
+    //!
+    //! Evaluate the quadratic polynomial
+    //!
+    //! \param x  value where compute \f$ p(x) \f$
+    //! \return   the value \f$ p(x) \f$
+    //!
     valueType
     eval( valueType x ) const
     { return evalPoly( ABC, 2, x ); }
 
-    //! evalute the quadratic polynomial
-    /*!
-     * \param[in] x value where compute \f$ p(x)=ax^2+bx+c \f$
-     * \return      the value \f$ p(x) \f$
-     */
+    //!
+    //! Evalute the quadratic polynomial
+    //! 
+    //! \param[in] x value where compute \f$ p(x)=ax^2+bx+c \f$
+    //! \return      the value \f$ p(x) \f$
+    //! 
     complexType
     eval( complexType const & x ) const
     { return evalPolyC( ABC, 2, x ); }
 
-    //! evalute the polynomial with its derivative
-    /*!
-     * \param[in]  x   value where compute \f$ p(x) \f$
-     * \param[out] p   value \f$ p(x) \f$
-     * \param[out] dp  value \f$ p'(x) \f$
-     */
+    //!
+    //! Evaluate the polynomial with its derivative
+    //! 
+    //! \param[in]  x   value where compute \f$ p(x) \f$
+    //! \param[out] p   value \f$ p(x) \f$
+    //! \param[out] dp  value \f$ p'(x) \f$
+    //! 
     void eval( valueType x, valueType & p, valueType & dp ) const;
 
-    //! print info of the roots of the polynomial
+    //!
+    //! Print info of the roots of the polynomial.
+    //!
     void
     info( std::ostream & s ) const;
 
-    //! check tolerance and quality of the computed roots
+    //!
+    //! Check tolerance and quality of the computed roots
+    //!
     bool
     check( std::ostream & s ) const;
 
@@ -392,69 +476,105 @@ namespace PolynomialRoots {
    |
    |  A * x^3 + B * x^2 + C * x + D
   \*/
-  /*! Cubic polynomial class
-   *
-   * **Constructor**
-   *
-   *      double a = 1;
-   *      double b = 2;
-   *      double c = 3;
-   *      double d = 3;
-   *      Cubic p(a,b,c,d); // build an solve ``a x^3 + b x^2 + c x + d = 0``
-   * 
-   *
-   *      Cubic p;
-   *      p.setup(a,b,c,d); // build an solve ``a x^3 + b x^2 + c x + d = 0``
-   * 
-   * **Get kind of solution**
-   * 
-   *      int  nroots = p.numRoots(); 
-   *      bool has_complex_roots = p.complexRoots();
-   *      bool has_a_double_root = p.doubleRoot();
-   *      bool has_a_triple_root = p.tripleRoot();
-   *
-   * **Get real roots**
-   * 
-   *      double r_min = 0;
-   *      double r_max = 2;
-   *      double r[3];
-   *      int nroots;
-   *      nroots = p.getRealRoots( r );
-   *      nroots = p.getPositiveRoots( r );
-   *      nroots = p.getNegativeRoots( r );
-   *      nroots = p.getRootsInRange( r_min, r_max, r );
-   *      nroots = p.getRootsInOpenRange( r_min, r_max, r );
-   *
-   * **Get roots**
-   * 
-   *      double r0 = p.real_root0();
-   *      double r1 = p.real_root1();
-   *      double r2 = p.real_root2();
-   *      complexType r0 = p.root0();
-   *      complexType r1 = p.root1();
-   *      complexType r2 = p.root2();
-   *
-   *      complexType r;
-   *      double re, im;
-   *      p.getRoot0( re, im );
-   *      p.getRoot0( r );
-   *      p.getRoot1( re, im );
-   *      p.getRoot1( r );
-   *      p.getRoot2( re, im );
-   *      p.getRoot2( r );
-   * 
-   * **Evaluate polynomial**
-   * 
-   *      {double or complex} v, x; 
-   *      v = p.eval( x );
-   * 
-   *      p.eval( x, p, dp );
-   * 
-   * **Information**
-   * 
-   *      p.info( cout );
-   *      bool ok = p.check( cout );
-   */
+  //! Cubic polynomial class
+  //! 
+  //! **Constructor**
+  //!
+  //! \rst
+  //! 
+  //! .. code-block:: cpp
+  //! 
+  //!      double a = 1;
+  //!      double b = 2;
+  //!      double c = 3;
+  //!      double d = 3;
+  //!      Cubic p(a,b,c,d); // build an solve ``a x^3 + b x^2 + c x + d = 0``
+  //! 
+  //! 
+  //!      Cubic p;
+  //!      p.setup(a,b,c,d); // build an solve ``a x^3 + b x^2 + c x + d = 0``
+  //!
+  //! \endrst
+  //! 
+  //! **Get kind of solution**
+  //!
+  //! \rst
+  //! 
+  //! .. code-block:: cpp
+  //! 
+  //!      int  nroots = p.numRoots(); 
+  //!      bool has_complex_roots = p.complexRoots();
+  //!      bool has_a_double_root = p.doubleRoot();
+  //!      bool has_a_triple_root = p.tripleRoot();
+  //!
+  //! \endrst
+  //! 
+  //! **Get real roots**
+  //!
+  //! \rst
+  //! 
+  //! .. code-block:: cpp
+  //! 
+  //!      double r_min = 0;
+  //!      double r_max = 2;
+  //!      double r[3];
+  //!      int nroots;
+  //!      nroots = p.getRealRoots( r );
+  //!      nroots = p.getPositiveRoots( r );
+  //!      nroots = p.getNegativeRoots( r );
+  //!      nroots = p.getRootsInRange( r_min, r_max, r );
+  //!      nroots = p.getRootsInOpenRange( r_min, r_max, r );
+  //!
+  //! \endrst
+  //! 
+  //! **Get roots**
+  //!
+  //! \rst
+  //! 
+  //! .. code-block:: cpp
+  //! 
+  //!      double r0 = p.real_root0();
+  //!      double r1 = p.real_root1();
+  //!      double r2 = p.real_root2();
+  //!      complexType r0 = p.root0();
+  //!      complexType r1 = p.root1();
+  //!      complexType r2 = p.root2();
+  //! 
+  //!      complexType r;
+  //!      double re, im;
+  //!      p.getRoot0( re, im );
+  //!      p.getRoot0( r );
+  //!      p.getRoot1( re, im );
+  //!      p.getRoot1( r );
+  //!      p.getRoot2( re, im );
+  //!      p.getRoot2( r );
+  //!
+  //! \endrst
+  //!
+  //! **Evaluate polynomial**
+  //!
+  //! \rst
+  //! 
+  //! .. code-block:: cpp
+  //! 
+  //!      {double or complex} v, x; 
+  //!      v = p.eval( x );
+  //! 
+  //!      p.eval( x, p, dp );
+  //!
+  //! \endrst
+  //! 
+  //! **Information**
+  //!
+  //! \rst
+  //! 
+  //! .. code-block:: cpp
+  //! 
+  //!      p.info( cout );
+  //!      bool ok = p.check( cout );
+  //!
+  //! \endrst
+  //! 
   class Cubic {
     valueType ABCD[4];
     valueType r0, r1, r2;
@@ -478,15 +598,15 @@ namespace PolynomialRoots {
       findRoots();
     }
 
-    //! compute the roots of cubic polynomial \f$ a x^3 + b x^2 + c x + d \f$
-    /*!
-     *
-     * \param[in] a coefficient of \f$ x^3 \f$
-     * \param[in] b coefficient of \f$ x^2 \f$
-     * \param[in] c coefficient of \f$ x   \f$
-     * \param[in] d coefficient of \f$ x^0 \f$
-     *
-     */
+    //!
+    //! Compute the roots of cubic polynomial 
+    //! \f$ a x^3 + b x^2 + c x + d \f$
+    //!
+    //! \param[in] a coefficient of \f$ x^3 \f$
+    //! \param[in] b coefficient of \f$ x^2 \f$
+    //! \param[in] c coefficient of \f$ x   \f$
+    //! \param[in] d coefficient of \f$ x^0 \f$
+    //! 
     void
     setup( valueType a, valueType b, valueType c, valueType d ) {
       valueType & A = ABCD[0];
@@ -497,124 +617,190 @@ namespace PolynomialRoots {
       findRoots();
     }
 
-    indexType numRoots()     const { return nrts; } //!< number of found roots
-    bool      complexRoots() const { return cplx; } //!< has complex roots?
-    bool      doubleRoot()   const { return dblx; } //!< has a double root?
-    bool      tripleRoot()   const { return trpx; } //!< has a triple root?
-
-    //! get the real roots
-    /*!
-     * \param[out] r vector that will be filled with the real roots
-     * \return the total number of real roots, 0, 1, 2 or 3
-     */
+    //!
+    //! Number of found roots.
+    //!
+    indexType numRoots()     const { return nrts; } 
+   
+    //!
+    //! Has complex roots?
+    //!
+    bool complexRoots() const { return cplx; }
+    
+    //!
+    //! Has a double root?
+    //!
+    bool doubleRoot() const { return dblx; }
+    
+    //!
+    //! Has a triple root?
+    //!
+    bool tripleRoot() const { return trpx; }
+    
+    //!
+    //! Get the real roots.
+    //! 
+    //! \param[out] r vector that will be filled with the real roots
+    //! \return the total number of real roots, 0, 1, 2 or 3
+    //! 
     indexType getRealRoots( valueType r[] ) const;
 
-    //! get positive real roots
-    /*!
-     * \param[out] r vector that will be filled with the real roots
-     * \return the total number of positive real roots, 0, 1, 2 or 3
-     */
+    //!
+    //! Get positive real roots.
+    //!
+    //! \param[out] r vector that will be filled with the real roots
+    //! \return the total number of positive real roots, 0, 1, 2 or 3
+    //!
     indexType getPositiveRoots( valueType r[] ) const;
 
-    //! get negative real roots
-    /*!
-     * \param[out] r vector that will be filled with the real roots
-     * \return the total number of negative real roots, 0, 1, 2 or 3
-     */
+    //!
+    //! Get negative real roots.
+    //! 
+    //! \param[out] r vector that will be filled with the real roots
+    //! \return the total number of negative real roots, 0, 1, 2 or 3
+    //! 
     indexType getNegativeRoots( valueType r[] ) const;
 
-    //! get real roots in a range
-    /*!
-     * \param[in]  a left side of the range
-     * \param[in]  b right side of the range
-     * \param[out] r vector that will be filled with the real roots
-     * \return the total number of real roots in the range [a,b]
-     */
+    //!
+    //! Get real roots in a closed range.
+    //! 
+    //! \param[in]  a left side of the range
+    //! \param[in]  b right side of the range
+    //! \param[out] r vector that will be filled with the real roots
+    //! \return the total number of real roots in the range [a,b]
+    //! 
     indexType getRootsInRange( valueType a, valueType b, valueType r[] ) const;
 
-    /*!
-     * \param[in]  a left side of the range
-     * \param[in]  b right side of the range
-     * \param[out] r vector that will be filled with the real roots
-     * \return the total number of real roots in the open range (a,b)
-     */
+    //!
+    //! Get real roots in an open range.
+    //! 
+    //! \param[in]  a left side of the range
+    //! \param[in]  b right side of the range
+    //! \param[out] r vector that will be filled with the real roots
+    //! \return the total number of real roots in the open range (a,b)
+    //! 
     indexType getRootsInOpenRange( valueType a, valueType b, valueType r[] ) const;
 
-    valueType real_root0() const { return r0; } //!< first real real
-    valueType real_root1() const { return r1; } //!< second real real
-    valueType real_root2() const { return r2; } //!< third real real
+    //!
+    //! First real root.
+    //!
+    valueType real_root0() const { return r0; }
 
+    //!
+    //! Second real root.
+    //!
+    valueType real_root1() const { return r1; }
+    
+    //!
+    //! Third real root.
+    //!
+    valueType real_root2() const { return r2; }
+    
+    //!
+    //! First complex or real root.
+    //!
     complexType
     root0() const
     { return cplx ? complexType(r0,r1) : complexType(r0,0); }
 
+    //!
+    //! Second complex or real root.
+    //!
     complexType
     root1() const
     { return cplx ? complexType(r0,-r1) : complexType(r1,0); }
 
+    //!
+    //! Third complex or real root.
+    //!
     complexType
     root2() const
     { return complexType(r2,0); }
 
+    //!
+    //! First complex or real root.
+    //!
     void
     getRoot0( valueType & re, valueType & im ) const {
       if ( cplx ) { re = r0; im = r1; }
       else        { re = r0; im = 0;  }
     }
 
+    //!
+    //! First complex or real root.
+    //!
     void
     getRoot0( complexType & r ) const
     { r = cplx ? complexType(r0,r1) : complexType(r0,0); }
 
+    //!
+    //! Second complex or real root.
+    //!
     void
     getRoot1( valueType & re, valueType & im ) const {
       if ( cplx ) { re = r0; im = -r1; }
       else        { re = r1; im = 0;   }
     }
 
+    //!
+    //! Second complex or real root.
+    //!
     void
     getRoot1( complexType & r ) const
     { r = cplx ? complexType(r0,-r1) : complexType(r1,0); }
 
+    //!
+    //! Third complex or real root.
+    //!
     void
     getRoot2( valueType & re, valueType & im ) const
     { re = r2; im = 0; }
 
+    //!
+    //! Third complex or real root.
+    //!
     void
     getRoot2( complexType & r ) const
     { r = complexType(r2,0); }
 
-    //! evalute the cubic polynomial
-    /*!
-     * \param x   value where compute \f$ p(x) \f$
-     * \return the value \f$ p(x) \f$
-     */
+    //!
+    //! Evalute the cubic polynomial.
+    //!
+    //! \param x   value where compute \f$ p(x) \f$
+    //! \return the value \f$ p(x) \f$
+    //!
     valueType
     eval( valueType x ) const
     { return evalPoly( ABCD, 3, x ); }
 
-    //! evalute the cubic polynomial
-    /*!
-     * \param x   value where compute \f$ p(x) \f$, x complex
-     * \return the value \f$ p(x) \f$
-     */
+    //!
+    //! Evalute the cubic polynomial.
+    //! 
+    //! \param x   value where compute \f$ p(x) \f$, x complex
+    //! \return the value \f$ p(x) \f$
+    //! 
     complexType
     eval( complexType const & x ) const
     { return evalPolyC( ABCD, 3, x ); }
 
-    //! evalute the polynomial with its derivative
-    /*!
-     * \param x   value where compute \f$ p(x) \f$
-     * \param p   value \f$ p(x) \f$
-     * \param dp  value \f$ p'(x) \f$
-     */
+    //!
+    //! Evalute the polynomial with its derivative.
+    //! 
+    //! \param x   value where compute \f$ p(x) \f$
+    //! \param p   value \f$ p(x) \f$
+    //! \param dp  value \f$ p'(x) \f$
+    //! 
     void eval( valueType x, valueType & p, valueType & dp ) const;
 
-    //! print info of the roots of the polynomial
+    //!
+    //! Print info of the roots of the polynomial.
+    //!
     void
     info( std::ostream & s ) const;
 
-    //! check tolerenace and quality of the computed roots
+    //!
+    //! Check tolerenace and quality of the computed roots.
+    //!
     bool
     check( std::ostream & s ) const;
 
@@ -630,73 +816,109 @@ namespace PolynomialRoots {
    |
    |  A * x^3 + B * x^2 + C * x + D
   \*/
-  /*! Quartic polynomial class
-   *
-   * **Constructor**
-   *
-   *      double a = 1;
-   *      double b = 2;
-   *      double c = 3;
-   *      double d = 3;
-   *      double e = 3;
-   *      Quartic p(a,b,c,d,e); // build an solve ``a x^4 + b x^3 + c x^2 + d x + e = 0``
-   * 
-   *
-   *      Quartic p;
-   *      p.setup(a,b,c,d,e); // build an solve ``a x^4 + b x^3 + c x^2 + d x + e = 0``
-   * 
-   * **Get kind of solution**
-   * 
-   *      int nroots = p.numRoots(); 
-   *      int nroots = p.numRealRoots();
-   *      int nroots = p.numComplexRoots();
-   *
-   * **Get real roots**
-   * 
-   *      double r_min = 0;
-   *      double r_max = 2;
-   *      double r[4];
-   *      int nroots;
-   *      nroots = p.getRealRoots( r );
-   *      nroots = p.getPositiveRoots( r );
-   *      nroots = p.getNegativeRoots( r );
-   *      nroots = p.getRootsInRange( r_min, r_max, r );
-   *      nroots = p.getRootsInOpenRange( r_min, r_max, r );
-   *
-   * **Get roots**
-   * 
-   *      double r0 = p.real_root0();
-   *      double r1 = p.real_root1();
-   *      double r2 = p.real_root2();
-   *      double r3 = p.real_root3();
-   *      complexType r0 = p.root0();
-   *      complexType r1 = p.root1();
-   *      complexType r2 = p.root2();
-   *      complexType r3 = p.root3();
-   *
-   *      complexType r;
-   *      double re, im;
-   *      p.getRoot0( re, im );
-   *      p.getRoot0( r );
-   *      p.getRoot1( re, im );
-   *      p.getRoot1( r );
-   *      p.getRoot2( re, im );
-   *      p.getRoot2( r );
-   *      p.getRoot3( re, im );
-   *      p.getRoot3( r );
-   * 
-   * **Evaluate polynomial**
-   * 
-   *      {double or complex} v, x; 
-   *      v = p.eval( x );
-   * 
-   *      p.eval( x, p, dp );
-   * 
-   * **Information**
-   * 
-   *      p.info( cout );
-   *      bool ok = p.check( cout );
-   */
+  //! Quartic polynomial class
+  //! 
+  //! **Constructor**
+  //!
+  //! \rst
+  //! 
+  //! .. code-block:: cpp
+  //! 
+  //!      double a = 1;
+  //!      double b = 2;
+  //!      double c = 3;
+  //!      double d = 3;
+  //!      double e = 3;
+  //!      Quartic p(a,b,c,d,e); // build an solve ``a x^4 + b x^3 + c x^2 + d x + e = 0``
+  //! 
+  //! 
+  //!      Quartic p;
+  //!      p.setup(a,b,c,d,e); // build an solve ``a x^4 + b x^3 + c x^2 + d x + e = 0``
+  //!
+  //! \endrst
+  //!
+  //! **Get kind of solution**
+  //!
+  //! \rst
+  //! 
+  //! .. code-block:: cpp
+  //! 
+  //!      int nroots = p.numRoots(); 
+  //!      int nroots = p.numRealRoots();
+  //!      int nroots = p.numComplexRoots();
+  //! 
+  //! \endrst
+  //!
+  //! **Get real roots**
+  //!
+  //! \rst
+  //! 
+  //! .. code-block:: cpp
+  //! 
+  //!      double r_min = 0;
+  //!      double r_max = 2;
+  //!      double r[4];
+  //!      int nroots;
+  //!      nroots = p.getRealRoots( r );
+  //!      nroots = p.getPositiveRoots( r );
+  //!      nroots = p.getNegativeRoots( r );
+  //!      nroots = p.getRootsInRange( r_min, r_max, r );
+  //!      nroots = p.getRootsInOpenRange( r_min, r_max, r );
+  //! 
+  //! \endrst
+  //!
+  //! **Get roots**
+  //!
+  //! \rst
+  //! 
+  //! .. code-block:: cpp
+  //! 
+  //!      double r0 = p.real_root0();
+  //!      double r1 = p.real_root1();
+  //!      double r2 = p.real_root2();
+  //!      double r3 = p.real_root3();
+  //!      complexType r0 = p.root0();
+  //!      complexType r1 = p.root1();
+  //!      complexType r2 = p.root2();
+  //!      complexType r3 = p.root3();
+  //! 
+  //!      complexType r;
+  //!      double re, im;
+  //!      p.getRoot0( re, im );
+  //!      p.getRoot0( r );
+  //!      p.getRoot1( re, im );
+  //!      p.getRoot1( r );
+  //!      p.getRoot2( re, im );
+  //!      p.getRoot2( r );
+  //!      p.getRoot3( re, im );
+  //!      p.getRoot3( r );
+  //! 
+  //! \endrst
+  //!
+  //! **Evaluate polynomial**
+  //!
+  //! \rst
+  //! 
+  //! .. code-block:: cpp
+  //! 
+  //!      {double or complex} v, x; 
+  //!      v = p.eval( x );
+  //! 
+  //!      p.eval( x, p, dp );
+  //! 
+  //! \endrst
+  //!
+  //! **Information**
+  //!
+  //! \rst
+  //! 
+  //! .. code-block:: cpp
+  //! 
+  //!      p.info( cout );
+  //!      bool ok = p.check( cout );
+  //!
+  //! \endrst
+  //! 
   class Quartic {
     valueType ABCDE[5];
     valueType r0, r1, r2, r3;
@@ -729,16 +951,16 @@ namespace PolynomialRoots {
       findRoots();
     }
 
-    //! compute the roots of quartic polynomial \f$ a x^4 + b x^3 + c x^2 + d x + e \f$
-    /*!
-     *
-     * \param[in] a coefficient of \f$ x^4 \f$
-     * \param[in] b coefficient of \f$ x^3 \f$
-     * \param[in] c coefficient of \f$ x^2  \f$
-     * \param[in] d coefficient of \f$ x   \f$
-     * \param[in] e coefficient of \f$ x^0 \f$
-     *
-     */
+    //!
+    //! Compute the roots of quartic polynomial
+    //! \f$ a x^4 + b x^3 + c x^2 + d x + e \f$
+    //! 
+    //! \param[in] a coefficient of \f$ x^4 \f$
+    //! \param[in] b coefficient of \f$ x^3 \f$
+    //! \param[in] c coefficient of \f$ x^2  \f$
+    //! \param[in] d coefficient of \f$ x   \f$
+    //! \param[in] e coefficient of \f$ x^0 \f$
+    //! 
     void
     setup(
       valueType a,
@@ -756,140 +978,214 @@ namespace PolynomialRoots {
       findRoots();
     }
 
-    indexType numRoots()        const { return nreal+ncplx; } //!< number of found roots
-    indexType numRealRoots()    const { return nreal; } //!< number of real roots
-    indexType numComplexRoots() const { return ncplx; } //!< number of complex roots
-
-    //! get the real roots
-    /*!
-     * \param[out] r vector that will be filled with the real roots
-     * \return the total number of real roots, 0, 1, 2, 3 or 4
-     */
+    //!
+    //! Number of roots found.
+    //!
+    indexType numRoots() const { return nreal+ncplx; }
+    
+    //!
+    //! Number of real roots.
+    //!
+    indexType numRealRoots() const { return nreal; }
+    
+    //!
+    //! Number of complex roots
+    //!
+    indexType numComplexRoots() const { return ncplx; }
+    
+    //!
+    //! Get the real roots.
+    //!
+    //! \param[out] r vector that will be filled with the real roots
+    //! \return the total number of real roots, 0, 1, 2, 3 or 4
+    //!
     indexType getRealRoots( valueType r[] ) const;
 
-    //! get positive real roots
-    /*!
-     * \param[out] r vector that will be filled with the real roots
-     * \return the total number of positive real roots, 0, 1, 2, 3 or 4
-     */
+    //!
+    //! Get positive real roots
+    //!
+    //! \param[out] r vector that will be filled with the real roots
+    //! \return the total number of positive real roots, 0, 1, 2, 3 or 4
+    //!
     indexType getPositiveRoots( valueType r[] ) const;
 
-    //! get negative real roots
-    /*!
-     * \param[out] r vector that will be filled with the real roots
-     * \return the total number of negative real roots, 0, 1, 2, 3 or 4
-     */
+    //!
+    //! Get negative real roots.
+    //! 
+    //! \param[out] r vector that will be filled with the real roots
+    //! \return the total number of negative real roots, 0, 1, 2, 3 or 4
+    //! 
     indexType getNegativeRoots( valueType r[] ) const;
 
-    //! get real roots in a range
-    /*!
-     * \param[in]  a left side of the range
-     * \param[in]  b right side of the range
-     * \param[out] r vector that will be filled with the real roots
-     * \return the total number of real roots in the range [a,b]
-     */
+    //!
+    //! Get real roots in a closed range.
+    //!
+    //! \param[in]  a left side of the range
+    //! \param[in]  b right side of the range
+    //! \param[out] r vector that will be filled with the real roots
+    //! \return the total number of real roots in the range [a,b]
+    //!
     indexType getRootsInRange( valueType a, valueType b, valueType r[] ) const;
 
-    /*!
-     * \param[in]  a left side of the range
-     * \param[in]  b right side of the range
-     * \param[out] r vector that will be filled with the real roots
-     * \return the total number of real roots in the open range (a,b)
-     */
+    //!
+    //! Get real roots in an open range.
+    //!
+    //! \param[in]  a left side of the range
+    //! \param[in]  b right side of the range
+    //! \param[out] r vector that will be filled with the real roots
+    //! \return the total number of real roots in the open range (a,b)
+    //! 
     indexType getRootsInOpenRange( valueType a, valueType b, valueType r[] ) const;
 
-    valueType real_root0() const { return r0; } //!< first real real
-    valueType real_root1() const { return r1; } //!< second real real
-    valueType real_root2() const { return r2; } //!< third real real
-    valueType real_root3() const { return r3; } //!< fourth real real
-
+    //!
+    //! First real root.
+    //!
+    valueType real_root0() const { return r0; }
+    
+    //!
+    //! Second real root.
+    //!
+    valueType real_root1() const { return r1; }
+    
+    //!
+    //! Third real root.
+    //!
+    valueType real_root2() const { return r2; }
+    
+    //!
+    //! Fourth real root.
+    //!
+    valueType real_root3() const { return r3; }
+    
+    //!
+    //! First real or complex root.
+    //!
     complexType
     root0() const
     { return cplx0() ? complexType(r0,r1) : complexType(r0,0); }
 
+    //!
+    //! Second real or complex root.
+    //!
     complexType
     root1() const
     { return cplx1() ? complexType(r0,-r1) : complexType(r1,0); }
 
+    //!
+    //! Third real or complex root.
+    //!
     complexType
     root2() const
     { return cplx2() ? complexType(r2,r3) : complexType(r2,0); }
 
+    //!
+    //! 4th real or complex root.
+    //!
     complexType
     root3() const
     { return cplx3() ? complexType(r2,-r3) : complexType(r3,0); }
 
+    //!
+    //! First real or complex root.
+    //!
     void
     getRoot0( valueType & re, valueType & im ) const {
       if ( cplx0() ) { re = r0; im = r1; }
       else           { re = r0; im = 0;  }
     }
 
+    //!
+    //! First real or complex root.
+    //!
     void
     getRoot0( complexType & r ) const {
       if ( cplx0() ) r = complexType(r0,r1);
       else           r = complexType(r0,0);
     }
 
+    //!
+    //! Second real or complex root.
+    //!
     void
     getRoot1( valueType & re, valueType & im ) const {
       if ( cplx1() ) { re = r0; im = -r1; }
       else           { re = r1; im = 0;   }
     }
 
+    //!
+    //! Second real or complex root.
+    //!
     void
     getRoot1( complexType & r ) const {
       if ( cplx1() ) r = complexType(r0,-r1);
       else           r = complexType(r1,0);
     }
 
+    //!
+    //! Third real or complex root.
+    //!
     void
     getRoot2( valueType & re, valueType & im ) const {
       if ( cplx2() ) { re = r2; im = r3; }
       else           { re = r2; im = 0;  }
     }
 
+    //!
+    //! Third real or complex root.
+    //!
     void
     getRoot2( complexType & r ) const {
       if ( cplx2() ) r = complexType(r2,r3);
       else           r = complexType(r2,0);
     }
 
+    //!
+    //! 4th real or complex root.
+    //!
     void
     getRoot3( valueType & re, valueType & im ) const {
       if ( cplx3() ) { re = r2; im = -r3; }
       else           { re = r3; im = 0;   }
     }
 
+    //!
+    //! 4th real or complex root.
+    //!
     void
     getRoot3( complexType & r ) const {
       if ( cplx3() ) r = complexType(r2,-r3);
       else           r = complexType(r3,0);
     }
 
-    //! evalute the quartic polynomial
-    /*!
-     * \param x   value where compute \f$ p(x) \f$, x complex
-     * \return the value \f$ p(x) \f$
-     */
+    //!
+    //! Evalute the quartic polynomial.
+    //!
+    //! \param x   value where compute \f$ p(x) \f$, x complex
+    //! \return the value \f$ p(x) \f$
+    //!
     valueType
     eval( valueType x ) const
     { return evalPoly( ABCDE, 4, x ); }
 
-    //! evalute the quartic polynomial
-    /*!
-     * \param x   value where compute \f$ p(x) \f$, x complex
-     * \return the value \f$ p(x) \f$
-     */
+    //!
+    //! Evalute the quartic polynomial.
+    //!
+    //! \param x   value where compute \f$ p(x) \f$, x complex
+    //! \return the value \f$ p(x) \f$
+    //!
     complexType
     eval( complexType const & x ) const
     { return evalPolyC( ABCDE, 4, x ); }
 
-    //! print info of the roots of the polynomial
+    //!
+    //! Print info of the roots of the polynomial.
+    //!
     void
     info( std::ostream & s ) const;
 
-    //! check tolerenace and quality of the computed roots
+    //!
+    //! Check tolerenace and quality of the computed roots.
+    //!
     bool
     check( std::ostream & s ) const;
 
-- 
2.34.1

