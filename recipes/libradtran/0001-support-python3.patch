diff --git a/src_py/GUI_definition.py b/src_py/GUI_definition.py
index 511ecaa..d327073 100644
--- a/src_py/GUI_definition.py
+++ b/src_py/GUI_definition.py
@@ -49,22 +49,22 @@ class ListInput(Input):
     def __init__(self, default=None, valid_range=None, optional=False,logical_file=False,
                  **kwargs):
         Input.__init__(self, optional=optional, **kwargs)
-        
+
         assert not valid_range is None, "You must provide a range of choices!"
         self.valid_range = []
-	for val in valid_range:
-		if isinstance(val,str):	self.valid_range.append( val.lower() )
-		else:			self.valid_range.append( val )
+        for val in valid_range:
+                if isinstance(val,str): self.valid_range.append( val.lower() )
+                else:                   self.valid_range.append( val )
 
-	if optional:
-		if self.valid_range.count(""):	self.valid_range.remove("")
-		self.valid_range.insert(0,"")
+        if optional:
+                if self.valid_range.count(""):  self.valid_range.remove("")
+                self.valid_range.insert(0,"")
 
-	if isinstance(default,str):	default=default.lower()
-        if default is None:		default = self.valid_range[0]
+        if isinstance(default,str):     default=default.lower()
+        if default is None:             default = self.valid_range[0]
         assert default in self.valid_range, "Default not among valid options!"
         self.default = default
-	self.logical_file=logical_file
+        self.logical_file=logical_file
 
 class IntegerListInput(ListInput):
     def __init__(self, **kwargs):
@@ -72,7 +72,7 @@ class IntegerListInput(ListInput):
 
         self.default = str(self.default)
         self.valid_range = tuple([str(i) for i in self.valid_range])
-    
+
 class BooleanInput(Input):
     pass
 
diff --git a/src_py/aerosol_options.py b/src_py/aerosol_options.py
index c030f9e..bf53a9e 100644
--- a/src_py/aerosol_options.py
+++ b/src_py/aerosol_options.py
@@ -1,29 +1,29 @@
 """--------------------------------------------------------------------
  * $Id$
- * 
+ *
  * This file is part of libRadtran.
  * Copyright (c) 1997-2012 by Arve Kylling, Bernhard Mayer,
  *                            Claudia Emde, Robert Buras
  *
  * ######### Contact info: http://www.libradtran.org #########
  *
- * This program is free software; you can redistribute it and/or 
- * modify it under the terms of the GNU General Public License   
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.        
- * 
- * This program is distributed in the hope that it will be useful, 
- * but WITHOUT ANY WARRANTY; without even the implied warranty of  
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the   
- * GNU General Public License for more details.                    
- * 
- * You should have received a copy of the GNU General Public License          
- * along with this program; if not, write to the Free Software                
- * Foundation, Inc., 59 Temple Place - Suite 330, 
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
  * Boston, MA 02111-1307, USA.
  *--------------------------------------------------------------------"""
 
-
+import io
 from option_definition import *
 
 class aerosol_mixed_options(option):
@@ -35,16 +35,16 @@ class aerosol_mixed_options(option):
 		self.dependencies.extend(['aerosol_haze', 'aerosol_vulcan',
 				     'aerosol_season', 'aerosol_visibility'])
 	def isMandatory(self, is_set, get_value):
-		cond = [is_set(opt) for opt in 'aerosol_haze',
+		cond = [is_set(opt) for opt in ('aerosol_haze',
 			'aerosol_vulcan', 'aerosol_season',
-			'aerosol_visibility']
+			'aerosol_visibility')]
 		if all(cond):
 			return False
 		elif any(cond):
 			return True
 		else:
 			return False
-		
+
 
 class setup_aerosol_group():
 
@@ -63,31 +63,31 @@ class setup_aerosol_group():
 			childs=['aerosol_angstrom','aerosol_king_byrne'],
 			continious_update=True
 		)
-	
+
 		aerosol_file = option(
 			name='aerosol_file',
 		        group='aerosol',
 			helpstr='Location of aerosol file',
 			documentation=documentation['aerosol_file'],
-			tokens=[ addLogical( name='id', logicals=['gg', 'ssa', 'tau', 'explicit', 'moments' ], setting='FN_AER_' ), 
-				addToken(name='Input.aer.filename[id]', datatype=file),
-				addSetting(name='Input.aer.spec', setting=1) ], 
+			tokens=[ addLogical( name='id', logicals=['gg', 'ssa', 'tau', 'explicit', 'moments' ], setting='FN_AER_' ),
+				addToken(name='Input.aer.filename[id]', datatype=io.IOBase),
+				addSetting(name='Input.aer.spec', setting=1) ],
 			non_unique=True,
 		)
-	
+
 	#	aerosol_shettle = option(
 	#		'aerosol_file',	#name
 	#	        'aerosol',      #group
 	#		'Specify aerosol properties in atmosphere',	#helpstr
 	#		documentation['aerosol_shettle'],     #documentation
-	#		[ addLogical( 'id', ['vulcan', 'haze', 'season'], 'AER_SHETTLE_' ), 
+	#		[ addLogical( 'id', ['vulcan', 'haze', 'season'], 'AER_SHETTLE_' ),
 	#		addToken('Input.aer[id]', int) ], #token
 	#	        '',     #parents
 	#	        '',     #non_parents
 	#	        ''      #childs
 	#	)
-	#	
-	
+	#
+
 		aerosol_profile_modtran = option(
 			name='aerosol_profile_modtran',
 			group='aerosol',
@@ -95,46 +95,46 @@ class setup_aerosol_group():
 			documentation=documentation['aerosol_profile_modtran'],
 			tokens=[addSetting(name='Input.aer.profile_modtran', setting=True)],
 		)
-	
+
 		aerosol_angstrom = option(
 			name='aerosol_angstrom',
-		        group='aerosol',  
-			helpstr='Scale the aerosol optical depth using the {\AA}ngstr{\"o}m formula.', 
-			documentation= documentation['aerosol_angstrom'], 
+		        group='aerosol',
+			helpstr='Scale the aerosol optical depth using the {\AA}ngstr{\"o}m formula.',
+			documentation= documentation['aerosol_angstrom'],
 			tokens=[addToken(name='Input.aer.alpha', datatype=float ),
 				addToken(name='Input.aer.beta', datatype=float, default='NOT_DEFINED_FLOAT', valid_range=[0, 1e6]),
 				addSetting(name='Input.aer.spec', setting=1) ] ,
-			parents=['aerosol_default'], 
+			parents=['aerosol_default'],
 		)
-	
+
 		aerosol_king_byrne = option(
 			name='aerosol_king_byrne',
-		        group='aerosol',  
-			helpstr='Scale the aerosol optical depth using the King Byrne formula.', 
-			documentation= documentation['aerosol_king_byrne'], 
+		        group='aerosol',
+			helpstr='Scale the aerosol optical depth using the King Byrne formula.',
+			documentation= documentation['aerosol_king_byrne'],
 			tokens=[addToken(name='Input.aer.alpha_0', datatype=float, default='NOT_DEFINED_FLOAT', valid_range=[-1e6, 1e6]),#alph_0 is roughly equivalent with log(angstrom beta) and can thus will mostly be negative
 				addToken(name='Input.aer.alpha_1', datatype=float, default='NOT_DEFINED_FLOAT', valid_range=[-1e6, 1e6]),
 				addToken(name='Input.aer.alpha_2', datatype=float, default='NOT_DEFINED_FLOAT', valid_range=[-800, 800]),
 				addSetting(name='Input.aer.spec', setting=1) ] ,
-			parents=['aerosol_default'], 
+			parents=['aerosol_default'],
 		)
-	
+
 		aerosol_modify = option(	#TODO: valid_ranges for GUI!!
 			name='aerosol_modify',
-			group='aerosol', 
+			group='aerosol',
 			helpstr='Modify aerosol optical properties.',
 			documentation=documentation['aerosol_modify'],
 			tokens=[addLogical( name='id1', logicals=['gg','ssa', 'tau', 'tau550'], setting='MODIFY_VAR_',gui_name='variable' ),
 				addLogical( name='id2', logicals=['set', 'scale' ], setting='MODIFY_TYPE_', gui_name='scale/set' ),
 				addToken( name='Input.aer.modify[id1][id2]', datatype=float, gui_name='value' ),
-				addSetting( name='Input.aer.spec', setting=1, default=0) ], 
+				addSetting( name='Input.aer.spec', setting=1, default=0) ],
 			non_unique=True,
 		)
-	
-	
+
+
 		aerosol_haze = option(
 			name='aerosol_haze',
-			group='aerosol', 
+			group='aerosol',
 			helpstr='Specify the aerosol type in the lower 2 km of the atmosphere',
 			documentation=documentation['aerosol_haze'],
 			#gui_inputs=(IntegerListInput(name='Input.aer.haze', default=None, valid_range=[1, 4, 5, 6]),),
@@ -143,7 +143,7 @@ class setup_aerosol_group():
 			childs=['aerosol_option_specification'],
 			extra_dependencies=['aerosol_haze','aerosol_vulcan','aerosol_visibility','aerosol_season'],
 		)
-		
+
 		aerosol_set_tau_at_wvl = option(
 			name='aerosol_set_tau_at_wvl',
 			group='aerosol',
@@ -154,48 +154,48 @@ class setup_aerosol_group():
 				addSetting( name='Input.aer.modify[MODIFY_VAR_TAU550][MODIFY_TYPE_SET]', setting='Input.aer.tau_wvl_tau'  ),
 				addSetting( name='Input.aer.spec', setting=1, default=0) ],
 		)
-		
+
 		aerosol_season = option(
 			name='aerosol_season',
-			group='aerosol', 
+			group='aerosol',
 			helpstr='Specify season',
 			documentation=documentation['aerosol_season'],
 			tokens= [ addToken(name='Input.aer.seasn', datatype=int, valid_range=[1,2]),
 				addSetting(name='Input.aer.spec', setting=1) ],
-			childs=['aerosol_option_specification'], 
+			childs=['aerosol_option_specification'],
 			extra_dependencies=['aerosol_haze','aerosol_vulcan','aerosol_visibility','aerosol_season'],
 		)
-		
+
 		aerosol_species_file = option(	#TODO: undefined number of optional arguments are allowed
 			name='aerosol_species_file',
 			group='aerosol',
 			helpstr='Specify mass density profiles of a mixture of aerosol types',
 			documentation=documentation['aerosol_species_file'],
 			gui_inputs=(ListInput(name='Input.aer.mixture_name', valid_range=['continental_clean', 'continental_average', 'continental_polluted', 'urban', 'maritime_clean', 'maritime_polluted', 'maritime_tropical', 'desert', 'antarctic'], optional=False),),
-			tokens= [ addToken(name='Input.aer.mixture_name', datatype=str, valid_range = ['continental_clean', 'continental_average', 'continental_polluted', 
-						'urban', 'maritime_clean', 'maritime_polluted', 'maritime_tropical', 'desert', 'antarctic','desert_spheriods'] ), 
+			tokens= [ addToken(name='Input.aer.mixture_name', datatype=str, valid_range = ['continental_clean', 'continental_average', 'continental_polluted',
+						'urban', 'maritime_clean', 'maritime_polluted', 'maritime_tropical', 'desert', 'antarctic','desert_spheriods'] ),
 				addSetting(name='Input.aer.n_species', setting=-1, default='NOT_DEFINED_INTEGER'),
 				addSetting(name='Input.aer.spec', setting=1) ],
 		)
-		
+
 		aerosol_species_library = option(
 			name='aerosol_species_library',
 			group='aerosol',
 			helpstr='Location of optical property files',
 			documentation=documentation['aerosol_species_library'],
-			tokens=[addToken(name='Input.aer.filename[FN_AER_SPECIES_LIB]', datatype=file, valid_range=['OPAC',file])],
+			tokens=[addToken(name='Input.aer.filename[FN_AER_SPECIES_LIB]', datatype=io.IOBase, valid_range=['OPAC',io.IOBase])],
 		)
-		
+
 		aerosol_visibility = option(
 			name='aerosol_visibility',
 			group='aerosol',
 			helpstr='Horizontal visibility in km',
 			documentation=documentation['aerosol_visibility'],
 			tokens=[addToken(name='Input.aer.visibility', datatype=float, default='NOT_DEFINED_FLOAT', valid_range=[0,1e6])],
-			childs=['aerosol_option_specification'], 
+			childs=['aerosol_option_specification'],
 			extra_dependencies=['aerosol_haze','aerosol_vulcan','aerosol_visibility','aerosol_season'],
 		)
-		
+
 		aerosol_vulcan = option(
 			name='aerosol_vulcan',
 			group='aerosol',
@@ -203,12 +203,12 @@ class setup_aerosol_group():
 			documentation=documentation['aerosol_vulcan'],
 			#gui_inputs=(IntegerListInput(name='Input.aer.vulcan', default=None, valid_range=[1, 2, 3, 4], optional=False),),
 			tokens=addToken(name='Input.aer.vulcan', datatype=int, valid_range=[1,4]),
-			childs=['aerosol_option_specification'], 
+			childs=['aerosol_option_specification'],
 			extra_dependencies=['aerosol_haze','aerosol_vulcan','aerosol_visibility','aerosol_season'],
 		)
-	
+
 		self.options = [ aerosol_default,
-			aerosol_file, aerosol_species_library, aerosol_species_file, 
+			aerosol_file, aerosol_species_library, aerosol_species_file,
 			aerosol_haze, aerosol_season, aerosol_vulcan, aerosol_visibility,
 			aerosol_profile_modtran,
 			aerosol_angstrom,aerosol_king_byrne,
@@ -216,12 +216,12 @@ class setup_aerosol_group():
 
 	def __iter__(self):
 		return iter(self.options)
-	
+
 def get_aerosol_documentation():
 	return {
 		'aerosol_default'	: r'''
-	Set up a default aerosol according to \citet{shettle89}. 
-	The default properties are 
+	Set up a default aerosol according to \citet{shettle89}.
+	The default properties are
 	a rural type aerosol in the boundary layer, background aerosol above 2km,
 	spring-summer conditions and a visibility of 50km. These settings may
 	be modified with \code{aerosol\_haze}, \code{aerosol\_vulcan}, \code{aerosol\_season},
@@ -238,36 +238,36 @@ def get_aerosol_documentation():
 	\parameter{gg} Location of aerosol asymmetry parameter file.
 
 	The file must have two columns.
-	Column 1 is the altitude in km. 
-	Column 2 is the asymmetry parameter of each layer. 
+	Column 1 is the altitude in km.
+	Column 2 is the asymmetry parameter of each layer.
 	The asymmetry parameter defined with this option is constant with wavelength.
 	If you require spectral dependence please use \code{aerosol\_file explicit}.
 	Comments start with \code{\#}. Empty lines are ignored.
-	\parameter{ssa} Location of aerosol single scattering albedo file. 
+	\parameter{ssa} Location of aerosol single scattering albedo file.
 
 	The file must have two columns.
-	Column 1 is the altitude in km. The altitude grid must be exactly equal to 
+	Column 1 is the altitude in km. The altitude grid must be exactly equal to
 	the altitude grid specified in the file \code{atmosphere\_file}.
-	Column 2 is the single scattering albedo of each layer. 
+	Column 2 is the single scattering albedo of each layer.
 	The single scattering albedo defined with this option is constant with wavelength. If you require spectral dependence please use \code{aerosol\_file explicit}.
 	Comments start with \code{\#}. Empty lines are ignored.
-	\parameter{tau} Location of aerosol optical depth file. 
+	\parameter{tau} Location of aerosol optical depth file.
 
 	The file must have two columns.
-	Column 1 is the altitude in km. The altitude grid must be exactly equal to 
+	Column 1 is the altitude in km. The altitude grid must be exactly equal to
 	the altitude grid specified in the file \code{atmosphere\_file}.
-	Column 2 is the aerosol optical depth of each layer. 
+	Column 2 is the aerosol optical depth of each layer.
 	To allow wavelength-dependent aerosol optical thickness please
 	use either \code{aerosol\_angstrom} or \code{aerosol\_file explicit}.
 	Comments start with \code{\#}. Empty lines are ignored.
-	\parameter{moments} Set the aerosol phase function moments to the values specified in 
+	\parameter{moments} Set the aerosol phase function moments to the values specified in
 	the aerosol moments file.
 
-	The file contains one column with arbitrary number of 
-	Legendre terms of the phase function. The phase function 
+	The file contains one column with arbitrary number of
+	Legendre terms of the phase function. The phase function
 	 $p(\mu)$ is
 	\begin{equation}
-	   p (\mu) = \sum_{m=0}^{\infty} (2m+1) \cdot k_m \cdot P_m (\mu) 
+	   p (\mu) = \sum_{m=0}^{\infty} (2m+1) \cdot k_m \cdot P_m (\mu)
 	\end{equation}
 	where $k_m$ is the m'th moment and $P_m (\mu)$ is the m'th Legendre
 	polynomial.  If not specified, a Henyey-Greenstein phase function is
@@ -278,28 +278,28 @@ def get_aerosol_documentation():
 	flexibility is wanted. May only be used together with the
 	\code{disort} or \code{fdisort2} solver in combination with the option
 	\code{disort_intcor moments}.
-	\parameter{explicit} A way to specify aerosol optical depth, single scattering albedo, 
-	and phase function moments for each layer. 
+	\parameter{explicit} A way to specify aerosol optical depth, single scattering albedo,
+	and phase function moments for each layer.
 
 	The file must have two columns where column 1 is the altitude in km. The second
 	column is a the name of a file which defines the optical properties of the layer
-	starting at the given altitude. The files specified in the second column must have the 
+	starting at the given altitude. The files specified in the second column must have the
 	following format:
 	\begin{description}
 	\item[Column 1:]
-	The wavelength in nm. These wavelengths may be different from those in \code{source solar file}. 
+	The wavelength in nm. These wavelengths may be different from those in \code{source solar file}.
 	Optical properties are interpolated to the requested wavelengths.
 	\item[Column 2:]
-	The extinction coefficient of the layer in units km-1. 
+	The extinction coefficient of the layer in units km-1.
 	\item[Column 3:]
 	The aerosol single scattering albedo of the layer.
 	\item[Column 4-(nmom+4):]
-	The moments of the aerosol phase function. 
+	The moments of the aerosol phase function.
 	\end{description}
-	For some simple examples see the files \file{examples/AERO\_*.LAYER}. Note that 
-	if using the \code{rte_solver disort} it makes good sense to make the 
-	number of moments larger than \code{number_of_streams}. For \code{rte_solver fdisort1} and 
-	\code{rte_solver polradtran} the number of moments included in the calculations 
+	For some simple examples see the files \file{examples/AERO\_*.LAYER}. Note that
+	if using the \code{rte_solver disort} it makes good sense to make the
+	number of moments larger than \code{number_of_streams}. For \code{rte_solver fdisort1} and
+	\code{rte_solver polradtran} the number of moments included in the calculations
 	will be \code{number_of_streams}+1. Higher order moments will be ignored for these solvers.
 	Please note that the uppermost line of the \code{aerosol_file explicit}
 	denotes simply the top altitude of the uppermost layer. The optical
@@ -313,18 +313,18 @@ def get_aerosol_documentation():
 
 
 		'aerosol_species_file'	: r'''
-	Specify mass density profiles of a mixture of aerosol types. 
+	Specify mass density profiles of a mixture of aerosol types.
 	\fcode{
 	aerosol\_species\_file profile [aero\_1 aero\_2 ... aero\_n]
 	}
-	where \code{aero\_1} to \code{aero\_n} are the aerosol species to be included. 
-	For each of these species, the optical properties are read from the 
-	\code{aerosol\_species\_library}. If \code{aerosol\_species\_library} is not definded, the default library OPAC which can be obtained from the   
+	where \code{aero\_1} to \code{aero\_n} are the aerosol species to be included.
+	For each of these species, the optical properties are read from the
+	\code{aerosol\_species\_library}. If \code{aerosol\_species\_library} is not definded, the default library OPAC which can be obtained from the
 	libRadtran website is used.
         The profile file needs to include vertical profiles for each
-	of these species. This file can be either in \emph{netCDF}-format 
-	(automatically recognized filename extension \code{.nc} or \code{.cdf}) 
-	or in ASCII format. The format of the ASCII file is: 
+	of these species. This file can be either in \emph{netCDF}-format
+	(automatically recognized filename extension \code{.nc} or \code{.cdf})
+	or in ASCII format. The format of the ASCII file is:
 	\fcode{
 	z1    dens(aero\_1, z1) dens(aero\_2, z1)  ... dens(aero\_n, z1)\\
 	z2    dens(aero\_1, z2) dens(aero\_2, z2)  ...\\
@@ -332,19 +332,19 @@ def get_aerosol_documentation():
 	 .        .           .\\
 	}
 	where \code{z} is the height in km, and \code{dens} are the aerosol mass
-	densities in g/m3. Please make sure to include one column for each of 
-	the species \code{aero\_1} to \code{aero\_n} listed after 
-	\code{aerosol\_species\_file}. 
-	For netCDF input it is also possible to specify the unit 'kg kg$^{-1}$'; the data 
+	densities in g/m3. Please make sure to include one column for each of
+	the species \code{aero\_1} to \code{aero\_n} listed after
+	\code{aerosol\_species\_file}.
+	For netCDF input it is also possible to specify the unit 'kg kg$^{-1}$'; the data
 	are then automatically converted to g/m$^3$.
-	
-	Some default aerosol mixtures are provided, corresponding to the definitions in 
+
+	Some default aerosol mixtures are provided, corresponding to the definitions in
 	\citet{hess98:_optic_proper_aeros_cloud}.
 	They can simply be invoked by
 	\fcode{
 	aerosol\_species\_file mixture\_name
 	}
-	where \code{mixture\_name} can be one of the following: 
+	where \code{mixture\_name} can be one of the following:
 	\fcode{\\
 	continental\_clean\\
 	continental\_average\\
@@ -356,7 +356,7 @@ def get_aerosol_documentation():
 	desert\\
 	antarctic
 	}
-	A variation of the desert mixture containing nonspherical particles is 
+	A variation of the desert mixture containing nonspherical particles is
 	\fcode{
 	desert\_spheroids
 	}
@@ -367,17 +367,17 @@ def get_aerosol_documentation():
 	expected: For each species defined in \code{aerosol\_species\_file},
 	\emph{netCDF}-file \emph{species\_name}\code{.nc},
 	(e.g. \code{INSO.nc}), which contains the optical properties of the aerosol
-	species, has to be provided. The netcdf format is the one produced by 
+	species, has to be provided. The netcdf format is the one produced by
 	the {\sl libRadtran} \code{mie} tool.
-	 
-        The default library is OPAC 
-        \citep{hess98:_optic_proper_aeros_cloud}, which is provided on 
-	the libRadtran webpage 
+
+        The default library is OPAC
+        \citep{hess98:_optic_proper_aeros_cloud}, which is provided on
+	the libRadtran webpage
 	\citep{hess98:_optic_proper_aeros_cloud}:
 	\fcode{
 	aerosol\_species\_library OPAC
 	}
-	OPAC contains following aerosol species: 
+	OPAC contains following aerosol species:
 	\fcode{INSO   insoluble \\
 	WASO   water\_soluble\\
 	SOOT   soot\\
@@ -411,7 +411,7 @@ def get_aerosol_documentation():
 
 		'aerosol_visibility'	: r'''
 	Horizontal visibility in km. Affects the profile according to \citet{shettle89}
-	and the optical thickness. 
+	and the optical thickness.
 	\fcode{
 	   aerosol\_visibility value
 	}
@@ -449,7 +449,7 @@ def get_aerosol_documentation():
 		'aerosol_profile_modtran': r'''
 	Squeeze aerosol profile up to 6 km when altitude is non-zero as in MODTRAN.
 	Per default the aerosol profile is shifted upwards
-	and remains unchanged. 
+	and remains unchanged.
 		''',
 
 		'aerosol_angstrom'	: r'''
@@ -457,27 +457,27 @@ def get_aerosol_documentation():
 	\begin{equation}
 	\tau = \beta \lambda^{-\alpha}
 	\end{equation}
-	where $\lambda$ is in units of micrometer \citep{Angstrom1929}. Specify 
+	where $\lambda$ is in units of micrometer \citep{Angstrom1929}. Specify
 	the {\AA}ngstr{\"o}m alpha and beta coefficients by
 	\fcode{
 	   aerosol\_angstrom alpha beta
 	}
-	The optical thickness defined here  is the integral from the user-defined 
-	\code{altitude} to TOA (top of atmosphere). 
+	The optical thickness defined here  is the integral from the user-defined
+	\code{altitude} to TOA (top of atmosphere).
 		''',
 
 		'aerosol_king_byrne'	: r'''
 	Scale the aerosol optical depth using the King Byrne formula \citep{king1976}:
 	\begin{equation}
-                \tau(\lambda)=e^{\alpha_0} \cdot \lambda^{\alpha_1} \cdot \lambda^{\alpha_2 ln(\lambda)} 
+                \tau(\lambda)=e^{\alpha_0} \cdot \lambda^{\alpha_1} \cdot \lambda^{\alpha_2 ln(\lambda)}
         \end{equation}
-	where $\lambda$ is in units of micrometer \citep{Angstrom1929}. Specify 
+	where $\lambda$ is in units of micrometer \citep{Angstrom1929}. Specify
 	the King Byrne $alpha_0$, $alpha_1$ and $alpha_2$ coefficients by
 	\fcode{
 	   aerosol\_king\_byrne alpha_0 alpha_1 alpha_2
 	}
-	The optical thickness defined here  is the integral from the user-defined 
-	\code{altitude} to TOA (top of atmosphere). 
+	The optical thickness defined here  is the integral from the user-defined
+	\code{altitude} to TOA (top of atmosphere).
 		''',
 
 		'aerosol_modify' : r'''
@@ -492,8 +492,8 @@ def get_aerosol_documentation():
 	Set the aerosol optical thickness at wavelength lambda (nm). Other wavelengths are scaled accordingly.
 	Note that this option requires for technical reasons that the
 	wavelength interval defined by \code{wavelength} does contain \code{lambda}.
-	The optical thickness defined here is the integral from the user-definded 
-	\code{altitude} to TOA (top of atmosphere). 
+	The optical thickness defined here is the integral from the user-definded
+	\code{altitude} to TOA (top of atmosphere).
 	\fcode{
 	   aerosol\_set\_tau\_at\_wvl lambda tau
 	}
diff --git a/src_py/cloud_options.py b/src_py/cloud_options.py
index bf9e0ad..1b6c527 100644
--- a/src_py/cloud_options.py
+++ b/src_py/cloud_options.py
@@ -1,28 +1,28 @@
 """--------------------------------------------------------------------
  * $Id$
- * 
+ *
  * This file is part of libRadtran.
  * Copyright (c) 1997-2012 by Arve Kylling, Bernhard Mayer,
  *                            Claudia Emde, Robert Buras
  *
  * ######### Contact info: http://www.libradtran.org #########
  *
- * This program is free software; you can redistribute it and/or 
- * modify it under the terms of the GNU General Public License   
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.        
- * 
- * This program is distributed in the hope that it will be useful, 
- * but WITHOUT ANY WARRANTY; without even the implied warranty of  
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the   
- * GNU General Public License for more details.                    
- * 
- * You should have received a copy of the GNU General Public License          
- * along with this program; if not, write to the Free Software                
- * Foundation, Inc., 59 Temple Place - Suite 330, 
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
  * Boston, MA 02111-1307, USA.
  *--------------------------------------------------------------------"""
-
+import io
 from option_definition import *
 
 class setup_cloud_group():
@@ -39,8 +39,8 @@ class setup_cloud_group():
             helpstr='Location of file defining water cloud properties.',
             documentation=documentation['wc_file'],
             tokens = [ addSetting(name='isp', setting=CaothType('wc') ),
-                addLogical( name='Input.caoth[isp].source', logicals=ProfileType().get_valid_range(), setting='CAOTH_FROM_'), 
-                addToken( name='Input.caoth[isp].filename', datatype=file ) ],
+                addLogical( name='Input.caoth[isp].source', logicals=ProfileType().get_valid_range(), setting='CAOTH_FROM_'),
+                addToken( name='Input.caoth[isp].filename', datatype=io.IOBase ) ],
             parents=['uvspec'],
             childs=['wc_modify',\
                  'interpret_as_level',\
@@ -61,7 +61,7 @@ class setup_cloud_group():
             helpstr='Define how liquid water content and effective droplet radius are translated to optical properties. ',
             documentation=documentation['wc_properties'],
             tokens = [ addSetting(name='isp', setting=CaothType('wc') ),
-                addLogical( name='Input.caoth[isp].properties', logicals=['hu', 'echam4', 'mie', file], setting='PROP_', gui_name='properties'), 
+                addLogical( name='Input.caoth[isp].properties', logicals=['hu', 'echam4', 'mie', io.IOBase], setting='PROP_', gui_name='properties'),
                 addLogical( name='Input.caoth[isp].interpolate' , logicals=['interpolate'], optional=True, gui_name='interpolate') ],
             parents=['wc_file'],
         )
@@ -86,7 +86,7 @@ class setup_cloud_group():
             documentation=documentation['ic_file'],
             tokens = [ addSetting(name='isp', setting=CaothType('ic') ),
                 addLogical( name='Input.caoth[isp].source', logicals=ProfileType().get_valid_range(), setting='CAOTH_FROM_' ),
-                addToken( name='Input.caoth[isp].filename', datatype=file ) ],
+                addToken( name='Input.caoth[isp].filename', datatype=io.IOBase ) ],
             parents=['uvspec'],
             childs=['ic_modify','ic_habit',\
                  'ic_fu', 'interpret_as_level',\
@@ -103,11 +103,11 @@ class setup_cloud_group():
 
         ic_properties = option(  # TODO: raytracing should only be enabled ifthreedmystic, see also ic_raytracing_file
             name='ic_properties',
-            group='cloud', 
+            group='cloud',
             helpstr='Define how ice water content and effective droplet radius are translated to optical properties. ',
             documentation=documentation['ic_properties'],
             tokens = [ addSetting(name='isp', setting=CaothType('ic') ),
-                                   addLogical( name='Input.caoth[isp].properties', logicals=['fu', 'echam4', 'yang', 'key', 'baum', 'baum_v36', 'hey', 'yang2013', 'raytracing', file], setting='PROP_', gui_name='properties' ), 
+                                   addLogical( name='Input.caoth[isp].properties', logicals=['fu', 'echam4', 'yang', 'key', 'baum', 'baum_v36', 'hey', 'yang2013', 'raytracing', io.IOBase], setting='PROP_', gui_name='properties' ),
                         addLogical( name='Input.caoth[isp].interpolate' , logicals=['interpolate'], optional=True, gui_name='interpolate') ],
             parents=['ic_file'],
             childs=['ic_habit', 'ic_habit_yang2013'],
@@ -127,27 +127,27 @@ class setup_cloud_group():
             non_unique=True,
         )
 
-        ic_habit = option( 
+        ic_habit = option(
             name='ic_habit',
             group='cloud',
             helpstr='Ice crystal habit for the \citet{Yang2000}, \citet{Key2002}, \code{baum_v36}, \code{hey} parameterizations.',
             documentation=documentation['ic_habit'],
             tokens = [ addSetting(name='isp', setting=CaothType('ic') ),
-                addLogical( name='Input.caoth[isp].habit',  
-                    logicals=['solid-column', 'hollow-column', 'rough-aggregate', 'rosette-4', 'rosette-6', 
+                addLogical( name='Input.caoth[isp].habit',
+                    logicals=['solid-column', 'hollow-column', 'rough-aggregate', 'rosette-4', 'rosette-6',
                               'plate', 'droxtal', 'dendrite', 'ghm'], setting='IC_HABIT_' ) ],
             parents=['ic_file'],
             speaker='ic_properties',
             enable_values=('key','yang','hey','baum_v36'),
         )
-                
-        ic_habit_yang2013 = option( 
+
+        ic_habit_yang2013 = option(
             name='ic_habit_yang2013',
             group='cloud',
             helpstr='Ice crystal habit for the \citet{yang2013} parameterization.',
             documentation=documentation['ic_habit_yang2013'],
             tokens = [ addSetting(name='isp', setting=CaothType('ic') ),
-                                   addLogical(name='Input.caoth[isp].habit',  
+                                   addLogical(name='Input.caoth[isp].habit',
                                               logicals=['column_8elements', 'droxtal', 'hollow_bullet_rosette', 'hollow_column', 'plate', 'plate_10elements',
                                                         'plate_5elements', 'solid_bullet_rosette', 'solid_column'], setting='IC_HABIT_' ),
                                    addLogical(name='Input.caoth[isp].roughness',
@@ -157,8 +157,8 @@ class setup_cloud_group():
             enable_values=('yang2013',),
         )
 
-                
-        ic_fu = option( 
+
+        ic_fu = option(
             name='ic_fu',
             group='cloud',
             documentation=documentation['ic_fu'],
@@ -174,7 +174,7 @@ class setup_cloud_group():
             name='ic_raytracing_file',
             group='cloud',
             documentation=documentation['ic_raytracing_file'],
-            tokens=[addToken( name='Input.filename[FN_RAYTRACING]', datatype=file ),],
+            tokens=[addToken( name='Input.filename[FN_RAYTRACING]', datatype=io.IOBase ),],
             threedmystic=True,
         )
 
@@ -182,7 +182,7 @@ class setup_cloud_group():
             name='cloud_fraction_file',
             group='cloud',
             documentation=documentation['cloud_fraction_file'],
-            tokens=[addToken( name='Input.filename[FN_CLOUD_FRACTION]', datatype=file ),],
+            tokens=[addToken( name='Input.filename[FN_CLOUD_FRACTION]', datatype=io.IOBase ),],
         )
 
         cloud_overlap = option(
@@ -207,20 +207,20 @@ class setup_cloud_group():
 
 
 
-        self.options = [wc_file, wc_properties, wc_modify, 
-                ic_file, ic_properties, ic_modify, 
+        self.options = [wc_file, wc_properties, wc_modify,
+                ic_file, ic_properties, ic_modify,
                 ic_habit, ic_habit_yang2013, ic_fu, ic_raytracing_file,
                 cloud_fraction_file, cloud_overlap, cloudcover]
-        
+
     def __iter__(self):
         return iter(self.options)
 
 def get_cloud_documentation():
     return {
         'wc_file'   : r'''
-    Location of file defining water cloud properties. 
+    Location of file defining water cloud properties.
     \fcode{
-    wc\_file type file
+    wc\_file type io.IOBase
     }
     \code{type} defines the file type, which can be one of the
     following:
@@ -237,23 +237,23 @@ def get_cloud_documentation():
     first cloud level is defined at 3km, the cloud would start at 1.37km
     above ground.  An example of a water cloud is given in
     \file{examples/WC.DAT}.
-    
+
     Per default the cloud properties are interpreted as layer
     properties. Before version 1.4 the default was level properties: The
     optical depth of a layer was calculated using information from the
-    upper and lower levels defining the layer.  
-    To switch to the old behaviour, use \code{interpret\_as\_level}. 
+    upper and lower levels defining the layer.
+    To switch to the old behaviour, use \code{interpret\_as\_level}.
     See section~\ref{seq:wc} about water clouds for a
     realistic example how the contents of the \code{wc\_file 1D} are converted
     to optical properties.
-    
+
     \ifthreedmystic{
 
-    \item[3D] Define a MYSTIC 3D water cloud input file. 
+    \item[3D] Define a MYSTIC 3D water cloud input file.
     In case the \code{rte\_solver} is not \code{mystic},
     independent column calculations are performed for the 3D field.
     (See \file{examples/UVSPEC\_WC\_IPA.INP} for an example.)
-    The expected format of the cloud file is: 
+    The expected format of the cloud file is:
     \fcode{
     Nx  Ny  Nz flag \\
     dx  dy  z(1) z(2) ... z(Nz+1) \\
@@ -261,16 +261,16 @@ def get_cloud_documentation():
     ix  iy  iz  ext  reff       (if flag == 2)\\
     ix  iy  iz  LWC  reff       (if flag == 3)\\
     }
-    where \code{Nx}, \code{Ny} and \code{Nz} are the number of grid boxes in 
+    where \code{Nx}, \code{Ny} and \code{Nz} are the number of grid boxes in
     \code{x}, \code{y}, and \code{z}-direction.
-    The parameter \code{flag} determines the format of the 3rd and 
-    following lines. In the second line \code{dx} and \code{dy} are the sizes of the boxes in x- 
+    The parameter \code{flag} determines the format of the 3rd and
+    following lines. In the second line \code{dx} and \code{dy} are the sizes of the boxes in x-
     and y-direction in km, \code{z()} are the positions of the z-levels in km.
     In the third and following lines the indices \code{ix}, \code{iy}, and \code{iz} specify cloudy pixels. Indices can take values from 1 to \code{N}.
-    The optical properties of the cloud are given by the other parameters in the line, 
+    The optical properties of the cloud are given by the other parameters in the line,
     where \code{ext} is the extinction coefficient [1/km], \code{g} the asymmetry parameter,
     \code{reff} the effective radius [micrometer], and \code{ssa} the single scattering albedo.
-    The conversion from microphysical to optical properties is defined by \code{wc\_properties} 
+    The conversion from microphysical to optical properties is defined by \code{wc\_properties}
     (identical to the 1D case). Note that the first dimension (x)
     propagates east, and the second dimension (y) north. For more
     information see section~\ref{sec:mystic}.
@@ -281,34 +281,34 @@ def get_cloud_documentation():
 %   be in the format as needed by MYSTIC, see \code{wc\_file 3D}.
 %   (See \file{examples/UVSPEC\_WC\_IPA.INP} for an example.)
     }
-    
-    \item[ipa\_files] A two-column file, defining water cloud property files (see \code{wc\_file 1D}) in the first 
-    column and the correspoding weights in the second column. 
+
+    \item[ipa\_files] A two-column file, defining water cloud property files (see \code{wc\_file 1D}) in the first
+    column and the correspoding weights in the second column.
     The radiative transfer calculation is performed independently for each
     cloud column and the result is the weighted average of all independent
     columns. If \code{ic\_file ipa\_files} and \code{wc\_file ipa\_files} are both
     defined, both must have the same columns in the same order, otherwise
     \code{uvspec} will complain. See
     \file{examples/UVSPEC\_WC\_IC\_IPA\_FILES.INP} for an example.
-    
+
     \item[moments] A way to specify water cloud extinction coefficient, single
     scattering albedo, and scattering phase function for each layer.
 
-    The file specified by 
+    The file specified by
     \code{wc\_file moments} has two columns where column 1 is the altitude in km. The second
-    column is the name of a file which defines the optical properties of the layer 
-    starting at the given altitude. The files specified in the second column must 
+    column is the name of a file which defines the optical properties of the layer
+    starting at the given altitude. The files specified in the second column must
     have the following format:
     \begin{description}
-    \item{Column 1: } 
-    The wavelength in nm. These wavelengths may be different from those in \code{source solar filename}. 
+    \item{Column 1: }
+    The wavelength in nm. These wavelengths may be different from those in \code{source solar filename}.
     Optical properties are interpolated to the requested wavelengths.
-    \item{Column 2:} 
-    The extinction coefficient of the layer in units km-1. 
-    \item{Column 3:} 
+    \item{Column 2:}
+    The extinction coefficient of the layer in units km-1.
+    \item{Column 3:}
     The single scattering albedo of the layer.
-    \item{Column 4-(nmom+4):} 
-    The moments of the scattering phase function. 
+    \item{Column 4-(nmom+4):}
+    The moments of the scattering phase function.
     \end{description}
     Note that if using the \code{rte\_solver disort} or \code{rte\_solver
     fdisort2} it makes good sense to make the number of moments larger
@@ -332,52 +332,52 @@ def get_cloud_documentation():
     }
     Possible choices for \code{property} are:
     \begin{description}
-    \parameter{hu} 
-    Parameterization by \citet{Hu1993}; 
-    this is the default setting. Note that 
-    the parameterization is somewhat different for \code{mol\_abs\_param FU} than for all other 
-    cases because in the latter case the parameterization from the newer (March 2000) 
-    Fu and Liou code is used while otherwise the data are taken from the original 
+    \parameter{hu}
+    Parameterization by \citet{Hu1993};
+    this is the default setting. Note that
+    the parameterization is somewhat different for \code{mol\_abs\_param FU} than for all other
+    cases because in the latter case the parameterization from the newer (March 2000)
+    Fu and Liou code is used while otherwise the data are taken from the original
     paper by \citet{Hu1993}. Note that this parameterization has been
     developed to calculate irradiances, hence it is less suitable for radiances.
     This is due to the use of the Henyey-Greenstein phase function as an approximation
     of the real Mie phase function.
-    \parameter{echam4} 
-    Use the very simple two-band parameterization of the ECHAM4 climate model, described 
+    \parameter{echam4}
+    Use the very simple two-band parameterization of the ECHAM4 climate model, described
     in \cite{Roeckner1996}; this is probably only meaningful if you want to compare
     your results with ECHAM4, the two bands are 0.2 - 0.68 micrometer and 0.68 - 4.0 micrometer;
     within these bands, the optical properties are assumed constant.
-    \parameter{mie} 
-    Use pre-calculated Mie tables; useful for \code{mol\_abs\_param}; 
+    \parameter{mie}
+    Use pre-calculated Mie tables; useful for \code{mol\_abs\_param};
     the tables are expected in \code{data\_files\_path}\file{/correlated\_k/.../}. \\
-    For spectral or pseudo-spectral (\code{mol\_abs\_param sbdart}) calculations, 
+    For spectral or pseudo-spectral (\code{mol\_abs\_param sbdart}) calculations,
     a set of pre-calculated tables is also available.
     %CE: commented some parts. Should be rewritten when new Mie tables are well
     % optimized.
-    % the wavelength grid points of these 
-    %data has been carefully selected such that the extinction cross section, 
-    %single scattering albedo, and the asymmetry parameter are accurate to 1\% 
+    % the wavelength grid points of these
+    %data has been carefully selected such that the extinction cross section,
+    %single scattering albedo, and the asymmetry parameter are accurate to 1\%
     %(compared to the fully-resolved Mie calculation) for all wavelengths
-    %between 250nm and 100 micrometer. 
+    %between 250nm and 100 micrometer.
     For spectral or pseudo-spectral
     calculations optional argument \code{interpolate} has to be defined explicitely to
     initiate the interpolation of the optical properties to the internal wavelength grid.
-    %Please note that this option may be extremely memory-consuming because for each 
-    %internal wavelength a full set of Legendre moments of the phase function is 
-    %stored (up to several thousands). 
-    The Mie tables are not part of the standard distribution 
-    (because of their large size) but they are freely available from http://www.libradtran.org. 
-    This is the correct option to calculate radiances, to be preferred over the 
+    %Please note that this option may be extremely memory-consuming because for each
+    %internal wavelength a full set of Legendre moments of the phase function is
+    %stored (up to several thousands).
+    The Mie tables are not part of the standard distribution
+    (because of their large size) but they are freely available from http://www.libradtran.org.
+    This is the correct option to calculate radiances, to be preferred over the
     Henyey-Greenstein approach of \citet{Hu1993}.
-    \parameter{filename} 
-    Read optical properties from specified filename; file format is as produced 
+    \parameter{filename}
+    Read optical properties from specified filename; file format is as produced
     by the \code{mie}-tool of the {\sl libRadtran} package (see \code{output\_user netcdf}).
     \end{description}
 
-    With the optional argument \code{interpolate} the water cloud optical properties 
-    are interpolated over wavelength; useful for precalculated optical property files. 
-    Please note that this option may be extremely memory-consuming because for each internal wavelength 
-    a full set of Legendre moments of the phase function is stored (up to several thousands). 
+    With the optional argument \code{interpolate} the water cloud optical properties
+    are interpolated over wavelength; useful for precalculated optical property files.
+    Please note that this option may be extremely memory-consuming because for each internal wavelength
+    a full set of Legendre moments of the phase function is stored (up to several thousands).
         ''',
 
         'wc_modify' : r'''
@@ -392,27 +392,27 @@ def get_cloud_documentation():
     Modify the water cloud asymmetry factor for all wavelengths and altitudes.
     \begin{description}
     \item[set]
-    \code{value} can be a float between -1.0 and 1.0. 
-    Please note that this option is only applied if a Henyey-Greenstein 
-    phase function is used but not if an explicit phase function is 
-    defined e.g. with \code{wc\_file moments}. It doesn't make sense to modify only 
-    the first moment of an explicit phase function.  
-    This option is useful only for monochromatic 
-    calculations or in wavelength regions where the optical 
-    properties of water clouds can be considered constant, 
-    e.g. the ultraviolet range. 
+    \code{value} can be a float between -1.0 and 1.0.
+    Please note that this option is only applied if a Henyey-Greenstein
+    phase function is used but not if an explicit phase function is
+    defined e.g. with \code{wc\_file moments}. It doesn't make sense to modify only
+    the first moment of an explicit phase function.
+    This option is useful only for monochromatic
+    calculations or in wavelength regions where the optical
+    properties of water clouds can be considered constant,
+    e.g. the ultraviolet range.
     \item[scale]
     Scale the water cloud asymmetry factor for all wavelengths and altitudes
     with \code{value} between 0.0 and 1.0.
     \end{description}
-    
+
     \parameter{ssa}
     Modify the water cloud single scattering albedo for all wavelengths
     and altitudes.
     \begin{description}
-    \item[set] \code{value} can be a float between 0.0 and 1.0. 
-    This option is useful only for monochromatic 
-    calculations or in wavelength regions where the optical properties of water clouds 
+    \item[set] \code{value} can be a float between 0.0 and 1.0.
+    This option is useful only for monochromatic
+    calculations or in wavelength regions where the optical properties of water clouds
     can be considered constant, e.g. the ultraviolet range.
     \item[scale]
     Scale the water cloud single scattering albedo for all wavelengths and altitudes
@@ -423,18 +423,18 @@ def get_cloud_documentation():
     Modify the total water cloud optical thickness.
     \begin{description}
     \item[set] Set optical thickness to a constant value for all wavelengths.
-    The optical thickness defined here is the integral from the surface at the 
-    user-defined \code{altitude} to TOA (top of atmosphere). This option is useful only 
-    for monochromatic calculations or in wavelength regions where the optical properties 
+    The optical thickness defined here is the integral from the surface at the
+    user-defined \code{altitude} to TOA (top of atmosphere). This option is useful only
+    for monochromatic calculations or in wavelength regions where the optical properties
     of water clouds can be considered constant, e.g. the ultraviolet range.
     \item[scale] Scale the water cloud optical thickness for all wavelengths and altitudes
     with \code{value} between 0.0 and 1000000.0. Also works for 3d clouds.
     \end{description}
 
     \parameter{tau550}
-    Set the water cloud optical thickness at 550nm. 
-    The optical thickness defined here 
-    is the integral from the surface at the user-defined \code{altitude} 
+    Set the water cloud optical thickness at 550nm.
+    The optical thickness defined here
+    is the integral from the surface at the user-defined \code{altitude}
     to TOA (top of atmosphere). Other wavelengths are scaled accordingly.
     Note that this option requires for technical reasons that the
     wavelength interval defined by \code{wavelength} does contain 550nm.
@@ -445,52 +445,52 @@ def get_cloud_documentation():
             ''',
 
         'ic_file'   : r'''
-    Location of file defining ice cloud properties. 
+    Location of file defining ice cloud properties.
     \fcode{
     ic\_file type file
     }
-    
+
     \code{type} defines the file type, which is identical to \code{wc\_file type}.
     See \code{wc\_file} for choices of \code{type} and a description on the file structures.
         ''',
 
         'ic_properties' : r'''
-    Defines how ice water content and effective particle radius are translated 
-    to optical properties. 
+    Defines how ice water content and effective particle radius are translated
+    to optical properties.
     \fcode{
     ic\_properties property [interpolate]
     }
     Possible choices for \code{property} are
     \begin{description}
     \parameter{fu}
-    Parameterization by \citet{Fu1996,Fu1998}, see \code{ic\_file}; 
+    Parameterization by \citet{Fu1996,Fu1998}, see \code{ic\_file};
     this is the default setting. Note that this is a parameterization
-    which has been created to calculate fluxes but not radiances. 
-    Note also that the optical properties in the solar range provided by 
+    which has been created to calculate fluxes but not radiances.
+    Note also that the optical properties in the solar range provided by
     \citet{Fu1996} are delta-scaled properties (that is, the forward peak of
     the phase function is truncated and optical thickness, asymmetry
     parameter, and single scattering albedo are reduced accordingly),
     whereas \code{uvspec} uses non delta-scaled properties unless the option
     \code{ic\_fu deltascaling on} is specified. By default the parameterization
     by \citet{Fu1996} is treated consistently with all other ice cloud
-    parameterizations. 
-    For wavelengths up to 4 micrometer \citet{Fu1996} is used while for wavelengths 
-    larger than 4 micrometer \citet{Fu1998} is chosen. Please note that 
+    parameterizations.
+    For wavelengths up to 4 micrometer \citet{Fu1996} is used while for wavelengths
+    larger than 4 micrometer \citet{Fu1998} is chosen. Please note that
     \citet{Fu1996} is based on ray-tracing calculations while \citet{Fu1998}
-    is a mixture of ray-tracing and Mie calculations (which is required for 
+    is a mixture of ray-tracing and Mie calculations (which is required for
     the infrared wavelengths where the geometrical assumption does not hold).
     Hence, both parameterizations are not fully consistent. Rather, differences
-    of some \% are to be expected in the wavelength region where both 
-    parameterizations overlap. Also, the wavelength dependence in the solar 
+    of some \% are to be expected in the wavelength region where both
+    parameterizations overlap. Also, the wavelength dependence in the solar
     and infrared parts is treated differently: In the solar part \citep{Fu1996}
-    the optical properties are defined for wavelength bands - hence they 
-    are assumed constant within each band. In the infrared \citep{Fu1998} 
-    they are defined at certain wavelengths and linearely interpolated 
+    the optical properties are defined for wavelength bands - hence they
+    are assumed constant within each band. In the infrared \citep{Fu1998}
+    they are defined at certain wavelengths and linearely interpolated
     in between. If you use this option, please see also the
     discussion of \code{ic\_fu deltascaling} and \code{ic\_fu reff\_def}.
-    The allowed range for the effective radius is from 9.315 -  65.120 micrometer. 
+    The allowed range for the effective radius is from 9.315 -  65.120 micrometer.
     \parameter{echam4}
-    Use the simple two-band parameterization of the ECHAM4 climate model, described 
+    Use the simple two-band parameterization of the ECHAM4 climate model, described
     in \cite{Roeckner1996}; this is probably only meaningful if you want to compare
     your results with ECHAM4, the two bands are 0.2 - 0.68 micrometer and 0.68 - 4.0 micrometer.
     Within the two ECHAM4 bands, the optical properties are assumed constant.
@@ -498,31 +498,31 @@ def get_cloud_documentation():
     Parameterization by \citet{Key2002}. This parameterization can also
     be used to calculate radiances because it uses a
     double-Henyey-Greenstein phase function which better represents both
-    forward and backward peaks. This parameterization covers the wavelength region  
+    forward and backward peaks. This parameterization covers the wavelength region
     from 0.2 to 5.0 micrometer and is available for the following \code{habit}:
-    \code{solid-column}, \code{hollow-column}, \code{rough-aggregate}, \code{rosette-4}, 
+    \code{solid-column}, \code{hollow-column}, \code{rough-aggregate}, \code{rosette-4},
     \code{rosette-6}, and \code{plate}.
     \parameter{yang}
     Parameterization similar to \citet{Key2002} but based on more recent
     single scattering calculations. Below 3.4 micrometer it actually equals
-    the \citet{Key2002} parameterization while from 3.4 - 100 micrometer new 
+    the \citet{Key2002} parameterization while from 3.4 - 100 micrometer new
     coefficients have been calculated with much higher wavelength
     resolution and better accuracy. Hence, \code{yang} should give a reasonably
     consistent approximation from 0.2 - 100 micrometer, suitable for spectrally
     resolved calculations of radiance and irradiance.
     The covered range for the effective radius depends on the \code{ic\_habit}.
     (In micrometer: \code{solid-column} [5.96, 84.22], \code{hollow-column} [4.97, 70.24],
-     \code{rough-aggregate} [3.55, 108.10], \code{rosettes-4} [2.77, 45.30], 
+     \code{rough-aggregate} [3.55, 108.10], \code{rosettes-4} [2.77, 45.30],
     \code{rosettes-6} [2.85, 46.01], \code{plate} [4.87, 48.18], \code{dendrites}
-     [0.45, 1.88], \code{droxtal} [9.48, 293.32], 
-    \code{spheroid}  [6.58, 203.39]). 
+     [0.45, 1.88], \code{droxtal} [9.48, 293.32],
+    \code{spheroid}  [6.58, 203.39]).
     \parameter{baum}
     Use ice cloud parameterization from \citet{baum05a:_bulk,baum05b:_bulk},
     \url{http://www.ssec.wisc.edu/\~baum/Cirrus/IceCloudModels.html}.
     In combination with the radiative transfer solvers \code{disort}, \ifmystic{\code{montecarlo},}
      and \code{fdisort2}, accurate phase functions are used.
         \parameter{baum_v36} Use cloud parameterization from
-    \citet{heymsfield2013,yang2013,baum2014} covering the 
+    \citet{heymsfield2013,yang2013,baum2014} covering the
     spectral range from 0.2 to 100~$\mu$m and effective radii from
     5 to 60 $\mu$m. The parameterization
     assumes severly roughened and randomly oriented ice particles
@@ -531,13 +531,13 @@ def get_cloud_documentation():
     \code{ghm} is based on a general habit mixture involving 9
     habits, \code{solid-column} assumes severely roughened solid
     columns, and \code{rough-aggregate} is based on severly
-        roughened aggregates. The default is \code{solid-column}. 
+        roughened aggregates. The default is \code{solid-column}.
     %\parameter{baum\_hufit }
     %Similar to the option \code{baum} but here the phase function
     %is parameterized by 128 Legendre coefficients, calculated with the
-    %delta-fit method from 
-    %\citet{Hu2000}. This parameterization covers the region  
-    %from 0.4 to 2.2 micrometer. If high accuracy is needed e.g. in the vicinity of the halo, 
+    %delta-fit method from
+    %\citet{Hu2000}. This parameterization covers the region
+    %from 0.4 to 2.2 micrometer. If high accuracy is needed e.g. in the vicinity of the halo,
     %the forward peak, or the backscatter peak, \code{ic\_properties baum}
     %is recommended.
     \parameter{hey}
@@ -548,7 +548,7 @@ def get_cloud_documentation():
     micrometers. The single scattering
     properties have been been generated by Hong Gang using the
     models by \citet{Yang2000}. The parameterization is based on
-    simple gamma distributions 
+    simple gamma distributions
     \begin{equation}
     n(r) = n_0 r^{\alpha} \exp\left(-\frac{(\alpha+3)r}{r_e}\right),
     \end{equation}
@@ -573,24 +573,24 @@ def get_cloud_documentation():
     \citet{yang2013} and assumes gamma size distributions as the
     \code{hey} parameterization. It is available for 9 habits and
     3 degrees of roughness, which can be selected using the option
-    \code{ic\_habit\_yang2013}. 
+    \code{ic\_habit\_yang2013}.
     %\parameter{ic-mie}
-    %Use pre-calculated Mie tables; useful for \code{mol\_abs\_param}; 
+    %Use pre-calculated Mie tables; useful for \code{mol\_abs\_param};
     %the tables are expected in \code{data\_files\_path}\file{/correlated\_k/.../}.
-    %For spectral or pseudo-spectral (\code{mol\_abs\_param sbdart}) calculations, 
-    %a set of pre-calculated tables is also available; the wavelength grid points of these 
-    %data has been carefully selected such that the extinction cross section, 
-    %single scattering albedo, and the asymmetry parameter are accurate to 1\% 
+    %For spectral or pseudo-spectral (\code{mol\_abs\_param sbdart}) calculations,
+    %a set of pre-calculated tables is also available; the wavelength grid points of these
+    %data has been carefully selected such that the extinction cross section,
+    %single scattering albedo, and the asymmetry parameter are accurate to 1\%
     %(compared to the fully-resolved Mie calculation) for all wavelengths
-    %between 250nm and 100 micrometer. 
+    %between 250nm and 100 micrometer.
     %For spectral or pseudo-spectral
     %calculations the optional argument \code{interpolate} has to be defined explicitely to
     %initiate the interpolation of the optical properties to the internal wavelength grid.
-    %Please note that this option may be extremely memory-consuming because for each 
-    %internal wavelength a full set of Legendre moments of the phase function is 
-    %stored (up to several thousands). The Mie tables are not part of the standard distribution 
-    %(because of their large size) but they are freely available from http://www.libradtran.org. 
-    %Note that a Mie calculation assumes spherical ice particles, the scattering function of 
+    %Please note that this option may be extremely memory-consuming because for each
+    %internal wavelength a full set of Legendre moments of the phase function is
+    %stored (up to several thousands). The Mie tables are not part of the standard distribution
+    %(because of their large size) but they are freely available from http://www.libradtran.org.
+    %Note that a Mie calculation assumes spherical ice particles, the scattering function of
     %which differs systematically from non-spherical particles. Hence, \code{ic\_properties mie}
     %is usually not representative of natural ice clouds.
     \ifthreedmystic{
@@ -599,18 +599,18 @@ def get_cloud_documentation():
     Works only in MYSTIC and in combination with \code{mc_panorama_forward} and \code{mc_sample_grid 360 180}.
      }
     \parameter{filename}
-    Read optical properties from specified filename; file format is as produced 
-    by the \code{mie} tool of {\sl libRadtran} (see \code{output\_user netcdf}). 
+    Read optical properties from specified filename; file format is as produced
+    by the \code{mie} tool of {\sl libRadtran} (see \code{output\_user netcdf}).
     % or by Frank Evans' \code{cloudprp}.
     \end{description}
     The default property is \code{fu}.
 
-    Please note also that, in contrast to spherical particles, there is no unique 
+    Please note also that, in contrast to spherical particles, there is no unique
     definition of effective size for non-spherical particles. In particular, the
-    above parameterizations use different definitions which, however, differ only by 
-    a constant factor. 
+    above parameterizations use different definitions which, however, differ only by
+    a constant factor.
     \citet{Yang2000}, \cite{Key2002}, and \citet{baum05a:_bulk,baum05b:_bulk}
-     use the general definition 
+     use the general definition
     \begin{equation}
        r_{\rm eff} = {{3}\over{4}}{{\int V(h) n(h) dh}\over{\int A(h) n(h) dh}}
     \end{equation}
@@ -619,29 +619,29 @@ def get_cloud_documentation():
       and $V$ and $A$ are the volume and mean
       projected area of the particles, respectively. The volume and area are
       based on the spherical diameter with equivalent volume and the
-      spherical diameter with equivalent projected area as defined by 
+      spherical diameter with equivalent projected area as defined by
       \citet{Yang2000}. On the other hand, \citet{Fu1996,Fu1998} use
       hexagonal columns and use the following definition
     \begin{equation}
        r_{\rm eff} =  {{\int D^2 L n(L) dL}\over{2 \int (D L + {\sqrt{3}\over{4}} D^2) n(L) dL}}
     \end{equation}
-      where $D$ is the width of the ice crystal (that is, the maximum diameter of the 
-      hexagonal area) and $L$ is the length. The integrand in the numerator is proportional 
-      to the volume while that in the denominator is proportional to the projected area. 
+      where $D$ is the width of the ice crystal (that is, the maximum diameter of the
+      hexagonal area) and $L$ is the length. The integrand in the numerator is proportional
+      to the volume while that in the denominator is proportional to the projected area.
       Evaluating these formulas one finds that, for the same hexagonal particle, the effective
-      radius would be $3 \sqrt{3} / 4 = 1.299$ times larger following the 
+      radius would be $3 \sqrt{3} / 4 = 1.299$ times larger following the
       \citet{Yang2000}, \citet{Key2002} definition rather than the \citet{Fu1996,Fu1998} definition.
-      As an example, an effective radius of 20$\mu m$ with 
+      As an example, an effective radius of 20$\mu m$ with
       \code{ic\_properties fu} and \code{ic\_fu reff\_def on} and
       1.299 $\cdot$ 20$\mu m$ = 26$\mu m$ with \code{ic\_properties yang} would give comparable results
-      for hexagonal columns. 
+      for hexagonal columns.
     To use the original definition of the effective radius by \citet{Fu1996,Fu1998} use
     \code{ic\_fu reff\_def on}!
 
-    With the optional argument \code{interpolate} the ice cloud optical properties are interpolated 
-    over wavelength; useful for precalculated optical property files defined with \code{ic\_properties}. 
-    Please note that this option may be extremely memory-consuming because for each internal wavelength 
-    a full set of Legendre moments of the phase function is stored (up to several thousands). 
+    With the optional argument \code{interpolate} the ice cloud optical properties are interpolated
+    over wavelength; useful for precalculated optical property files defined with \code{ic\_properties}.
+    Please note that this option may be extremely memory-consuming because for each internal wavelength
+    a full set of Legendre moments of the phase function is stored (up to several thousands).
         ''',
 
         'ic_modify' : r'''
@@ -651,7 +651,7 @@ def get_cloud_documentation():
     }
     This option is identical to \code{wc\_modify}.
     Please refer to \code{wc\_modify} for a detailed description of \code{variable}.
-    
+
     If you use this option in combination with the ice
     cloud properties by \citet{Fu1996}, please make sure that you understand
     the explanation of \code{ic\_fu}.
@@ -662,26 +662,26 @@ def get_cloud_documentation():
     \code{hey} parameterizations, see also  \code{ic\_properties key/yang/hey}.
     \fcode{
     ic\_habit type
-    } 
-    For Key/Yang \code{type} may be one of \code{solid-column}, 
-    \code{hollow-column}, \code{rough-aggregate}, \code{rosette-4}, 
+    }
+    For Key/Yang \code{type} may be one of \code{solid-column},
+    \code{hollow-column}, \code{rough-aggregate}, \code{rosette-4},
     \code{rosette-6}, \code{plate}, \code{droxtal}, \code{dendrite}
     and \code{spheroid}. Please note that this parameterization is only valid for
-    a restricted size range, depending on the habit (see table 1 in 
+    a restricted size range, depending on the habit (see table 1 in
     \citet{Key2002}. Also, some of the habits are only available for
     wavelengths below 5 micrometer (\code{rosette-4}) while others are only available
     for wavelengths larger than 3 micrometer (\code{droxtal}, \code{spheroid}).
 
-    For \code{hey} the following habits can be chosen: \code{solid-column}, 
-    \code{hollow-column}, \code{rough-aggregate}, \code{rosette-6}, 
-    \code{plate}, \code{droxtal}, and the general habit mixture \code{ghm} 
+    For \code{hey} the following habits can be chosen: \code{solid-column},
+    \code{hollow-column}, \code{rough-aggregate}, \code{rosette-6},
+    \code{plate}, \code{droxtal}, and the general habit mixture \code{ghm}
         which follows the ``recipe'' by \citet{baum05a:_bulk}. All
     habits and the habit mixture are available for effective radii from 5 to 90 micrometers in
     the wavelength region from 0.2 to 5 micrometers.
 
         The parameterization \code{baum\_v36} includes the general habit mixture
-        \code{ghm} and the habits \code{solid-column} and \code{aggregate}, 
-        all crystals modeled with severe roughness.          
+        \code{ghm} and the habits \code{solid-column} and \code{aggregate},
+        all crystals modeled with severe roughness.
         ''',
 
         'ic_habit_yang2013' : r'''
@@ -689,25 +689,25 @@ def get_cloud_documentation():
         \code{ic\_properties yang2013}.
     \fcode{
     ic\_habit type roughness
-    } 
-    The following habits are available: \code{column\_8elements}, 
-        \code{droxtal}, \code{hollow\_bullet\_rosette}, \code{hollow\_column}, 
-        \code{plate}, \code{plate\_10elements}, \code{plate\_5elements}, \code{solid\_bullet\_rosette}, 
+    }
+    The following habits are available: \code{column\_8elements},
+        \code{droxtal}, \code{hollow\_bullet\_rosette}, \code{hollow\_column},
+        \code{plate}, \code{plate\_10elements}, \code{plate\_5elements}, \code{solid\_bullet\_rosette},
         and \code{solid\_column}.
 
-        For each habit three degrees of roughness needs to be specified, options are \code{smooth}, 
-        \code{moderate} and \code{severe}.         
-        
-        ''',        
+        For each habit three degrees of roughness needs to be specified, options are \code{smooth},
+        \code{moderate} and \code{severe}.
+
+        ''',
 
         'ic_fu' : r'''
     \fcode{
     ic\_fu reff\_def on/off
     }
     Specify wich definition of the effective radius is used.
-    
+
     If \code{on} the parameterization uses the original definition of the effective radius
-    as specified in \citet{Fu1996,Fu1998}. 
+    as specified in \citet{Fu1996,Fu1998}.
 
     Default is \code{off}. The same definition of the effective radius is used as the \citet{Key2002},
     \citet{Yang2000} and \citet{baum05a:_bulk,baum05b:_bulk}
@@ -716,34 +716,34 @@ def get_cloud_documentation():
     \fcode{
     ic\_fu deltascaling on/off
     }
-    Specify if the \citet{Fu1996} optical properties are delta-scaled or not. 
+    Specify if the \citet{Fu1996} optical properties are delta-scaled or not.
 
     If \code{on} delta-scaling is switched on.
 
     If  \code{off} delta-scaling is switched off. The default is without delta-scaling.
-    Please note that this was changed on July 22, 2008: 
+    Please note that this was changed on July 22, 2008:
     Before, delta-scaling was switched on by default which might have
     caused some confusion, because irradiance calculations were not
     consistent with the other ice cloud parameterizations implemented in
-    \code{uvspec}. 
-    Using the \citet{Fu1996} parameterization in combination with one of 
+    \code{uvspec}.
+    Using the \citet{Fu1996} parameterization in combination with one of
     \code{ic\_modify} you now get
     consistent results with all other ice cloud parameterizations.
-    
+
     %THIS IS THE OLD DOCUMENTATION (BEFORE CHANGE OF DELTA-SCALING
     %                     DEFAULT).
     %
-    %It has been confirmed that the difference with and 
-    %without delta-scaling is typically on the order of less than 1 - 2\% 
+    %It has been confirmed that the difference with and
+    %without delta-scaling is typically on the order of less than 1 - 2\%
     %and therefore it was decided to switch delta-scaling off by default.
     %Please note that this has nothing to do with the internal delta-scaling
-    %by the solvers: e.g. disort2 always applies it's own internal delta-scaling 
+    %by the solvers: e.g. disort2 always applies it's own internal delta-scaling
     %anyway. (THE FOLLOWING NEEDS TO BE MODIFIED).
     %If you define a cloud only by its microphysical properties (ice water
     %content, effective radius), delta-scaling should certainly be switched
-    %on and you do not need to read further. 
+    %on and you do not need to read further.
     %If, however, you want to
-    %use the Fu (1996) parameterization in combination with one of 
+    %use the Fu (1996) parameterization in combination with one of
     %\code{ic_set_tau/tau550/gg/ssa} or \code{ic_scale_gg/ssa} it might be
     %reasonable to switch delta-scaling off and you should make sure that
     %you understand the following. Citing from Fu (1996): "For nonspherical
@@ -778,7 +778,7 @@ def get_cloud_documentation():
 
 
                 'ic_raytracing_file' : r'''
-        ASCII file containing ice crystal properties for geometric optics ray tracing. 
+        ASCII file containing ice crystal properties for geometric optics ray tracing.
         \fcode{
         ic\_raytracing\_file file
         }
@@ -794,7 +794,7 @@ def get_cloud_documentation():
 
 
                 'cloud_fraction_file' : r'''
-        File containing a cloud fraction profile. 
+        File containing a cloud fraction profile.
         \fcode{
         cloud\_fraction\_file file
         }
@@ -805,16 +805,16 @@ def get_cloud_documentation():
                 ''',
 
                 'cloud_overlap' : r'''
-        Cloud overlap assumption. 
+        Cloud overlap assumption.
         \fcode{
         cloud\_overlap type
         }
         Following types are implemented:
         \begin{description}
-        \item[rand] Random overlap of cloud layers 
+        \item[rand] Random overlap of cloud layers
         \item[maxrand]  Maximum random overlap scheme
         \item[max]      Maximum overlap scheme
-        \item[off]      Turn off cloud overlap for ECMWF clouds                                        
+        \item[off]      Turn off cloud overlap for ECMWF clouds
         \end{description}
         Per default the \code{cloud\_overlap} scheme is switched off.
                 ''',
@@ -829,16 +829,16 @@ def get_cloud_documentation():
         \begin{description}
         \item[ic] Cloud cover of ice cloud, where the cloud properties are taken
         from \code{ic\_file}.
-        \item[wc] Cloud cover of water cloud, where the cloud properties are taken 
+        \item[wc] Cloud cover of water cloud, where the cloud properties are taken
         from \code{wc\_file}.
         \end{description}
 
         When a cloud cover is specified, the result will be calculated by
-        the independent pixel approximation (IPA), that is, as weighted average 
-        of cloudless sky and overcast sky. 
+        the independent pixel approximation (IPA), that is, as weighted average
+        of cloudless sky and overcast sky.
         Please note that, if both \code{cloudcover ic} and
         \code{cloudcover wc} are set, both must be equal.
-        
+
         This option is ignored, if the option \code{cloud\_fraction\_file} is used.
                 ''',
     }
diff --git a/src_py/general_atmosphere_options.py b/src_py/general_atmosphere_options.py
index 0a96b6b..2e25ac6 100644
--- a/src_py/general_atmosphere_options.py
+++ b/src_py/general_atmosphere_options.py
@@ -1,26 +1,26 @@
 
 """--------------------------------------------------------------------
  * $Id$
- * 
+ *
  * This file is part of libRadtran.
  * Copyright (c) 1997-2012 by Arve Kylling, Bernhard Mayer,
  *                            Claudia Emde, Robert Buras
  *
  * ######### Contact info: http://www.libradtran.org #########
  *
- * This program is free software; you can redistribute it and/or 
- * modify it under the terms of the GNU General Public License   
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.        
- * 
- * This program is distributed in the hope that it will be useful, 
- * but WITHOUT ANY WARRANTY; without even the implied warranty of  
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the   
- * GNU General Public License for more details.                    
- * 
- * You should have received a copy of the GNU General Public License          
- * along with this program; if not, write to the Free Software                
- * Foundation, Inc., 59 Temple Place - Suite 330, 
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
  * Boston, MA 02111-1307, USA.
  *--------------------------------------------------------------------"""
 
@@ -36,7 +36,7 @@ class setup_general_atm_group():
 		atmos_region = option(
 			name='atmos_region',
 			group='general atmosphere',
-			helpstr='Define atmospheric region.', 
+			helpstr='Define atmospheric region.',
 			documentation=documentation['atmos_region'],
 			tokens = [ addSetting( name="Input.rte.mc.backward.yes", setting=1),
 				addToken(name="Input.rte.mc.ixmin", datatype=int, default='NOT_DEFINED_INTEGER'),
@@ -51,7 +51,7 @@ class setup_general_atm_group():
 		no_absorption = option(
 			name='no_absorption',
 			group='general atmosphere',
-			helpstr='Switch off absorption.', 
+			helpstr='Switch off absorption.',
 			documentation=documentation['no_absorption'],
 			gui_inputs=(TextInput(name='no_absorption',optional=True),),
 			tokens = [ addSetting(name='ispoff', setting='get_caothoff_index(&Input.caothoff,&Input.n_caothoff, "all")' ),
@@ -64,7 +64,7 @@ class setup_general_atm_group():
 		no_scattering = option(
 			name='no_scattering',
 			group='general atmosphere',
-			helpstr='Switch off scattering.', 
+			helpstr='Switch off scattering.',
 			documentation=documentation['no_scattering'],
 			gui_inputs=(TextInput(name='no_scattering',optional=True),),
 			tokens = [ addSetting(name='ispoff', setting='get_caothoff_index(&Input.caothoff,&Input.n_caothoff, "all")' ),
@@ -81,20 +81,20 @@ class setup_general_atm_group():
 			documentation=documentation['interpret_as_level'],
 			gui_inputs=(TextInput(name='Input.caothoff[isp].layer'),),
 			tokens = [ addToken(name='isp', datatype=CaothType ),
-				addSetting( name='Input.caoth[isp].layer', setting='FALSE') ], 
+				addSetting( name='Input.caoth[isp].layer', setting='FALSE') ],
 			parents=['wc_file','ic_file','profile_file'],
 			non_unique=True,
 		)
-		
+
 		zout_interpolate = option(
-			name='zout_interpolate', 
+			name='zout_interpolate',
 			group='general_atmosphere',
-			helpstr='Interpolate atmospheric profiles.', 
-			documentation=documentation['zout_interpolate'], 
+			helpstr='Interpolate atmospheric profiles.',
+			documentation=documentation['zout_interpolate'],
 			tokens=addSetting(name='Input.atm.zout_interpolate', setting='ZOUT_INTERPOLATE', default='NO_ZOUT_INTERPOLATE'),
 			parents=['uvspec'],
 			)
-	
+
 		z_interpolate = not_yet_lex2py_option(
 			name='z_interpolate',
 			group='general_atmosphere',
@@ -105,25 +105,25 @@ class setup_general_atm_group():
 		)
 
 		atm_z_grid = option(
-			name='atm_z_grid', 
-			group='atmosphere', 
+			name='atm_z_grid',
+			group='atmosphere',
 			documentation=documentation['atm_z_grid'],
 			gui_inputs=(TextInput(name='Input.atm.z_atm_forced_sea'),),
-			tokens= [ addToken(name='Input.atm.z_atm_forced_sea', datatype=SignedFloats), 
+			tokens= [ addToken(name='Input.atm.z_atm_forced_sea', datatype=SignedFloats),
 				addSetting(name='Input.atm.nz_atm_forced_sea', setting='ntokens') ],
 			parents=['uvspec'],
 			)
 
 		reverse_atmosphere = option(
-			name='reverse_atmosphere', 
-			group='atmosphere', 
+			name='reverse_atmosphere',
+			group='atmosphere',
 			helpstr='Atmosphere is turned on the head.',
 			documentation=documentation['reverse_atmosphere'],
-			tokens=addSetting(name='Input.rte.reverse', setting=1, default=0), 
+			tokens=addSetting(name='Input.rte.reverse', setting=1, default=0),
 			parents=['uvspec'],
 			)
 
-		self.options = [atmos_region, no_absorption, no_scattering, 
+		self.options = [atmos_region, no_absorption, no_scattering,
 				interpret_as_level, zout_interpolate, z_interpolate,
 				atm_z_grid, reverse_atmosphere]
 
@@ -153,17 +153,17 @@ def get_general_atmosphere_documentation():
 	}
 	If \code{name} is not set, all absorption (molecular, aerosol, cloud, ice cloud, and any profile) is switched off.
 
-	If used together with \code{xxx\_modify set tau} this might be a bit confusing but 
-	probably the most logical way. E.g. when using \code{aerosol\_default} and 
+	If used together with \code{xxx\_modify set tau} this might be a bit confusing but
+	probably the most logical way. E.g. when using \code{aerosol\_default} and
 	\code{aerosol\_modify set tau 1}, the aerosol optical thickness is set to 1,
-	with 0.940539 scattering and 0.059461 absorption. If \code{no\_absorption} 
+	with 0.940539 scattering and 0.059461 absorption. If \code{no\_absorption}
 	is added, the absorption optical thickness is set to 0 while the scattering
-	optical thickness is preserved at 0.940539 (even though 1 was specified by 
-	the user). We find this the most logical solution of the problem because 
-	by switching \code{no\_absorption} off and on one tests the effect of the 
-	absorber in an isolated way, rather than mixing absorption and scattering. 
-	The same is true for water and ice clouds. Note, that thermal emission of 
-	molecules is also switched off. 
+	optical thickness is preserved at 0.940539 (even though 1 was specified by
+	the user). We find this the most logical solution of the problem because
+	by switching \code{no\_absorption} off and on one tests the effect of the
+	absorber in an isolated way, rather than mixing absorption and scattering.
+	The same is true for water and ice clouds. Note, that thermal emission of
+	molecules is also switched off.
 
 	Possible choises for the optional argument \code{name} are:
 	\begin{description}
@@ -176,7 +176,7 @@ def get_general_atmosphere_documentation():
 	\fcode{
 	no\_scattering [name]
 	}
-	If \code{name} is not set, all scattering (molecular, aerosol, cloud, ice cloud, and any profile) is switched off. 
+	If \code{name} is not set, all scattering (molecular, aerosol, cloud, ice cloud, and any profile) is switched off.
 
 	Possible choises for the optional argument \code{name} are:
 	\begin{description}
@@ -190,7 +190,7 @@ def get_general_atmosphere_documentation():
 
 		'interpret_as_level'	: r'''
 	Interpret profile properties as level properties (this was the default
-	behaviour before version 1.4). 
+	behaviour before version 1.4).
 	\fcode{
 	interpret\_as\_level profile
 	}
@@ -200,11 +200,11 @@ def get_general_atmosphere_documentation():
 	follows:
 	\begin{verbatim}
 	#      z     LWC    R\_eff
-	#     (km)  (g/m^3) (um)  
-	       5.000    0      0   
-	       4.000   0.2   12.0 
-	       3.000   0.1   10.0 
-	       2.000   0.1    8.0 
+	#     (km)  (g/m^3) (um)
+	       5.000    0      0
+	       4.000   0.2   12.0
+	       3.000   0.1   10.0
+	       2.000   0.1    8.0
 	\end{verbatim}
 	The value 0.2 g/m$^3$ refers to altitude 4.0km, as e.g. in a
 	radiosonde profile. The properties of each layer are calculated as
@@ -217,13 +217,13 @@ def get_general_atmosphere_documentation():
 	between 3 and 4km are cloudy while those between 1 and 2km and between
 	4 and 5km are not.
 
-	Note that since version 1.4 the default is to interpret profile properties as 
-	layer properties. For example wc properties are assumed to be constant over the layer. 
+	Note that since version 1.4 the default is to interpret profile properties as
+	layer properties. For example wc properties are assumed to be constant over the layer.
 	The layer reaches from the level, where the properties are defined in the
 	\code{wc\_file} to the level above that one.  The following lines
 	\begin{verbatim}
 	#      z     LWC    R_eff
-	#     (km)  (g/m^3) (um) 
+	#     (km)  (g/m^3) (um)
 	       4.000   0.0   0.0
 	       3.000   1.0  10.0
 	\end{verbatim}
@@ -231,9 +231,9 @@ def get_general_atmosphere_documentation():
 		''',
 
 		'atm_z_grid' : r'''
-	With this option the vertical resolution of the \code{atmosphere\_file} data is changed to 
-	the levels (in km above sea surface) given as argument. This might be useful in oder to reduce the number 
-	of levels (save computational time)\ifmystic{ or in order to easily adjust the atmosphere profile to the resolution 
+	With this option the vertical resolution of the \code{atmosphere\_file} data is changed to
+	the levels (in km above sea surface) given as argument. This might be useful in oder to reduce the number
+	of levels (save computational time)\ifmystic{ or in order to easily adjust the atmosphere profile to the resolution
 	of a Monte Carlo cloud file \code{wc\_file 3D} or \code{ic\_file 3D}}.
 	\fcode{
 	atm\_z\_grid 0 2 4 6 8 10 20 30 ...
@@ -242,21 +242,21 @@ def get_general_atmosphere_documentation():
 
 		'zout_interpolate' : r'''
 	The z-grid of optical properties is determined by the \code{atmosphere\_file},
-	and, if specified, by other profile files like \code{mol\_file}, \code{rh\_file}, 
-	or \code{refractive\_index\_file}. 
-	Additional levels might be introduced by the \code{zout} 
-	option and the second argument of the \code{altitude} option. By default 
-	(if \code{zout\_interpolate} is not specified) levels introduced 
-	by the \code{zout} option will not affect the optical property 
-	profiles, that is, the optical properties are constant within the layers specified by 
+	and, if specified, by other profile files like \code{mol\_file}, \code{rh\_file},
+	or \code{refractive\_index\_file}.
+	Additional levels might be introduced by the \code{zout}
+	option and the second argument of the \code{altitude} option. By default
+	(if \code{zout\_interpolate} is not specified) levels introduced
+	by the \code{zout} option will not affect the optical property
+	profiles, that is, the optical properties are constant within the layers specified by
 	the \code{atmosphere\_file} and profile files.
-	If \code{zout\_interpolate} is specified, the atmospheric profiles (tracegases, temperature ...) 
-	are interpolated to the levels introduced by \code{zout}, and optical 
+	If \code{zout\_interpolate} is specified, the atmospheric profiles (tracegases, temperature ...)
+	are interpolated to the levels introduced by \code{zout}, and optical
 	properties are determined from the interpolated atmospheric properties.
 	If \code{heating\_rate}, \code{rte\_solver polradtran}, \code{rte\_solver rodents},
 	\code{rte\_solver twostrebe}, \code{rte\_solver twomaxrnd}, \code{rte\_solver twomaxrnd3C}, \code{rte\_solver dynamic\_twostream}
-	is specified, \code{zout\_interpolate} 
-	will also be automatically activated. 
+	is specified, \code{zout\_interpolate}
+	will also be automatically activated.
 	\code{zout\_interpolate} generally causes smoother variation of the optical properties.
 		''',
 
diff --git a/src_py/geometry_options.py b/src_py/geometry_options.py
index ae4312e..bfa1158 100644
--- a/src_py/geometry_options.py
+++ b/src_py/geometry_options.py
@@ -1,29 +1,29 @@
 """--------------------------------------------------------------------
  * $Id$
- * 
+ *
  * This file is part of libRadtran.
  * Copyright (c) 1997-2012 by Arve Kylling, Bernhard Mayer,
  *                            Claudia Emde, Robert Buras
  *
  * ######### Contact info: http://www.libradtran.org #########
  *
- * This program is free software; you can redistribute it and/or 
- * modify it under the terms of the GNU General Public License   
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.        
- * 
- * This program is distributed in the hope that it will be useful, 
- * but WITHOUT ANY WARRANTY; without even the implied warranty of  
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the   
- * GNU General Public License for more details.                    
- * 
- * You should have received a copy of the GNU General Public License          
- * along with this program; if not, write to the Free Software                
- * Foundation, Inc., 59 Temple Place - Suite 330, 
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
  * Boston, MA 02111-1307, USA.
  *--------------------------------------------------------------------"""
 
-
+import io
 from option_definition import *
 
 class setup_geometry_group():
@@ -38,19 +38,19 @@ class setup_geometry_group():
             group='geometry',
             helpstr='Solar zenith angle',
             documentation=documentation['sza'],
-            tokens = [ addToken(name='Input.atm.sza', datatype=float, default='NOT_DEFINED_FLOAT', valid_range=[0.,180.]), 
-                addSetting(name='Input.atm.sza_source', setting='SZA_DIRECT_INPUT', default='SZA_BY_TIME_AND_LOCATION') ], 
+            tokens = [ addToken(name='Input.atm.sza', datatype=float, default='NOT_DEFINED_FLOAT', valid_range=[0.,180.]),
+                addSetting(name='Input.atm.sza_source', setting='SZA_DIRECT_INPUT', default='SZA_BY_TIME_AND_LOCATION') ],
             parents=['uvspec'],
             non_parents=['sza_file','ECHAM_sza'],
         )
 
         sza_file = option(
-            name='sza_file', 
+            name='sza_file',
             group='geometry',
-            helpstr='Location of solar zenith angle file.', 
-            documentation=documentation['sza_file'], 
-            tokens = [ addToken(name='Input.filename[FN_SZA]', datatype=file),
-                addSetting(name='Input.atm.sza_source', setting='SZA_FROM_SZA_FILE', default='SZA_BY_TIME_AND_LOCATION') ], 
+            helpstr='Location of solar zenith angle file.',
+            documentation=documentation['sza_file'],
+            tokens = [ addToken(name='Input.filename[FN_SZA]', datatype=io.IOBase),
+                addSetting(name='Input.atm.sza_source', setting='SZA_FROM_SZA_FILE', default='SZA_BY_TIME_AND_LOCATION') ],
             parents=['uvspec'],
             non_parents=['sza', 'ECHAM_sza'],
         )
@@ -59,8 +59,8 @@ class setup_geometry_group():
             name='phi0',
             group='geometry',
             helpstr='Solar azimuth angle',
-            documentation=documentation['phi0'], 
-            tokens=addToken(name='Input.atm.phi0', datatype=float, valid_range=[-360.,360.]), 
+            documentation=documentation['phi0'],
+            tokens=addToken(name='Input.atm.phi0', datatype=float, valid_range=[-360.,360.]),
             parents=['uvspec'],
         )
 
@@ -88,13 +88,13 @@ class setup_geometry_group():
             childs=[]
         )
 
-        mc_bw_umu_file = option( 
+        mc_bw_umu_file = option(
             name='mc_bw_umu_file',
             group='geometry',
-            helpstr='Define a different umu and phi for each pixel.', 
+            helpstr='Define a different umu and phi for each pixel.',
             documentation=documentation['mc_bw_umu_file'],
             gui_inputs=(FileInput(name='filename'),),
-            tokens=[ addToken(name="Input.rte.mc.filename[FN_MC_UMU]", datatype=file),
+            tokens=[ addToken(name="Input.rte.mc.filename[FN_MC_UMU]", datatype=io.IOBase),
                 addSetting(name='Input.rte.mc.allocate_umu_and_phi',setting=True) ],
             parents=['mc_backward'],
             speaker='rte_solver',
@@ -106,9 +106,9 @@ class setup_geometry_group():
             name='earth_radius',
             group='geometry',
             helpstr='Radius of the Earth in km',
-            documentation=documentation['earth_radius'], 
+            documentation=documentation['earth_radius'],
             tokens=addToken(name='Input.r_earth', datatype=float, default=6370.0),
-            parents=['uvspec'], 
+            parents=['uvspec'],
         )
 
         latitude = option(
@@ -116,13 +116,13 @@ class setup_geometry_group():
             group='geometry',
             helpstr='Specify the latitude of the location to simulate.',
             documentation=documentation['latitude'],
-            gui_inputs=( ListInput(name='hemisphere', valid_range=['n','s']), FloatInput(name='degrees',valid_range=[0,180]), 
+            gui_inputs=( ListInput(name='hemisphere', valid_range=['n','s']), FloatInput(name='degrees',valid_range=[0,180]),
                 FloatInput(name='minutes',valid_range=[0,60],optional=True), FloatInput(name='seconds',valid_range=[0,60], optional=True),),
             tokens = [ addLogical(name='Input.lat_signum',logicals=['n','s'],setting='LATITUDE_SIGNUM_'),
                 addToken(name='Input.lat_degrees', datatype=float),
                 addToken(name='Input.lat_minutes', datatype=float, optional=True),
                 addToken(name='Input.lat_seconds', datatype=float, optional=True) ],
-            parents=['uvspec'], 
+            parents=['uvspec'],
             extra_dependencies=['latitude','longitude'],
             showInGui=False
         )
@@ -132,7 +132,7 @@ class setup_geometry_group():
             group='geometry',
             helpstr='Specify the longitude of the location to simulate.',
             documentation=documentation['longitude'],
-            gui_inputs=( ListInput(name='hemisphere', valid_range=['e','w']), FloatInput(name='degrees',valid_range=[0,180]), 
+            gui_inputs=( ListInput(name='hemisphere', valid_range=['e','w']), FloatInput(name='degrees',valid_range=[0,180]),
                 FloatInput(name='minutes',valid_range=[0,60],optional=True), FloatInput(name='seconds',valid_range=[0,60], optional=True),),
             tokens = [ addLogical(name='Input.lon_signum',logicals=['e','w'],setting='LONGITUDE_SIGNUM_'),
                 addToken(name='Input.lon_degrees', datatype=float),
@@ -147,18 +147,18 @@ class setup_geometry_group():
             name='day_of_year',
             group='geometry',
             helpstr='Correction fo sun-earth distance',
-            documentation=documentation['day_of_year'], 
+            documentation=documentation['day_of_year'],
             tokens=addToken(name='Input.UTC.tm_yday', datatype=int, default='NOT_DEFINED_INTEGER' ),
-            parents=['uvspec'], 
+            parents=['uvspec'],
         )
 
         mc_bcond = option(
             name='mc_bcond',
             group='geometry',
-            helpstr='Define MYSTIC boundary conditions.', 
-            documentation=documentation['mc_bcond'], 
-            tokens=addLogical(name='Input.rte.mc.bcond', logicals=['periodic','mirror','absorb'], setting='MCBCOND_' ), 
-            parents=['uvspec'], 
+            helpstr='Define MYSTIC boundary conditions.',
+            documentation=documentation['mc_bcond'],
+            tokens=addLogical(name='Input.rte.mc.bcond', logicals=['periodic','mirror','absorb'], setting='MCBCOND_' ),
+            parents=['uvspec'],
             speaker='rte_solver',
             enable_values=("mystic","montecarlo"),
             mystic =True,
@@ -169,7 +169,7 @@ class setup_geometry_group():
         mc_sample_grid = option(
             name='mc_sample_grid',
             group='geometry',
-            helpstr='Sample grid size (Nx Ny [dx dy]) for MYSTIC.', 
+            helpstr='Sample grid size (Nx Ny [dx dy]) for MYSTIC.',
             documentation=documentation['mc_sample_grid'],
             tokens= [ addToken(name="Input.rte.mc.Nx_sample", datatype=int),
                   addToken(name="Input.rte.mc.Ny_sample", datatype=int),
@@ -200,7 +200,7 @@ class setup_geometry_group():
         mc_spherical3D_scene = option(
             name='mc_spherical3D_scene',
             group='geometry',
-            helpstr='Define scene on globe.', 
+            helpstr='Define scene on globe.',
             documentation=documentation['mc_spherical3D_scene'],
             tokens=[addSetting(name='Input.rte.mc.spherical3D_scene', setting=1),
                 addToken(name='Input.rte.mc.spherical3D_scene_lon_min', datatype=float, gui_name='LON_W'),
@@ -217,7 +217,7 @@ class setup_geometry_group():
         mc_satellite_view = option(
             name='mc_satellite_view',
             group='geometry',
-            helpstr='Simulate a satellite image.', 
+            helpstr='Simulate a satellite image.',
             documentation=documentation['mc_satellite_view'],
             tokens=[addSetting(name='Input.rte.mc.pan_angles', setting='calloc (4, sizeof(double))'),
                 addToken(name='Input.rte.mc.pan_angles[0]', datatype=Double),
@@ -238,7 +238,7 @@ class setup_geometry_group():
         mc_satellite_position = option(
             name='mc_satellite_position',
             group='geometry',
-            helpstr='Define the position of the satellite.', 
+            helpstr='Define the position of the satellite.',
             documentation=documentation['mc_satellite_position'],
             tokens=[addSetting(name='Input.rte.mc.sensorposition', setting='MC_SENSORPOSITION_SPHERICAL'),
                 addToken(name='Input.rte.mc.sensorposition_lon', datatype=float),
@@ -253,7 +253,7 @@ class setup_geometry_group():
         mc_sun_position = option(
             name='mc_sun_position',
             group='geometry',
-            helpstr='Sun position', 
+            helpstr='Sun position',
             documentation=documentation['mc_sun_position'],
             tokens=[addSetting(name='Input.atm.sza_source', setting='SZA_DIRECT_INPUT'),
                 addToken(name='Input.atm.phi0_spher', datatype=float),
@@ -268,7 +268,7 @@ class setup_geometry_group():
         mc_sensordirection = option(
             name='mc_sensordirection',
             group='geometry',
-            helpstr='Define viewing direction of an irradiance sensor.', 
+            helpstr='Define viewing direction of an irradiance sensor.',
             documentation=documentation['mc_sensordirection'],
             tokens=[ addToken(name="Input.rte.mc.sensordirection_dx", datatype=float, gui_name='dx'),
                 addToken(name="Input.rte.mc.sensordirection_dy", datatype=float, gui_name='dy'),
@@ -283,7 +283,7 @@ class setup_geometry_group():
         mc_sensorposition = option(
             name='mc_sensorposition',
             group='geometry',
-            helpstr='Define the position of a sensor.', 
+            helpstr='Define the position of a sensor.',
             documentation=documentation['mc_sensorposition'],
             tokens=[  addToken(name="Input.rte.mc.sensorposition_x", datatype=float, gui_name='x'),
                   addToken(name="Input.rte.mc.sensorposition_y", datatype=float, gui_name='y'),
@@ -297,12 +297,12 @@ class setup_geometry_group():
         )
 
         mc_reference_to_nn = option(
-            name='mc_reference_to_nn', 
+            name='mc_reference_to_nn',
             group='geometry',
             helpstr='The sampled pixels correspond to he surface pixels.',
             documentation=documentation['mc_reference_to_nn'],
-            tokens=[ addSetting(name='Input.rte.mc.reference_to_NN', setting=1, default=0)], 
-            parents=['mc_backward'],  
+            tokens=[ addSetting(name='Input.rte.mc.reference_to_NN', setting=1, default=0)],
+            parents=['mc_backward'],
             speaker='rte_solver',
             enable_values=("mystic","montecarlo"),
             threedmystic =True
@@ -311,7 +311,7 @@ class setup_geometry_group():
         mc_panorama_forward = option(
             name='mc_panorama_forward',
             group='geometry',
-            helpstr='Simulate a 4pi panorama with forward MYSTIC.', 
+            helpstr='Simulate a 4pi panorama with forward MYSTIC.',
             documentation=documentation['mc_panorama_forward'],
             tokens=[addSetting(name='Input.rte.mc.pan_angles', setting='calloc (4, sizeof(double))'),
                 addSetting(name='Input.rte.mc.pan_angles[0]', setting=0.0),
@@ -329,11 +329,11 @@ class setup_geometry_group():
         mc_panorama_file = option(
             name='mc_panorama_file',
             group='geometry',
-            helpstr='Simulate a panorama with user-defined angles.', 
+            helpstr='Simulate a panorama with user-defined angles.',
             documentation=documentation['mc_panorama_file'],
             tokens=[addSetting(name='Input.rte.mc.panorama', setting='PAN_MODE_FILE'),
                 addSetting(name='Input.rte.mc.allocate_umu_and_phi', setting=True),
-                addToken(name='Input.rte.mc.filename[FN_MC_PANORAMA_ANGLES]', datatype=file)],
+                addToken(name='Input.rte.mc.filename[FN_MC_PANORAMA_ANGLES]', datatype=io.IOBase)],
             parents=['mc_backward'],
             non_parents=['mc_panorama_view','mc_satellite_view'],
             speaker='rte_solver',
@@ -344,7 +344,7 @@ class setup_geometry_group():
         mc_panorama_view = option(
             name='mc_panorama_view',
             group='geometry',
-            helpstr='Simulate a panorama.', 
+            helpstr='Simulate a panorama.',
             documentation=documentation['mc_panorama_view'],
             tokens=[addSetting(name='Input.rte.mc.pan_angles', setting='calloc (4, sizeof(double))'),
                 addToken(name='Input.rte.mc.pan_angles[0]', datatype=Double),
@@ -364,17 +364,17 @@ class setup_geometry_group():
         mc_panorama_alignment = option(
             name='mc_panorama_alignment',
             group='geometry',
-            helpstr='Panorama alignment.', 
+            helpstr='Panorama alignment.',
             documentation=documentation['mc_panorama_alignment'],
             tokens=addLogical(name='Input.rte.mc.pan_alignment',logicals=['mu','sun','zenith'],setting='PAN_ALIGNMENT_'),
             threedmystic=True,
             parents=['mc_panorama_view','mc_panorama_file'],
-        )           
+        )
 
         mc_panorama = option(
             name='mc_panorama',
             group='geometry',
-            helpstr='Panorama settings.', 
+            helpstr='Panorama settings.',
             documentation=documentation['mc_panorama'],
             tokens=[addLogical(name='id',logicals=['distr_photons_over_pixel','no_pixel','quicklook','with_direct_rad','weight_with_cos','circumsolar_var_red','transmittance'],setting='PAN_FLAG_'),
                 addSetting(name='Input.rte.mc.pan[id]',setting=1) ],
@@ -386,7 +386,7 @@ class setup_geometry_group():
         mc_blitz_position = option(
             name='mc_blitz_position',
             group='geometry',
-            helpstr='Define lightning as source.', 
+            helpstr='Define lightning as source.',
             documentation=documentation['mc_blitz_position'],
             tokens=[addSetting(name='Input.rte.mc.blitz_position', setting='calloc (6, sizeof(double))'),
                 addToken(name='Input.rte.mc.blitz_position[0]', datatype=Double),
@@ -407,12 +407,12 @@ class setup_geometry_group():
         self.options = [sza, sza_file, phi0, phi, umu, mc_bw_umu_file,
                 earth_radius,
                 latitude,longitude,
-# missing time, 
+# missing time,
                 day_of_year,
-                mc_bcond, mc_sample_grid, mc_spherical, mc_spherical3D_scene, 
+                mc_bcond, mc_sample_grid, mc_spherical, mc_spherical3D_scene,
                 mc_satellite_view, mc_satellite_position, mc_sun_position,
-                mc_sensordirection, mc_sensorposition, 
-                mc_reference_to_nn, mc_panorama_view, mc_panorama_file, 
+                mc_sensordirection, mc_sensorposition,
+                mc_reference_to_nn, mc_panorama_view, mc_panorama_file,
                 mc_panorama_alignment, mc_panorama, mc_panorama_forward,
                 mc_blitz_position,
                 ]
@@ -424,8 +424,8 @@ class setup_geometry_group():
 def get_geometry_documentation():
     return {
         'day_of_year' : r'''
-    Integer, to correct the calculated radiation quantities for the 
-    Sun-Earth distance for the specified Julian day (1-365). 
+    Integer, to correct the calculated radiation quantities for the
+    Sun-Earth distance for the specified Julian day (1-365).
     \fcode{
        day_of_year value
     }
@@ -435,7 +435,7 @@ def get_geometry_documentation():
     for that purpose.
         ''',
         'earth_radius' : r'''
-    Specify the earth radius in km. 
+    Specify the earth radius in km.
     \fcode{
         earth_radius value
     }
@@ -451,16 +451,16 @@ def get_geometry_documentation():
     where \code{N} and \code{S} stands for the northern and southern hemisphere, respectively.
     \code{deg min sec} is the position in degrees, arc minutes, and arc seconds.
     \code{deg} might also be a float number. \code{min} and \code{sec} may be obmitted.
-    The \code{latitude} information will be used for the following: 
-    
+    The \code{latitude} information will be used for the following:
+
     %\code{latitude} in combination with \code{longitude}, \code{time}, and any \code{map}-option
     %is used to select the location where to read the input data.
-    
-    \code{latitude} in combination with \code{longitude} and \code{time} is used to calculate 
+
+    \code{latitude} in combination with \code{longitude} and \code{time} is used to calculate
     the solar zenith angle, if no \code{sza} is specified (see also \code{time_interval}).
-    
+
     \code{latitude} in combination with \code{longitude} and \code{time} is used to choose a
-    suitable default atmosphere file, if no \code{atmosphere_file} is specified. 
+    suitable default atmosphere file, if no \code{atmosphere_file} is specified.
         ''',
 
         'longitude' : r'''
@@ -472,12 +472,12 @@ def get_geometry_documentation():
     where \code{E} and \code{W} stand for the eastern and western hemisphere, respectively.
     \code{deg min sec} is the position in degrees, arc minutes, and arc seconds.
     \code{deg} might also be a float number. \code{min} and \code{sec} may be obmitted.
-    For possible usage of the \code{longitude} information, see \code{latitude}. 
+    For possible usage of the \code{longitude} information, see \code{latitude}.
         ''',
 
         'mc_bcond' : r'''
     Undocumented option to define MYSTIC boundary conditions: periodic (default),
-    absorbing (\code{absorb}), mirror (\code{mirror}) -- make sure that you understand 
+    absorbing (\code{absorb}), mirror (\code{mirror}) -- make sure that you understand
     what you are doing! While \code{mirror} gives reasonable results in the thermal spectral range,
     the direct sun is messed up because it changes direction (by mirroring) without being scattered.
         ''',
@@ -502,7 +502,7 @@ def get_geometry_documentation():
         ''',
 
         'mc_coherent_backscatter' : r'''
-    Switches on coherent backscattering for lidar and radar. Works only 
+    Switches on coherent backscattering for lidar and radar. Works only
     with \code{mc_lidar} or \code{mc_radar}, use only with \code{mc_polarisation}.
         ''',
 
@@ -514,13 +514,13 @@ def get_geometry_documentation():
     }
     Variance reduction method for the calculation of circumsolar radiation.
     Re-distributes the initial backward photon directions according to DDIS phase\_max.
-    Use only if you calculate the average radiance for one large FOV (at least two times of the angular radius of the sun disk, e.g. 
+    Use only if you calculate the average radiance for one large FOV (at least two times of the angular radius of the sun disk, e.g.
     if your sensor convers 0$^\circ$ to 1$^\circ$ from the sun center or 0$^\circ$ to 5$^\circ$ from the sun
     center). For smaller FOVs (e.g 0$^\circ$ to 0.35$^\circ$) it may slow down convergence as this method does not yet consider
-    the extent of the sun disk. Results should not be wrong but you may need more photons to achieve the same 
+    the extent of the sun disk. Results should not be wrong but you may need more photons to achieve the same
     standard deviation. Consideration of the sun's extent in this method should be easy to implement, however.
     For the simulations of radiance profiles (so called sunshapes) this option should probably not be used as it will
-    only increase computing time without any benefit. For further information see Reinhardt (2013) Sect. 3.4.2 
+    only increase computing time without any benefit. For further information see Reinhardt (2013) Sect. 3.4.2
     (Dissertation, LMU, urn:nbn:de:bvb:19-164380, http://edoc.ub.uni-muenchen.de/16438/).
 
     \fcode{
@@ -528,10 +528,10 @@ def get_geometry_documentation():
     }
     With only \code{mc_panorama_view} all photons for the same pixel
     are emitted into exactly the same direction. The finite solid angle that
-    is covered by one pixel is not accounted for. With 
+    is covered by one pixel is not accounted for. With
     \code{mc_panorama distr_photons_over_pixel} the photons are distributed
-    over the FOV covered by the pixel. 
-    
+    over the FOV covered by the pixel.
+
     \fcode{
     mc_panorama no_pixel
     }
@@ -549,7 +549,7 @@ def get_geometry_documentation():
     \code{mc_panorama no_pixel} MYSTIC will calculate radiances at
     $\phi=0$, $\phi=90$ and $\phi=180$. Without this option you will get
     values for $\phi=30$, $\phi=90$ and $\phi=150$.
-    
+
     \fcode{
     mc_panorama quicklook
     }
@@ -563,22 +563,22 @@ def get_geometry_documentation():
     scattering and aerosols while using this option. The result lets you
     see roughly where your panorama is looking at surface, sunlit clouds,
     shaded clouds, or slanted clouds.
-    
+
     \fcode{
     mc_panorama with_direct_rad
-    } 
+    }
     Output is direct plus diffuse radiance.
     Use together with \code{mc_panorama distr_photons_over_pixel}.
 
     \fcode{
     mc_panorama weight_with_cos
-    } 
+    }
     Output is weighted with the cosine of the angle between photon and zenith of camera.
     Use together with \code{mc_panorama distr_photons_over_pixel}.
 
     \fcode{
     mc_panorama transmittance
-    } 
+    }
     Rather than radiance, the transmittance to the surface or top of atmosphere is calculated.
         ''',
 
@@ -599,19 +599,19 @@ def get_geometry_documentation():
     sun. Increasing $\phi$ means the direction of looking moves clock-wise
     around the sun-camera-line (seen from the sun). If the sun is in the
     zenith, the definition of $\phi$ is identical to that in \code{phi}.
-    
+
     The sub-option \code{mu} aligns the camera geometry according to the
     options \code{umu} and \code{phi}. Be aware that \code{phi0} and
     \code{phi} are defined differently!
-    
+
     The sub-option \code{zenith} makes only sense when using
     \code{mc_spherical 3D}. Then the camera is aligned to the zenith with
     respect to the lon-lat position of the camera.
         ''',
 
         'mc_panorama_file'  : r'''
-    Simulate a number of sensor directions defined in a two column file which 
-    contains an arbitrary number of azimuth amd polar angles. 
+    Simulate a number of sensor directions defined in a two column file which
+    contains an arbitrary number of azimuth amd polar angles.
     Only works with \code{mc_sensorposition} and \code{mc_backward}.
     Otherwise identical tp \code{mc_panorama_view}.
         ''',
@@ -706,7 +706,7 @@ def get_geometry_documentation():
     \code{mc_satellite_position}/\code{mc_sensorposition},
     \code{mc_sample_grid}, \code{mc_backward} and
     \code{mc_spherical 3D}. Can best be explained by following example:
-    
+
     \fcode{\\
     mc_spherical 3D \\
     mc_satellite_view PHI_W PHI_E THETA_S THETA_N \\
@@ -715,7 +715,7 @@ def get_geometry_documentation():
     mc_sun_position SUN_LON SUN_LAT \\
     mc_backward \\
     }
-    
+
     In this example, the earth is a sphere (not plane parallel). The
     satellite is in zenith above longitude SAT\_LON degrees, latitude
     SAT\_LAT degrees, and at an altitude of SAT\_ALT
@@ -729,7 +729,7 @@ def get_geometry_documentation():
     in zenith at the latitude SUN\_LAT degrees (positive meaning north) and
     longitude SUN\_LON degrees (positive meaning east). See also
     \code{mc_panorama_view}, which is a similar option.  Example for MSG:
-    
+
     \fcode{\\
     mc_spherical 3D \\
     mc_satellite_view -10 10 -10 10 \\
@@ -738,42 +738,42 @@ def get_geometry_documentation():
     mc_sun_position -10 23\# about 1PM UTC on mid summer \\
     mc_backward \\
     }
-    
+
     Only meaningful with \code{rte_solver montecarlo}.
         ''',
 
         'mc_sensordirection'  : r'''
-    Define viewing direction of an irradiance sensor in Monte Carlo backward mode. 
+    Define viewing direction of an irradiance sensor in Monte Carlo backward mode.
     \fcode{
     mc_sensordirection x-value y-value z-value
     }
-    Has been introduced for 
-    irradiance calculations in topography and might not properly work with all options. 
-    For radiance use the usual \code{umu} and \code{phi}. 
+    Has been introduced for
+    irradiance calculations in topography and might not properly work with all options.
+    For radiance use the usual \code{umu} and \code{phi}.
         ''',
 
         'mc_sensorposition'  : r'''
-    Define the position of a sensor. 
+    Define the position of a sensor.
     \fcode{
     mc_sensorposition x-value y-value z-value
     }
     Has been introduced for irradiance calculations in topography
-    and might not properly work with all options. 
+    and might not properly work with all options.
         ''',
 
         'mc_spherical' : r'''
-    Spherical geometry in MYSTIC. 
+    Spherical geometry in MYSTIC.
     \fcode{
     mc_spherical 1D
     }
-    Works only in "1D" - \code{wc_file 3D} 
+    Works only in "1D" - \code{wc_file 3D}
     and \code{ic_file 3D} are not yet considered. If \code{mc_spherical} is selected
     \code{mc_backward} is switched on automatically. Viewing
     direction (\code{umu}, \code{phi}) and sun position
     (\code{sza}, \code{phi0}) are defined with respect to the
     sensor position specified by \code{zout}. For details about
     the implementation of spherical geometry please refer to
-    \citet{emde2007}. 
+    \citet{emde2007}.
 
     \iflidar{
     \fcode{
@@ -792,11 +792,11 @@ def get_geometry_documentation():
     this option, 3d clouds and 2d albedo maps are folded around the full
     globe when using \code{mc_spherical 3D}. This option defines the limits
     of the clouds and albedo maps in terms of longitude and latitude. Example:
-    
+
     \fcode{\\
     mc_spherical3D_scene LON_W LON_E LAT_S LAT_N \\
     }
-    
+
     The scene spans from LON\_W degrees in the west to LON\_E degrees in
     the east (positive values are east, negative are west of Greenwich)
     and from LAT\_S degrees in the south to LAT\_N degrees in the
@@ -813,22 +813,22 @@ def get_geometry_documentation():
         ''',
 
         'phi' : r'''
-    Azimuth output angles (in degrees) in increasing order. 
+    Azimuth output angles (in degrees) in increasing order.
     \fcode{
     phi values
     }
     The radiance is output at \code{phi} and \code{umu}.
     \begin{itemize}
-    \item Sensor in the North (looking South):  0 deg 
-    \item Sensor in the East  (looking West):   90 deg 
-    \item Sensor in the South (looking North):  180 deg 
-    \item Sensor in the West  (looking East):   270 deg 
+    \item Sensor in the North (looking South):  0 deg
+    \item Sensor in the East  (looking West):   90 deg
+    \item Sensor in the South (looking North):  180 deg
+    \item Sensor in the West  (looking East):   270 deg
     \end{itemize}
     For all one-dimensional solvers the absolute azimuth does not matter, but only the relative azimuth \code{phi}-\code{phi0}.
         ''',
 
         'phi0' : r'''
-    Azimuth angle of the sun (0 to 360 degrees). 
+    Azimuth angle of the sun (0 to 360 degrees).
     \fcode{phi0 value}
     \begin{itemize}
     \item Sun in the South:    0 degrees
@@ -840,7 +840,7 @@ def get_geometry_documentation():
         ''',
 
         'sza' : r'''
-    The solar zenith angle (degrees). 
+    The solar zenith angle (degrees).
     \fcode{
     sza value
     }
@@ -849,26 +849,26 @@ def get_geometry_documentation():
 
         'sza_file' : r'''
     Location of solar zenith angle file for wavelength-dependent solar
-    zenith angle. 
+    zenith angle.
     \fcode{
     sza_file file
     }
-    This option is useful if you want to simulate an instrument 
-    which scans so slowly that the solar zenith angle may change significantly during 
-    the wavelength scan. 
-    The file must have two or three columns. Column 1 is the wavelength, 
+    This option is useful if you want to simulate an instrument
+    which scans so slowly that the solar zenith angle may change significantly during
+    the wavelength scan.
+    The file must have two or three columns. Column 1 is the wavelength,
     in nm, and column 2 the corresponding  solar zenith angle. Optionally
-    the third column may contain the corresponding solar azimuth angle. The solar 
-    azimuth angle is only needed when calculating radiances. The wavelength 
-    grid may be freely set. The solar zenith and azimuth angle will be interpolated to 
+    the third column may contain the corresponding solar azimuth angle. The solar
+    azimuth angle is only needed when calculating radiances. The wavelength
+    grid may be freely set. The solar zenith and azimuth angle will be interpolated to
     the wavelength grid used for the radiation calculation.
     Comments start with \code{\#}. Empty lines are ignored.
         ''',
 
         'umu' : r'''
-    Cosine of output polar angles in increasing order, starting with 
-    negative (downwelling radiance, looking upward) values (if any) and on through 
-    positive (upwelling radiance, looking downward) values. 
+    Cosine of output polar angles in increasing order, starting with
+    negative (downwelling radiance, looking upward) values (if any) and on through
+    positive (upwelling radiance, looking downward) values.
     Must not be zero.
     \fcode{
     umu values
diff --git a/src_py/mc_options.py b/src_py/mc_options.py
index 3a05bfb..ffa7f89 100644
--- a/src_py/mc_options.py
+++ b/src_py/mc_options.py
@@ -1,41 +1,42 @@
 """--------------------------------------------------------------------
  * $Id$
- * 
+ *
  * This file is part of libRadtran.
  * Copyright (c) 1997-2012 by Arve Kylling, Bernhard Mayer,
  *                            Claudia Emde, Robert Buras
  *
  * ######### Contact info: http://www.libradtran.org #########
  *
- * This program is free software; you can redistribute it and/or 
- * modify it under the terms of the GNU General Public License   
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.        
- * 
- * This program is distributed in the hope that it will be useful, 
- * but WITHOUT ANY WARRANTY; without even the implied warranty of  
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the   
- * GNU General Public License for more details.                    
- * 
- * You should have received a copy of the GNU General Public License          
- * along with this program; if not, write to the Free Software                
- * Foundation, Inc., 59 Temple Place - Suite 330, 
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
  * Boston, MA 02111-1307, USA.
  *--------------------------------------------------------------------"""
 
+import io
 from option_definition import *
 
 class setup_mc_group():
-	
+
 	group_name = 'Monte Carlo'
 
 	def __init__(self):
 		documentation = get_mc_documentation()
 
-		mc_escape = not_yet_lex2py_option(  #TODO: bad implementation in lex_starter.l 
+		mc_escape = not_yet_lex2py_option(  #TODO: bad implementation in lex_starter.l
 			name='mc_escape',
 			group='mc',
-			helpstr='Calculate MYSTIC radiances via escape probabilities.', 
+			helpstr='Calculate MYSTIC radiances via escape probabilities.',
 			documentation=documentation['mc_escape'],
 			gui_inputs=(ListInput(name='on/off',valid_range=['on','off']),),
 			tokens=addToken(name="", datatype=str),
@@ -47,7 +48,7 @@ class setup_mc_group():
 		mc_core = option(
 			name='mc_core',
 			group='mc',
-			helpstr='Activate massive delta scaling in the core of thick clouds.', 
+			helpstr='Activate massive delta scaling in the core of thick clouds.',
 			documentation=documentation['mc_core'],
 			# gui_inputs=(ListInput(name='on/off',valid_range=['on','off'],optional=True),),
 			tokens= [ addSetting(name="Input.rte.mc.core_isactive", setting=1),
@@ -92,7 +93,7 @@ class setup_mc_group():
 		mc_vroom = option(
 			name='mc_vroom',
 			group='mc',
-			helpstr='Use Variance Reduction Methods in MYSTIC.', 
+			helpstr='Use Variance Reduction Methods in MYSTIC.',
 			documentation=documentation['mc_vroom'],
 			gui_inputs=(ListInput(name='on/off',valid_range=['on','off'],optional=True),),
 			tokens= [ addSetting(name="Input.rte.mc.vroom", setting=1),
@@ -102,11 +103,11 @@ class setup_mc_group():
 			enable_values=("mystic","montecarlo"),
 			mystic =True
 		)
-				
+
 		mc_visualize = option(
 			name='mc_visualize',
 			group='mc',
-			helpstr='Switch on OpenGL visualization for MYSTIC.', 
+			helpstr='Switch on OpenGL visualization for MYSTIC.',
 			documentation=documentation['mc_visualize'],
 			gui_inputs=(ListInput(name='hiddenline',valid_range = ['hiddenline'],optional=True),),
 			tokens= [ addSetting(name="Input.rte.mc.visualize", setting=1),
@@ -116,14 +117,14 @@ class setup_mc_group():
 			enable_values=("mystic","montecarlo"),
 			threedmystic =True
 		)
-				
-		mc_truncate = option(  
+
+		mc_truncate = option(
 			name='mc_truncate',
 			group='mc',
-			helpstr='Truncate phase function at the specified polar angle mu.', 
+			helpstr='Truncate phase function at the specified polar angle mu.',
 			documentation=documentation['mc_truncate'],
 			tokens = [ addSetting(name="Input.rte.mc.truncate", setting=0.99),
-				addToken(name="Input.rte.mc.truncate", datatype=float, optional=True) ], 
+				addToken(name="Input.rte.mc.truncate", datatype=float, optional=True) ],
 			gui_inputs=( FloatInput(name='Polar angle mu',optional=True, default=0.99), ) ,
 			parents=['uvspec'],
 			speaker='rte_solver',
@@ -132,11 +133,11 @@ class setup_mc_group():
 			showInGui =False,
                         islidar = True
 		)
-				
+
 		mc_backward = option(
 			name='mc_backward',
 			group='mc',
-			helpstr='Backward tracing of photons.', 
+			helpstr='Backward tracing of photons.',
 			documentation=documentation['mc_backward'],
 			gui_inputs=(IntegerInput(name='mc_backward_islower',optional=True),IntegerInput(name='mc_backward_jslower',optional=True),IntegerInput(name='mc_backward_isupper',optional=True),IntegerInput(name='mc_backward_jsupper',optional=True),),
 			tokens = [ addSetting( name="Input.rte.mc.backward.yes", setting=1),
@@ -158,7 +159,7 @@ class setup_mc_group():
 		mc_backward_increment = option(
 			name='mc_backward_increment',
 			group='mc',
-			helpstr='Backward tracing of photons.', 
+			helpstr='Backward tracing of photons.',
 			documentation=documentation['mc_backward_increment'],
 			gui_inputs=(IntegerInput(name='mc_backward_isstep',optional=True),IntegerInput(name='mc_backward_jsstep',optional=True),),
 			tokens = [
@@ -172,15 +173,15 @@ class setup_mc_group():
 			mystic =True
 		)
 
-        
+
 		mc_sample_cldprp = option(
-			name='mc_sample_cldprp', 
-			group='mc',  
+			name='mc_sample_cldprp',
+			group='mc',
 			helpstr='Turns on sampling of cloud properties by photons.',
 			documentation=documentation['mc_sample_cldprp'],
 			tokens=[ addSetting(name='Input.rte.mc.backward.yes', setting=1, default=0),
-				   addSetting(name='Input.rte.mc.sample_cldprp', setting=1) ], 
-			parents=['mc_backward'],  
+				   addSetting(name='Input.rte.mc.sample_cldprp', setting=1) ],
+			parents=['mc_backward'],
 			speaker='rte_solver',
 			enable_values=("mystic","montecarlo"),
 			threedmystic =True,
@@ -189,54 +190,54 @@ class setup_mc_group():
 
 		mc_surface_reflectalways = option(
 			name='mc_surface_reflectalways',
-			group='mc',  
+			group='mc',
 			helpstr='The photon is reflected and the albedo is considered by reducing the photon weight.',
 			documentation=documentation['mc_surface_reflectalways'],
-			tokens=[ addSetting(name='Input.rte.mc.reflectalways', setting=1, default=0)], 
-			parents=['uvspec'],  
+			tokens=[ addSetting(name='Input.rte.mc.reflectalways', setting=1, default=0)],
+			parents=['uvspec'],
 			speaker='rte_solver',
 			enable_values=("mystic","montecarlo"),
 			mystic =True,
 			showInGui=False,
 		)
-		
+
 		mc_DoLE = option(
 			name='mc_DoLE',
-			group='mc',  
+			group='mc',
 			helpstr='Double local estimate of specular ocean reflection to speed up convergence.',
 			documentation=documentation['mc_DoLE'],
-			tokens=[ addSetting(name='Input.rte.mc.DoLE', setting=1, default=0)], 
-			parents=['uvspec'],  
+			tokens=[ addSetting(name='Input.rte.mc.DoLE', setting=1, default=0)],
+			parents=['uvspec'],
 			speaker='rte_solver',
 			enable_values=("mystic","montecarlo"),
 			mystic =True,
 			showInGui=False,
                         islidar=True
 		)
-		
-		mc_spectral_is = option(  
-			name='mc_spectral_is', 
-			group='mc', 
-			helpstr='Turns on spectral importance sampling.', 
-			documentation=documentation['mc_spectral_is'],     
-			gui_inputs = (FloatInput(name='wavelength',optional=True,  valid_range=[0, 1000000.0]),),  
+
+		mc_spectral_is = option(
+			name='mc_spectral_is',
+			group='mc',
+			helpstr='Turns on spectral importance sampling.',
+			documentation=documentation['mc_spectral_is'],
+			gui_inputs = (FloatInput(name='wavelength',optional=True,  valid_range=[0, 1000000.0]),),
 			tokens=[addSetting(name='Input.rte.mc.spectral_is', setting=True, default=False),
-				addToken(name='Input.rte.mc.spectral_is_wvl[0]', datatype=float, valid_range=[0, 1e6],optional=True) ], 
-			parents=['uvspec'], 
+				addToken(name='Input.rte.mc.spectral_is_wvl[0]', datatype=float, valid_range=[0, 1e6],optional=True) ],
+			parents=['uvspec'],
 			speaker='rte_solver',
 			enable_values=("mystic","montecarlo"),
 			mystic =True,
                         showInGui=False
                 )
 
-		mc_aerosol_is = option(  
+		mc_aerosol_is = option(
 			name='mc_aerosol_is',
 			group='mc',
-			helpstr='Enable aerosol concentration importance sampling.', 
-			documentation=documentation['mc_aerosol_is'], 
-			tokens=[ addToken(name='Input.rte.mc.filename[FN_MC_AERIS]', datatype=file),
+			helpstr='Enable aerosol concentration importance sampling.',
+			documentation=documentation['mc_aerosol_is'],
+			tokens=[ addToken(name='Input.rte.mc.filename[FN_MC_AERIS]', datatype=io.IOBase),
 				 addSetting(name='Input.rte.mc.concentration_is', setting=True, default=False) ],
-			parents=['uvspec'], 
+			parents=['uvspec'],
 			speaker='rte_solver',
 			enable_values=("mystic","montecarlo"),
 			mystic =True,
@@ -245,29 +246,29 @@ class setup_mc_group():
                         developer=True
 		)
 
-		mc_boxairmass = option(  
+		mc_boxairmass = option(
 			name='mc_boxairmass',
 			group='mc',
-			helpstr='Calculate box-air-mass factors', 
-			documentation=documentation['mc_boxairmass'], 
+			helpstr='Calculate box-air-mass factors',
+			documentation=documentation['mc_boxairmass'],
 			tokens=[addLogical(name='id', logicals=['1D','3D'],
                                            setting='DIM_'),
                                 addSetting(name='Input.rte.mc.boxairmass[id]', setting=1)],
-			parents=['mc_backward'], 
+			parents=['mc_backward'],
 			speaker='rte_solver',
 			enable_values=("mystic","montecarlo"),
 			mystic =True,
 			showInGui = False,
                         islidar = False
 			)
-		
+
 		mc_azimuth_old = option(
 			name='mc_azimuth_old',
 			group='mc',
 			helpstr='Use old MYSTIC azimuth convention.',
-			documentation=documentation['mc_azimuth_old'], 
-			tokens=addSetting(name='Input.rte.mc.azimuth', setting='MCAZIMUTH_OLD', default ='MCAZIMUTH_NEW'),	
-			parents=['uvspec'], 
+			documentation=documentation['mc_azimuth_old'],
+			tokens=addSetting(name='Input.rte.mc.azimuth', setting='MCAZIMUTH_OLD', default ='MCAZIMUTH_NEW'),
+			parents=['uvspec'],
 			speaker='rte_solver',
 			enable_values=("mystic","montecarlo"),
 			mystic =True,
@@ -288,12 +289,12 @@ class setup_mc_group():
 		)
 
 		mc_backward_sunshape_file = option(
-			name='mc_backward_sunshape_file', 
-			group='mc', 
-			helpstr='Path to a 2-coloumned text file containing the extraterrestrial sun shape.', 
+			name='mc_backward_sunshape_file',
+			group='mc',
+			helpstr='Path to a 2-coloumned text file containing the extraterrestrial sun shape.',
 			documentation=documentation['mc_backward_sunshape_file'],
-			tokens=addToken(name='Input.rte.mc.filename[FN_MC_SUNSHAPE_FILE]', datatype=file),
-			parents=['mc_backward'], 
+			tokens=addToken(name='Input.rte.mc.filename[FN_MC_SUNSHAPE_FILE]', datatype=io.IOBase),
+			parents=['mc_backward'],
 			speaker='rte_solver',
 			enable_values=("mystic","montecarlo"),
 			mystic =True,
@@ -308,7 +309,7 @@ class setup_mc_group():
 			helpstr='Write extra photon information',
 			documentation=documentation['mc_backward_writeback'],
 			tokens=addSetting(name='Input.rte.mc.backward.writeback', setting=1),
-			parents=['mc_backward'], 
+			parents=['mc_backward'],
 			speaker='rte_solver',
 			enable_values=("mystic","montecarlo"),
 			mystic =True,
@@ -318,13 +319,13 @@ class setup_mc_group():
 
 		mc_coherent_backscatter = option(
 			name='mc_coherent_backscatter',
-			group='mc', 
+			group='mc',
 			helpstr='Switches on coherent backscattering for lidar and radar.',
-			documentation=documentation['mc_coherent_backscatter'], 
+			documentation=documentation['mc_coherent_backscatter'],
 			tokens=[addSetting(name='Input.rte.mc.coherent_backscatter',setting=1,default=0),
                                 addToken(name='Input.rte.mc.coherent_backscatter_lmode',datatype=int, optional=True,default=1),
                                 addToken(name='Input.rte.mc.coherent_backscatter_off',datatype=int, optional=True,default=0) ],
-			parents=[], 
+			parents=[],
 			speaker='rte_solver',
 			enable_values=("mystic","montecarlo"),
 			mystic =True,
@@ -335,26 +336,26 @@ class setup_mc_group():
 
 		mc_delta_scaling = option(
 			name='mc_delta_scaling',
-			group='mc', 
+			group='mc',
 			helpstr='Truncate phase function in MYSTIC.',
 			documentation=documentation['mc_delta_scaling'],
-			tokens=[ addSetting(name='Input.rte.mc.delta_scaling_mucut', setting=0.99),	
+			tokens=[ addSetting(name='Input.rte.mc.delta_scaling_mucut', setting=0.99),
 				addSetting(name='Input.rte.mc.delta_scaling_start', setting=0),
-				addToken(name='Input.rte.mc.delta_scaling_mucut', datatype=float, optional=True),	
-				addToken(name='Input.rte.mc.delta_scaling_start', datatype=int, optional =True) ], 
-			parents=['uvspec'], 
+				addToken(name='Input.rte.mc.delta_scaling_mucut', datatype=float, optional=True),
+				addToken(name='Input.rte.mc.delta_scaling_start', datatype=int, optional =True) ],
+			parents=['uvspec'],
 			speaker='rte_solver',
 			enable_values=("mystic","montecarlo"),
 			threedmystic =True,
 			showInGui =False
 		)
 
-		mc_maxscatters = option( 
+		mc_maxscatters = option(
 			name='mc_maxscatters',
 			group='mc',
 			helpstr='Photons are destroyed after n scatters. For testing only.',
-			documentation=documentation['mc_maxscatters'], 
-			tokens=addToken(name='Input.rte.mc.maxscatters', datatype=int, default = 'NOT_DEFINED_INTEGER', valid_range=[0,1e6]), # 1e6 is float, not integer!??  
+			documentation=documentation['mc_maxscatters'],
+			tokens=addToken(name='Input.rte.mc.maxscatters', datatype=int, default = 'NOT_DEFINED_INTEGER', valid_range=[0,1e6]), # 1e6 is float, not integer!??
 			parents=['uvspec'],
 			speaker='rte_solver',
 			enable_values=("mystic","montecarlo"),
@@ -363,7 +364,7 @@ class setup_mc_group():
 
 		)
 
-		mc_minscatters = option( 
+		mc_minscatters = option(
 			name='mc_minscatters',
 			group='mc',
 			helpstr='Local estimates are not performed before n scatters. For testing only',
@@ -380,7 +381,7 @@ class setup_mc_group():
 		mc_minphotons = option(
 			name='mc_minphotons',
 			group='mc',
-			helpstr='Minimum value of photons to be used per simulation.',	
+			helpstr='Minimum value of photons to be used per simulation.',
 			documentation=documentation['mc_minphotons'],
 			gui_inputs=(IntegerInput(name='Input.rte.mc.minphotons', default=0, valid_range=[0, 1000000]),),
 			tokens=addToken(name='Input.rte.mc.minphotons', datatype=int, default=0, valid_range=[0,1e6]),
@@ -391,36 +392,36 @@ class setup_mc_group():
 		)
 
 		mc_photons = option(
-			name='mc_photons', 
-			group='mc', 
-			helpstr='Total number of photons to be traced by the Monte Carlo solver.', 
-			documentation=documentation['mc_photons'], 
+			name='mc_photons',
+			group='mc',
+			helpstr='Total number of photons to be traced by the Monte Carlo solver.',
+			documentation=documentation['mc_photons'],
 			gui_inputs=(IntegerInput(name='Input.rte.mc.photons', default=10000, valid_range=[0, 10000000000]),),
-			tokens=addToken(name='Input.rte.mc.photons', datatype=long, valid_range=[0,1e10]),
+			tokens=addToken(name='Input.rte.mc.photons', datatype=int, valid_range=[0,1e10]),
 			parents=['uvspec'],
 			speaker='rte_solver',
 			enable_values=("mystic","montecarlo"),
 			mystic =True
 		)
 
-		mc_photons_file = option(  
+		mc_photons_file = option(
 			name='mc_photons_file',
-			group='mc', 
+			group='mc',
 			helpstr='Define a MYSTIC spectral photon file.',
 			documentation=documentation['mc_photons_file'],
 			gui_inputs=(FileInput(name='filename'),),
-			tokens=addToken( name='Input.rte.mc.filename[FN_MC_PHOTONS]', datatype=file ),	
-			parents=['uvspec'], 
+			tokens=addToken( name='Input.rte.mc.filename[FN_MC_PHOTONS]', datatype=io.IOBase ),
+			parents=['uvspec'],
 			speaker='rte_solver',
 			enable_values=("mystic","montecarlo"),
 			mystic =True
 		)
 
 		mc_polarisation = option(
-			name='mc_polarisation', 
-			group='mc', 
-			helpstr='Turn on polarisation for Monte Carlo solver.', 
-			documentation=documentation['mc_polarisation'], 
+			name='mc_polarisation',
+			group='mc',
+			helpstr='Turn on polarisation for Monte Carlo solver.',
+			documentation=documentation['mc_polarisation'],
 			tokens = [ addSetting(name='Input.rte.mc.polarisation', setting=1, default=0),
 				 addSetting(name='Input.rte.mc.reflectalways', setting=1,default=0),
                                  addToken(name='Input.rte.mc.polarisation_state', datatype=int,valid_range=[-3,4],default=0,optional=True)],
@@ -429,12 +430,12 @@ class setup_mc_group():
 			enable_values=("mystic","montecarlo"),
 			mystic =True
 		)
-		
+
 		mc_rad_alpha =  option(
-			name='mc_rad_alpha', 
-			group='mc', 
-			helpstr='Define opening angle for radiance simulations.', 
-			documentation=documentation['mc_rad_alpha'], 
+			name='mc_rad_alpha',
+			group='mc',
+			helpstr='Define opening angle for radiance simulations.',
+			documentation=documentation['mc_rad_alpha'],
 			gui_inputs=(IntegerInput(name='Input.rte.mc.alpha',
 						 default=5, valid_range=[0, 90]),),
 			tokens=addToken(name='Input.rte.mc.alpha', datatype=float, default=5,
@@ -444,10 +445,10 @@ class setup_mc_group():
 			enable_values=("mystic","montecarlo"),
 			mystic =True
 		)
-		
+
 		mc_radial_pathlength = option(
-			name='mc_radial_pathlength', 
-			group='mc', 
+			name='mc_radial_pathlength',
+			group='mc',
 			helpstr='I3RC case 7',
 			documentation=documentation['mc_radial_pathlength'],
 			tokens=[ addToken(name='Input.rte.mc.Nr', datatype=int, default=0,valid_range=[0,1e6]),
@@ -461,7 +462,7 @@ class setup_mc_group():
 
 		mc_radial_pathlength_dt = option(
 			name='mc_radial_pathlength_dt',
-			group='mc', 
+			group='mc',
 			helpstr='Time increment for mc_radial_pathlength',
 			documentation=documentation['mc_radial_pathlength_dt'],
 			tokens=addToken(name='Input.rte.mc.dt', datatype=float, default=1e-7, valid_range=[0,1e6]),
@@ -473,10 +474,10 @@ class setup_mc_group():
 		)
 
 		mc_readrandomstatus = option(  # TODO: Documentation wrong! filename is not implemented!
-			name='mc_readrandomstatus', 
-			group='mc', 
+			name='mc_readrandomstatus',
+			group='mc',
 			helpstr='Read from file the random status for the random number generator.',  #Documentation wrong!
-			documentation=documentation['mc_readrandomstatus'], 
+			documentation=documentation['mc_readrandomstatus'],
 			tokens=[addSetting(name='Input.rte.mc.readrandomstatus',setting=1),
 				addSetting(name='Input.rte.mc.readrandomseed',setting=1) ],
 			parents=['uvspec'],
@@ -487,10 +488,10 @@ class setup_mc_group():
 		)
 
 		mc_randomseed = option(
-			name='mc_randomseed', 
-			group='mc', 
+			name='mc_randomseed',
+			group='mc',
 			helpstr='Set random seed for MYSTIC.',
-			documentation=documentation['mc_randomseed'], 
+			documentation=documentation['mc_randomseed'],
 			gui_inputs=(IntegerInput(name='Input.rte.mc.randomseed', default=0, valid_range=[0, 1000000000000000]),),
 			tokens=addToken(name='Input.rte.mc.randomseed', datatype=int, valid_range=[0,1e15]),
 			parents=['uvspec'],
@@ -501,54 +502,54 @@ class setup_mc_group():
 		mc_refraction = option(
 			name='mc_refraction',
 			group='mc',
-			helpstr='Enable refraction.', 
+			helpstr='Enable refraction.',
 			documentation=documentation['mc_refraction'],
-			tokens=addSetting(name='Input.rte.mc.refraction', setting=1, default=0), 
-			parents=['mc_spherical'], 
+			tokens=addSetting(name='Input.rte.mc.refraction', setting=1, default=0),
+			parents=['mc_spherical'],
 			speaker='rte_solver',
 			enable_values=("mystic",),
 			mystic =True,
 			showInGui=False,
 			developer=True,
 		)
-	
+
 		mc_ris = option(
 			name='mc_ris',
 			group='mc',
 			helpstr='Use with mc_radar to get good statistics, artificially enhances the optical depth of the clouds for microwave wavelengths.',
 			documentation=documentation['mc_ris'],
 			tokens= [addLogical(name='id', logicals=['factor','optical_depth'], setting='MC_RIS_'),
-				addToken(name='Input.rte.mc.ris[id]', datatype=Double ) ], 
+				addToken(name='Input.rte.mc.ris[id]', datatype=Double ) ],
 			parents=[],
 			speaker='rte_solver',
 			enable_values=("mystic",),
-			threedmystic =True, 
+			threedmystic =True,
 			islidar = True,
 			showInGui = False
 		)
 
 		self.options = [mc_polarisation, mc_refraction, mc_coherent_backscatter,
 				mc_backward,
-                mc_backward_increment, 
+                mc_backward_increment,
 				mc_escape, mc_core, mc_core_threshold, mc_core_scale, mc_core_savefile,mc_vroom,
 				mc_surface_reflectalways,
 				mc_delta_scaling, mc_truncate,
-				mc_spectral_is, 
+				mc_spectral_is,
 				mc_aerosol_is,
 				mc_boxairmass,
 				mc_ris,
-			        mc_photons, mc_minphotons, mc_photons_file, 
-				mc_visualize, 
+			        mc_photons, mc_minphotons, mc_photons_file,
+				mc_visualize,
 				mc_maxscatters, mc_minscatters,
-				mc_randomseed, 
+				mc_randomseed,
 				mc_readrandomstatus,
-                         	mc_backward_sunshape_file, 
-				mc_sample_cldprp, 
-				mc_azimuth_old, 
+                         	mc_backward_sunshape_file,
+				mc_sample_cldprp,
+				mc_azimuth_old,
 				mc_backward_heat,
-				mc_backward_writeback, 
+				mc_backward_writeback,
 				mc_rad_alpha,
-				mc_radial_pathlength, 
+				mc_radial_pathlength,
 				mc_radial_pathlength_dt,
 				mc_DoLE
 				]
@@ -560,18 +561,18 @@ class setup_mc_group():
 def get_mc_documentation():
 	return {
 		'mc_escape'  : r'''
-	Calculate MYSTIC radiances via escape probabilities; slows down the tracing 
+	Calculate MYSTIC radiances via escape probabilities; slows down the tracing
 	but usually speeds up the computation considerably since it reduces
-	noise. Switched on per default since it should basically be used always 
+	noise. Switched on per default since it should basically be used always
 	when calculating radiances. Only meaningful with \code{rte_solver montecarlo}. The syntax is
 	\fcode{
 	  mc_escape on/off
-	} 
+	}
   		''',
 		'mc_rad_alpha'  : r'''
 	Define opening angle for radiance calculations without local
-	estimate. Ths oprion is useful for all-sky simulations.	
-                ''', 
+	estimate. Ths oprion is useful for all-sky simulations.
+                ''',
 		'mc_vroom' : r'''
 	Variance Reduction Optimal Options Method (VROOM). Options are "on"
 	and "off". Needs to be specified if you are calculating radiances and
@@ -587,7 +588,7 @@ def get_mc_documentation():
 	or the pixel area from \code{ix_start} to \code{ix_end} and \code{iy_start} to \code{iy_end}.
 	All x-indices must be in the range of 0 ... (\code{Nx}-1) and y-indices the range of 0 ... (\code{Ny}-1).
 	If no coordinates are specified, all sample pixels will be calculated.
-	\code{mc_backward} computes radiances and downward diffuse irradiances. If 
+	\code{mc_backward} computes radiances and downward diffuse irradiances. If
 	a different quantity is required, please use \code{mc_backward_output}.
        		''',
 		'mc_backward_increment'  : r'''
@@ -600,23 +601,23 @@ def get_mc_documentation():
     are calculated. Defaults to 1.
        		''',
         'mc_sample_cldprp'  : r'''
-	Switch on sampling of cloud properties (reff/tau/dlwc) by photons. 
-	This option needs \code{mc_backward}. The optical properties contributing to 
-	the result for each pixel are integrated using the photon weight 
+	Switch on sampling of cloud properties (reff/tau/dlwc) by photons.
+	This option needs \code{mc_backward}. The optical properties contributing to
+	the result for each pixel are integrated using the photon weight
 	$p_{weight,n}$ in the following way:
 	\begin{equation*}
 	{\langle r_e \rangle}_\textrm{wc}^\textrm{tau}\,=\,\frac{
 	\sum\limits_{n=0}^{photons}\,p_{weight,n}\,r_{\textrm{wc},n}}
 	{\sum\limits_{n=0}^{photons}\,p_{weight,n}}\qquad
-	r_{\textrm{wc}} \,=\, 
+	r_{\textrm{wc}} \,=\,
 	\frac{\int_0^\tau\ \tau_{\textrm{w}}r_{\textrm{ew}}\,\mathrm{d}\tau}
 	{\int_0^\tau \tau_{\textrm{w}}\,\mathrm{d}\tau}
 	\end{equation*}
-	For each internal wavelength, one [basename]\_[wvl].cldprp file with 
-	the following format is created where values marked with top are taken at 
+	For each internal wavelength, one [basename]\_[wvl].cldprp file with
+	the following format is created where values marked with top are taken at
 	first cloud contact:
 	\fcode{
-	ix iy 
+	ix iy
 	${\langle r_e \rangle}^\textrm{tau}_\textrm{wc}$
 	${\langle r_e \rangle}^\textrm{tau}_\textrm{ic}$
 	${\langle r_e \rangle}^\textrm{hit}_\textrm{wc}$
@@ -624,8 +625,8 @@ def get_mc_documentation():
 	${\langle \tau \rangle}_\textrm{wc}$
 	${\langle \tau \rangle}_\textrm{mc}$
 	$\nabla LWC$ $\nabla IWC$
-	}	
-	Values denoted with \textit{hit} are taken at the last cloud contact 
+	}
+	Values denoted with \textit{hit} are taken at the last cloud contact
 	before hitting the sensor, while the the water content gradient is
 	taken at the last cloud scattering before hitting the sensor (information
 	about cloud surface orientation).
@@ -633,7 +634,7 @@ def get_mc_documentation():
 		'mc_spectral_is': r'''
 	Calculate a spectrum with high spectral
 	resolution using an importance sampling
-	method.  
+	method.
 	\fcode{
 	mc_spectral_is [wvl]
 	}
@@ -644,9 +645,9 @@ def get_mc_documentation():
 	coefficients.  The spectral variation of the
 	phase matrix is neglected, for all wavelengths
 	the phase matrix of the calculation wavelength
-	is assumed. 
-	
-	Use the optional argument \code{wvl} to specify calculation wavelength. 
+	is assumed.
+
+	Use the optional argument \code{wvl} to specify calculation wavelength.
 	If not set, the central wavelength of the selected spectral interval is used.
 
 	This method is very efficient for
@@ -662,7 +663,7 @@ def get_mc_documentation():
 	This option is currently only included for 1D
 	atmospheres. The ouput is a two-column file (basename+\".amf\")
 	including the altitude levels and the box-airmass-factors
-	corresponding to the layer above the given altitude level. 
+	corresponding to the layer above the given altitude level.
         The altitude levels in the output file correspond to the once
         provided with \code{atmosphere_file} and the boxairmass factors
         are for the layers above the given altitude levels.
@@ -671,17 +672,17 @@ def get_mc_documentation():
 	the pathlength distribution significantly.
 	        ''',
 		'mc_surface_reflectalways': r'''
-	Usually, a photon is either absorbed or reflected at the surface, 
-	with a probability defined by the surface albedo. If 
-	\code{mc_surface_reflectalways} is specified, each photon is reflected and 
+	Usually, a photon is either absorbed or reflected at the surface,
+	with a probability defined by the surface albedo. If
+	\code{mc_surface_reflectalways} is specified, each photon is reflected and
 	the albedo is considered by reducing the photon weight. In case of BRDF,
-	\code{mc_surface_reflectalways} is switched on automatically because the 
-	other method is no longer implemented for non-Lambertian BRDFs, due to 
-	implementation and numerical problems. For small albedos, the computational 
-	time is increased if \code{mc_surface_reflectalways} is used; however, 
-	the accuracy of the upward radiance (reflected by the surface) is increased 
-	considerably. In case of clouds, however, computational time might be 
-	increased considerably without gaining accuracy. 
+	\code{mc_surface_reflectalways} is switched on automatically because the
+	other method is no longer implemented for non-Lambertian BRDFs, due to
+	implementation and numerical problems. For small albedos, the computational
+	time is increased if \code{mc_surface_reflectalways} is used; however,
+	the accuracy of the upward radiance (reflected by the surface) is increased
+	considerably. In case of clouds, however, computational time might be
+	increased considerably without gaining accuracy.
        		''',
 		'mc_DoLE': r'''
         Variance reduction method, use double local estimate and specular
@@ -689,12 +690,12 @@ def get_mc_documentation():
         experimental. USE ONLY IF YOU REALLY KNOW WHAT YOU ARE DOING!
        		''',
 		'mc_truncate': r'''
-	Truncate phase function at the specified polar angle mu. 
+	Truncate phase function at the specified polar angle mu.
 	USE ONLY IF YOU REALLY KNOW WHAT YOU ARE DOING!
        	 	''',
 		'mc_aerosol_is' : r'''
 	Enable aerosol concentration importance sampling. The input file
-	includes one column containing the desired scaling factors: 
+	includes one column containing the desired scaling factors:
 	\fcode{
 	mc_aerosol_is file
 	}
@@ -713,24 +714,24 @@ def get_mc_documentation():
 	\fcode{
 	  mc_backward_heat [option]
 	}
-        where option is one of 
+        where option is one of
 	\begin{description}
-	\parameter{emabs} 
+	\parameter{emabs}
 	  straightforward backward calculation of emission and absorption where the photons are started randomly in a grid box
-	\parameter{emabsopt} 
+	\parameter{emabsopt}
           optimized version of \code{emabs}: photons are started
 	  closer to the grid box edges using a variance reduction
-          technique. 
-	\parameter{denet} 
+          technique.
+	\parameter{denet}
           calculate heating rates as the difference of net fluxes at
           the grid box faces
-	\parameter{hybrid} 
+	\parameter{hybrid}
           optimum combination of the above (default)
 	\end{description}
         \code{emabs} and \code{emabsopt} calculate the heating rates as the difference of the emission and absorption of the grid
 	box, while with \code{denet} photons are started directly at
 	the grid box's faces. \code{denet} has been shown to perform
-	better for grid box optical thicknesses larger than 5, while for optical thicknesses smaller than 5 \code{emabsopt} performes better. 
+	better for grid box optical thicknesses larger than 5, while for optical thicknesses smaller than 5 \code{emabsopt} performes better.
         "hybrid" is the combination of "emabsopt" and "denet". The
 	respective method is selected automatically depending on the
 	grid box optical thickness.
@@ -742,14 +743,14 @@ def get_mc_documentation():
 	Path to a 2-coloumned text file containing the extraterrestrial sun shape. 1. column:
 	A probability density or if you want to a radiance distribution. Does not need
 	to be normalized 2. column: Relative angular distance to center from sun inside sun disc,
-	values from 0 to 1 (0: center, 1: limb).  Use \code{mc_sun_angular_size} to manually 
+	values from 0 to 1 (0: center, 1: limb).  Use \code{mc_sun_angular_size} to manually
 	set the extent of the sun. If filename is set to "default", or if only sun radius is given
 	 a spectrally resolved sun shape as in \citet{koepke2001} is used.
 		''',
 		'mc_backward_writeback' : r'''
-	If set, the distribution of photons contributing to the result is written 
+	If set, the distribution of photons contributing to the result is written
 	to a file with extension .bac which may be useful for some interpretations
-	(it basically tells you where the photons come from whichn contribute to the result). 
+	(it basically tells you where the photons come from whichn contribute to the result).
 		''',
 		'mc_coherent_backscatter' : r'''
 	Switches on coherent backscattering, use only with \code{mc_polarisation}.
@@ -757,8 +758,8 @@ def get_mc_documentation():
 	  mc_coherent_backscatter [option1] [option2]
 	}
         \begin{itemize}
-        \item If used without \code{mc_lidar} or \code{mc_radar} it will calculate enhancement values directly 
-        from averaged scattering matrices (\citet{mishchenko2006}) and output them 
+        \item If used without \code{mc_lidar} or \code{mc_radar} it will calculate enhancement values directly
+        from averaged scattering matrices (\citet{mishchenko2006}) and output them
         into a .mish.cb file. This method is only correct in the exact backscattering
         direction, its accuracy is around $5\%$ compared to \citet{Mishchenko1992}.
         \item If used with \code{mc_lidar} or \code{mc_radar} it will use the Stokes Vector method which explicitely
@@ -768,14 +769,14 @@ def get_mc_documentation():
         calculate the quotients from the results. This method is not limited to the exact
         backscattering direction, but the accuracy especially in backscattering direction can be
         problematic, so it should be viewed as an
-        experimental option. Additional output like the value of $0.75/(kl^*)$ which gives the cone 
+        experimental option. Additional output like the value of $0.75/(kl^*)$ which gives the cone
         halfwidth in radian (\citet{fiebig2010_phd}) is written into a .lid.cb file.
         \end{itemize}
         Description of options:
         \begin{description}
         \parameter{option1}
           Sets configuration for CB with Lidar. Takes the values 0, 1, 2 which correspond to the
-          three cases A, B, C in fig. 3.8 in \citet{pause16}. Optional, default is 0, use 1 or 2 to get 
+          three cases A, B, C in fig. 3.8 in \citet{pause16}. Optional, default is 0, use 1 or 2 to get
           a significant CB signal.
         \parameter{option2}
           If set to 1 omits adding the CB signal to the full signal, that means the result is just
@@ -807,7 +808,7 @@ def get_mc_documentation():
 	If set, this is the minimum value of photons to be used per
 	simulation. The default value is \code{MIN_MCPHOTONS}, set in
 	uvspec.h.
-	
+
 	\fcode{
 	mc_maxscatters value
 	}
@@ -830,7 +831,7 @@ def get_mc_documentation():
 		''',
 		'mc_polarisation' : r'''
 	Switch on polarisation for \code{rte_solver montecarlo}. By default uses unpolarized
-        sunlight (light starting with an initial Stokes Vector (1,0,0,0). Optionally you may provide 
+        sunlight (light starting with an initial Stokes Vector (1,0,0,0). Optionally you may provide
         one of the following numbers to specify one of the following initial Stokes Vectors:
         \begin{itemize}
         \item 0 : (1,0,0,0) (default)
@@ -840,42 +841,42 @@ def get_mc_documentation():
         \item -1 : (1,-1,0,0)
         \item -2 : (1,0,-1,0)
         \item -3 : (1,0,0,-1)
-        \item 4 : Each photon's Stokes Vector is randomly determined fulfilling the condition 
-        $I^2=Q^2+U^2+V^2$, use this e.g. if you need unpolarized radiation with 
-        \code{mc_coherent_backscatter} using \code{mc_lidar} or \code{mc_radar}. Averaging over 
+        \item 4 : Each photon's Stokes Vector is randomly determined fulfilling the condition
+        $I^2=Q^2+U^2+V^2$, use this e.g. if you need unpolarized radiation with
+        \code{mc_coherent_backscatter} using \code{mc_lidar} or \code{mc_radar}. Averaging over
         a large number of these random Stokes Vectors leads again to unpolarized radiation (1,0,0,0).
         \end{itemize}
 	Details about the implementation of polarisation are described in \citet{emde2010}.
 		''',
 		'mc_radial_pathlength' : r'''
-	I3RC case 7, laser beam experiment. Radiances are sampled in radial 
-	and pathlength elements. Specify the number of radial (Nr) and time (Nt) intervals. 
-	The radius increment is calculated from Nr and the domain size. The time interval 
-	may  be specified with \code{mc_radial_pathlength_dt}. 
+	I3RC case 7, laser beam experiment. Radiances are sampled in radial
+	and pathlength elements. Specify the number of radial (Nr) and time (Nt) intervals.
+	The radius increment is calculated from Nr and the domain size. The time interval
+	may  be specified with \code{mc_radial_pathlength_dt}.
 		''',
 		'mc_radial_pathlength_dt' : r'''
-	Specify time increment for \code{mc_radial_pathlength}. Time is converted to pathlength 
+	Specify time increment for \code{mc_radial_pathlength}. Time is converted to pathlength
 	assuming a speed of light of 3$\cdot$10$^8$~m/s
 		''',
                 'mc_randomseed' : r'''
-       	Provide your own random seed (positive integer) for the random number generator. 
+       	Provide your own random seed (positive integer) for the random number generator.
        	\fcode{
        	mc_randomseed value
        	}
-       	Usually a random seed is determined from current time plus process id. 
+       	Usually a random seed is determined from current time plus process id.
        	This option is useful to re-run a simulation for debugging.
        		''',
 		'mc_refraction' : '''
-	Enable refraction for \code{rte_solver montecarlo}. Works only 
+	Enable refraction for \code{rte_solver montecarlo}. Works only
 	in 1D spherical geometry (with option \code{mc_spherical}).
 		''',
 		'mc_visualize' : r'''
-	Switch on OpenGL visualization for MYSTIC. 
+	Switch on OpenGL visualization for MYSTIC.
 	\fcode{
 	mc_visualize [hiddenline]
 	}
-	Use the optional argument \code{hiddenline} to switch on hidden line removal for 
-	the MYSTIC online visualization. Good for topography, not so good for clouds because 
+	Use the optional argument \code{hiddenline} to switch on hidden line removal for
+	the MYSTIC online visualization. Good for topography, not so good for clouds because
 	the latter look much more realistic when the hidden layers are plotted in transparent mode.
 
 	Try the following keys in the graphics window:
@@ -913,7 +914,7 @@ def get_mc_documentation():
         simulated and if needed an average over all paths is calculated.
 		''',
 		'mc_readrandomstatus' : r'''
-	Read from file the random status for the random number generator. 
+	Read from file the random status for the random number generator.
 	\fcode{
 	mc_readrandomstatus file
 	}
@@ -929,7 +930,7 @@ def get_mc_documentation():
 	If set, in the inner part of all clouds specified by "wc\_file 3D" the scattering phase function is delta-scaled, i.e. it is assumed to be almost isotropic,
 	while simultaneously reducing the optical thickness. Depending on the specific setup, this can substantially decrease the number of scatterings
 	inside the cloud core and therefore simulation time. Deviations in the outcome are kept small by use of the original phase function in the cloud boundary. However, the option should not be used if the sensor points closely towards the sun. Which gridboxes belong to the cloud core is determined by an algorithm. Its result can be seen by setting "mc\_core\_savefile", the thickness of the cloud boundary can be set via "mc\_core\_threshold". Because "mc\_core" does not refine the cloud grid, the given cloud gridboxes should have a resolution finer than "mc\_core\_threshold". Alternatively, the user can specify the core pixels manually by providing a file similar to a 3D cloud file. In this case, the algorithm is not applied and "mc\_core\_threshold" has no effect.
-	Corefile structure: 
+	Corefile structure:
 	\fcode{
     Nx  Ny  Nz 4 \\
     dx  dy  z(1) z(2) ... z(nlev) \\
diff --git a/src_py/molecular_options.py b/src_py/molecular_options.py
index 2168592..edb7567 100644
--- a/src_py/molecular_options.py
+++ b/src_py/molecular_options.py
@@ -1,67 +1,67 @@
 """--------------------------------------------------------------------
  * $Id$
- * 
+ *
  * This file is part of libRadtran.
  * Copyright (c) 1997-2012 by Arve Kylling, Bernhard Mayer,
  *                            Claudia Emde, Robert Buras
  *
  * ######### Contact info: http://www.libradtran.org #########
  *
- * This program is free software; you can redistribute it and/or 
- * modify it under the terms of the GNU General Public License   
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.        
- * 
- * This program is distributed in the hope that it will be useful, 
- * but WITHOUT ANY WARRANTY; without even the implied warranty of  
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the   
- * GNU General Public License for more details.                    
- * 
- * You should have received a copy of the GNU General Public License          
- * along with this program; if not, write to the Free Software                
- * Foundation, Inc., 59 Temple Place - Suite 330, 
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
  * Boston, MA 02111-1307, USA.
  *--------------------------------------------------------------------"""
 
-
+import io
 from option_definition import *
 
 class setup_molecular_group():
 
-	group_name = 'Molecular atmosphere'
-
-	def __init__(self):
-		documentation = get_molecular_documentation()
-
-		atmosphere_file = option(
-			name='atmosphere_file',
-			group='atmosphere',
-			helpstr='Location of the atmosphere data file.', 
-			documentation=documentation['atmosphere_file'], 
-			tokens= addToken(name='Input.atmosphere_filename', datatype=str, valid_range=['subarctic_winter', 'subarctic_summer', 'midlatitude_summer', 'midlatitude_winter', 'tropics', 'US-standard', file]),
-			parents=['uvspec'], 
-			plot = {'plot_type': '2D',
-				'optional_args': {'column_names': (
-						"altitude",
-						"pressure",
-						"temperature",
-						"air",
-						"ozone",
-						"oxygen",
-						"water vapour",
-						"CO2",
-						"NO2",)
-						  }
-				},
-			mandatory=True,
-		)
+        group_name = 'Molecular atmosphere'
+
+        def __init__(self):
+                documentation = get_molecular_documentation()
+
+                atmosphere_file = option(
+                        name='atmosphere_file',
+                        group='atmosphere',
+                        helpstr='Location of the atmosphere data file.',
+                        documentation=documentation['atmosphere_file'],
+                        tokens= addToken(name='Input.atmosphere_filename', datatype=str, valid_range=['subarctic_winter', 'subarctic_summer', 'midlatitude_summer', 'midlatitude_winter', 'tropics', 'US-standard', io.IOBase]),
+                        parents=['uvspec'],
+                        plot = {'plot_type': '2D',
+                                'optional_args': {'column_names': (
+                                                "altitude",
+                                                "pressure",
+                                                "temperature",
+                                                "air",
+                                                "ozone",
+                                                "oxygen",
+                                                "water vapour",
+                                                "CO2",
+                                                "NO2",)
+                                                  }
+                                },
+                        mandatory=True,
+                )
 
                 atmosphere_file_3D = option(
-			name='atmosphere_file_3D',
-			group='atmosphere',
-			helpstr='Location of the 3D atmosphere data file.', 
-			documentation=documentation['atmosphere_file_3D'], 
-			tokens= [addToken(name='Input.atmosphere3d_filename', datatype=str),
+                        name='atmosphere_file_3D',
+                        group='atmosphere',
+                        helpstr='Location of the 3D atmosphere data file.',
+                        documentation=documentation['atmosphere_file_3D'],
+                        tokens= [addToken(name='Input.atmosphere3d_filename', datatype=str),
                                  addSetting(name='Input.atmosphere3d', setting='True'),
                                  addSetting(name='isp', setting='get_caoth_index(&Input.caoth,&Input.n_caoth,"molecular_3d",0)'),
                                  addSetting(name='Input.caoth[isp].source', setting='CAOTH_FROM_3D'),
@@ -72,675 +72,675 @@ class setup_molecular_group():
                         developer = False,
                         threedmystic =True
                 )
-                
-
-		radiosonde = not_yet_lex2py_option(
-			name='radiosonde',
-			group='atmosphere',
-			helpstr='Specify density profiles.',
-			documentation=documentation['radiosonde'],
-			gui_inputs=(TextInput(name=''),),
-			parents=['uvspec'],
-		)
-
-		radiosonde_levels_only = option(
-			name='radiosonde_levels_only',
-			group='atmosphere', 
-			helpstr='', 
-			documentation=documentation['radiosonde_levels_only'], 
-			tokens=addSetting(name='Input.atm.rs_add_upper_levels',setting='FALSE'), 
-			parents=['uvspec'],
-		)
-
-		mol_file = option(
-			name='mol_file',
-			group='molecular',
-			documentation=documentation['mol_file'],
-			gui_inputs=(ListInput(name='mol_id',
-					      valid_range=['O3', 'O2', 'H2O',
-							   'CO2', 'NO2', 'BRO',
-							   'OCLO', 'HCHO', 'O4',
-							   'SO2', 'CH4', 'N2O',
-							   'CO', 'N2'],
-					      optional=False),
-				    FileInput(name='Input.atm.filename[mol_id]'),
-				    ListInput(name='Input.atm.unit_profile[mol_id]', valid_range=['','cm_3', 'm_3', 'MMR', 'VMR', 'RH'], optional=True),),
-			tokens = [ addLogical( name='mol_id', logicals=['O3', 'O2', 'H2O', 'CO2', 'NO2', 'BRO', 'OCLO', 'HCHO', 'O4', 'SO2', 'CH4', 'N2O', 'CO', 'N2'], setting='MOL_' ) ,
-				addToken( name='Input.atm.filename[mol_id]', datatype=file ),
-				addLogical(name='Input.atm.unit_profile[mol_id]', logicals=['cm_3', 'm_3', 'MMR', 'VMR', 'RH'], optional=True) ],
-			parents=['uvspec'],
-			non_unique=True,
-		)
-
-		pressure = option(
-			name='pressure',
-			group='atmosphere', 
-			helpstr='Surface pressure',
-			documentation=documentation['pressure'], 
-			gui_inputs=(FloatInput(name='Input.pressure', default='NOT_DEFINED_FLOAT', valid_range=[0, 1000000.0]),),
-			tokens=addToken(name='Input.pressure', datatype=float, default='NOT_DEFINED_FLOAT', valid_range=[0,1e6]),
-			parents=['uvspec'],
-		)
-
-		refractive_index_file = option(
-			name='refractive_index_file',
-			group='atmosphere', 
-			helpstr='', 
-			documentation=documentation['refractive_index_file'], 
-			gui_inputs=(TextInput(name='Input.filename[FN_REFIND]'),),
-			tokens=addToken(name='Input.filename[FN_REFIND]', datatype=str), 
-			parents=['uvspec'],
-		)
-
-		crs_model = option(
-			name='crs_model',
-			group='molecular',
-			helpstr='Specify cross section.',
-			documentation=documentation['crs_model'],
-			gui_inputs=(ListInput(name='mol_id', valid_range=['no2', 'o3', 'o4', 'rayleigh'], optional=False), ListInput(name='crs_model', valid_range=['Bass_and_Paur', 'Molina', 'Daumont', 'Serdyuchenko', 'Bogumil', 'Bodhaine', 'Bodhaine29', 'Nicolet', 'Penndorf', 'Burrows', 'Vandaele', 'Greenblatt', 'Thalman'], optional=False),),
-			tokens= [ addLogical( name='mol_id', logicals=['no2', 'o3', 'o4', 'rayleigh'], setting='CRS_MOL_' ),
-				addLogical( name='Input.crs_model[mol_id]',  logicals=[ 'Bodhaine', 'Nicolet', 'Penndorf', 'Bodhaine29', 'Bass_and_Paur', 'Molina', 'Daumont', 'Serdyuchenko', 'Bogumil', 'Burrows', 'Vandaele', 'Greenblatt', 'Thalman'], setting='CRS_MODEL_') ],
-			parents=['uvspec'],
-			non_unique=True,
-		)
-
-		crs_file = option(
-			name='crs_file',
-			group='molecular',
-			documentation=documentation['crs_file'],
-			gui_inputs=(ListInput(name='mol_id', valid_range=['O3', 'O2', 'H2O', 'CO2', 'NO2', 'BRO', 'OCLO', 'HCHO', 'O4', 'SO2', 'CH4', 'N2O', 'CO', 'N2'], optional=False), FileInput(name='Output.crs.filename[mol_id]'),),
-			tokens = [ addLogical( name='mol_id', logicals=['O3', 'O2', 'H2O', 'CO2', 'NO2', 'BRO', 'OCLO', 'HCHO', 'O4', 'SO2', 'CH4', 'N2O', 'CO', 'N2'], setting='MOL_' ) ,
-				addToken( name='Output.crs.filename[mol_id]', datatype=file ) ],
-			parents=['uvspec'],
-			non_unique=True,
-		)
-
-		rayleigh_depol = option(
-			name='rayleigh_depol',
-			group='atmosphere',
-			helpstr='Rayleigh depolarization factor.', 
-			documentation=documentation['rayleigh_depol'], 
-			gui_inputs=(FloatInput(name='Input.rayleigh_depol'),),
-			tokens=addToken(name='Input.rayleigh_depol', datatype=float, default='NOT_DEFINED_FLOAT'), 
-			parents=['uvspec'],
-		)
-
-		mol_abs_param = option(
-			name='mol_abs_param',
-			group='spectral',
-			helpstr='Set correlated_k scheme. ',
-			documentation=documentation['mol_abs_param'],
-			tokens = [ addLogical( name='Input.ck_scheme', logicals=['kato', 'kato2', 'kato2.96','kato2andwandji','fu','avhrr_kratz','sbdart','lowtran','reptran','reptran_channel','crs',file], setting='CK_'),
-				addToken(name='Input.ck_reptran_arg', datatype=str, optional=True)],
-			parents=['uvspec'],
-			childs= ['ck_lowtran_absorption','ck_fu_h2o_continuum'],
-			continious_update=True,
-		)
-                
+
+
+                radiosonde = not_yet_lex2py_option(
+                        name='radiosonde',
+                        group='atmosphere',
+                        helpstr='Specify density profiles.',
+                        documentation=documentation['radiosonde'],
+                        gui_inputs=(TextInput(name=''),),
+                        parents=['uvspec'],
+                )
+
+                radiosonde_levels_only = option(
+                        name='radiosonde_levels_only',
+                        group='atmosphere',
+                        helpstr='',
+                        documentation=documentation['radiosonde_levels_only'],
+                        tokens=addSetting(name='Input.atm.rs_add_upper_levels',setting='FALSE'),
+                        parents=['uvspec'],
+                )
+
+                mol_file = option(
+                        name='mol_file',
+                        group='molecular',
+                        documentation=documentation['mol_file'],
+                        gui_inputs=(ListInput(name='mol_id',
+                                              valid_range=['O3', 'O2', 'H2O',
+                                                           'CO2', 'NO2', 'BRO',
+                                                           'OCLO', 'HCHO', 'O4',
+                                                           'SO2', 'CH4', 'N2O',
+                                                           'CO', 'N2'],
+                                              optional=False),
+                                    FileInput(name='Input.atm.filename[mol_id]'),
+                                    ListInput(name='Input.atm.unit_profile[mol_id]', valid_range=['','cm_3', 'm_3', 'MMR', 'VMR', 'RH'], optional=True),),
+                        tokens = [ addLogical( name='mol_id', logicals=['O3', 'O2', 'H2O', 'CO2', 'NO2', 'BRO', 'OCLO', 'HCHO', 'O4', 'SO2', 'CH4', 'N2O', 'CO', 'N2'], setting='MOL_' ) ,
+                                addToken( name='Input.atm.filename[mol_id]', datatype=io.IOBase ),
+                                addLogical(name='Input.atm.unit_profile[mol_id]', logicals=['cm_3', 'm_3', 'MMR', 'VMR', 'RH'], optional=True) ],
+                        parents=['uvspec'],
+                        non_unique=True,
+                )
+
+                pressure = option(
+                        name='pressure',
+                        group='atmosphere',
+                        helpstr='Surface pressure',
+                        documentation=documentation['pressure'],
+                        gui_inputs=(FloatInput(name='Input.pressure', default='NOT_DEFINED_FLOAT', valid_range=[0, 1000000.0]),),
+                        tokens=addToken(name='Input.pressure', datatype=float, default='NOT_DEFINED_FLOAT', valid_range=[0,1e6]),
+                        parents=['uvspec'],
+                )
+
+                refractive_index_file = option(
+                        name='refractive_index_file',
+                        group='atmosphere',
+                        helpstr='',
+                        documentation=documentation['refractive_index_file'],
+                        gui_inputs=(TextInput(name='Input.filename[FN_REFIND]'),),
+                        tokens=addToken(name='Input.filename[FN_REFIND]', datatype=str),
+                        parents=['uvspec'],
+                )
+
+                crs_model = option(
+                        name='crs_model',
+                        group='molecular',
+                        helpstr='Specify cross section.',
+                        documentation=documentation['crs_model'],
+                        gui_inputs=(ListInput(name='mol_id', valid_range=['no2', 'o3', 'o4', 'rayleigh'], optional=False), ListInput(name='crs_model', valid_range=['Bass_and_Paur', 'Molina', 'Daumont', 'Serdyuchenko', 'Bogumil', 'Bodhaine', 'Bodhaine29', 'Nicolet', 'Penndorf', 'Burrows', 'Vandaele', 'Greenblatt', 'Thalman'], optional=False),),
+                        tokens= [ addLogical( name='mol_id', logicals=['no2', 'o3', 'o4', 'rayleigh'], setting='CRS_MOL_' ),
+                                addLogical( name='Input.crs_model[mol_id]',  logicals=[ 'Bodhaine', 'Nicolet', 'Penndorf', 'Bodhaine29', 'Bass_and_Paur', 'Molina', 'Daumont', 'Serdyuchenko', 'Bogumil', 'Burrows', 'Vandaele', 'Greenblatt', 'Thalman'], setting='CRS_MODEL_') ],
+                        parents=['uvspec'],
+                        non_unique=True,
+                )
+
+                crs_file = option(
+                        name='crs_file',
+                        group='molecular',
+                        documentation=documentation['crs_file'],
+                        gui_inputs=(ListInput(name='mol_id', valid_range=['O3', 'O2', 'H2O', 'CO2', 'NO2', 'BRO', 'OCLO', 'HCHO', 'O4', 'SO2', 'CH4', 'N2O', 'CO', 'N2'], optional=False), FileInput(name='Output.crs.filename[mol_id]'),),
+                        tokens = [ addLogical( name='mol_id', logicals=['O3', 'O2', 'H2O', 'CO2', 'NO2', 'BRO', 'OCLO', 'HCHO', 'O4', 'SO2', 'CH4', 'N2O', 'CO', 'N2'], setting='MOL_' ) ,
+                                addToken( name='Output.crs.filename[mol_id]', datatype=io.IOBase ) ],
+                        parents=['uvspec'],
+                        non_unique=True,
+                )
+
+                rayleigh_depol = option(
+                        name='rayleigh_depol',
+                        group='atmosphere',
+                        helpstr='Rayleigh depolarization factor.',
+                        documentation=documentation['rayleigh_depol'],
+                        gui_inputs=(FloatInput(name='Input.rayleigh_depol'),),
+                        tokens=addToken(name='Input.rayleigh_depol', datatype=float, default='NOT_DEFINED_FLOAT'),
+                        parents=['uvspec'],
+                )
+
+                mol_abs_param = option(
+                        name='mol_abs_param',
+                        group='spectral',
+                        helpstr='Set correlated_k scheme. ',
+                        documentation=documentation['mol_abs_param'],
+                        tokens = [ addLogical( name='Input.ck_scheme', logicals=['kato', 'kato2', 'kato2.96','kato2andwandji','fu','avhrr_kratz','sbdart','lowtran','reptran','reptran_channel','crs',io.IOBase], setting='CK_'),
+                                addToken(name='Input.ck_reptran_arg', datatype=str, optional=True)],
+                        parents=['uvspec'],
+                        childs= ['ck_lowtran_absorption','ck_fu_h2o_continuum'],
+                        continious_update=True,
+                )
+
                 reptran_file = option(
                         name='reptran_file',
                         group='spectral',
                         helpstr='File containing representative wavelengths.',
                         documentation=documentation['reptran_file'],
-                        tokens=addToken(name='Input.filename[FN_REPTRAN]', datatype=file), 
+                        tokens=addToken(name='Input.filename[FN_REPTRAN]', datatype=io.IOBase),
+                        parents=['uvspec'],
+                        showInGui = False,
+                )
+
+                ck_lowtran_absorption = option(
+                        name='ck_lowtran_absorption',
+                        group='molecular',
+                        helpstr='Switch off absorption by individual minor trace gases.',
+                        documentation=documentation['ck_lowtran_absorption'],
+                        gui_inputs=(ListInput(name='Input.absorption_gas', valid_range=['O4', 'N2', 'CO', 'SO2', 'NH3', 'NO', 'HNO3']),
+                        ListInput(name='On/Off',valid_range=['on','off'], default='On'),),
+                        tokens = [ addLogical(name='mol_id', logicals=['O4','N2','CO','SO2','NH3','NO','HNO3'], setting='CK_ABS_' ) ,
+                                addLogical(name='Input.ck_abs[mol_id]', logicals=['on','off'], setting='SWITCH_') ],
+                        parents=['mol_abs_param'],
+                        speaker="mol_abs_param",
+                        enable_values=("lowtran",),
+                        non_unique=True,
+                )
+
+                ck_fu_h2o_continuum = option(
+                        name='ck_fu_h2o_continuum',
+                        group='molecular',
+                        helpstr='', #TODO
+                        documentation=documentation['ck_fu_h2o_continuum'],
+                        tokens=addLogical(name='Input.ck_h2ocont',logicals=['on','off','v2.1','v2.4'],setting='CK_H2OCONT_'),
                         parents=['uvspec'],
-			showInGui = False,
+                        speaker='mol_abs_param',
+                        enable_values=('fu',), #TODO:stimmt das?
+                        developer=True,
                 )
 
-		ck_lowtran_absorption = option(
-			name='ck_lowtran_absorption',
-			group='molecular',
-			helpstr='Switch off absorption by individual minor trace gases.', 
-			documentation=documentation['ck_lowtran_absorption'],
-			gui_inputs=(ListInput(name='Input.absorption_gas', valid_range=['O4', 'N2', 'CO', 'SO2', 'NH3', 'NO', 'HNO3']),
-			ListInput(name='On/Off',valid_range=['on','off'], default='On'),),
-			tokens = [ addLogical(name='mol_id', logicals=['O4','N2','CO','SO2','NH3','NO','HNO3'], setting='CK_ABS_' ) ,
-				addLogical(name='Input.ck_abs[mol_id]', logicals=['on','off'], setting='SWITCH_') ],
-			parents=['mol_abs_param'],
-			speaker="mol_abs_param",
-			enable_values=("lowtran",),
-			non_unique=True,
-		)
-
-		ck_fu_h2o_continuum = option(
-			name='ck_fu_h2o_continuum',
-			group='molecular',
-			helpstr='', #TODO
-			documentation=documentation['ck_fu_h2o_continuum'],
-			tokens=addLogical(name='Input.ck_h2ocont',logicals=['on','off','v2.1','v2.4'],setting='CK_H2OCONT_'),
-			parents=['uvspec'],
-			speaker='mol_abs_param',
-			enable_values=('fu',), #TODO:stimmt das?
-			developer=True,
-		)
-
-		mol_tau_file = option(
-			name='mol_tau_file',
-			group='molecular',
-			helpstr='Location of Molecular optical depth file.', 
-			documentation=documentation['mol_tau_file'],
-			gui_inputs=(ListInput(name='id', valid_range=['sca', 'abs'], optional=False), FileInput(name='Input.filename[id]'),),
-			tokens = [ addLogical(name='id', logicals=[ 'sca','abs' ], setting='FN_MOL_TAU_'),
-				   addToken(name='Input.filename[id]', datatype=file) ],
-			parents=['uvspec'],
-			non_unique=True,
-		)
-
-		mol_modify = option(
-			name='mol_modify',
-			group='molecular',
-			helpstr='Modify column of molecular specie', 
-			documentation=documentation['mol_modify'],
-			gui_inputs = ( ListInput(name='moltype', valid_range=[ 'O3','O2','H2O','CO2','NO2','BRO','OCLO','HCHO','O4','SO2','CH4','N2O','CO','N2' ], optional=False),
-				       FloatInput(name='value',  valid_range=[0, 1000000.0]),
-				       ListInput(name='unit', valid_range=[ 'DU', 'CM_2', 'MM' ], optional=False)),
-			tokens = [ addLogical(name='id', logicals=[ 'O3','O2','H2O','CO2','NO2','BRO','OCLO','HCHO','O4','SO2','CH4','N2O','CO','N2' ], setting='MOL_'),
-				   addToken(name='Input.atm.column[id]', datatype=float),
-				   addLogical( name='Input.atm.unit_column[id]', logicals=[ 'DU', 'CM_2', 'MM' ], setting='MOL_UNIT_') ],
-			parents=['uvspec'],
-			non_unique=True,
-		)
-
-		mixing_ratio = option(
-			name='mixing_ratio',
-			group='molecular',
-			helpstr='Mixing ratio of molecular specie', 
-			documentation=documentation['mixing_ratio'],
-			gui_inputs = ( ListInput(name='moltype', valid_range=[ 'O2','H2O','CO2','NO2','CH4','N2O','F11','F12','F22' ], optional=False),
-				       FloatInput(name='value',  valid_range=[0, 1000000.0])),
-			tokens = [ addLogical(name='id', logicals=[ 'O2','H2O','CO2','NO2','CH4','N2O','F11','F12','F22' ], setting='MX_'),
-				   addToken(name='Input.mixing_ratio[id]', datatype=float, valid_range=[0,1e6]) ],
-			parents=['uvspec'],
-			non_unique=True,
-		)
-
-
-		self.options = [atmosphere_file, atmosphere_file_3D,
+                mol_tau_file = option(
+                        name='mol_tau_file',
+                        group='molecular',
+                        helpstr='Location of Molecular optical depth file.',
+                        documentation=documentation['mol_tau_file'],
+                        gui_inputs=(ListInput(name='id', valid_range=['sca', 'abs'], optional=False), FileInput(name='Input.filename[id]'),),
+                        tokens = [ addLogical(name='id', logicals=[ 'sca','abs' ], setting='FN_MOL_TAU_'),
+                                   addToken(name='Input.filename[id]', datatype=io.IOBase) ],
+                        parents=['uvspec'],
+                        non_unique=True,
+                )
+
+                mol_modify = option(
+                        name='mol_modify',
+                        group='molecular',
+                        helpstr='Modify column of molecular specie',
+                        documentation=documentation['mol_modify'],
+                        gui_inputs = ( ListInput(name='moltype', valid_range=[ 'O3','O2','H2O','CO2','NO2','BRO','OCLO','HCHO','O4','SO2','CH4','N2O','CO','N2' ], optional=False),
+                                       FloatInput(name='value',  valid_range=[0, 1000000.0]),
+                                       ListInput(name='unit', valid_range=[ 'DU', 'CM_2', 'MM' ], optional=False)),
+                        tokens = [ addLogical(name='id', logicals=[ 'O3','O2','H2O','CO2','NO2','BRO','OCLO','HCHO','O4','SO2','CH4','N2O','CO','N2' ], setting='MOL_'),
+                                   addToken(name='Input.atm.column[id]', datatype=float),
+                                   addLogical( name='Input.atm.unit_column[id]', logicals=[ 'DU', 'CM_2', 'MM' ], setting='MOL_UNIT_') ],
+                        parents=['uvspec'],
+                        non_unique=True,
+                )
+
+                mixing_ratio = option(
+                        name='mixing_ratio',
+                        group='molecular',
+                        helpstr='Mixing ratio of molecular specie',
+                        documentation=documentation['mixing_ratio'],
+                        gui_inputs = ( ListInput(name='moltype', valid_range=[ 'O2','H2O','CO2','NO2','CH4','N2O','F11','F12','F22' ], optional=False),
+                                       FloatInput(name='value',  valid_range=[0, 1000000.0])),
+                        tokens = [ addLogical(name='id', logicals=[ 'O2','H2O','CO2','NO2','CH4','N2O','F11','F12','F22' ], setting='MX_'),
+                                   addToken(name='Input.mixing_ratio[id]', datatype=float, valid_range=[0,1e6]) ],
+                        parents=['uvspec'],
+                        non_unique=True,
+                )
+
+
+                self.options = [atmosphere_file, atmosphere_file_3D,
                                 radiosonde, radiosonde_levels_only,
-				mol_file, mixing_ratio, mol_modify,
-				pressure,
-				refractive_index_file,
-				crs_model,
-				crs_file,
-				rayleigh_depol,
-				mol_abs_param,
-				ck_lowtran_absorption,
-				ck_fu_h2o_continuum,
-				mol_tau_file,
+                                mol_file, mixing_ratio, mol_modify,
+                                pressure,
+                                refractive_index_file,
+                                crs_model,
+                                crs_file,
+                                rayleigh_depol,
+                                mol_abs_param,
+                                ck_lowtran_absorption,
+                                ck_fu_h2o_continuum,
+                                mol_tau_file,
                                 reptran_file,
-				]
+                                ]
 
-	def __iter__(self):
-		return iter(self.options)
+        def __iter__(self):
+                return iter(self.options)
 
 
 def get_molecular_documentation():
-	return {
-		'ck_lowtran_absorption' : r'''
-	Switch off absorption by individual minor trace gases which are currently only
-	included when \code{mol\_abs\_param lowtran} is chosen. The syntax is
-	\fcode{
-	  ck\_lowtran\_absorption species on/off
-	}
-	where species may be one of O4, N2, CO, SO2, NH3, NO, HNO3. By default all
-	are switched on. 
-	
-	This option may also be used to turn on/off absorption by O4 in spectral 
-	resolution. It is on by default.
-		''',
-		'atmosphere_file' : r'''
-	Location of the atmospheric data file. 
-	\fcode{
-	atmosphere\_file file
-	}
-	The file must have at least three columns containing the altitude,
-	pressure, and temperature. Missing profiles are filled with 0 (e.g., if you did not specify 
-	the ozone profile, there will be no ozone absorption!), with exception of the air density which 
-	is calculated from pressure and temperature. Other trace gases may be set by \code{mol\_file}.  
-	The columns are interpreted as follows:
-	\begin{description}
-	\item[1] Altitude above sea level in km
-	\item[2] Pressure in hPa
-	\item[3] Temperature in K
-	\item[4] air density in cm$^{-3}$
-	\item[5] Ozone density in cm$^{-3}$
-	\item[6] Oxygen density in cm$^{-3}$
-	\item[7] Water vapour density in cm$^{-3}$
-	\item[8] CO2 density in cm$^{-3}$
-	\item[9] NO2 density in cm$^{-3}$
-	\end{description}
-	The atmosphere is specified
-	top-down, that is, the top level is the first line in the file, the bottom
-	(surface) level the last line. All properties refer to model \emph{level} z,
-	not to model \emph{layer}. It is important that the correct units are 
-	used, otherwise unpredictable results are guaranteed.
-	Comments start with \code{\#}. Empty lines are ignored. Please note that there 
-	is some redundancy: For air as an ideal gas the density $\rho$, can be
-	calculated from pressure and temperature, $\rho = p / kT$. \code{uvspec} will check 
-	if this relation is fulfilled and will stop if it is not. 
-	{\sl libRadtran} provides the six standard atmospheres by \citet{Anderson1986}:
-	\begin{description}
-	\item[afglt]   Tropical            (\code{tropics})                                           
-       	\item[afglms]  Midlatitude Summer  (\code{midlatitude\_summer})
-	\item[afglmw]  Midlatitude Winter  (\code{midlatitude\_winter})
-	\item[afglss]  Subarctic Summer    (\code{subarctic\_summer})
-	\item[afglsw]  Subarctic Winter    (\code{subarctic\_winter})
-	\item[afglus]  U.S. Standard       (\code{US-standard})                   
-	\end{description}
-	which may be chosen by for example
-	\fcode{
-	atmosphere\_file tropics
-	}
-	or by specifying the full file name. These atmosphere files are found in 
-	\file{data/atmmod}.
-	If no \code{atmosphere\_file} is defined, {\sl uvspec} will automatically select one. 
-	If the information  \code{time}, \code{latitude} and \code{longitude} are provided in 
-	the input file {\sl uvspec} will choose from the first 5 files, otherwise it takes 
-	the U.S. Standard atmosphere.
-		''',
+        return {
+                'ck_lowtran_absorption' : r'''
+        Switch off absorption by individual minor trace gases which are currently only
+        included when \code{mol\_abs\_param lowtran} is chosen. The syntax is
+        \fcode{
+          ck\_lowtran\_absorption species on/off
+        }
+        where species may be one of O4, N2, CO, SO2, NH3, NO, HNO3. By default all
+        are switched on.
+
+        This option may also be used to turn on/off absorption by O4 in spectral
+        resolution. It is on by default.
+                ''',
+                'atmosphere_file' : r'''
+        Location of the atmospheric data file.
+        \fcode{
+        atmosphere\_file file
+        }
+        The file must have at least three columns containing the altitude,
+        pressure, and temperature. Missing profiles are filled with 0 (e.g., if you did not specify
+        the ozone profile, there will be no ozone absorption!), with exception of the air density which
+        is calculated from pressure and temperature. Other trace gases may be set by \code{mol\_file}.
+        The columns are interpreted as follows:
+        \begin{description}
+        \item[1] Altitude above sea level in km
+        \item[2] Pressure in hPa
+        \item[3] Temperature in K
+        \item[4] air density in cm$^{-3}$
+        \item[5] Ozone density in cm$^{-3}$
+        \item[6] Oxygen density in cm$^{-3}$
+        \item[7] Water vapour density in cm$^{-3}$
+        \item[8] CO2 density in cm$^{-3}$
+        \item[9] NO2 density in cm$^{-3}$
+        \end{description}
+        The atmosphere is specified
+        top-down, that is, the top level is the first line in the file, the bottom
+        (surface) level the last line. All properties refer to model \emph{level} z,
+        not to model \emph{layer}. It is important that the correct units are
+        used, otherwise unpredictable results are guaranteed.
+        Comments start with \code{\#}. Empty lines are ignored. Please note that there
+        is some redundancy: For air as an ideal gas the density $\rho$, can be
+        calculated from pressure and temperature, $\rho = p / kT$. \code{uvspec} will check
+        if this relation is fulfilled and will stop if it is not.
+        {\sl libRadtran} provides the six standard atmospheres by \citet{Anderson1986}:
+        \begin{description}
+        \item[afglt]   Tropical            (\code{tropics})
+        \item[afglms]  Midlatitude Summer  (\code{midlatitude\_summer})
+        \item[afglmw]  Midlatitude Winter  (\code{midlatitude\_winter})
+        \item[afglss]  Subarctic Summer    (\code{subarctic\_summer})
+        \item[afglsw]  Subarctic Winter    (\code{subarctic\_winter})
+        \item[afglus]  U.S. Standard       (\code{US-standard})
+        \end{description}
+        which may be chosen by for example
+        \fcode{
+        atmosphere\_file tropics
+        }
+        or by specifying the full file name. These atmosphere files are found in
+        \file{data/atmmod}.
+        If no \code{atmosphere\_file} is defined, {\sl uvspec} will automatically select one.
+        If the information  \code{time}, \code{latitude} and \code{longitude} are provided in
+        the input file {\sl uvspec} will choose from the first 5 files, otherwise it takes
+        the U.S. Standard atmosphere.
+                ''',
                 'atmosphere_file_3D' : r'''
-        Specify filename for a 3D molecular atmosphere. The file includes 3D fields of pressure, temperature and water vapor. Other species are not yet implemented in 3D and are specified as 1D altitude profiles using the option \code{atmosphere\_file}. The format of the 3D atmosphere file is as follows: 
+        Specify filename for a 3D molecular atmosphere. The file includes 3D fields of pressure, temperature and water vapor. Other species are not yet implemented in 3D and are specified as 1D altitude profiles using the option \code{atmosphere\_file}. The format of the 3D atmosphere file is as follows:
         \fcode{Nx  Ny  Nz  flag \\
                dx  dy  z(1) z(2) z(3) ... z(n) \\
                ix  iy  iz  p  T  H2O \\
                ...
                 }
-        where \code{Nx}, \code{Ny} and \code{Nz} are the number of grid boxes in 
+        where \code{Nx}, \code{Ny} and \code{Nz} are the number of grid boxes in
         \code{x}, \code{y}, and \code{z}-direction.
         The parameter \code{flag} is not yet used.
-        In the second line \code{dx} and \code{dy} are the sizes of the boxes in x- 
+        In the second line \code{dx} and \code{dy} are the sizes of the boxes in x-
         and y-direction in km. In the third and following lines the indices \code{ix}, \code{iy}, and \code{iz} specify atmosphere pixels. \code{p} is the pressure in hPa, \code{T} the temperature in K and \code{H2O} the water vapor concentration in kg/kg.
- 
+
         See also the examples \code{examples/UVSPEC_MC_ABS3D.INP} and \code{examples/UVSPEC_MC_ABS3D_THERMAL.INP} which use the 3D atmosphere file \code{examples/UVSPEC_MC_ABS3D_AFGLUS3D.INP} as input. This atmosphere file includes the same atmospheric profile (US standard) in 3$\times$2 pixels and the examples check for solar and thermal radiation, whether the 3D input yields the same results as 1D calculations.
 
         Currently the implementation has some restrictions:
-        \begin{itemize}       
+        \begin{itemize}
         \item the altitude profiles of the 1D atmosphere file, the 3D atmosphere file and also other 3D profile files (including \code{wc_file 3D} and \code{ic_file 3D}) must include the same vertical grids
         \item the conversion of heating rates to K/d is only approximate, because it uses pressure and temperature of the first pixel, rather than the 3D fields
         \item ... may be more?
         \end{itemize}
 
         {\sl \code{atmosphere_file_3D} is an experimental option! Please check your results carefully and contact Claudia Emde in case you find any bugs or inconsistencies.}
-        	''',    
-
-		'radiosonde' : r'''
-	This option allows to change the temperature and pressure profile, and optionally to 
-	specify one or more density profiles. The entry in the input file looks like this:
-	\fcode{
-	radiosonde filename [gas\_species] [unit] ...
-	}
-	Currently the following gas\_species are included: ozone (O3), nitrogen dioxide (NO2), 
-	water vapor (H2O), bromine oxide (BRO), chlorine dioxide (OCLO), formaldehyde (HCHO), 
-	carbon dioxide (CO2), sulphur dioxide (SO2), and the oxygen dimer (O4). 
-	Each gas species is identified by its abbrevations given in parentheses above.
-	Unit is an optional argument to defines the unit of the density. The profiles can
-	be given in particles per cm$^3$ (CM-3), in particles per m$^3$ (M-3), as volume 
-	mixing ratio (VMR), as mass mixing ratio in kg/kg (MMR), or as relative humidity 
-	(RH) (only for water). The default unit is RH for water vapour, 
-	MMR for ozone, and CM3 for all other gases.
-	The radiosonde file must have (2 + number of gases) columns:
-	\begin{description}
-	\item[1] pressure in hPa
-	\item[2] temperature in Kelvin
-	\item[3, 4, ...] density of trace gas in the specified unit
-	\end{description}
-	A new z-grid will be calculated, starting at \code{altitude} and assuming a linear temperature variation
-	between levels. The air density will be recalculated according to the ideal gas law, and the density of 
-	the well mixed gases O2 and CO2 will be scaled accordingly.
-	The atmospheric data above the radiosonde data is taken from the \code{atmosphere\_file} level by level, starting 
-	at the first pressure level above the radiosonde data. The z-grid of the \code{atmosphere\_file} in 
-	this height region is shifted accordingly.
-	Also if the density in the radiosonde file is specified as -1 at a level, 
-	the value from the \code{atmosphere\_file} is used.
-	Possible calls are
-	\fcode{
-	radiosonde ../examples/radiosonde.dat
-	}
-	just in order to change the temperature and pressure profile, or
-	\fcode{
-	radiosonde ../examples/radiosonde2.dat H2O RH O3 MMR NO2
-	}
-	where water vapour density will be given as relative humidity, ozone as mass mixing ratio, 
-	and NO2 in cm$^{-3}$ (default).
-		''',
-
-		'radiosonde_levels_only' : r'''
-	The atmosphere considered in the simulation has the same height range as the data in 
-	the \code{radiosonde}-file. No further levels are added above those.
-	This option has only an effect in combination with \code{radiosonde}.
-		''',
-
-		'mol_file' :	r'''
-	Specify density profiles (or matrix, see below) of various trace gases to be included in the radiative 
-	transfer calculation.
-	\fcode{
-	mol\_file gas\_species filename [unit]
-	}
-	At the moment following \code{gas\_species} are included: ozone (O3), nitrogen dioxide (NO2), water vapor (H2O),
-	bromine oxide (BRO), chlorine dioxide (OCLO), formaldehyde (HCHO), carbon dioxide (CO2), 
-	sulphur dioxide (SO2), oxygen (O2), the oxygen dimer (O4), methane (CH4), nitrous oxide (N20), 
-        carbon monoxide (CO), and nitrogen (N2). 
-	The gas species is identified 
-	by their abbrevations given in the parenthesis above.
-
-	The model expects a density file with two columns:
-	\begin{description}
-	\item[1] Altitude above sea level in km.
-	\item[2] The density of trace gas [in the specified unit]
-	\end{description}
-	The altitude grid may be different from that in \code{atmosphere\_file}. All densities inside the range 
-	of the \code{mol\_file} are replaced. For all other altitudes the values from the 
-	\code{atmosphere\_file} are used. If the density is specified as -1 at a level, 
-	the value from \code{atmosphere\_file} is used.
+                ''',
+
+                'radiosonde' : r'''
+        This option allows to change the temperature and pressure profile, and optionally to
+        specify one or more density profiles. The entry in the input file looks like this:
+        \fcode{
+        radiosonde filename [gas\_species] [unit] ...
+        }
+        Currently the following gas\_species are included: ozone (O3), nitrogen dioxide (NO2),
+        water vapor (H2O), bromine oxide (BRO), chlorine dioxide (OCLO), formaldehyde (HCHO),
+        carbon dioxide (CO2), sulphur dioxide (SO2), and the oxygen dimer (O4).
+        Each gas species is identified by its abbrevations given in parentheses above.
+        Unit is an optional argument to defines the unit of the density. The profiles can
+        be given in particles per cm$^3$ (CM-3), in particles per m$^3$ (M-3), as volume
+        mixing ratio (VMR), as mass mixing ratio in kg/kg (MMR), or as relative humidity
+        (RH) (only for water). The default unit is RH for water vapour,
+        MMR for ozone, and CM3 for all other gases.
+        The radiosonde file must have (2 + number of gases) columns:
+        \begin{description}
+        \item[1] pressure in hPa
+        \item[2] temperature in Kelvin
+        \item[3, 4, ...] density of trace gas in the specified unit
+        \end{description}
+        A new z-grid will be calculated, starting at \code{altitude} and assuming a linear temperature variation
+        between levels. The air density will be recalculated according to the ideal gas law, and the density of
+        the well mixed gases O2 and CO2 will be scaled accordingly.
+        The atmospheric data above the radiosonde data is taken from the \code{atmosphere\_file} level by level, starting
+        at the first pressure level above the radiosonde data. The z-grid of the \code{atmosphere\_file} in
+        this height region is shifted accordingly.
+        Also if the density in the radiosonde file is specified as -1 at a level,
+        the value from the \code{atmosphere\_file} is used.
+        Possible calls are
+        \fcode{
+        radiosonde ../examples/radiosonde.dat
+        }
+        just in order to change the temperature and pressure profile, or
+        \fcode{
+        radiosonde ../examples/radiosonde2.dat H2O RH O3 MMR NO2
+        }
+        where water vapour density will be given as relative humidity, ozone as mass mixing ratio,
+        and NO2 in cm$^{-3}$ (default).
+                ''',
+
+                'radiosonde_levels_only' : r'''
+        The atmosphere considered in the simulation has the same height range as the data in
+        the \code{radiosonde}-file. No further levels are added above those.
+        This option has only an effect in combination with \code{radiosonde}.
+                ''',
+
+                'mol_file' :    r'''
+        Specify density profiles (or matrix, see below) of various trace gases to be included in the radiative
+        transfer calculation.
+        \fcode{
+        mol\_file gas\_species filename [unit]
+        }
+        At the moment following \code{gas\_species} are included: ozone (O3), nitrogen dioxide (NO2), water vapor (H2O),
+        bromine oxide (BRO), chlorine dioxide (OCLO), formaldehyde (HCHO), carbon dioxide (CO2),
+        sulphur dioxide (SO2), oxygen (O2), the oxygen dimer (O4), methane (CH4), nitrous oxide (N20),
+        carbon monoxide (CO), and nitrogen (N2).
+        The gas species is identified
+        by their abbrevations given in the parenthesis above.
+
+        The model expects a density file with two columns:
+        \begin{description}
+        \item[1] Altitude above sea level in km.
+        \item[2] The density of trace gas [in the specified unit]
+        \end{description}
+        The altitude grid may be different from that in \code{atmosphere\_file}. All densities inside the range
+        of the \code{mol\_file} are replaced. For all other altitudes the values from the
+        \code{atmosphere\_file} are used. If the density is specified as -1 at a level,
+        the value from \code{atmosphere\_file} is used.
         Altitude ranges not covered by the \code{atmosphere\_file} are ignored.
 
-	\code{unit} is an optional argument to define the unit of the density. The profiles can
-	be given in particles per cm$^{3}$ (\code{cm\_3}), in particles per m$^{3}$ (\code{m\_3}), as volume mixing ratio (\code{vmr}), as mass mixing 
-	ratio (\code{mmr}), or as relative humidity (\code{rh}) (only for water). The default for \code{unit} is cm$^{-3}$.
-	
-	To scale the profile to a total column value use \code{mol\_modify}.
-	
-	For airmass factor calculations it is for some species necessary to account for the 
-	variation of the profile with sza. This may be accomplished by specifying a \code{mol\_file} 
-	in the following format:
-	\fcode{
-	0.0       SZA1      SZA2 ...\\
-	z(1)    dens(1,1)    ...\\
-	z(2)      .           .\\
-	 .        .           .
-	}
-	where z(i) are the altitude levels above sea level in km, SZA is the solar zenith 
-	angle in degrees, and dens is the density [in the specified unit] of the trace gases as 
-	function of solar zenith angle and altitude. 
-	The matrix may only be specified for one species. It may however be combined with profiles
-	of other species. 
-	A density matrix can only be used in connection with \code{rte\_solver sdisort}!
-		''', 
-
-		'pressure' : r'''
-	The surface pressure (at the user-defined \code{altitude}) in hPa. 
-	\fcode{
-	pressure value
-	}
-	The pressure profile as well as air, O2 and CO2 density profiles 
-	are scaled accordingly.
-		''',
-
-		'refractive_index_file' : r'',
-
-		'crs_model' : r'''
-	Choose between various cross sections.
-	\fcode{
-	crs\_model species crs
-	}
-	Following \code{species} are included:
-	\begin{description}
-
-	\parameter{rayleigh} Specify the Rayleigh cross section.
-	Choose between the following Rayleigh scattering cross sections (\code{crs}):
-	\begin{description}
-	\item[Bodhaine]		\citet{Bodhaine1999} Rayleigh scattering cross section using their Eqs. 22-23.
-	\item[Bodhaine29]	\citet{Bodhaine1999} Rayleigh scattering cross section using their Eq. 29.
-	\item[Nicolet] 		\citet{Nicolet1984} Rayleigh scattering cross section.
-	\item[Penndorf]		\citet{Penndorf1957} Rayleigh scattering cross section.
-	\end{description}
-	\citet{Bodhaine1999} is default.
-
-	\parameter{o3} Choose ozone cross section. 
-	\code{crs} can be one of the following:
-	\begin{description}
-	\item[Bass\_and\_Paur]	\citet{Bass1985} ozone cross section.
-	\item[Molina] 		\citet{Molina1986} ozone cross section.
-	\item[Daumont]		Ozone cross section by \citet{Daumont1992}, \citet{Malicet1995}.
-	\item[Bogumil]		Ozone cross section from \citet{Bogumil2003}.
-        \item[Serdyuchenko]     Ozone cross section from Serdyuchenko.        
-	\end{description}
-	\citet{Molina1986} is default.
-
-	\parameter{no2} Choose between the various NO2 cross sections.
-	\code{crs} is one of:
-	\begin{description}
-	\item[Burrows]		\citet{Burrows1998} NO2 cross section.
-	\item[Bogumil]		NO2 cross section from \citet{Bogumil2003}.
+        \code{unit} is an optional argument to define the unit of the density. The profiles can
+        be given in particles per cm$^{3}$ (\code{cm\_3}), in particles per m$^{3}$ (\code{m\_3}), as volume mixing ratio (\code{vmr}), as mass mixing
+        ratio (\code{mmr}), or as relative humidity (\code{rh}) (only for water). The default for \code{unit} is cm$^{-3}$.
+
+        To scale the profile to a total column value use \code{mol\_modify}.
+
+        For airmass factor calculations it is for some species necessary to account for the
+        variation of the profile with sza. This may be accomplished by specifying a \code{mol\_file}
+        in the following format:
+        \fcode{
+        0.0       SZA1      SZA2 ...\\
+        z(1)    dens(1,1)    ...\\
+        z(2)      .           .\\
+         .        .           .
+        }
+        where z(i) are the altitude levels above sea level in km, SZA is the solar zenith
+        angle in degrees, and dens is the density [in the specified unit] of the trace gases as
+        function of solar zenith angle and altitude.
+        The matrix may only be specified for one species. It may however be combined with profiles
+        of other species.
+        A density matrix can only be used in connection with \code{rte\_solver sdisort}!
+                ''',
+
+                'pressure' : r'''
+        The surface pressure (at the user-defined \code{altitude}) in hPa.
+        \fcode{
+        pressure value
+        }
+        The pressure profile as well as air, O2 and CO2 density profiles
+        are scaled accordingly.
+                ''',
+
+                'refractive_index_file' : r'',
+
+                'crs_model' : r'''
+        Choose between various cross sections.
+        \fcode{
+        crs\_model species crs
+        }
+        Following \code{species} are included:
+        \begin{description}
+
+        \parameter{rayleigh} Specify the Rayleigh cross section.
+        Choose between the following Rayleigh scattering cross sections (\code{crs}):
+        \begin{description}
+        \item[Bodhaine]         \citet{Bodhaine1999} Rayleigh scattering cross section using their Eqs. 22-23.
+        \item[Bodhaine29]       \citet{Bodhaine1999} Rayleigh scattering cross section using their Eq. 29.
+        \item[Nicolet]          \citet{Nicolet1984} Rayleigh scattering cross section.
+        \item[Penndorf]         \citet{Penndorf1957} Rayleigh scattering cross section.
+        \end{description}
+        \citet{Bodhaine1999} is default.
+
+        \parameter{o3} Choose ozone cross section.
+        \code{crs} can be one of the following:
+        \begin{description}
+        \item[Bass\_and\_Paur]  \citet{Bass1985} ozone cross section.
+        \item[Molina]           \citet{Molina1986} ozone cross section.
+        \item[Daumont]          Ozone cross section by \citet{Daumont1992}, \citet{Malicet1995}.
+        \item[Bogumil]          Ozone cross section from \citet{Bogumil2003}.
+        \item[Serdyuchenko]     Ozone cross section from Serdyuchenko.
+        \end{description}
+        \citet{Molina1986} is default.
+
+        \parameter{no2} Choose between the various NO2 cross sections.
+        \code{crs} is one of:
+        \begin{description}
+        \item[Burrows]          \citet{Burrows1998} NO2 cross section.
+        \item[Bogumil]          NO2 cross section from \citet{Bogumil2003}.
         \item[Vandaele]         NO2 cross section from Vandaele et al.
-	\end{description}
-	\citet{Burrows1998} is default.
+        \end{description}
+        \citet{Burrows1998} is default.
 
         \parameter{o4} Choose between the various O4 cross sections.
-	\code{crs} is one of:
-	\begin{description}        
+        \code{crs} is one of:
+        \begin{description}
         \item[Greenblatt]     O4 cross section by \citet{greenblatt1990}.
         \item[Thalman]       O4 cross section by \citet{thalman2013}.
         \end{description}
 
-        \end{description}        
-		''',
-
-		'crs_file' : r'''
-	May be used to specify cross sections of O3, O2, H2O, CO2, NO2, BRO, OCLO, HCHO, 
-        O4, SO2, CH4, N2O, CO, or N2 to be used instead of those supplied with 
-	{\sl libRadtran}. No temperature dependence may be specified. Use as follows:
-	\fcode{
-	crs\_file NO2 ../examples/no2\_crs.dat
-	}
-	The species, e.g. \code{NO2}, must be specified to identify the
-	species for which the cross section applies.
-	The cross section file has two columns:
-	\begin{description}
-	\item[1] wavelength (nm)
-	\item[2] cross section (cm$^2$)
-	\end{description}
-		''',
-
-		'rh_file' : r'''
-	File that defines a profile of relative humidity. 
-	\fcode{
-	rh\_file file
-	}
-	If specified, the water vapour 
-	profile in \code{atmosphere\_file} is over-written. If -1 is specified at a level, the value 
-	from \code{atmosphere\_file} is used. 
-		''',
-
-		'ck_fu_h2o_continuum' : r'''
-	Undocumented option to switch the H2O continuum on or off or select a specific 
-	version of the continuum.
-		''',
-
-		'mixing_ratio' : r'''
-	Mixing ratio in ppm.
-	\fcode{
-	mixing\_ratio species value
-	}
-	\code{species} can be one of the following:
-	\begin{description}
-	\item[O2] The mixing ratio of O2 in ppm. Scale the profile so that the mixing
+        \end{description}
+                ''',
+
+                'crs_file' : r'''
+        May be used to specify cross sections of O3, O2, H2O, CO2, NO2, BRO, OCLO, HCHO,
+        O4, SO2, CH4, N2O, CO, or N2 to be used instead of those supplied with
+        {\sl libRadtran}. No temperature dependence may be specified. Use as follows:
+        \fcode{
+        crs\_file NO2 ../examples/no2\_crs.dat
+        }
+        The species, e.g. \code{NO2}, must be specified to identify the
+        species for which the cross section applies.
+        The cross section file has two columns:
+        \begin{description}
+        \item[1] wavelength (nm)
+        \item[2] cross section (cm$^2$)
+        \end{description}
+                ''',
+
+                'rh_file' : r'''
+        File that defines a profile of relative humidity.
+        \fcode{
+        rh\_file file
+        }
+        If specified, the water vapour
+        profile in \code{atmosphere\_file} is over-written. If -1 is specified at a level, the value
+        from \code{atmosphere\_file} is used.
+                ''',
+
+                'ck_fu_h2o_continuum' : r'''
+        Undocumented option to switch the H2O continuum on or off or select a specific
+        version of the continuum.
+                ''',
+
+                'mixing_ratio' : r'''
+        Mixing ratio in ppm.
+        \fcode{
+        mixing\_ratio species value
+        }
+        \code{species} can be one of the following:
+        \begin{description}
+        \item[O2] The mixing ratio of O2 in ppm. Scale the profile so that the mixing
         ratio at the user-defined \code{altitude} assumes the specified value.
-	\item[H2O] The mixing ratio of H2O in ppm. Scale the profile so that the mixing
+        \item[H2O] The mixing ratio of H2O in ppm. Scale the profile so that the mixing
         ratio at the user-define \code{altitude} assumes the specified value.
         \item[CO2] The mixing ratio of CO2 in ppm. Scale the profile so that the mixing
         ratio at the user-defined \code{altitude} assumes the specified value.
-	\item[NO2] The mixing ratio of NO2 in ppm. Scale the profile so that the mixing
+        \item[NO2] The mixing ratio of NO2 in ppm. Scale the profile so that the mixing
         ratio at the user-defined \code{altitude} assumes the specified value.
-        \item[CH4] The mixing ratio of CH4 in ppm (default: 1.6 ppm). 
-	\item[N2O] The mixing ratio of N2O in ppm (default: 0.28 ppm).
-	\item[F11] The mixing ratio of F11 in ppm (default: 0.000268 ppm).
-	\item[F12] The mixing ratio of F12 in ppm (default: 0.000503 ppm).
-	\item[F22] The mixing ratio of F22 in ppm (default: 0.000105 ppm).
-	\end{description}
+        \item[CH4] The mixing ratio of CH4 in ppm (default: 1.6 ppm).
+        \item[N2O] The mixing ratio of N2O in ppm (default: 0.28 ppm).
+        \item[F11] The mixing ratio of F11 in ppm (default: 0.000268 ppm).
+        \item[F12] The mixing ratio of F12 in ppm (default: 0.000503 ppm).
+        \item[F22] The mixing ratio of F22 in ppm (default: 0.000105 ppm).
+        \end{description}
         The \code{mixing_ratio} of F11, F12, and F22 and the default values for CH4 and N2O are ignored in case of \code{mol_abs_param reptran}.
 
-		''',
+                ''',
 
-		'mol_modify' : r'''
-	Set the total column of a density profile. The column is integrated between the 
-	user-defined \code{altitude} and TOA (top of atmosphere). The syntax is
-	\fcode{
-	mol\_modify species column unit
-	}
-	where \code{species} is one of O3, O2, H2O, CO2, NO2, BRO, OCLO, HCHO, O4, SO2, 
+                'mol_modify' : r'''
+        Set the total column of a density profile. The column is integrated between the
+        user-defined \code{altitude} and TOA (top of atmosphere). The syntax is
+        \fcode{
+        mol\_modify species column unit
+        }
+        where \code{species} is one of O3, O2, H2O, CO2, NO2, BRO, OCLO, HCHO, O4, SO2,
         CH4, N2O, CO, or N2, see also \code{mol\_file}.
-	The second argument is the total column value, and the third argument is the unit, 
-	in which the column is given. The unit can be DU (Dobson units), CM\_2 (molecules/cm$^2$) or MM.
+        The second argument is the total column value, and the third argument is the unit,
+        in which the column is given. The unit can be DU (Dobson units), CM\_2 (molecules/cm$^2$) or MM.
 
-	Please note that the unit MM is only valid for species H2O and specifies the precipitable water 
-	in kg / m2 (which is approximately 1mm).The water vapor profile is scaled accordingly. The precipitable water 
+        Please note that the unit MM is only valid for species H2O and specifies the precipitable water
+        in kg / m2 (which is approximately 1mm).The water vapor profile is scaled accordingly. The precipitable water
         is integrated from the user-defined \code{altitude} to TOA (top of atmosphere).
 
-	The default units are DU for O3, and CM\_2 for all other gases. It is possible to have
-	several \code{mol\_modify} commands in the input file (maximum one per species). The following sets
-	the NO$_2$ total column to 1.2 DU.
-	\fcode{
-	mol\_modify NO2 1.2 DU
-	}
-		''',
-
-		'rayleigh_depol' : r'''
-	Rayleigh depolarization factor.
-	\fcode{
-	rayleigh\_depol value
-	}
-	The Rayleigh scattering phase function is
-	$p(\mu) = a + b  \mu^2$ where $a = 1.5{(1+\texttt{depol})/(2+\texttt{depol})}$ and  
-	$b = 1.5{(1-\texttt{depol})/(2+\texttt{depol})}$. By default the depolarization is calculated
-	using the expressions from \citet{Bodhaine1999}.
-		''',
-
-		'mol_abs_param' : r'''
-	To calculate integrated shortwave or longwave irradiance, or to simulate 
-	satellite instrument channels, use
-	\fcode{
-	   mol\_abs\_param type
-	}
-	to choose between the following types of schemes:
-	\begin{description}
+        The default units are DU for O3, and CM\_2 for all other gases. It is possible to have
+        several \code{mol\_modify} commands in the input file (maximum one per species). The following sets
+        the NO$_2$ total column to 1.2 DU.
+        \fcode{
+        mol\_modify NO2 1.2 DU
+        }
+                ''',
+
+                'rayleigh_depol' : r'''
+        Rayleigh depolarization factor.
+        \fcode{
+        rayleigh\_depol value
+        }
+        The Rayleigh scattering phase function is
+        $p(\mu) = a + b  \mu^2$ where $a = 1.5{(1+\texttt{depol})/(2+\texttt{depol})}$ and
+        $b = 1.5{(1-\texttt{depol})/(2+\texttt{depol})}$. By default the depolarization is calculated
+        using the expressions from \citet{Bodhaine1999}.
+                ''',
+
+                'mol_abs_param' : r'''
+        To calculate integrated shortwave or longwave irradiance, or to simulate
+        satellite instrument channels, use
+        \fcode{
+           mol\_abs\_param type
+        }
+        to choose between the following types of schemes:
+        \begin{description}
         \item[reptran]
         Representative wavelengths parameterization adapted for spectral bands.
-        This parameterization is used by default if no \code{mol\_abs\_param} option is given 
+        This parameterization is used by default if no \code{mol\_abs\_param} option is given
         in the {\sl uvspec} input file.
         Different band widths may be selected by
         \fcode{
           mol\_abs\_param reptran [fine|medium|coarse]
-        } 
+        }
         (fine: 1cm$^{-1}$; medium: 5cm$^{-1}$; coarse: 15cm$^{-1}$; coarse is default).
         The data files for coarse resolution are included in the libRadtran package.
         The files required for fine and medium resolution can be downloaded from the libRadtran homepage.
-        Absorption data is mainly based on HITRAN 2004. Absorption by H2O, CO2, O3, N2O, CO, CH4, O2, N2, and NO2 
-        is considered, and absorption by all other gases is zero. 
-        By default volume mixing ratios of N2O, CO, CH4, and N2 (those are not in the 
-        \code{atmosphere\_file}) from the US standard atmosphere are applied. 
+        Absorption data is mainly based on HITRAN 2004. Absorption by H2O, CO2, O3, N2O, CO, CH4, O2, N2, and NO2
+        is considered, and absorption by all other gases is zero.
+        By default volume mixing ratios of N2O, CO, CH4, and N2 (those are not in the
+        \code{atmosphere\_file}) from the US standard atmosphere are applied.
         Use \code{mol\_file} or \code{mol\_modify} to change the gas profiles.
         In case of radiative transfer problems with solar source, the extraterrestrial spectrum from
         Kurudz is applied by default. This parameterization is described in detail by \citet{gasteiger2014}.
         \item[reptran\_channel]
-        Representative wavelengths parameterization for satellite channels. Usage 
+        Representative wavelengths parameterization for satellite channels. Usage
         \fcode{
           mol\_abs\_param reptran\_channel channel\_name
         }
         Channel-integrated quantities are obtained using \code{output\_process per\_band}.
-        The file \file{data/correlated\_k/reptran/channel\_list.txt} provides a list of available channels; 
-        more information on the channels is provided in \file{data/filter/}. 
+        The file \file{data/correlated\_k/reptran/channel\_list.txt} provides a list of available channels;
+        more information on the channels is provided in \file{data/filter/}.
         See \citet{gasteiger2014} for details about the approach.
         \item[crs]
-        Switch off spectral parameterizations. Only molecular absorption cross sections from 
+        Switch off spectral parameterizations. Only molecular absorption cross sections from
         \code{crs_file} (including the default ones) are considered.
-	\item[kato] 
-	\citet{Kato1999b} correlated-k distribution, shortwave; based on HITRAN 96. Please note that the 
-	bands above 2.5 micrometer are not very reliable which, however, this has only little impact
-	on integrated shortwave radiation.
-	\item[kato2] 
-	\citet{Kato1999b}, shortwave; optimized version (Seiji Kato, personal communication, 2003);
-	please note that \code{kato2} only has 148 subbands (that is, calls to the \code{rte\_solver}) 
-	compared to 575 for \code{kato} which translates to a increase in computational speed by 
-	up to a factor of 4 with only little increase in uncertainty. The absorption data are
-	based on HITRAN 2000. Please note that the bands above 2.5 micrometer are not very reliable which, 
-	however, this has only little impact on integrated shortwave radiation.
-	\item[kato2andwandji] 
-        Similar to \code{kato2}, but the UV bands \#3 and \#4 use the improved parameterization 
+        \item[kato]
+        \citet{Kato1999b} correlated-k distribution, shortwave; based on HITRAN 96. Please note that the
+        bands above 2.5 micrometer are not very reliable which, however, this has only little impact
+        on integrated shortwave radiation.
+        \item[kato2]
+        \citet{Kato1999b}, shortwave; optimized version (Seiji Kato, personal communication, 2003);
+        please note that \code{kato2} only has 148 subbands (that is, calls to the \code{rte\_solver})
+        compared to 575 for \code{kato} which translates to a increase in computational speed by
+        up to a factor of 4 with only little increase in uncertainty. The absorption data are
+        based on HITRAN 2000. Please note that the bands above 2.5 micrometer are not very reliable which,
+        however, this has only little impact on integrated shortwave radiation.
+        \item[kato2andwandji]
+        Similar to \code{kato2}, but the UV bands \#3 and \#4 use the improved parameterization
         by \citet{WandjiNyamsi2015}.
-	\item[kato2.96]
-	\citet{Kato1999b}, shortwave; optimized version (Seiji Kato, personal communication, 2003);
-	similar to \code{kato2} but based on HITRAN96. Please note that the bands above 2.5 micrometer 
-	are not very reliable which, however, has only little impact on integrated shortwave radiation.
-	\item[fu]
-	\citet{fu92,fu93}, shortwave and longwave; fast parameterization, developed for climate models.
-	\item[avhrr\_kratz] 
-	\citet{Kratz1995}, AVHRR instrument channels
-	\item[lowtran]
-	Gas absorption parameterization from LOWTRAN; code adopted from SBDART \citep{Ricchiazzi1998b}; 
-	please see the section on "Spectral resolution".
-	\item[sbdart]
-	Identical to LOWTRAN.
-	\end{description}
-	If \code{mol\_abs\_param} kato/kato2/kato2.96/fu/avhrr\_kratz is specified, the extraterrestrial 
-	flux is taken from
-	internally defined files specific for each parameterization, not 
-	from \code{source solar file}. The output is the integrated irradiance for 
-	each band. To get e.g. integrated shortwave irradiance, simply add all 
-	bands of the \citet{Kato1999b} or the \citet{fu92,fu93}
-	parameterization. The five AVHRR channels are weighted sums of the
-	libRadtran output. Examples how to integrate the output in the
-	\code{avhrr\_kratz} case are included in the {\sl uvspec} self check
-	which is initiated with  
-	\code{make check}.
-		''',
+        \item[kato2.96]
+        \citet{Kato1999b}, shortwave; optimized version (Seiji Kato, personal communication, 2003);
+        similar to \code{kato2} but based on HITRAN96. Please note that the bands above 2.5 micrometer
+        are not very reliable which, however, has only little impact on integrated shortwave radiation.
+        \item[fu]
+        \citet{fu92,fu93}, shortwave and longwave; fast parameterization, developed for climate models.
+        \item[avhrr\_kratz]
+        \citet{Kratz1995}, AVHRR instrument channels
+        \item[lowtran]
+        Gas absorption parameterization from LOWTRAN; code adopted from SBDART \citep{Ricchiazzi1998b};
+        please see the section on "Spectral resolution".
+        \item[sbdart]
+        Identical to LOWTRAN.
+        \end{description}
+        If \code{mol\_abs\_param} kato/kato2/kato2.96/fu/avhrr\_kratz is specified, the extraterrestrial
+        flux is taken from
+        internally defined files specific for each parameterization, not
+        from \code{source solar file}. The output is the integrated irradiance for
+        each band. To get e.g. integrated shortwave irradiance, simply add all
+        bands of the \citet{Kato1999b} or the \citet{fu92,fu93}
+        parameterization. The five AVHRR channels are weighted sums of the
+        libRadtran output. Examples how to integrate the output in the
+        \code{avhrr\_kratz} case are included in the {\sl uvspec} self check
+        which is initiated with
+        \code{make check}.
+                ''',
 
                  'reptran_file' : r'''
-        Location of the representative wavelengths file. 
+        Location of the representative wavelengths file.
         \fcode{
           reptran\_file file
         }
-        This option is useful together with 'mol\_abs\_param reptran' and 'mol\_abs\_param reptran\_channel' 
+        This option is useful together with 'mol\_abs\_param reptran' and 'mol\_abs\_param reptran\_channel'
         options, if you want to use your own representative wavelengths parameterization.
         ''',
 
-		'mol_tau_file' : r'''
-	Location of molecular scattering or absorption optical depth file.
-	\fcode{
-	mol\_tau\_file sca/abs filename
-	}
-	\begin{description}
-	\parameter{sca}	Usually, the Rayleigh scattering
-	cross section is calculated from the air pressure provided in \code{atmosphere\_file}
-	(scaled with \code{pressure}). Use this parameter only if you really want to specify
-	the optical depth directly (e.g. for a model intercomparison). The
-	optical thickness profile may be either monochromatic or spectral. 
-	\parameter{abs} Usually, molecular absorption
-	is calculated from trace gas concentrations provided in \code{atmosphere\_file}
-	(scaled with \code{mol\_modify O3}, etc.). Use this option only if you want to specify
-	the optical depth directly (e.g. for a model intercomparison) or for a line-by-line
-	calculation. If a spectral \code{mol\_tau\_file} is specified, the wavelength 
-	grid defined there is used as the internal wavelength grid for the radiative transfer
-	calculation, if not defined otherwise with \code{wavelength\_grid\_file}.
-	\end{description}
-
-	The file can be either of the following three formats:
-	\begin{description}
-	\parameter{Monochromatic} 
-	Column 1 is the altitude in km 
-	%AK: This is probably old stuff prior to redistribute
-	%where the altitude grid must be exactly equal 
-	%to the altitude grid specified in \code{atmosphere\_file}. 
-	Column 2 is the absorption optical depth of each layer.
-	\parameter{Spectral, ASCII}
-	The first line contains the level altitudes in decreasing order; the following lines 
-	contain the wavelength [nm] in the first column and then the absorption optical depths
-	of each layer. 
-	\parameter{Spectral,  netcdf}
-	An example is available at the libRadtran homepage, 
-	the file \file{UVSPEC.O2A.afglms.cdf} is a line-by-line spectrum of the oxygen A-Band 
-	around 760nm, calculated for the mid-latitude summer 
-	atmosphere. The advantage of
-	netcdf compared to ASCII is that it is much faster to read, and that the file 
-	is a self-contained, including data and a description of the variables and arrays.
-	It is therefore particularly useful for line-by-line calculations where usually 
-	many spectral data points are involved. 
-	%netcdf is a common platform independent format; the description, a library to read and 
-	%write netcdf including some tools to generate netcdf is available at 
-	%http://www.unidata.ucar.edu/packages/netcdf/. A \code{mol\_tau\_file abs} must obey 
-	%certain rules; 
-	\end{description}
-	Comments start with \code{\#}. Empty lines are ignored.
-		''',
+                'mol_tau_file' : r'''
+        Location of molecular scattering or absorption optical depth file.
+        \fcode{
+        mol\_tau\_file sca/abs filename
+        }
+        \begin{description}
+        \parameter{sca} Usually, the Rayleigh scattering
+        cross section is calculated from the air pressure provided in \code{atmosphere\_file}
+        (scaled with \code{pressure}). Use this parameter only if you really want to specify
+        the optical depth directly (e.g. for a model intercomparison). The
+        optical thickness profile may be either monochromatic or spectral.
+        \parameter{abs} Usually, molecular absorption
+        is calculated from trace gas concentrations provided in \code{atmosphere\_file}
+        (scaled with \code{mol\_modify O3}, etc.). Use this option only if you want to specify
+        the optical depth directly (e.g. for a model intercomparison) or for a line-by-line
+        calculation. If a spectral \code{mol\_tau\_file} is specified, the wavelength
+        grid defined there is used as the internal wavelength grid for the radiative transfer
+        calculation, if not defined otherwise with \code{wavelength\_grid\_file}.
+        \end{description}
+
+        The file can be either of the following three formats:
+        \begin{description}
+        \parameter{Monochromatic}
+        Column 1 is the altitude in km
+        %AK: This is probably old stuff prior to redistribute
+        %where the altitude grid must be exactly equal
+        %to the altitude grid specified in \code{atmosphere\_file}.
+        Column 2 is the absorption optical depth of each layer.
+        \parameter{Spectral, ASCII}
+        The first line contains the level altitudes in decreasing order; the following lines
+        contain the wavelength [nm] in the first column and then the absorption optical depths
+        of each layer.
+        \parameter{Spectral,  netcdf}
+        An example is available at the libRadtran homepage,
+        the file \file{UVSPEC.O2A.afglms.cdf} is a line-by-line spectrum of the oxygen A-Band
+        around 760nm, calculated for the mid-latitude summer
+        atmosphere. The advantage of
+        netcdf compared to ASCII is that it is much faster to read, and that the file
+        is a self-contained, including data and a description of the variables and arrays.
+        It is therefore particularly useful for line-by-line calculations where usually
+        many spectral data points are involved.
+        %netcdf is a common platform independent format; the description, a library to read and
+        %write netcdf including some tools to generate netcdf is available at
+        %http://www.unidata.ucar.edu/packages/netcdf/. A \code{mol\_tau\_file abs} must obey
+        %certain rules;
+        \end{description}
+        Comments start with \code{\#}. Empty lines are ignored.
+                ''',
 
 }
diff --git a/src_py/option_definition.py b/src_py/option_definition.py
index 3716954..8064f43 100644
--- a/src_py/option_definition.py
+++ b/src_py/option_definition.py
@@ -1,383 +1,384 @@
 
 """--------------------------------------------------------------------
  * $Id$
- * 
+ *
  * This file is part of libRadtran.
  * Copyright (c) 1997-2012 by Arve Kylling, Bernhard Mayer,
  *                            Claudia Emde, Robert Buras
  *
  * ######### Contact info: http://www.libradtran.org #########
  *
- * This program is free software; you can redistribute it and/or 
- * modify it under the terms of the GNU General Public License   
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.        
- * 
- * This program is distributed in the hope that it will be useful, 
- * but WITHOUT ANY WARRANTY; without even the implied warranty of  
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the   
- * GNU General Public License for more details.                    
- * 
- * You should have received a copy of the GNU General Public License          
- * along with this program; if not, write to the Free Software                
- * Foundation, Inc., 59 Temple Place - Suite 330, 
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
  * Boston, MA 02111-1307, USA.
  *--------------------------------------------------------------------"""
 
+import io
 import GUI_definition
 from GUI_definition import *
 
 class option():
-	def __init__(self, name=None, group=None, 
-		     helpstr="", documentation="", tokens=[],
-		     gui_inputs=(),
-		     parents=[], non_parents=[], non_parent_exceptions=[], childs=[],
-		     speaker=None, enable_values=None,
-		     mystic=False, threedmystic=False, islidar=False, developer=False,
-		     extra_dependencies=[], 
-		     plot=None, showInGui = True,
-		     continious_update=False,mandatory=False,non_unique=False):
-
-		assert not name is None
-		assert not group is None
-
-		assert hasattr(gui_inputs, "__iter__"), "Oops! gui_inputs" \
-		    " for option {0} must be a tuple/list".format(name)
-		tokens = _checkForDictionary(tokens)
-		
-		if tokens == -1:
-			print '''ERROR: found in definition of %s:\n
-			Please check your tokens and settings again''' %(name)
-
-		self.parents = parents
-		self.non_parents = non_parents
-		self.non_parent_exceptions = non_parent_exceptions
-		self.childs = childs
-		self.name = name
-		self.help = helpstr
-		self.plot = plot
-		self.tokens = tokens
-		self.showInGui = showInGui
-		self.continious_update = continious_update
-		self._mandatory=mandatory
-		self._extra_dependencies=extra_dependencies
-		self.non_unique=non_unique
-
-		# Please use empty lists
-		if self.childs == '': self.childs = []
-		if self.non_parents == '': self.non_parents = []
-		if self.non_parent_exceptions == '': self.non_parent_exceptions = []
-
-		self.dependencies = list(self.childs + self.non_parents + self.non_parent_exceptions + extra_dependencies)
-		if self._mandatory and not name in self.dependencies: self.dependencies.append(self.name)
-			
-		for inp in gui_inputs:
-			assert inp.__class__.__name__ in GUI_definition.__all__
-		if not gui_inputs:	gui_inputs = self._set_gui_input(gui_inputs,tokens)
-		self.gui_inputs = self._addBooleanToGuiInput(gui_inputs)
-
-		self.dict = {
-			'name'		 : name,	      #as defined in uvspec_lex.l
-			'group'          : group,             # e.g. WC
-			'help'           : helpstr,           # Help string (short), could appear as pop-up in GUI
-			'documentation'  : documentation,     # Full documentation 
-			'tokens'	 : tokens,	      # Variable in uvspec inp_struct to change
-			'parents'        : parents,           # (specifies which options must also be defined together with this option)
-			# One of the options must also be defined with this options
-			'non_parents'    : non_parents,       # specifies which options must not be defined together with this option 
-			'non_parent_exceptions'    : non_parent_exceptions,       # specifies which options inside non_parents should be ignored
-			'childs'    	 : childs,	      # (specifies which options can be defined with this option)
-			# Options which will be unlocked when defining this option
-			'mystic'	 : mystic,	      # mystic option
-			'threedmystic'	 : threedmystic,      # 3D mystic option
-			'islidar'	 : islidar,           # lidar option
-			'developer'	 : developer,         # developer option, undocumented for esasLight
-			'plot'           : plot,              # Setup plotting for options which should be plotted
-			}
-
-		self.canEnable = self._canEnable
-
-		if  speaker and enable_values:
-			self._speaker = speaker
-			assert not isinstance(enable_values, basestring), "Missing comma in one-item-tuple?"
-			self._enable_values = enable_values
-			self.canEnable = self._canEnableContinousOption
-		if extra_dependencies:
-			self.isMandatory = self._isMandatoryMixedOption
-		
-
-	# Pretend to be a dictionary to avoid breaking old code
-	def __getitem__(self, *args, **kwargs):
-		return self.dict.__getitem__(*args, **kwargs)
-	def __setitem__(self, *args, **kwargs):
-		return self.dict.__setitem__(*args, **kwargs)
-	def __contains__(self, *args, **kwargs):
-		return self.dict.__contains__(*args, **kwargs)
-	def get(self, *args, **kwargs):
-		return self.dict.get(*args, **kwargs)
-
-	def _canEnableContinousOption(self, is_set, get_value):
-		"""
-		Remember that self.speaker must be a subclass of
-		continious_option.
-		"""
-		r = self._canEnable(is_set, get_value)
-		if r and is_set(self._speaker) and  \
-			    get_value(self._speaker)[0] in self._enable_values:
-			return r
-		else:
-			return False
-
-	def _canEnable(self, is_set, get_value):
-		"""
-		Tells the GUI wether the option should be enabled or disabled.
-		Returns True if the option should be enabled and False if it
-		should be disabled.
-
-		is_set is a function that returns True if an option is enabled
-		and has been edited by the user, else False. It takes one
-		argument, the name of an option as a string.
-
-		get_value returns the current value of an option
-
-		This is used to implement the logic in the GUI. If more
-		complex logic than the parent, non-parent, children logic is
-		needed this function should be overloaded.
-
-		Remember to update the dependency tuple, a tuple of options
-		which should be enabled or disabled depending on if this
-		option is set.
-		"""
-		parents = any([is_set(parent) for parent in self.parents]) \
-		    or not self.parents
-		non_parents = all([(not is_set(non_parent) or self.non_parent_exceptions.count(non_parent) or non_parent==self.name) \
-					   for non_parent in self.non_parents]) \
-					   or not self.non_parents
-		return parents and non_parents
-
-	def isMandatory(self, is_set, get_value):
-		"""
-		Returns True for mandatory options. Similar to canEnable.
-		"""
-		if self._mandatory and not is_set(self.name):	return True
-		return False
-
-	def _isMandatoryMixedOption(self, is_set, get_value):
-		cond = [is_set(opt) for opt in self._extra_dependencies]
-		if all(cond):
-			return False
-		elif any(cond):
-			return True
-		else:
-			return False
-		
-
-	def _set_gui_input(self,gui_inputs,tokens):
-
-		if not self.showInGui:
-			return gui_inputs
-		for inp in tokens:
-			try:
-				name = inp.gui_name
-			except KeyError:
-				pass
-			if not name:	name = inp.get('name')
-			try:
-				vr = inp.get('valid_range')
-			except KeyError:
-				vr = None
-
-			if isinstance(inp, addSetting):
-				continue
-			elif isinstance(inp, addLogical):
-				gui_inp = (ListInput(name=name,valid_range=inp.get('valid_range'),optional=inp.get('optional'),default=inp.get('default'),logical_file=inp.get('logical_file')),)
-			elif isinstance(inp, addToken):
-				dtype = inp.get('datatype')
-				if dtype == float or dtype==Double:
-					if not vr: vr = (-1e99, 1e99)
-					gui_inp = (FloatInput(name=name,optional=inp.get('optional'),valid_range=vr,default=inp.get('default')),)
-				elif dtype == int:
-					if not vr: vr = (-1e99, 1e99)
-					gui_inp = (IntegerInput(name=name,valid_range=vr,optional=inp.get('optional'),default=inp.get('default')),)
-				elif vr:
-					gui_inp = (ListInput(name=name,valid_range=inp.get('valid_range'),optional=inp.get('optional'),default=inp.get('default'),logical_file=inp.get('logical_file')),)
-				elif dtype == file:
-					gui_inp = ( FileInput(name=name,optional=inp.get('optional')) ,)
-				else:	gui_inp = (TextInput(name=name,optional=inp.get('optional')),)
-			gui_inputs = gui_inputs.__add__(gui_inp)
-		return gui_inputs
-
-	def _addBooleanToGuiInput(self,gui_inputs):
-		if not self.showInGui:
-			return ()
-		for inp in gui_inputs:
-			if not inp.optional or inp.__class__ == BooleanInput:
-				return gui_inputs
-		return ( BooleanInput(name=''), ).__add__(gui_inputs)
+        def __init__(self, name=None, group=None,
+                     helpstr="", documentation="", tokens=[],
+                     gui_inputs=(),
+                     parents=[], non_parents=[], non_parent_exceptions=[], childs=[],
+                     speaker=None, enable_values=None,
+                     mystic=False, threedmystic=False, islidar=False, developer=False,
+                     extra_dependencies=[],
+                     plot=None, showInGui = True,
+                     continious_update=False,mandatory=False,non_unique=False):
+
+                assert not name is None
+                assert not group is None
+
+                assert hasattr(gui_inputs, "__iter__"), "Oops! gui_inputs" \
+                    " for option {0} must be a tuple/list".format(name)
+                tokens = _checkForDictionary(tokens)
+
+                if tokens == -1:
+                        print('''ERROR: found in definition of %s:\n
+                        Please check your tokens and settings again''' %(name))
+
+                self.parents = parents
+                self.non_parents = non_parents
+                self.non_parent_exceptions = non_parent_exceptions
+                self.childs = childs
+                self.name = name
+                self.help = helpstr
+                self.plot = plot
+                self.tokens = tokens
+                self.showInGui = showInGui
+                self.continious_update = continious_update
+                self._mandatory=mandatory
+                self._extra_dependencies=extra_dependencies
+                self.non_unique=non_unique
+
+                # Please use empty lists
+                if self.childs == '': self.childs = []
+                if self.non_parents == '': self.non_parents = []
+                if self.non_parent_exceptions == '': self.non_parent_exceptions = []
+
+                self.dependencies = list(self.childs + self.non_parents + self.non_parent_exceptions + extra_dependencies)
+                if self._mandatory and not name in self.dependencies: self.dependencies.append(self.name)
+
+                for inp in gui_inputs:
+                        assert inp.__class__.__name__ in GUI_definition.__all__
+                if not gui_inputs:      gui_inputs = self._set_gui_input(gui_inputs,tokens)
+                self.gui_inputs = self._addBooleanToGuiInput(gui_inputs)
+
+                self.dict = {
+                        'name'           : name,              #as defined in uvspec_lex.l
+                        'group'          : group,             # e.g. WC
+                        'help'           : helpstr,           # Help string (short), could appear as pop-up in GUI
+                        'documentation'  : documentation,     # Full documentation
+                        'tokens'         : tokens,            # Variable in uvspec inp_struct to change
+                        'parents'        : parents,           # (specifies which options must also be defined together with this option)
+                        # One of the options must also be defined with this options
+                        'non_parents'    : non_parents,       # specifies which options must not be defined together with this option
+                        'non_parent_exceptions'    : non_parent_exceptions,       # specifies which options inside non_parents should be ignored
+                        'childs'         : childs,            # (specifies which options can be defined with this option)
+                        # Options which will be unlocked when defining this option
+                        'mystic'         : mystic,            # mystic option
+                        'threedmystic'   : threedmystic,      # 3D mystic option
+                        'islidar'        : islidar,           # lidar option
+                        'developer'      : developer,         # developer option, undocumented for esasLight
+                        'plot'           : plot,              # Setup plotting for options which should be plotted
+                        }
+
+                self.canEnable = self._canEnable
+
+                if  speaker and enable_values:
+                        self._speaker = speaker
+                        assert not isinstance(enable_values, str), "Missing comma in one-item-tuple?"
+                        self._enable_values = enable_values
+                        self.canEnable = self._canEnableContinousOption
+                if extra_dependencies:
+                        self.isMandatory = self._isMandatoryMixedOption
+
+
+        # Pretend to be a dictionary to avoid breaking old code
+        def __getitem__(self, *args, **kwargs):
+                return self.dict.__getitem__(*args, **kwargs)
+        def __setitem__(self, *args, **kwargs):
+                return self.dict.__setitem__(*args, **kwargs)
+        def __contains__(self, *args, **kwargs):
+                return self.dict.__contains__(*args, **kwargs)
+        def get(self, *args, **kwargs):
+                return self.dict.get(*args, **kwargs)
+
+        def _canEnableContinousOption(self, is_set, get_value):
+                """
+                Remember that self.speaker must be a subclass of
+                continious_option.
+                """
+                r = self._canEnable(is_set, get_value)
+                if r and is_set(self._speaker) and  \
+                            get_value(self._speaker)[0] in self._enable_values:
+                        return r
+                else:
+                        return False
+
+        def _canEnable(self, is_set, get_value):
+                """
+                Tells the GUI wether the option should be enabled or disabled.
+                Returns True if the option should be enabled and False if it
+                should be disabled.
+
+                is_set is a function that returns True if an option is enabled
+                and has been edited by the user, else False. It takes one
+                argument, the name of an option as a string.
+
+                get_value returns the current value of an option
+
+                This is used to implement the logic in the GUI. If more
+                complex logic than the parent, non-parent, children logic is
+                needed this function should be overloaded.
+
+                Remember to update the dependency tuple, a tuple of options
+                which should be enabled or disabled depending on if this
+                option is set.
+                """
+                parents = any([is_set(parent) for parent in self.parents]) \
+                    or not self.parents
+                non_parents = all([(not is_set(non_parent) or self.non_parent_exceptions.count(non_parent) or non_parent==self.name) \
+                                           for non_parent in self.non_parents]) \
+                                           or not self.non_parents
+                return parents and non_parents
+
+        def isMandatory(self, is_set, get_value):
+                """
+                Returns True for mandatory options. Similar to canEnable.
+                """
+                if self._mandatory and not is_set(self.name):   return True
+                return False
+
+        def _isMandatoryMixedOption(self, is_set, get_value):
+                cond = [is_set(opt) for opt in self._extra_dependencies]
+                if all(cond):
+                        return False
+                elif any(cond):
+                        return True
+                else:
+                        return False
+
+
+        def _set_gui_input(self,gui_inputs,tokens):
+
+                if not self.showInGui:
+                        return gui_inputs
+                for inp in tokens:
+                        try:
+                                name = inp.gui_name
+                        except KeyError:
+                                pass
+                        if not name:    name = inp.get('name')
+                        try:
+                                vr = inp.get('valid_range')
+                        except KeyError:
+                                vr = None
+
+                        if isinstance(inp, addSetting):
+                                continue
+                        elif isinstance(inp, addLogical):
+                                gui_inp = (ListInput(name=name,valid_range=inp.get('valid_range'),optional=inp.get('optional'),default=inp.get('default'),logical_file=inp.get('logical_file')),)
+                        elif isinstance(inp, addToken):
+                                dtype = inp.get('datatype')
+                                if dtype == float or dtype==Double:
+                                        if not vr: vr = (-1e99, 1e99)
+                                        gui_inp = (FloatInput(name=name,optional=inp.get('optional'),valid_range=vr,default=inp.get('default')),)
+                                elif dtype == int:
+                                        if not vr: vr = (-1e99, 1e99)
+                                        gui_inp = (IntegerInput(name=name,valid_range=vr,optional=inp.get('optional'),default=inp.get('default')),)
+                                elif vr:
+                                        gui_inp = (ListInput(name=name,valid_range=inp.get('valid_range'),optional=inp.get('optional'),default=inp.get('default'),logical_file=inp.get('logical_file')),)
+                                elif dtype == io.IOBase:
+                                        gui_inp = ( FileInput(name=name,optional=inp.get('optional')) ,)
+                                else:   gui_inp = (TextInput(name=name,optional=inp.get('optional')),)
+                        gui_inputs = gui_inputs.__add__(gui_inp)
+                return gui_inputs
+
+        def _addBooleanToGuiInput(self,gui_inputs):
+                if not self.showInGui:
+                        return ()
+                for inp in gui_inputs:
+                        if not inp.optional or inp.__class__ == BooleanInput:
+                                return gui_inputs
+                return ( BooleanInput(name=''), ).__add__(gui_inputs)
 
 
 class Dimension():
-	"""
-	Options which can take dimensions (number+word) as argument ( 1D, 3D )
-	"""
-	def __init__(self):
-		self.valid_range = ["1d","3d"]
-	def get_valid_range(self):
-		return self.valid_range
+        """
+        Options which can take dimensions (number+word) as argument ( 1D, 3D )
+        """
+        def __init__(self):
+                self.valid_range = ["1d","3d"]
+        def get_valid_range(self):
+                return self.valid_range
 
 class ProfileType():
-	"""
-	Options which can take several profile files as argument (e.g. 1D, 3D, moments, ipa_files)
-	"""
-	def __init__(self):
-		self.valid_range = ["1d","3d","ipa_files","moments"]
-	def get_valid_range(self):
-		return self.valid_range
+        """
+        Options which can take several profile files as argument (e.g. 1D, 3D, moments, ipa_files)
+        """
+        def __init__(self):
+                self.valid_range = ["1d","3d","ipa_files","moments"]
+        def get_valid_range(self):
+                return self.valid_range
 
 class CaothType():
-	"""
-	Options which can take several profile as argument (e.g. wc, ic or any other profile)
-	"""
-	def __init__(self,caoth=None):
-		self.caoth = caoth
-	def get_caoth(self):
-		return self.caoth
+        """
+        Options which can take several profile as argument (e.g. wc, ic or any other profile)
+        """
+        def __init__(self,caoth=None):
+                self.caoth = caoth
+        def get_caoth(self):
+                return self.caoth
 class CaothoffType():
-	"""
-	Quick fix for new option names no_scattering and no_absorption
-	"""
+        """
+        Quick fix for new option names no_scattering and no_absorption
+        """
 
 class Double(float):
-	"""Double for c allocation double"""
+        """Double for c allocation double"""
 
 class SignedFloats():
-	"""Signed floats for c allocation multiple floats"""
+        """Signed floats for c allocation multiple floats"""
 
 class Integers():
-	"""Integers for c allocation multiple integers"""
+        """Integers for c allocation multiple integers"""
 
 class VariableNumberOfLines():
-	pass
+        pass
 
 # valid_datatypes = ( # i.e. datatypes the GUI support (soon)
-# 	ProfileType,
-# 	CaothType,
-# 	CaothoffType,
-# 	Double,
-# 	SignedFloats,
-# 	VariableNumberOfLines,
-	
-# 	# In my opinion these should be replaced by DatatFile, Integer etc., since as
-# 	# far as I know, the only property used is that file, int etc. are distinct
-# 	# and globally avilable variables. It is completely irrelevant, that they
-# 	# happen to be internal datatypes of python.
-# 	file, int, float, long, str
+#       ProfileType,
+#       CaothType,
+#       CaothoffType,
+#       Double,
+#       SignedFloats,
+#       VariableNumberOfLines,
+
+#       # In my opinion these should be replaced by DatatFile, Integer etc., since as
+#       # far as I know, the only property used is that file, int etc. are distinct
+#       # and globally avilable variables. It is completely irrelevant, that they
+#       # happen to be internal datatypes of python.
+#       file, int, float, long, str
 # )
 
 class not_yet_lex2py_option(option):
-	"""
-	Quick fix for options which are currently hard to implement in
-	the python-structures.
-	"""
-	def writeLex(self):
-		return ""
+        """
+        Quick fix for options which are currently hard to implement in
+        the python-structures.
+        """
+        def writeLex(self):
+                return ""
 
 class addInput():
-	def __init__(self, name='', default=None, gui_name=None):
-		self.name = name
-		self.default = default
-		self.gui_name = gui_name
+        def __init__(self, name='', default=None, gui_name=None):
+                self.name = name
+                self.default = default
+                self.gui_name = gui_name
 
-		self.dict = {
-			'name'		: self.name,		# variable name to set as defined in uvspec_lex.l
-			'default'	: self.default,	# default value for GUI AND uvspec_lex.l
-		}
+                self.dict = {
+                        'name'          : self.name,            # variable name to set as defined in uvspec_lex.l
+                        'default'       : self.default, # default value for GUI AND uvspec_lex.l
+                }
 
-	def __getitem__(self, *args, **kwargs):
-		return self.dict.__getitem__(*args, **kwargs)
+        def __getitem__(self, *args, **kwargs):
+                return self.dict.__getitem__(*args, **kwargs)
 
-	def get(self, *args, **kwargs):
-		return self.dict.get(*args, **kwargs)
+        def get(self, *args, **kwargs):
+                return self.dict.get(*args, **kwargs)
 
 
 class addToken(addInput):
-	def __init__(self, datatype=None, valid_range=None, optional=False, **kwargs):
-		addInput.__init__(self,**kwargs)
-
-		logical_file = False
-		if valid_range:
-			if valid_range[-1] == file:
-				valid_range.pop(-1)
-				logical_file = True
-		self.datatype = datatype
-		self.valid_range = valid_range
-		self.optional = optional
-
-		self.dict['datatype']    = self.datatype	# datatype of input token, possible types are float, int, str, file (for GUI)
-		self.dict['valid_range'] = self.valid_range	# important for GUI and unsigned floats
-		self.dict['optional']	 = self.optional	# optional argument
-		self.dict['logical_file']= logical_file		#if not logical argument, then input is filename
-		
+        def __init__(self, datatype=None, valid_range=None, optional=False, **kwargs):
+                addInput.__init__(self,**kwargs)
+
+                logical_file = False
+                if valid_range:
+                        if valid_range[-1] == io.IOBase:
+                                valid_range.pop(-1)
+                                logical_file = True
+                self.datatype = datatype
+                self.valid_range = valid_range
+                self.optional = optional
+
+                self.dict['datatype']    = self.datatype        # datatype of input token, possible types are float, int, str, file (for GUI)
+                self.dict['valid_range'] = self.valid_range     # important for GUI and unsigned floats
+                self.dict['optional']    = self.optional        # optional argument
+                self.dict['logical_file']= logical_file         #if not logical argument, then input is filename
+
 class addLogical(addToken):
-	def __init__(self, logicals=[], setting='', logical_file=False, datatype=str, **kwargs):
-		
-		if logicals[-1] == file:
-			logicals.pop(-1)
-			logical_file = True
-		elif isinstance( logicals[-1], CaothType ):
-			logicals.pop(-1)
-			caoth = True
-
-		if   sorted([ dim.lower() for dim in logicals ]) == ProfileType().get_valid_range():	datatype = ProfileType
-		elif sorted([ dim.lower() for dim in logicals ]) ==   Dimension().get_valid_range():	datatype = Dimension
-
-		addToken.__init__(self,datatype=datatype,valid_range=logicals,**kwargs)
-			
-		self.setting = setting
-		self.logical_file = logical_file
-
-		if isinstance(logicals, ProfileType): self.datatype=ProfileType
-
-		self.dict['logicals']		= self.valid_range	# variable name to set as defined in uvspec_lex.l
-		self.dict['setting']		= self.setting	 	# value variable should be set to as in uvspec_lex.l
-		self.dict['destination']	= self.name	 	# default value for uvspec_lex.l
-		self.dict['logical_file']	= self.logical_file	#if not logical argument, then input is filename
-		
+        def __init__(self, logicals=[], setting='', logical_file=False, datatype=str, **kwargs):
+
+                if logicals[-1] == io.IOBase:
+                        logicals.pop(-1)
+                        logical_file = True
+                elif isinstance( logicals[-1], CaothType ):
+                        logicals.pop(-1)
+                        caoth = True
+
+                if   sorted([ dim.lower() for dim in logicals ]) == ProfileType().get_valid_range():    datatype = ProfileType
+                elif sorted([ dim.lower() for dim in logicals ]) ==   Dimension().get_valid_range():    datatype = Dimension
+
+                addToken.__init__(self,datatype=datatype,valid_range=logicals,**kwargs)
+
+                self.setting = setting
+                self.logical_file = logical_file
+
+                if isinstance(logicals, ProfileType): self.datatype=ProfileType
+
+                self.dict['logicals']           = self.valid_range      # variable name to set as defined in uvspec_lex.l
+                self.dict['setting']            = self.setting          # value variable should be set to as in uvspec_lex.l
+                self.dict['destination']        = self.name             # default value for uvspec_lex.l
+                self.dict['logical_file']       = self.logical_file     #if not logical argument, then input is filename
+
 
 class addSetting(addInput):
-	def __init__(self, setting='', **kwargs):
-		addInput.__init__(self,**kwargs)
+        def __init__(self, setting='', **kwargs):
+                addInput.__init__(self,**kwargs)
+
+                if isinstance( setting, CaothType ):
+                        if setting.get_caoth():
+                                self.setting = 'get_caoth_index(&Input.caoth,&Input.n_caoth,"%s",1)' %( setting.get_caoth() )
+                        else:
+                                print("Error: Must define caoth wc/ic")
+                else:
+                        self.setting = setting
 
-		if isinstance( setting, CaothType ):
-			if setting.get_caoth():
-				self.setting = 'get_caoth_index(&Input.caoth,&Input.n_caoth,"%s",1)' %( setting.get_caoth() )
-			else:
-				print "Error: Must define caoth wc/ic"
-		else:
-			self.setting = setting
+                self.dict['setting']    = self.setting  # value variable should be set to as in uvspec_lex.l
 
-		self.dict['setting']	= self.setting 	# value variable should be set to as in uvspec_lex.l
-		
 
 def addPlot(plot_type, optional_args={}):
-	return {
-		'plot_type'     : plot_type,     # One of '2D' or 'map'
-		'optional_args' : optional_args # A dictionary of other information required by the specific plot_types. Currently it should be empty for map and contain a list of column_names for 2D.
-		}
+        return {
+                'plot_type'     : plot_type,     # One of '2D' or 'map'
+                'optional_args' : optional_args # A dictionary of other information required by the specific plot_types. Currently it should be empty for map and contain a list of column_names for 2D.
+                }
 
 def _checkForDictionary(argument):
-	
-	if not argument: return []
-	elif isinstance(argument,list): 
-		for arg in argument:
-			if   isinstance(arg,addToken):	continue
-			elif isinstance(arg,addSetting):	continue
-			elif isinstance(arg,addLogical):	continue
-			else:	return -1 
-			
-		return argument
-				
-	elif isinstance(argument, addToken):	return [argument]
-	elif isinstance(argument, addSetting):	return [argument]
-	elif isinstance(argument, addLogical):	return [argument]
-	else: return -1	
+
+        if not argument: return []
+        elif isinstance(argument,list):
+                for arg in argument:
+                        if   isinstance(arg,addToken):  continue
+                        elif isinstance(arg,addSetting):        continue
+                        elif isinstance(arg,addLogical):        continue
+                        else:   return -1
+
+                return argument
+
+        elif isinstance(argument, addToken):    return [argument]
+        elif isinstance(argument, addSetting):  return [argument]
+        elif isinstance(argument, addLogical):  return [argument]
+        else: return -1
diff --git a/src_py/output_options.py b/src_py/output_options.py
index d19a6fa..7ee030f 100644
--- a/src_py/output_options.py
+++ b/src_py/output_options.py
@@ -1,29 +1,29 @@
 """--------------------------------------------------------------------
  * $Id$
- * 
+ *
  * This file is part of libRadtran.
  * Copyright (c) 1997-2012 by Arve Kylling, Bernhard Mayer,
  *                            Claudia Emde, Robert Buras
  *
  * ######### Contact info: http://www.libradtran.org #########
  *
- * This program is free software; you can redistribute it and/or 
- * modify it under the terms of the GNU General Public License   
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.        
- * 
- * This program is distributed in the hope that it will be useful, 
- * but WITHOUT ANY WARRANTY; without even the implied warranty of  
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the   
- * GNU General Public License for more details.                    
- * 
- * You should have received a copy of the GNU General Public License          
- * along with this program; if not, write to the Free Software                
- * Foundation, Inc., 59 Temple Place - Suite 330, 
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
  * Boston, MA 02111-1307, USA.
  *--------------------------------------------------------------------"""
 
-
+import io
 from option_definition import *
 
 class setup_output_group():
@@ -86,18 +86,18 @@ class setup_output_group():
 		print_disort_info = option(
 			name='print_disort_info',
 			group='output',
-			helpstr='Print various disort output. See disort.doc', 
+			helpstr='Print various disort output. See disort.doc',
 			documentation=documentation['print_disort_info'],
 			tokens=[addToken(name="Input.rte.prndis", datatype=Integers),
 				addSetting(name='Input.rte.nprndis',setting='ntokens') ],
 		)
 
 		data_files_path = option(
-			name='data_files_path', 
-			group='output', 
-			documentation=documentation['data_files_path'],	
+			name='data_files_path',
+			group='output',
+			documentation=documentation['data_files_path'],
 			gui_inputs=(FileInput(name='Input.filename[FN_PATH]'),),
-			tokens = addToken(name='Input.filename[FN_PATH]' , datatype=file),	
+			tokens = addToken(name='Input.filename[FN_PATH]' , datatype=io.IOBase),
 		)
 
 		output_process = option(
@@ -113,26 +113,26 @@ class setup_output_group():
 
 		output_file = option(
 			name='output_file',
-			group='output', 
-			helpstr='Location of the output file', 
-			documentation=documentation['output_file'], 
+			group='output',
+			helpstr='Location of the output file',
+			documentation=documentation['output_file'],
 			gui_inputs=(TextInput(name='Input.filename[FN_OUTFILE]'),),
 			tokens=addToken(name='Input.filename[FN_OUTFILE]', datatype=str),
 			parents=['uvspec'],
 		)
 
 		output_format = option(
-			name='output_format', 
+			name='output_format',
 			group='output',
 			helpstr='Output format',
 			documentation=documentation['output_format'],
-			tokens=addLogical(name='Input.output_format', logicals=['ascii','flexstor','netCDF','sat_picture'], setting='OUTPUT_FORMAT_'), 
+			tokens=addLogical(name='Input.output_format', logicals=['ascii','flexstor','netCDF','sat_picture'], setting='OUTPUT_FORMAT_'),
 		)
 
 		output_user = not_yet_lex2py_option(
 			name='output_user',
 			group='output',
-			helpstr='User defined output', 
+			helpstr='User defined output',
 			documentation=documentation['output_user'],
 			gui_inputs=(TextInput(name=''),),
 			tokens=addToken(name="", datatype=str),
@@ -150,7 +150,7 @@ class setup_output_group():
 
 		heating_rate = option(
 			name='heating_rate',
-			group='output',	
+			group='output',
 			helpstr='Calculation of heating rates.',
 			documentation=documentation['heating_rate'],
 			gui_inputs=(ListInput(name='Input.heating', valid_range=['none', 'local', 'layer_fd', 'layer_cd'], optional=True),),
@@ -176,7 +176,7 @@ class setup_output_group():
 			helpstr='If specified, the calculated spectrum is convolved with the function found in the slit_function_file.',
 			documentation=documentation['slit_function_file'],
 			gui_inputs=(FileInput(name='Input.filename[FN_SLITFUNCTION]'),),
-			tokens = [ addToken(name='Input.filename[FN_SLITFUNCTION]', datatype=file),
+			tokens = [ addToken(name='Input.filename[FN_SLITFUNCTION]', datatype=io.IOBase),
 				addSetting(name='Input.convolve', setting=1, default=0) ],
 			parents=['uvspec'],
 			non_parents=['filter_function_file','thermal_bands_file'],
@@ -208,7 +208,7 @@ class setup_output_group():
 			helpstr='Spline interpolate to arbitrary wavelengths, in nm, given as a single column in file.',
 			documentation=documentation['spline_file'],
 			gui_inputs=(FileInput(name='Input.filename[FN_SPLINE]'),),
-			tokens = [ addToken(name='Input.filename[FN_SPLINE]', datatype=file),
+			tokens = [ addToken(name='Input.filename[FN_SPLINE]', datatype=io.IOBase),
 				addSetting(name='Input.spline', setting=1, default=0) ] ,
 			parents=['uvspec'],
 			non_parents=['spline'],
@@ -219,7 +219,7 @@ class setup_output_group():
 			group='output',
 			helpstr='If specified, the calculated spectrum is multiplied with a filter function defined in file.',
 			documentation=documentation['filter_function_file'],
-			tokens=[addToken(name='Input.filename[FN_FILTERFUNCTION]',datatype=file),
+			tokens=[addToken(name='Input.filename[FN_FILTERFUNCTION]',datatype=io.IOBase),
 				addLogical(name='Input.filter_function_normalize', logicals=['normalize'], optional=True) ],
 			parents=['uvspec'],
 			non_parents=['slit_function_file','thermal_bands_file'],
@@ -243,8 +243,8 @@ class setup_output_group():
 
 		zout = not_yet_lex2py_option(
 			name='zout',
-			group='output',	
-			helpstr='Output altitude(s).', 
+			group='output',
+			helpstr='Output altitude(s).',
 			documentation=documentation['zout'],
 			gui_inputs=(TextInput(name=''),),
 			tokens=addToken(name="", datatype=str),
@@ -254,8 +254,8 @@ class setup_output_group():
 
 		zout_sea = not_yet_lex2py_option(
 			name='zout_sea',
-			group='output',	
-			helpstr='Output altitude(s) above sea surface.', 
+			group='output',
+			helpstr='Output altitude(s) above sea surface.',
 			documentation=documentation['zout_sea'],
 			gui_inputs=(TextInput(name=''),),
 			tokens=addToken(name="", datatype=str),
@@ -264,13 +264,13 @@ class setup_output_group():
 		)
 
 		mc_backward_output = option(
-			name='mc_backward_output', 
+			name='mc_backward_output',
 			group='output',
-			helpstr='Specify quantity to be calculated using backward Monte Carlo.', 
-			documentation=documentation['mc_backward_output'], 
-			tokens=[ addLogical(name='Input.rte.mc.backward.output', logicals=['edir','edn','eup','fdir','fdn','fup','act','abs','emis','heat','exp','exn','eyp','eyn','ednpv'], setting='MCBACKWARD_', gui_name='output' ),	
-				 addLogical(name='Input.rte.mc.abs_unit', logicals=['W_per_m2_and_dz', 'W_per_m3', 'K_per_day'], setting='MCABS_UNIT_' , optional = True, gui_name='unit' ) ], 
-			parents=['mc_backward'], 
+			helpstr='Specify quantity to be calculated using backward Monte Carlo.',
+			documentation=documentation['mc_backward_output'],
+			tokens=[ addLogical(name='Input.rte.mc.backward.output', logicals=['edir','edn','eup','fdir','fdn','fup','act','abs','emis','heat','exp','exn','eyp','eyn','ednpv'], setting='MCBACKWARD_', gui_name='output' ),
+				 addLogical(name='Input.rte.mc.abs_unit', logicals=['W_per_m2_and_dz', 'W_per_m3', 'K_per_day'], setting='MCABS_UNIT_' , optional = True, gui_name='unit' ) ],
+			parents=['mc_backward'],
 			speaker='rte_solver',
 			enable_values=("mystic","montecarlo"),
 			mystic =True
@@ -281,9 +281,9 @@ class setup_output_group():
 			group='output',
 			helpstr='Specify quantity to be calculated using forward Monte Carlo.',
 			documentation=documentation['mc_forward_output'],
-			tokens = [ addLogical( name='Input.rte.mc.absorption', logicals=['absorption','actinic','emission','heating'], setting='MCFORWARD_ABS_', gui_name='output' ), 
+			tokens = [ addLogical( name='Input.rte.mc.absorption', logicals=['absorption','actinic','emission','heating'], setting='MCFORWARD_ABS_', gui_name='output' ),
 				addLogical(name='Input.rte.mc.abs_unit', logicals=['W_per_m2_and_dz', 'W_per_m3', 'K_per_day'] , setting='MCABS_UNIT_',  optional = True, gui_name='unit' ) ],
-			parents=['uvspec'], 
+			parents=['uvspec'],
 			non_parents=['mc_backward'],
 			speaker='rte_solver',
 			enable_values=("mystic","montecarlo"),
@@ -291,24 +291,24 @@ class setup_output_group():
 		)
 
 		mc_basename = option(
-			name='mc_basename', 
-			group='output', 
+			name='mc_basename',
+			group='output',
 			helpstr='Filename for MYSTIC output.',
 			documentation=documentation['mc_basename'],
-			tokens=addToken(name='Input.rte.mc.filename[FN_MC_BASENAME]',datatype=file),
-			parents=['uvspec'], 
+			tokens=addToken(name='Input.rte.mc.filename[FN_MC_BASENAME]',datatype=io.IOBase),
+			parents=['uvspec'],
 			speaker='rte_solver',
 			enable_values=("mystic","montecarlo"),
 			mystic =True
 		)
 
 		mc_backward_writeallpixels = option(
-			name='mc_backward_writeallpixels', 
-			group='output', 
+			name='mc_backward_writeallpixels',
+			group='output',
 			helpstr='Write all pixels to the output files',
-			documentation=documentation['mc_backward_writeallpixels'],	
-			tokens=addSetting(name='Input.rte.mc.backward.writeallpixels', setting=1),	
-			parents=['mc_backward'], 
+			documentation=documentation['mc_backward_writeallpixels'],
+			tokens=addSetting(name='Input.rte.mc.backward.writeallpixels', setting=1),
+			parents=['mc_backward'],
 			speaker='rte_solver',
 			enable_values=("mystic","montecarlo"),
 			threedmystic =True
@@ -317,10 +317,10 @@ class setup_output_group():
 		mc_std = option(
 			name='mc_std',
 			group='output',
-			helpstr='Calculate MYSTIC standard deviation.', 
+			helpstr='Calculate MYSTIC standard deviation.',
 			documentation=documentation['mc_std'],
-			tokens=addSetting(name='Input.rte.mc.std', setting=1, default=0), 
-			parents=['uvspec'], 
+			tokens=addSetting(name='Input.rte.mc.std', setting=1, default=0),
+			parents=['uvspec'],
 			speaker='rte_solver',
 			enable_values=("mystic","montecarlo"),
 			threedmystic =True
@@ -381,12 +381,12 @@ class setup_output_group():
 				heating_rate,
 				write_output_as_netcdf,
 				slit_function_file, spline, spline_file,
-				filter_function_file,  
+				filter_function_file,
 				pressure_out,
-				zout, zout_sea,  
+				zout, zout_sea,
 				mc_backward_output,
-				mc_forward_output, 
-				mc_basename, 
+				mc_forward_output,
+				mc_basename,
 				mc_backward_writeallpixels,
 				mc_std,
 				mc_surfaceparallel, mc_jacobian, mc_jacobian_std,
@@ -400,7 +400,7 @@ def get_output_documentation():
 		'data_files_path' : r'''
 	The path to the directory where all \code{uvspec} internal data files live, e.g.
 	the files that are in the subdirectories of the \file{data} directory
-	that comes with the \code{uvspec} distribution. 
+	that comes with the \code{uvspec} distribution.
 	\fcode{
 	data\_files\_path path
 	}
@@ -408,59 +408,59 @@ def get_output_documentation():
 		''',
 
 		'include' : r'''
-	Include a file into the \code{uvspec} input.  
-	\fcode{ 
-	include file 
-	} 
-	Works exactly like the C \code{\#include} or  
-	the Fortran \code{INCLUDE} statements. 
+	Include a file into the \code{uvspec} input.
+	\fcode{
+	include file
+	}
+	Works exactly like the C \code{\#include} or
+	the Fortran \code{INCLUDE} statements.
 		''',
 
 		'mc_backward_writeallpixels' : r'''
-	If set, write all pixels to the output files; otherwise, only those are written 
+	If set, write all pixels to the output files; otherwise, only those are written
 	which are actually calculated.
 		''',
 
 		'mc_backward_output' : r'''
-	Specify quantity to be calculated using backward Monte Carlo. 
+	Specify quantity to be calculated using backward Monte Carlo.
 	\fcode{
 	mc\_backward\_output output [unit]
 	}
 	So far the
-	following \code{output} options have been implemented: 
+	following \code{output} options have been implemented:
 	\begin{description}
-	\parameter{edir} 
+	\parameter{edir}
 	  direct horizontal irradiance
-	\parameter{edn} 
+	\parameter{edn}
 	  diffuse downward irradiance (default)
-	\parameter{eup} 
+	\parameter{eup}
 	  diffuse upward irradiance
-        \parameter{exp} 
+        \parameter{exp}
 	  diffuse irradiance in positive x direction for grid box above specified altitude at the left (lower x) face; output is written to eup.
-        \parameter{exn} 
+        \parameter{exn}
 	  diffuse irradiance in negative x direction for grid box above specified altitude at the left (lower x) face; output is written to edn.
-        \parameter{eyp} 
+        \parameter{eyp}
 	  diffuse irradiance in positive y direction for grid box above specified altitude at the front (lower y) face; output is written to eup.
-        \parameter{eyn} 
+        \parameter{eyn}
 	  diffuse irradiance in negative y direction for grid box above specified altitude at the front (lower y) face; output is written to edn.
-	\parameter{act} 
+	\parameter{act}
 	  actinic flux
-	\parameter{abs} 
+	\parameter{abs}
 	  absorption
-        \parameter{emis} 
+        \parameter{emis}
           emission
-        \parameter{heat} 
+        \parameter{heat}
           heating rates, that is absorption + emission
 	\end{description}
-	For \code{abs}, \code{emis}, \code{heat} an optional argument \code{W\_per\_m2\_and\_dz} (default), 
-	\code{W\_per\_m3}, or \code{K\_per\_day} may be specified which converts the result e.g. to heating rates. 
+	For \code{abs}, \code{emis}, \code{heat} an optional argument \code{W\_per\_m2\_and\_dz} (default),
+	\code{W\_per\_m3}, or \code{K\_per\_day} may be specified which converts the result e.g. to heating rates.
 		''',
 
 		'mc_forward_output' : r'''
 	Specify quantity to be calculated using forward Monte Carlo.
 	Forward output is calculated for each grid box; may need a considerable amount of memory,
         depending on the 3D cloud grid. Only meaningful with \code{rte\_solver mystic}.
-	This option is only available for forward calculations. 
+	This option is only available for forward calculations.
 	For backward please use \code{mc\_backward\_output}.
 	\fcode{
 	mc\_forward\_output quantity [unit]
@@ -468,30 +468,30 @@ def get_output_documentation():
 	\code{quantity} can be one of the following:
 	\begin{description}
 	\parameter{absorption}
-	Calculate MYSTIC absorption and write it to file \code{mc\_basename}.abs.spc 
+	Calculate MYSTIC absorption and write it to file \code{mc\_basename}.abs.spc
         in the following format:
         \fcode{
         lambda ix iy iz absorption
         }
 	For backward please use \code{mc\_backward\_output abs}.
 	\parameter{actinic}
-	Calculate MYSTIC actinic flux by dividing the absorbed energy by the 
-        absorption coeffcient; this method is much better than the traditional photon counting 
-        which usually comprises spikes (because in the latter method each photon is weighted with 
-        $1/\cos(\theta)$ which may be a very large number);  
-        For backward please use \code{mc\_backward\_output act}. 
+	Calculate MYSTIC actinic flux by dividing the absorbed energy by the
+        absorption coeffcient; this method is much better than the traditional photon counting
+        which usually comprises spikes (because in the latter method each photon is weighted with
+        $1/\cos(\theta)$ which may be a very large number);
+        For backward please use \code{mc\_backward\_output act}.
 	\parameter{emission}
-	Calculate MYSTIC emission. Note that emission is calculated directly without tracing 
-        any photons which makes this option very fast. Changing \code{mc\_photons} will therefore 
-        not affect the result. Only meaningful with \code{source thermal}. 
+	Calculate MYSTIC emission. Note that emission is calculated directly without tracing
+        any photons which makes this option very fast. Changing \code{mc\_photons} will therefore
+        not affect the result. Only meaningful with \code{source thermal}.
 	For backward please use \code{mc\_backward\_output emis}.
 	\parameter{heating}
-	Calculate MYSTIC heating rates. This is identical to \code{absorption} for \code{source solar}. 
-	For \code{source thermal}, however, the emission of a photon in a grid box is counted as cooling. 
+	Calculate MYSTIC heating rates. This is identical to \code{absorption} for \code{source solar}.
+	For \code{source thermal}, however, the emission of a photon in a grid box is counted as cooling.
 	For backward please use \code{mc\_backward\_output heat}.
 	\end{description}
         The optional argument \code{unit} may be one of \code{W\_per\_m2\_and\_dz} (default), \code{W\_per\_m3}, or \code{K\_per\_day}.
-	\code{unit} may be specified to convert the result e.g. to heating rates. 
+	\code{unit} may be specified to convert the result e.g. to heating rates.
 		''',
 
 		'mc_basename' : r'''
@@ -502,20 +502,20 @@ def get_output_documentation():
 		''',
 
 	'mc_jacobian' : r'''
-	Calculate Jacobians. i.e. the derivative of radiance/irradiance with respect to absorption/scattering optical thickness. The derivatives are calculated for each vertical layer. 
+	Calculate Jacobians. i.e. the derivative of radiance/irradiance with respect to absorption/scattering optical thickness. The derivatives are calculated for each vertical layer.
 
         The option is implemented only for \code{rte\_solver montecarlo} in backward tracing mode \code{mc\_backward}.
 
-        The derivatives are calculated separately for all species (i.e. molecules, aerosols and clouds). So far the option is only included for monochromatic simulations. 
+        The derivatives are calculated separately for all species (i.e. molecules, aerosols and clouds). So far the option is only included for monochromatic simulations.
 
         The result is provided in the output file \code{basename.jac}, which includes the following columns: \\
 
         x \hspace{1ex}  y \hspace{1ex}  z$_i$ \hspace{1ex}  $\frac{\partial{I}}{\partial{\tau_{s,mol,i}}}$ \hspace{1ex} $\frac{\partial{I}}{\partial{\tau_{a,mol,i}}}$ \hspace{1ex}  $\frac{\partial{I}}{\partial{\tau_{s,aer,i}}}$ \hspace{1ex}  $\frac{\partial{I}}{\partial{\tau_{a,aer,i}}}$
-        
+
 		''',
 	'mc_jacobian_std' : r'''
-	Calculate jacobi matrix standard deviation. Only meaningful with 
-	\code{mc\_jacobian}. 
+	Calculate jacobi matrix standard deviation. Only meaningful with
+	\code{mc\_jacobian}.
 		''',
 
 		'mc_std' : r'''
@@ -525,23 +525,23 @@ def get_output_documentation():
 		'mc_surfaceparallel' : r'''
 	Calculate irradiance parallel to the surface instead of horizonal irradiance. This
 	option is obviously only interesting for topograpy and only for calculations at
-	the surface. For other levels the option is ignored. 
+	the surface. For other levels the option is ignored.
 		''',
 
 		'filter_function_file' : r'''
-	If specified, the calculated spectrum is multiplied with a filter function 
+	If specified, the calculated spectrum is multiplied with a filter function
 	defined in file.
 	\fcode{
 	filter\_function\_file file [normalize]
 	}
-	The file must contain two columns. 
-	Column 1 is the wavelength, in nm. Column 2 is the corresponding filter 
+	The file must contain two columns.
+	Column 1 is the wavelength, in nm. Column 2 is the corresponding filter
 	function value. Comments start with \code{\#}. Empty lines are ignored.
-	In combination with \code{output\_process sum} or \code{output\_process integrate} this option 
-	is useful e.g. to calculate weighted irradiances or actinic fluxes or 
+	In combination with \code{output\_process sum} or \code{output\_process integrate} this option
+	is useful e.g. to calculate weighted irradiances or actinic fluxes or
 	to simulate broadband or satellite observations.
 
-	If the optional second argument \code{normalize} is specified, 
+	If the optional second argument \code{normalize} is specified,
 	the integral of the filter function over wavelength is normalized such
 	that \code{output\_process integrate} gives radiative properties per wavelength, averaged over
 	the filter function.
@@ -549,18 +549,18 @@ def get_output_documentation():
 
 		'slit_function_file' : r'''
 	If specified, the calculated spectrum is convolved with the function found
-	in the \file{slit\_function\_file}. 
+	in the \file{slit\_function\_file}.
 	\fcode{
-	slit\_function\_file file 
+	slit\_function\_file file
 	}
 	The file must contain two columns. Column 1 is the wavelength, in nm, and relative to the
 	center wavelength. Column 2 is the corresponding slit function value. It must
 	be unity at the maximum. The wavelength steps in the slit function file must
-	be equidistant. Comments start with \code{\#}. Empty lines are ignored. Please 
+	be equidistant. Comments start with \code{\#}. Empty lines are ignored. Please
 	note that prior to convolution the spectrum is interpolated to the wavelength
 	steps of the slit function. For this reason, make sure that the resolution
-	of the slit function is high enough even if the slit function is e.g. a 
-	simple triangle which could in principle be described with 3 grid points. For an 
+	of the slit function is high enough even if the slit function is e.g. a
+	simple triangle which could in principle be described with 3 grid points. For an
 	example see \file{examples/TRI\_SLIT.DAT} and the \code{make\_slitfunction} tool.
 		''',
 
@@ -568,29 +568,29 @@ def get_output_documentation():
 	\fcode{
 	spline lambda\_0 lambda\_1 lambda\_step
 	}
-	Spline interpolate the calculated spectrum between wavelengths \code{lambda\_0} 
+	Spline interpolate the calculated spectrum between wavelengths \code{lambda\_0}
 	and \code{lambda\_1} in steps of \code{lambda\_step},
 	in nm. Specified as e.g.
 	\fcode{
 	spline 290. 365. 0.5
 	}
-	Here, the calculated spectrum is interpolated to wavelengths 290.0, 290.5, 291.0, 
+	Here, the calculated spectrum is interpolated to wavelengths 290.0, 290.5, 291.0,
 	..., 364.5, 365.0. For interpolation to arbitrary wavelengths use \code{spline\_file}.
 	The specified wavelength interval must be within the one specified by \code{wavelength}.
 		''',
 
 		'spline_file' : r'''
-	Spline interpolate to arbitrary wavelengths, in nm, given as a single column in file 
-	\file{spline\_file}. 
+	Spline interpolate to arbitrary wavelengths, in nm, given as a single column in file
+	\file{spline\_file}.
 	\fcode{
 	spline\_file file
 	}
-	The specified wavelengths must be within the range specified 
+	The specified wavelengths must be within the range specified
 	by \code{wavelength}. Comments start with \code{\#}. Empty lines are ignored.
 		''',
 
 		'test_optical_properties' : r'''
-	Write optical properties to file. This is made for test suite. 
+	Write optical properties to file. This is made for test suite.
 	rte_solver will be switched to null_solver.
 		''',
 
@@ -604,23 +604,23 @@ def get_output_documentation():
 	\parameter{brightness}
 	Convert radiances / irradiances to equivalent brightness temperatures.
 	\parameter{reflectivity}
-	Calculate transmission / reflectivity instead of absolute quantities. 
-	For irradiances / actinic fluxes the transmission T is defined as 
+	Calculate transmission / reflectivity instead of absolute quantities.
+	For irradiances / actinic fluxes the transmission T is defined as
 	\begin{equation}
 	   T = {{E}\over{E_0 \cos{\theta}}}
 	\end{equation}
 	  where $E$ is the irradiance / actinic flux, $E_0$ is the extraterrestrial flux,
 	  and $\theta$ is the solar zenith angle.
-	The reflectivity R is defined as 
+	The reflectivity R is defined as
 	\begin{equation}
 	   R = {{\pi \cdot L}\over{E_0 \cos{\theta}}}
 	\end{equation}
 	 where $L$ is the radiance, $E_0$ is the extraterrestrial flux,
 	 and $\theta$ is the solar zenith angle.
-	Obviously, reflectivities do not depend on Sun-Earth distance. Please 
+	Obviously, reflectivities do not depend on Sun-Earth distance. Please
 	note the difference to \code{transmittance}.
 	\parameter{transmittance}
-	Calculate transmittance / reflectance instead of absolute quantities. 
+	Calculate transmittance / reflectance instead of absolute quantities.
 	That is, set the extraterrestrial irradiance to 1 and do not correct for Sun-Earth distance:
 	\begin{equation}
 	   T = \frac{E}{E_0}
@@ -631,103 +631,103 @@ def get_output_documentation():
 		''',
 
 		'output_user' : r'''
-	User defined output. 
+	User defined output.
 	%This option is case sensitive.
-	Here the user may specify the columns desired for output. 
+	Here the user may specify the columns desired for output.
 	\fcode{
 	output\_user format
 	}
 	where \code{format} is one or more of the following.
 	\begin{description}
-	\parameter{lambda} 
+	\parameter{lambda}
 	Wavelength in nm.
-	\parameter{wavenumber} 
+	\parameter{wavenumber}
 	Wave number in cm$^{-1}$.
-	\parameter{sza} 
+	\parameter{sza}
 	solar zenith angle
-	\parameter{zout} 
+	\parameter{zout}
 	Output altitude in km.
 	\parameter{edir, eglo, edn, eup, enet, esum}
 	The direct, global, diffuse downward, and diffuse upward irradiance.
-	Net is global - upward, sum is global + upward. 
-	\parameter{uu} 
+	Net is global - upward, sum is global + upward.
+	\parameter{uu}
 	Radiances:  uu(umu(0),phi(0)) ... uu(umu(0),phi(m)) ... uu(umu(n),phi(0)) ... uu(umu(n),phi(m))
 	\parameter{fdir, fglo, fdn, fup, f}
 	The direct, global, diffuse downward, diffuse upward, and total actinic flux.
-	\parameter{uavgdir, uavgglo, uavgdn, uavgup, uavg} 
-	The Direct, global, diffuse downward, diffuse upward, and total diffuse 
+	\parameter{uavgdir, uavgglo, uavgdn, uavgup, uavg}
+	The Direct, global, diffuse downward, diffuse upward, and total diffuse
 	mean intensity (= actinic flux / 4$\pi$).
 	\parameter{spher\_alb}
 	Spherical albedo of the complete atmosphere.
-	\parameter{albedo} 
+	\parameter{albedo}
 	Albedo.
-	\parameter{heat} 
+	\parameter{heat}
 	Heating rate in K/day.
 	\end{description}
 
 	It is also possible to gain some information about the atmosphere and the clouds:
 	\begin{description}
-	\parameter{p} 
+	\parameter{p}
 	pressure [hPa], ,
 	\parameter{T, T\_d}
 	temperature [K], dewpoint temperature [K]
-	\parameter{T\_sur} 
+	\parameter{T\_sur}
 	surface temperature [K]
-	\parameter{theta } 
+	\parameter{theta }
 	potential temperature [K]
-	\parameter{theta\_e} 
+	\parameter{theta\_e}
 	equivalent potential temperature [K]
-	\parameter{n\_xxx} 
+	\parameter{n\_xxx}
 	number density of the gas xxx [cm$^{-3}$]
-	\parameter{rho\_xxx} 
+	\parameter{rho\_xxx}
 	mass density of the gas xxx [kg/m$^3$]
-	\parameter{mmr\_xxx} 
+	\parameter{mmr\_xxx}
 	mass mixing ratio of the gas xxx [kg/kg]
-	\parameter{vmr\_xxx} 
+	\parameter{vmr\_xxx}
 	volume mixing ratio of the gas xxx [m$^3$/m$^3$]
-	\parameter{rh} 
+	\parameter{rh}
 	relative humidity over water [percent]
-	\parameter{rh\_ice} 
+	\parameter{rh\_ice}
 	relative humidity over ice   [percent]
-	\parameter{c\_p} 
+	\parameter{c\_p}
 	specific heat capacity of the air (humidity and temperature dependent)
-	\parameter{CLWC} 
+	\parameter{CLWC}
 	cloud liquid water content   [kg/kg]
-	\parameter{CLWD} 
+	\parameter{CLWD}
 	cloud liquid water density   [g/m$^3$]
-	\parameter{CIWC} 
+	\parameter{CIWC}
 	cloud ice water content      [kg/kg]
-	\parameter{CIWD} 
+	\parameter{CIWD}
 	cloud ice water density      [g/m$^3$]
-	\parameter{TCC} 
+	\parameter{TCC}
 	total cloud cover            [0-1]
 	\end{description}
-	where \code{xxx} is one of 
+	where \code{xxx} is one of
 	AIR, O3, O2, H2O, CO2, NO2, BRO, OCLO, HCHO, or O4.
 
-	Default output is  
+	Default output is
 	\fcode{
-	output\_user lambda lambda, edir, edn, eup, uavgdir, uavgdn, uavgup 
+	output\_user lambda lambda, edir, edn, eup, uavgdir, uavgdn, uavgup
 	}
-	for \code{fdisort1}, \code{sdisort}, and \code{spsdisort}, whereas the default for 
-	\code{twostr} is 
+	for \code{fdisort1}, \code{sdisort}, and \code{spsdisort}, whereas the default for
+	\code{twostr} is
 	\fcode{
 	output\_user lambda, edir, edn, eup, uavg.
 	}
-	The lines containing radiances and the output of \code{rte\_solver polradtran} are not affected. 
+	The lines containing radiances and the output of \code{rte\_solver polradtran} are not affected.
 		''',
 
-		'pressure_out' : r''' 
-	Specify the output levels in pressure coordinates. The syntax is   
-	\fcode{ 
-	pressure\_out p1 p2 ... 
+		'pressure_out' : r'''
+	Specify the output levels in pressure coordinates. The syntax is
+	\fcode{
+	pressure\_out p1 p2 ...
 	}
-	where '\code{p1 p2 ...}' are the output levels in hPa.  
-	The pressure output levels must be sorted in decreasing order.  
-	Output pressure levels must be within the range defined in the 
-	\code{atmosphere\_file}. You can also use \code{toa} for  
-	\code{top of atmosphere} and \code{sur} for \code{surface altitude} and \code{cpt}  
-	for \code{cold point tropopause}. 
+	where '\code{p1 p2 ...}' are the output levels in hPa.
+	The pressure output levels must be sorted in decreasing order.
+	Output pressure levels must be within the range defined in the
+	\code{atmosphere\_file}. You can also use \code{toa} for
+	\code{top of atmosphere} and \code{sur} for \code{surface altitude} and \code{cpt}
+	for \code{cold point tropopause}.
 		''',
 
 		'print_disort_info' : r'''
@@ -735,16 +735,16 @@ def get_output_documentation():
 	\fcode{
 	print\_disort\_info  value
 	}
-	Print various disort input and output in disorts own format. See 
+	Print various disort input and output in disorts own format. See
 	\file{libsrc\_f/DISORT2.doc} for more information.
-	\strong{Warning:} Produces a lot of output. 
+	\strong{Warning:} Produces a lot of output.
 		''',
 
 		'heating_rate' : r'''
 	Calculation of heating rates. Output is only provided at altitudes specified by \code{zout}.
 	To get heating rate profiles a number of altitudes must thus be specified by \code{zout}.
 	Heating rates is the change of temperature with time in units of K/day.
-	For spectral calculations the default output is a matrix: 
+	For spectral calculations the default output is a matrix:
 	\begin{Verbatim}
 		0.0        zout1          zout2 ...
 		lambda1    heating\_rates  ...
@@ -752,13 +752,13 @@ def get_output_documentation():
 		   .         .
 		   .         .
 	\end{Verbatim}
-	For integrated calculations (\code{output\_process sum} or \code{output\_process integrate}) the default output 
+	For integrated calculations (\code{output\_process sum} or \code{output\_process integrate}) the default output
 	is in two columns with column 1 being the altitude and column 2 the heating rates.
 	The output of \code{heating\_rate} can also be specified with the \code{output\_user} option.
 	Note that heating rates are only well-behaved up to altitudes
-	for which the respective correlated-k options are valid. E.g. about 60 km for 
+	for which the respective correlated-k options are valid. E.g. about 60 km for
 	\code{fu} and about 80 km for \code{kato}, \code{kato2}, \code{kato2.96}, and \code{lowtran}.
-	Attention: For spectral calculations, the extraterrestrial spectrum is assumed to be in 
+	Attention: For spectral calculations, the extraterrestrial spectrum is assumed to be in
 	mW/(m2 nm).
 
 	Three different methods are implemented to calculate the heating rate, which can be selected
@@ -766,13 +766,13 @@ def get_output_documentation():
 	\fcode{
 	heating\_rate [method]
 	}
-	where \code{method} may be either \code{layer\_cd} (heating rates are derived from centered 
-	differences of the flux (the default method), \code{local} (heating rates are derived 
-	from the actinic flux), or \code{layer\_fd} (heating rates are derived from forward differences of the flux 
-        over one layer. Attention: \code{heating\_rate local} introduces new levels into the profile which  
+	where \code{method} may be either \code{layer\_cd} (heating rates are derived from centered
+	differences of the flux (the default method), \code{local} (heating rates are derived
+	from the actinic flux), or \code{layer\_fd} (heating rates are derived from forward differences of the flux
+        over one layer. Attention: \code{heating\_rate local} introduces new levels into the profile which
 	slightly affects the model output.
-	With \code{layer\_fd}, the output is 
-	not representative for a \emph{level}, but for the \emph{layer} from the z-level of the line in the output file, 
+	With \code{layer\_fd}, the output is
+	not representative for a \emph{level}, but for the \emph{layer} from the z-level of the line in the output file,
 	where it is written, up to next \emph{output level} above!
 		''',
 
@@ -783,22 +783,22 @@ def get_output_documentation():
 	}
 	where type is one of
 	\begin{description}
-	\parameter{sum} 
-	Sum output over wavelength. Useful in combination with the 
-	\code{mol\_abs\_param} option (\code{kato}, \code{kato2}, \code{kato2.96}, 
+	\parameter{sum}
+	Sum output over wavelength. Useful in combination with the
+	\code{mol\_abs\_param} option (\code{kato}, \code{kato2}, \code{kato2.96},
 	\code{Fu}, \code{avhrr\_kratz}).
-        In case of \code{mol\_abs\_param reptran}, the units are automatically converted to \code{per\_band} before summation. 
-	\parameter{integrate} 
-	Integrate output over wavelength for solar and over wavenumber for thermal simulations. 
+        In case of \code{mol\_abs\_param reptran}, the units are automatically converted to \code{per\_band} before summation.
+	\parameter{integrate}
+	Integrate output over wavelength for solar and over wavenumber for thermal simulations.
 	Useful for spectral calculations, \code{mol\_abs\_param lowtran} and \code{reptran}.
-	\parameter{per\_nm } 
+	\parameter{per\_nm }
 	Output is given in W/(m$^2$ nm) or mW/(m$^2$ nm) (W or mW is determined by the extraterrestrial spectrum.)
-	\parameter{per\_cm-1 } 
+	\parameter{per\_cm-1 }
 	Output is given in W/(m$^2$ cm$^{-1})$ or mW/(m$^2$ cm$^{-1}$).
-	\parameter{per\_band } 
-	Output is given in W/m$^2$ or mW/m$^2$ per correlated-k or reptran band. (This option can not be used for 
+	\parameter{per\_band }
+	Output is given in W/m$^2$ or mW/m$^2$ per correlated-k or reptran band. (This option can not be used for
 	spectral calculations and \code{mol\_abs\_param} LOWTRAN in the solar range.)
-	\parameter{none} 
+	\parameter{none}
 	No processing - output spectral information (default).
 	\end{description}
 		''',
@@ -809,61 +809,61 @@ def get_output_documentation():
 
 		'verbose' : r'''
 	If specified abundances of informative messages are output to stderr. To make
-	use of this information, you may want to write the standard \code{uvspec} output to 
+	use of this information, you may want to write the standard \code{uvspec} output to
 	one file and the diagnostic messages to another. To do so, try
-	\code{(./uvspec < uvspec.inp > uvspec.out) >\& verbose.txt} (depending on your shell you 
-	might need a slightly different syntax). The irradiances 
-	and radiances will be written to \file{uvspec.out} while all 
+	\code{(./uvspec < uvspec.inp > uvspec.out) >\& verbose.txt} (depending on your shell you
+	might need a slightly different syntax). The irradiances
+	and radiances will be written to \file{uvspec.out} while all
 	diagnostic messages go into \file{verbose.txt}. See also \code{quiet}.
 		''',
 
 		'output_file'	: r'''
-	\fcode {             
+	\fcode {
 	    output\_file filename
 	}
-	uvspec output will be written to \code{filename}. The format can be set by the option 
-	\code{output\_format} (default is ascii).  
+	uvspec output will be written to \code{filename}. The format can be set by the option
+	\code{output\_format} (default is ascii).
 		''',
 
 		'write_output_as_netcdf' : r'''
-	 Option only works with 
-	\code{mc\_lidar} and \code{mc\_radar}. Output is written into netcdf file rather than dozens 
-	of ASCII files. Saves disk space. 
+	 Option only works with
+	\code{mc\_lidar} and \code{mc\_radar}. Output is written into netcdf file rather than dozens
+	of ASCII files. Saves disk space.
 		''',
 
 		'zout'	: r'''
-	This option is used to specify the output altitudes in km \emph{above surface altitude}. 
-	One or more altitudes may be specified in increasing magnitude. 
+	This option is used to specify the output altitudes in km \emph{above surface altitude}.
+	One or more altitudes may be specified in increasing magnitude.
 	\fcode{
 	zout 0 1 2 3 4 5 ...
 	}
 	Output altitudes must be within the range defined in the
 	\code{atmosphere\_file}. Note that \code{zout} does not restructure the
 	atmosphere model. Hence, if you specify \code{zout 0.730} and have your
-	atmosphere model in \code{atmosphere\_file} go all the way down to 
+	atmosphere model in \code{atmosphere\_file} go all the way down to
 	sea level, i.e. 0.0km., output is presented at 0.730km and calculations
-	performed with an atmosphere between 0.0 and 0.730 km (and above of course). 
+	performed with an atmosphere between 0.0 and 0.730 km (and above of course).
 	If you want calculations done for e.g. an elevated site you have to restructure
 	the atmosphere model and make sure it stops at the appropriate altitude.
-	This you may either due by editing the atmosphere file or by using 
-	\code{altitude}. Note that for \code{rte\_solver polradtran} the atmosphere file must 
-	contain the altitudes specified by \code{zout}. You can also use \code{toa} for 
-	\code{top of atmosphere} and \code{sur} for \code{surface altitude} and \code{cpt} 
+	This you may either due by editing the atmosphere file or by using
+	\code{altitude}. Note that for \code{rte\_solver polradtran} the atmosphere file must
+	contain the altitudes specified by \code{zout}. You can also use \code{toa} for
+	\code{top of atmosphere} and \code{sur} for \code{surface altitude} and \code{cpt}
 	for \code{cold point tropopause}.
 
-	Instead of specifying the altitudes in km, it is also possible to use keywords as 
-	argument for this option. Possible keywords are \code{atm\_levels}, 
-	\code{all\_levels}, \code{model\_levels}, \code{model\_layers}, and \code{model\_levels\_and\_layers}. 
-	For \code{atm\_levels}, all levels from the \code{atmosphere\_file} are used as output levels.  
-	For \code{all\_levels}, all levels (including levels from \code{atmosphere\_file}, 
-	\code{mol\_file}, cloud files, \code{altitude} options) are used as output levels. 
-	For \code{model\_levels}, \code{model\_layers}, \code{model\_levels\_and\_layers} 
+	Instead of specifying the altitudes in km, it is also possible to use keywords as
+	argument for this option. Possible keywords are \code{atm\_levels},
+	\code{all\_levels}, \code{model\_levels}, \code{model\_layers}, and \code{model\_levels\_and\_layers}.
+	For \code{atm\_levels}, all levels from the \code{atmosphere\_file} are used as output levels.
+	For \code{all\_levels}, all levels (including levels from \code{atmosphere\_file},
+	\code{mol\_file}, cloud files, \code{altitude} options) are used as output levels.
+	For \code{model\_levels}, \code{model\_layers}, \code{model\_levels\_and\_layers}
 	the levels, layers, or both from the \code{ECMWF\_atmosphere\_file} are used as output level.
 	Usage e.g.:
 	\fcode{
 	zout model\_levels [nlev\_max]
 	}
-	With the optional argument \code{nlev\_max} the user may specify the number of zout layers 
+	With the optional argument \code{nlev\_max} the user may specify the number of zout layers
 	from the ground.
 		''',
 
@@ -875,7 +875,7 @@ def get_output_documentation():
 	\fcode {
 	    output\_format format
 	}
-	where \code{format} is either \code{ascii} (default) or \code{flexstor}. 
+	where \code{format} is either \code{ascii} (default) or \code{flexstor}.
 	Note that \code{flexstor} does not currently work when \code{umu} and/or \code{phi} is specified.
 	There is also the
 	possibility to write uvspec simulation results to an existing netCDF file. For
diff --git a/src_py/profile_options.py b/src_py/profile_options.py
index 4248995..1122ccb 100644
--- a/src_py/profile_options.py
+++ b/src_py/profile_options.py
@@ -1,28 +1,28 @@
 """--------------------------------------------------------------------
  * $Id$
- * 
+ *
  * This file is part of libRadtran.
  * Copyright (c) 1997-2012 by Arve Kylling, Bernhard Mayer,
  *                            Claudia Emde, Robert Buras
  *
  * ######### Contact info: http://www.libradtran.org #########
  *
- * This program is free software; you can redistribute it and/or 
- * modify it under the terms of the GNU General Public License   
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.        
- * 
- * This program is distributed in the hope that it will be useful, 
- * but WITHOUT ANY WARRANTY; without even the implied warranty of  
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the   
- * GNU General Public License for more details.                    
- * 
- * You should have received a copy of the GNU General Public License          
- * along with this program; if not, write to the Free Software                
- * Foundation, Inc., 59 Temple Place - Suite 330, 
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
  * Boston, MA 02111-1307, USA.
  *--------------------------------------------------------------------"""
-
+import io
 from option_definition import *
 
 class setup_cloud_group():
@@ -38,9 +38,9 @@ class setup_cloud_group():
 			helpstr='Location of file defining profile properties.',
 			documentation=documentation['profile_file'],
 			gui_inputs=(TextInput(name='name'),ListInput(name='source', valid_range=['1D', '3D', 'moments', 'ipa', 'ipa_files'], optional=False), FileInput(name='Input.caoth[isp].filename'),),
-			tokens = [ addToken(name='isp', datatype=CaothType), 
-				addLogical( name='Input.caoth[isp].source', logicals=ProfileType().get_valid_range(), setting='CAOTH_FROM_'), 
-				addToken( name='Input.caoth[isp].filename', datatype=file ) ],
+			tokens = [ addToken(name='isp', datatype=CaothType),
+				addLogical( name='Input.caoth[isp].source', logicals=ProfileType().get_valid_range(), setting='CAOTH_FROM_'),
+				addToken( name='Input.caoth[isp].filename', datatype=io.IOBase ) ],
 			parents=['uvspec'],
 			childs=['profile_properties','profile_modify','interpret_as_level'],
 			plot = {'plot_type': '2D',
@@ -60,7 +60,7 @@ class setup_cloud_group():
 			documentation=documentation['profile_properties'],
 #			gui_inputs=(ListInput(name='Input.caoth[isp].properties', valid_range=['hu', 'echam4', 'mie', 'fu', 'yang', 'key', 'baum_hufit', 'baum', 'hey', 'ic_mie'], optional=False), ListInput(name='Input.caoth[isp].interpolate', valid_range=['','interpolate'], optional=True),),
 			tokens = [ addToken( name='isp', datatype=CaothType ),
-				addLogical( name='Input.caoth[isp].properties', logicals=['hu', 'echam4', 'mie', 'fu', 'yang', 'key', 'baum_v36', 'baum', 'hey', file], setting='PROP_' ),
+				addLogical( name='Input.caoth[isp].properties', logicals=['hu', 'echam4', 'mie', 'fu', 'yang', 'key', 'baum_v36', 'baum', 'hey', io.IOBase], setting='PROP_' ),
 				addLogical( name='Input.caoth[isp].interpolate' , logicals=['interpolate'], optional=True) ],	#TODO: BUTTON in GUI, not str!
 			parents=['profile_file'],
 			non_unique=True,
@@ -75,38 +75,38 @@ class setup_cloud_group():
 			tokens = [ addToken( name='isp', datatype=CaothType ),
 				addLogical( name='id1', logicals=['gg','ssa', 'tau', 'tau550'], setting='MODIFY_VAR_' ),
 				addLogical( name='id2', logicals=['set', 'scale' ], setting='MODIFY_TYPE_' ),
-				addToken( name='Input.caoth[isp].modify[id1][id2]', datatype=float ) ], 
+				addToken( name='Input.caoth[isp].modify[id1][id2]', datatype=float ) ],
 			parents=['profile_file'],
 			non_unique=True,
 		)
 
 		self.options = [profile_file, profile_properties, profile_modify]
-		
+
 	def __iter__(self):
 		return iter(self.options)
 
 def get_profile_documentation():
 	return {
 		'profile_file' : r'''
-	Define file containing properties of clouds, aerosols, hydrometeors, etc. 
+	Define file containing properties of clouds, aerosols, hydrometeors, etc.
 	This option is a generalization of the options \code{wc\_file} and \code{ic\_file}.
-	
+
 	Usage:
 	\fcode{
 	profile\_file typename type file
 	}
-	
-	\code{typename} describes the name of the profile; typically this 
+
+	\code{typename} describes the name of the profile; typically this
 	describes what kind of particles are dealt with here. Examples
-	are \code{wc} (water clouds), \code{ic} (ice clouds), \code{aer} (aerosols), drizzle. 
-	The \code{typename} is needed to refer to this profile when using other options, 
+	are \code{wc} (water clouds), \code{ic} (ice clouds), \code{aer} (aerosols), drizzle.
+	The \code{typename} is needed to refer to this profile when using other options,
 	such as \code{profile\_properties}. Note that \code{typename} "wc" and "ic"
 	have special effects (i.e.~default properties, and "ic" properties are
 	not allowed with "wc" files, and vice versa).
-	
+
 	\code{type} defines the file type, which is identical to \code{wc\_file type}.
-	Please refer to \code{wc\_file} for choises of \code{type} and a detailed description 
-	on the file structures.	
+	Please refer to \code{wc\_file} for choises of \code{type} and a detailed description
+	on the file structures.
 		''',
 
 		'profile_properties' : r'''
@@ -114,15 +114,15 @@ def get_profile_documentation():
 	particle radius are translated to optical properties for profile
 	\code{typename}. This option is a generalization of the options
 	\code{wc\_properties} and \code{ic\_properties}.
-	
+
 	Usage:
 	\fcode{
 	profile\_properties typename property [interpolate]
 	}
-	
+
 	\code{typename} describes the name of the profile; it must be identical
 	to the one defined in \code{profile\_file}.
-	
+
 	Please refer to \code{wc\_properties} and \code{ic\_properties} for possible choices for \code{property}.
 		''',
 		'profile_modify' : r'''
@@ -135,6 +135,6 @@ def get_profile_documentation():
 
 	This option is identical to \code{wc\_modify}.
 	Please refer to \code{wc\_modify} for a detailed description of \code{variable}.
-		''',	
+		''',
 	}
 
diff --git a/src_py/solver_options.py b/src_py/solver_options.py
index df3fa78..e7bbbba 100644
--- a/src_py/solver_options.py
+++ b/src_py/solver_options.py
@@ -1,25 +1,25 @@
 """--------------------------------------------------------------------
  * $Id$
- * 
+ *
  * This file is part of libRadtran.
  * Copyright (c) 1997-2012 by Arve Kylling, Bernhard Mayer,
  *                            Claudia Emde, Robert Buras
  *
  * ######### Contact info: http://www.libradtran.org #########
  *
- * This program is free software; you can redistribute it and/or 
- * modify it under the terms of the GNU General Public License   
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.        
- * 
- * This program is distributed in the hope that it will be useful, 
- * but WITHOUT ANY WARRANTY; without even the implied warranty of  
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the   
- * GNU General Public License for more details.                    
- * 
- * You should have received a copy of the GNU General Public License          
- * along with this program; if not, write to the Free Software                
- * Foundation, Inc., 59 Temple Place - Suite 330, 
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
  * Boston, MA 02111-1307, USA.
  *--------------------------------------------------------------------"""
 
@@ -28,7 +28,7 @@ from option_definition import *
 
 
 class setup_solver_group():
-    
+
     group_name = 'Solver'
 
     def __init__(self):
@@ -40,9 +40,9 @@ class setup_solver_group():
             helpstr='Radiative transfer equation solver.',
             documentation=documentation['rte_solver'],
             gui_inputs=(ListInput(name='solver', valid_range=['disort', 'twostr', 'mystic', 'rodents', 'sslidar', 'null'], optional=False),),
-            tokens=addLogical( name='Input.rte.solver', 
+            tokens=addLogical( name='Input.rte.solver',
                         logicals = [ 'disort', 'twostr', 'mystic', 'rodents', 'sslidar', 'null',
-                                     'sdisort', 'spsdisort', 'fdisort1', 'fdisort2', 'sos', 'polradtran', 'ftwostr', 'montecarlo', 'tzs', 'sssi', 'sss', 'twostrebe', 'twomaxrnd', 'twomaxrnd3C', 'dynamic_twostream', 'dynamic_tenstream'],   
+                                     'sdisort', 'spsdisort', 'fdisort1', 'fdisort2', 'sos', 'polradtran', 'ftwostr', 'montecarlo', 'tzs', 'sssi', 'sss', 'twostrebe', 'twomaxrnd', 'twomaxrnd3C', 'dynamic_twostream', 'dynamic_tenstream'],
                         setting='SOLVER_' ),
             parents=['uvspec'],
             childs=['polradtran_quad_type','polradtran','polradtran_max_delta_tau',
@@ -54,23 +54,23 @@ class setup_solver_group():
              'mc_escape','mc_vroom','mc_backward','mc_spectral_is',
              'mc_spectral_is_wvl','mc_forward_output',
              'mc_albedo_file','mc_albedo_spectral_file','mc_albedo_type','mc_rossli_file',
-             'mc_backward_output', 'mc_backward_writeallpixels', 
+             'mc_backward_output', 'mc_backward_writeallpixels',
              'mc_basename',
-             'mc_delta_scaling', 'mc_elevation_file', 
+             'mc_delta_scaling', 'mc_elevation_file',
                          'mc_tenstream',
              'mc_ipa','mc_tipa','ipa_3d','tipa',
-             'mc_maxscatters','mc_minscatters','mc_minphotons','mc_photons', 
+             'mc_maxscatters','mc_minscatters','mc_minphotons','mc_photons',
              'mc_photons_file','mc_polarisation',
              'mc_wcloud_file','mc_icloud_file',
              'mc_randomseed', 'mc_rpv_file','mc_rpv_spectral_file','mc_rpv_type',
              'mc_ambrals_spectral_file','mc_ambrals_type','mc_spherical','mc_std',
              'sur_temperature_file','mc_sample_grid','mc_sensordirection','mc_sensorposition',
              'mc_reference_to_nn','mc_bw_umu_file','mc_truncate','mc_bcond','mc_coherent_backscatter',
-             'mc_surface_reflectalways','mc_refraction','mc_visualize','mc_hiddenline', 
+             'mc_surface_reflectalways','mc_refraction','mc_visualize','mc_hiddenline',
              'mc_surfaceparallel', 'mc_jacobian', 'mc_jacobian_std',
              'sslidar','sslidar_nranges','sslidar_polarisation',
              'tzs_cloud_top_height', 'twomaxrnd3C_scale_cf' ,
-             'dynamic_twostream_iterations', 'dynamic_tenstream_iterations', 'mc_nca' 
+             'dynamic_twostream_iterations', 'dynamic_tenstream_iterations', 'mc_nca'
                         ],
             continious_update=True,
         )
@@ -102,7 +102,7 @@ class setup_solver_group():
         disort_intcor = option(
             name='disort_intcor',
             group='solver',
-            helpstr='Intensity correction method', 
+            helpstr='Intensity correction method',
             documentation=documentation['disort_intcor'],
             gui_inputs=(ListInput(name='disort_intcor', valid_range = ['phase', 'moments', 'off']),),
             tokens=addLogical(name="Input.rte.disort_icm", logicals=['phase', 'moments', 'off'], setting='DISORT_ICM_'),
@@ -206,7 +206,7 @@ class setup_solver_group():
 #no_sdisort     nscat = option(
 #no_sdisort         name='nscat',
 #no_sdisort         group='solver',
-#no_sdisort         helpstr='Order of scattering.', 
+#no_sdisort         helpstr='Order of scattering.',
 #no_sdisort         documentation=documentation['nscat'],
 #no_sdisort         gui_inputs=(IntegerInput(name='Input.rte.nscat'),),
 #no_sdisort         tokens=addToken('Input.rte.nscat', int, default=20),
@@ -251,7 +251,7 @@ class setup_solver_group():
             speaker="rte_solver",
             enable_values=("disort", "twostr",)
         )
-        
+
         ipa_3d = option(
             name='ipa_3d',
             group='solver',
@@ -264,11 +264,11 @@ class setup_solver_group():
             speaker='rte_solver',
             enable_values=("disort","twostr","rodents",),
         )
-        
+
         mc_tenstream = option(
             name='mc_tenstream',
-            group='solver', 
-            helpstr='Run Tenstream approximation solver instead of Photon Tracing. Optional argument: configuration string', 
+            group='solver',
+            helpstr='Run Tenstream approximation solver instead of Photon Tracing. Optional argument: configuration string',
             documentation=documentation['mc_tenstream'],
             tokens=[ addSetting(name='Input.rte.mc.tenstream', setting=1,default=0), addToken(name='Input.rte.mc.tenstream_options', datatype=str, optional=True, default="NULL")],
             parents=['uvspec'],
@@ -279,8 +279,8 @@ class setup_solver_group():
 
         mc_ipa = option(
             name='mc_ipa',
-            group='solver', 
-            helpstr='Run MYSTIC in independent pixel mode.', 
+            group='solver',
+            helpstr='Run MYSTIC in independent pixel mode.',
             documentation=documentation['mc_ipa'],
             tokens=addSetting(name='Input.rte.mc.ipa', setting=1,default=0),
             parents=['uvspec'],
@@ -364,7 +364,7 @@ class setup_solver_group():
             speaker='rte_solver',
             enable_values=('tzs',),
         )
-        
+
         twomaxrnd3C_scale_cf = option(
             name='twomaxrnd3C_scale_cf',
             group='solver',
@@ -399,27 +399,27 @@ class setup_solver_group():
         )
         mc_nca = option(
             name='mc_nca',
-            group='solver', 
-            helpstr='Neighboring Column Approximation (Klinger and Mayer 2016, 2019) for the calculation of 3d thermal heating rates', 
+            group='solver',
+            helpstr='Neighboring Column Approximation (Klinger and Mayer 2016, 2019) for the calculation of 3d thermal heating rates',
             documentation=documentation['mc_nca'],
             tokens=[ addSetting(name='Input.rte.mc.nca', setting=1,default=0), addToken(name='Input.rte.mc.nca_options', datatype=str, optional=True, default="NULL")],
             parents=['uvspec'],
             speaker='rte_solver',
             enable_values=("mystic",),
-            threedmystic = False  # CK2019 added nca   
-        
+            threedmystic = False  # CK2019 added nca
+
         )
-          
+
         self.options = [rte_solver, pseudospherical, disort_spherical_albedo,
-            deltam, 
-            isotropic_source_toa, raman, 
+            deltam,
+            isotropic_source_toa, raman,
             mc_tenstream,
             mc_ipa, ipa_3d, mc_tipa, tipa,
-            number_of_streams,              
-            disort_intcor, 
-            polradtran, 
-            polradtran_quad_type, polradtran_max_delta_tau, 
-            sslidar, sslidar_polarisation, sslidar_nranges, 
+            number_of_streams,
+            disort_intcor,
+            polradtran,
+            polradtran_quad_type, polradtran_max_delta_tau,
+            sslidar, sslidar_polarisation, sslidar_nranges,
             sdisort, sos_nscat, tzs_cloud_top_height,
             twomaxrnd3C_scale_cf, dynamic_twostream_iterations, dynamic_tenstream_iterations,
             mc_nca ]
@@ -455,11 +455,11 @@ def get_solver_documentation():
         ''',
 
         'ipa_3d' : r'''
-    This option can be used to carry out a 3D calculation with a 1D-solver, where a 
+    This option can be used to carry out a 3D calculation with a 1D-solver, where a
     3D-cloud file as used for MYSTIC (flag 3) serves as an input file. Further, a sample grid needs to be specified
     via \code{mc_sample_grid}, where the grid and the resolution has to be the same as in the 3D-cloud file
     (Nx, Ny, dx, dy). To calculate heating rates, \code{mc_backward_output heat K_per_day} must stand in the input
-    file. 
+    file.
         ''',
 
         'mc_tenstream' : r'''
@@ -472,7 +472,7 @@ def get_solver_documentation():
           \code{svn co https://svn.physik.uni-muenchen.de/repos/hdcp2-rt/tenstream}\\
         Then follow the instructions to compile the tenstream lib in \\
         \code{tenstream/README} \\
-        If it was successful, there should be the file \\ 
+        If it was successful, there should be the file \\
         \code{tenstream/build/lib/libtenstream.a}.
 
         Now configure libRadtran and it should hopefully find the tenstream-lib:\\
@@ -480,7 +480,7 @@ def get_solver_documentation():
         It should say \\
           \code{ TENSTREAM solver:     yes }\\
 
-        Input files are the same as for MYSTIC calculations with the additional 
+        Input files are the same as for MYSTIC calculations with the additional
         option mc\_tenstream.
         You can call the MPI version with:\\
         \code{mpirun -np 2 bin/uvspec_mpi <inputfile>  <PETSc options> }.
@@ -520,7 +520,7 @@ def get_solver_documentation():
     montecarlo}. Choose either \code{mc_tipa dir3d} or \code{mc_tipa
     dirdiff}. The latter is the analogon to \code{tipa dirdiff}, where the
     3d-cloud-matrix is tilted according to the solar zenith angle and is
-    then used as input for all the following calculations. 
+    then used as input for all the following calculations.
     In \code{mc_tipa dir3d}, photons are propagated in 3d until the first
         scattering occurs, after that the photon is captured within the current
         column.
@@ -545,7 +545,7 @@ def get_solver_documentation():
         ''',
 
         'rte_solver' : r'''
-    Set the radiative transfer equation solver to be used. 
+    Set the radiative transfer equation solver to be used.
     \fcode{
     rte_solver type
     }
@@ -554,15 +554,15 @@ def get_solver_documentation():
     \begin{description}
 
     \parameter{disort}
-    C-version of the disort algorithm, translated from Fortran by Tim Dowling. 
+    C-version of the disort algorithm, translated from Fortran by Tim Dowling.
     This is the recommended discrete ordinate code in {\sl libRadtran}.
     For documentation see \file{src\_f/DISORT2.doc} as well as the papers and
     the DISORT report at
     ftp://climate1.gsfc.nasa.gov/wiscombe/Multiple\_Scatt/.  The intensity
     correction can be performed according to \citet{nakajima1988} using
-    \code{disort_intcor moments} (like in the original code), or with the 
-    improvements described in (Buras, Dowling, Emde, in preparation; default). Can be run in  
-    plane-parallel geometry (default) or in pseudo-spherical geometry 
+    \code{disort_intcor moments} (like in the original code), or with the
+    improvements described in (Buras, Dowling, Emde, in preparation; default). Can be run in
+    plane-parallel geometry (default) or in pseudo-spherical geometry
     (using \code{pseudospherical}).
 
     \parameter{twostr}
@@ -573,8 +573,8 @@ def get_solver_documentation():
 
     \parameter{fdisort1}
     The standard plane--parallel disort algorithm by \citet{Stamnes1988c},
-    version 1.3 -- provided for compatibility reasons. Use only if you have troubles with the default                    
-        \code{disort} or for historical reasons. For documentation see \file{src\_f/DISORT.doc} as well 
+    version 1.3 -- provided for compatibility reasons. Use only if you have troubles with the default
+        \code{disort} or for historical reasons. For documentation see \file{src\_f/DISORT.doc} as well
     as the papers and the DISORT report at
     ftp://climate1.gsfc.nasa.gov/wiscombe/Multiple\_Scatt/. To optimize
     for computational time and memory, please adjust the parameters in
@@ -604,7 +604,7 @@ def get_solver_documentation():
     Pseudospherical disort as described by \citet{Dahlback1991}. Double
     precision version. To optimize for computational time and memory,
     please adjust the parameters in \file{src\_f/DISORT.MXD} for your
-    application and re-compile.  
+    application and re-compile.
 
     \parameter{spsdisort} Pseudospherical
     disort as described by \citet{Dahlback1991}, single precision
@@ -613,7 +613,7 @@ def get_solver_documentation():
     conditions. For large optical thickness it is numerically unstable and
     may produce wrong results. To optimize for computational time and
     memory, please adjust the parameters in \file{src_f/DISORT.MXD} for
-    your application and re-compile.  
+    your application and re-compile.
 
     \parameter{polradtran} The plane-parallel radiative transfer solver of \citet{Evans1991}.
     Includes polarization. The full implementation of the polRadtran
@@ -633,7 +633,7 @@ def get_solver_documentation():
     }
 
      \parameter{twomaxrnd}
-     Delta-Eddington two--stream solver with Maximum-Random-Overlap according to \citet{Zdunkowski2007} by Nina Crnivec. As inputs, a \code{wc_file 1D} and/or a \code{ic_file 1D} are required, plus a \code{cloud_fraction_file}. The same cloud fraction is used for water and ice clouds. \code{zout_interpolate} is activated automatically. See \citet{Crnivec2019} for more details. 
+     Delta-Eddington two--stream solver with Maximum-Random-Overlap according to \citet{Zdunkowski2007} by Nina Crnivec. As inputs, a \code{wc_file 1D} and/or a \code{ic_file 1D} are required, plus a \code{cloud_fraction_file}. The same cloud fraction is used for water and ice clouds. \code{zout_interpolate} is activated automatically. See \citet{Crnivec2019} for more details.
 
      \parameter{twomaxrnd3C}
      Delta-Eddington two--stream solver with Maximum-Random-Overlap according to Zdunkowski et al. by Nina Crnivec. In addition to \code{twomaxrnd} "tripleclouds" by Shonk and Hogan (2008) is considered. A \code{cloud_fraction_file} has to be specified as well as two cloudy columns, defined as profiles wcn (optically thiN) and wck (optically thicK clouds), e.g. \code{profile_file wcn 1D ./wcn.dat}. \code{zout_interpolate} is activated automatically.See \citet{Crnivec2020}, in particular appendix A.
@@ -679,9 +679,9 @@ def get_solver_documentation():
     polarization is involved; (3) for applications
     where spherical geometry plays a role; and (4)
     whenever sharp features of the scattering
-    phase function play a role, like for the 
+    phase function play a role, like for the
     calculation of the backscatter glory or the
-    aureole.  
+    aureole.
     \parameter{mystic}
     Same as \code{montecarlo}.
     }
@@ -689,8 +689,8 @@ def get_solver_documentation():
     \parameter{tzs} TZS stands for "thermal, zero scattering" and is a
     very fast analytical solution for the special case of thermal emission
     in a non-scattering atmosphere. Please note that TZS does only
-    radiance calculations at top of the atmosphere. "Blackbody clouds" may be included 
-        using the option \code{tzs_cloud_top_height}. 
+    radiance calculations at top of the atmosphere. "Blackbody clouds" may be included
+        using the option \code{tzs_cloud_top_height}.
 
     \parameter{sss}
     SSS stands for "solar, single scattering" and is an analytical single
@@ -715,22 +715,22 @@ def get_solver_documentation():
     \fcode{
     raman [original]
     }
-    The \code{raman} option includes single order rotational Raman scattering in 
-    the calculation. The solution treats Raman as a perturbation similar to the 
+    The \code{raman} option includes single order rotational Raman scattering in
+    the calculation. The solution treats Raman as a perturbation similar to the
     approaches of \citet{Vountas1998} and \citet{Spurr2008}.
-    
+
     The \code{raman} option may only be used for spectral calculation.
 
     The disort radiative transfer solver with a general source is needed to solve the radiative transfer
-    equation including Raman scattering. This solver is automagically invoked when specifying 
+    equation including Raman scattering. This solver is automagically invoked when specifying
     the \code{raman} option. It is thus not neccessary to set the \code{rte_solver}.
 
     The \code{raman} option is optimized with respect to speed. The optimized implementation
     should be just as accurate as the original version. To use the original version
-    invode \code{raman original}. With the optional argument \code{original} each wavelength 
-    is treated individually and is thus accurate, but computationally very expensive. 
+    invode \code{raman original}. With the optional argument \code{original} each wavelength
+    is treated individually and is thus accurate, but computationally very expensive.
 
-    Please note that while the \code{raman} option has been extensively tested and verified, it 
+    Please note that while the \code{raman} option has been extensively tested and verified, it
     is nevertheless a new option, hence, use it with care.
         ''',
         'pseudospherical' : r'''
@@ -738,7 +738,7 @@ def get_solver_documentation():
         ''',
         'disort_spherical_albedo' : r'''
     Calculate spherical albedo using \code{disort}. When this option is enabled,
-    only the spherical albedo is calculated. The output is enabled by 
+    only the spherical albedo is calculated. The output is enabled by
     \fcode{output_user spher_alb}
         ''',
         'disort_intcor' : r'''
@@ -751,7 +751,7 @@ def get_solver_documentation():
         ''',
         'isotropic_source_toa' : r'''
     Specifies that isotropic illumination is used at top-boundary instead
-    of beam source. Useful for those who want to calculate the reflectance 
+    of beam source. Useful for those who want to calculate the reflectance
     for a homogeneous or inhomogeneous atmosphere. The intensity is still set by
     \code{source solar file}. Only works with \code{disort} and \code{twostr}.
         ''',
@@ -772,13 +772,13 @@ def get_solver_documentation():
     where \code{type} is one of
     \begin{description}
     \item[G] (default) gaussian
-    \item[D] double gaussian, 
+    \item[D] double gaussian,
     \item[L] Lobatto
-    \item[E] extra-angle(s), this must be used of \code{polradtran} is used in 
-    combination with \code{umu}. Will internally use Gaussian scheme (\code{G}). 
+    \item[E] extra-angle(s), this must be used of \code{polradtran} is used in
+    combination with \code{umu}. Will internally use Gaussian scheme (\code{G}).
     See also radtran documentation (\file{libsrc_f/README.polRadtran}).
     \end{description}
-    Default G.                                  
+    Default G.
     This option is only relevant for \code{rte_solver polradtran}.
         ''',
 
@@ -790,7 +790,7 @@ def get_solver_documentation():
     }
     Order of Fourier azimuth series.
     The value \code{0} (default for irradiance) is the azimuthally symmetric case.
-    For radiance computation a higher order is required, thus the default for radiances is 4. 
+    For radiance computation a higher order is required, thus the default for radiances is 4.
 
     \fcode{
     polradtran nstokes value
@@ -840,10 +840,10 @@ def get_solver_documentation():
     \fcode{
     sdisort nscat value
     }
-    Set the order of scattering. 
-    If \code{value} is set to 1 \code{sdisort} will run in single scattering mode 
+    Set the order of scattering.
+    If \code{value} is set to 1 \code{sdisort} will run in single scattering mode
     while if set to 2, \code{sdisort} runs in full multiple scattering mode.
-    Default is 2 for \code{rte_solver sdisort}. 
+    Default is 2 for \code{rte_solver sdisort}.
 
     \fcode{
     sdisort nrefrac value
@@ -876,5 +876,5 @@ def get_solver_documentation():
         ''',
         'mc_nca' : r'''
     Approximate calculation of 3D thermal heating rates with the Neighbouring Column Approximation \citep{klinger2016, klinger2019}. For an example and a description how to define the 3D cloud input see \file{examples/UVSPEC_HEAT_NCA2019_*}.
-        ''', # CK2019 added nca 
+        ''', # CK2019 added nca
     }
diff --git a/src_py/special_options.py b/src_py/special_options.py
index 9a479eb..5439f09 100644
--- a/src_py/special_options.py
+++ b/src_py/special_options.py
@@ -1,26 +1,26 @@
 
 """--------------------------------------------------------------------
  * $Id$
- * 
+ *
  * This file is part of libRadtran.
  * Copyright (c) 1997-2012 by Arve Kylling, Bernhard Mayer,
  *                            Claudia Emde, Robert Buras
  *
  * ######### Contact info: http://www.libradtran.org #########
  *
- * This program is free software; you can redistribute it and/or 
- * modify it under the terms of the GNU General Public License   
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.        
- * 
- * This program is distributed in the hope that it will be useful, 
- * but WITHOUT ANY WARRANTY; without even the implied warranty of  
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the   
- * GNU General Public License for more details.                    
- * 
- * You should have received a copy of the GNU General Public License          
- * along with this program; if not, write to the Free Software                
- * Foundation, Inc., 59 Temple Place - Suite 330, 
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
  * Boston, MA 02111-1307, USA.
  *--------------------------------------------------------------------"""
 
@@ -29,177 +29,177 @@ from option_definition import *
 
 class setup_special_group():
 
-	group_name = 'Special'
+        group_name = 'Special'
 
-	def __init__(self):
-		documentation = get_special_documentation()
+        def __init__(self):
+                documentation = get_special_documentation()
 
                 brdf_non_parents=['albedo','albedo_file','albedo_library',
                                   'brdf_rossli', 'brdf_rossli_file', 'brdf_rossli_hotspot',
-                                  'brdf_cam', 'brdf_cam_solar_wind', 'cox_and_munk_u10_map', 
+                                  'brdf_cam', 'brdf_cam_solar_wind', 'cox_and_munk_u10_map',
                                   'brdf_rpv_file', 'brdf_rpv', 'brdf_rpv_library','brdf_rpv_type',
                                   'brdf_hapke', 'brdf_hapke_file',
                                   'mc_albedo_file', 'mc_rossli_file', 'mc_rpv_type', 'mc_rpv_file', 'mc_rpv_spectral_file', 'mc_ambrals_type', 'mc_ambrals_spectral_file',
                                   'bpdf_tsang_u10']
 
-                
+
                 refractive_index_pv = option(
-			name='refractive_index_pv',
-			group='special',
-			documentation=documentation['refractive_index_pv'],
-			tokens=addToken(name='Input.rte.mc.refractive_index_pv', datatype=float, default=1.526),	
-		        mystic=True,
+                        name='refractive_index_pv',
+                        group='special',
+                        documentation=documentation['refractive_index_pv'],
+                        tokens=addToken(name='Input.rte.mc.refractive_index_pv', datatype=float, default=1.526),
+                        mystic=True,
                         showInGui=False
-		)
-                
-                
-		albedo_library = option(
-			name='albedo_library',
-			group='special',
-			helpstr='Spectral albedos of different surface types.',
-			documentation=documentation['albedo_library'], 
-			tokens=addToken(name='Input.alb.library', datatype=str, valid_range=['IGBP',file]),
-			parents=['uvspec'],
-			non_parents=brdf_non_parents,
-			childs=['brdf_rpv_type'],
-			showInGui = False
                 )
-	
-		cloud_fraction_map = option(
-			name='cloud_fraction_map',
-			group='special',
-			documentation=documentation['cloud_fraction_map'],
-			tokens=addToken(name='Input.filename[FN_CLOUD_FRACTION_MAP]',datatype=file),
-			developer=True,
+
+
+                albedo_library = option(
+                        name='albedo_library',
+                        group='special',
+                        helpstr='Spectral albedos of different surface types.',
+                        documentation=documentation['albedo_library'],
+                        tokens=addToken(name='Input.alb.library', datatype=str, valid_range=['IGBP',io.IOBase]),
+                        parents=['uvspec'],
+                        non_parents=brdf_non_parents,
+                        childs=['brdf_rpv_type'],
+                        showInGui = False
                 )
 
-		albedo_map = option(
-			name='albedo_map',
-			group='special',
-			documentation=documentation['albedo_map'],
-			tokens=[addSetting(name='Input.alb.source', setting='ALBEDO_FROM_ALBEDO_MAP') ,
-				addToken(name='Input.filename[FN_ALBEDO_MAP]',datatype=file),
-				addToken(name='Input.alb.netCDF_alb_name',datatype=file,optional=True),
-				addToken(name='Input.alb.scale_factor',datatype=float,optional=True) ],
+                cloud_fraction_map = option(
+                        name='cloud_fraction_map',
+                        group='special',
+                        documentation=documentation['cloud_fraction_map'],
+                        tokens=addToken(name='Input.filename[FN_CLOUD_FRACTION_MAP]',datatype=io.IOBase),
+                        developer=True,
+                )
+
+                albedo_map = option(
+                        name='albedo_map',
+                        group='special',
+                        documentation=documentation['albedo_map'],
+                        tokens=[addSetting(name='Input.alb.source', setting='ALBEDO_FROM_ALBEDO_MAP') ,
+                                addToken(name='Input.filename[FN_ALBEDO_MAP]',datatype=io.IOBase),
+                                addToken(name='Input.alb.netCDF_alb_name',datatype=io.IOBase,optional=True),
+                                addToken(name='Input.alb.scale_factor',datatype=float,optional=True) ],
                         developer=True
                 )
 
-		altitude_map = option(
-			name='altitude_map',
-			group='special',
-			documentation=documentation['altitude_map'],
-			tokens=[addSetting(name='Input.alt.source', setting='ALT_FROM_MAP') ,
-				addToken(name='Input.filename[FN_ALTITUDE_MAP]',datatype=file),
-				addToken(name='Input.alt.netCDF_alt_name',datatype=file,optional=True),
-				addToken(name='Input.alt.scale_factor',datatype=float,optional=True) ],
+                altitude_map = option(
+                        name='altitude_map',
+                        group='special',
+                        documentation=documentation['altitude_map'],
+                        tokens=[addSetting(name='Input.alt.source', setting='ALT_FROM_MAP') ,
+                                addToken(name='Input.filename[FN_ALTITUDE_MAP]',datatype=io.IOBase),
+                                addToken(name='Input.alt.netCDF_alt_name',datatype=io.IOBase,optional=True),
+                                addToken(name='Input.alt.scale_factor',datatype=float,optional=True) ],
                         developer=True
                 )
 
-		cox_and_munk_u10_map = option(
-			name='cox_and_munk_u10_map',
-			group='special',
-			helpstr='Location of netCDF file with wind speed for ocean BRDF.', 
-			documentation=documentation['cox_and_munk_u10_map'], 
-			tokens = [ addToken(name='Input.filename[FN_U10_MAP]', datatype=file), 
-				addSetting(name='Input.disort2_brdf', setting='BRDF_CAM', default='BRDF_NONE') ], 
-			parents=['uvspec'],
-			non_parents=brdf_non_parents,
+                cox_and_munk_u10_map = option(
+                        name='cox_and_munk_u10_map',
+                        group='special',
+                        helpstr='Location of netCDF file with wind speed for ocean BRDF.',
+                        documentation=documentation['cox_and_munk_u10_map'],
+                        tokens = [ addToken(name='Input.filename[FN_U10_MAP]', datatype=io.IOBase),
+                                addSetting(name='Input.disort2_brdf', setting='BRDF_CAM', default='BRDF_NONE') ],
+                        parents=['uvspec'],
+                        non_parents=brdf_non_parents,
                         non_parent_exceptions=['brdf_cam', 'brdf_cam_solar_wind', 'cox_and_munk_u10_map', 'mc_rossli_file'],
-			showInGui= False,
+                        showInGui= False,
                         developer=True
-		)
-
-		cox_and_munk_pcl_map = option(
-			name='cox_and_munk_pcl_map',
-			group='special',
-			documentation=documentation['cox_and_munk_pcl_map'],
-			tokens=[addSetting(name='Input.disort2_brdf', setting='BRDF_CAM') ,
-				addToken(name='Input.filename[FN_PIGMENTS_MAP]',datatype=file),
-				addToken(name='Input.cm.pcl_netCDF_name',datatype=file,optional=True),
-				addToken(name='Input.cm.pcl_scale_factor',datatype=float,optional=True) ],
+                )
+
+                cox_and_munk_pcl_map = option(
+                        name='cox_and_munk_pcl_map',
+                        group='special',
+                        documentation=documentation['cox_and_munk_pcl_map'],
+                        tokens=[addSetting(name='Input.disort2_brdf', setting='BRDF_CAM') ,
+                                addToken(name='Input.filename[FN_PIGMENTS_MAP]',datatype=io.IOBase),
+                                addToken(name='Input.cm.pcl_netCDF_name',datatype=io.IOBase,optional=True),
+                                addToken(name='Input.cm.pcl_scale_factor',datatype=float,optional=True) ],
                         developer=True
-		)
-
-		cox_and_munk_sal_map = option(
-			name='cox_and_munk_sal_map',
-			group='special',
-			documentation=documentation['cox_and_munk_sal_map'],
-			tokens=[addSetting(name='Input.disort2_brdf', setting='BRDF_CAM') ,
-				addToken(name='Input.filename[FN_SALINITY_MAP]',datatype=file),
-				addToken(name='Input.cm.sal_netCDF_name',datatype=file,optional=True),
-				addToken(name='Input.cm.sal_scale_factor',datatype=float,optional=True) ],
+                )
+
+                cox_and_munk_sal_map = option(
+                        name='cox_and_munk_sal_map',
+                        group='special',
+                        documentation=documentation['cox_and_munk_sal_map'],
+                        tokens=[addSetting(name='Input.disort2_brdf', setting='BRDF_CAM') ,
+                                addToken(name='Input.filename[FN_SALINITY_MAP]',datatype=io.IOBase),
+                                addToken(name='Input.cm.sal_netCDF_name',datatype=io.IOBase,optional=True),
+                                addToken(name='Input.cm.sal_scale_factor',datatype=float,optional=True) ],
                         developer=True
-		)
-
-		emissivity_map = option(
-			name='emissivity_map',
-			group='special',
-			documentation=documentation['emissivity_map'],
-			tokens=[addSetting(name='Input.alb.source', setting='ALBEDO_FROM_EMISSIVITY_MAP') ,
-				addToken(name='Input.filename[FN_ALBEDO_MAP]',datatype=file),
-				addToken(name='Input.alb.netCDF_alb_name',datatype=file,optional=True),
-				addToken(name='Input.alb.scale_factor',datatype=float,optional=True) ],
+                )
+
+                emissivity_map = option(
+                        name='emissivity_map',
+                        group='special',
+                        documentation=documentation['emissivity_map'],
+                        tokens=[addSetting(name='Input.alb.source', setting='ALBEDO_FROM_EMISSIVITY_MAP') ,
+                                addToken(name='Input.filename[FN_ALBEDO_MAP]',datatype=io.IOBase),
+                                addToken(name='Input.alb.netCDF_alb_name',datatype=io.IOBase,optional=True),
+                                addToken(name='Input.alb.scale_factor',datatype=float,optional=True) ],
                         developer=True
-		)
-                
-              
-		surface_temperature_map = option(
-			name='surface_temperature_map',
-			group='special',
-			documentation=documentation['surface_temperature_map'],
-			tokens=[addToken(name='Input.filename[FN_SURFACE_TEMP_MAP]',datatype=file),
-				addToken(name='Input.netCDF_name_surf_T',datatype=file,optional=True)],
+                )
+
+
+                surface_temperature_map = option(
+                        name='surface_temperature_map',
+                        group='special',
+                        documentation=documentation['surface_temperature_map'],
+                        tokens=[addToken(name='Input.filename[FN_SURFACE_TEMP_MAP]',datatype=io.IOBase),
+                                addToken(name='Input.netCDF_name_surf_T',datatype=io.IOBase,optional=True)],
                         developer=True
-		)
-
-		surface_type_map = option(
-			name='surface_type_map',
-			group='special',
-			documentation=documentation['surface_type_map'],
-			tokens=[addSetting(name='Input.alb.surf_type_map',setting='TRUE'),
-				addToken(name='Input.filename[FN_SURFACE_TYPE_MAP]',datatype=file),
-				addToken(name='Input.alb.netCDF_surf_name',datatype=file,optional=True)]
                 )
 
-		ECHAM_sza = option(
-			name='ECHAM_sza',
-			group='special',
-			documentation=documentation['ECHAM_sza'],
-			tokens=[addToken(name='Input.filename[FN_SZA]',datatype=file),
-				addSetting(name='Input.atm.sza',setting='NOT_DEFINED_FLOAT'),
-				addSetting(name='Input.atm.sza_source',setting='SZA_ECHAM') ],
-			developer=True,
-		)
-
-		ECMWF_ozone_climatology = option(
-			name='ECMWF_ozone_climatology',
-			group='special',
-			documentation=documentation['ECMWF_ozone_climatology'],
-			tokens=addSetting(name='Input.atm.ECMWF_ozone_climatology',setting='TRUE'),
+                surface_type_map = option(
+                        name='surface_type_map',
+                        group='special',
+                        documentation=documentation['surface_type_map'],
+                        tokens=[addSetting(name='Input.alb.surf_type_map',setting='TRUE'),
+                                addToken(name='Input.filename[FN_SURFACE_TYPE_MAP]',datatype=io.IOBase),
+                                addToken(name='Input.alb.netCDF_surf_name',datatype=io.IOBase,optional=True)]
+                )
+
+                ECHAM_sza = option(
+                        name='ECHAM_sza',
+                        group='special',
+                        documentation=documentation['ECHAM_sza'],
+                        tokens=[addToken(name='Input.filename[FN_SZA]',datatype=io.IOBase),
+                                addSetting(name='Input.atm.sza',setting='NOT_DEFINED_FLOAT'),
+                                addSetting(name='Input.atm.sza_source',setting='SZA_ECHAM') ],
+                        developer=True,
+                )
+
+                ECMWF_ozone_climatology = option(
+                        name='ECMWF_ozone_climatology',
+                        group='special',
+                        documentation=documentation['ECMWF_ozone_climatology'],
+                        tokens=addSetting(name='Input.atm.ECMWF_ozone_climatology',setting='TRUE'),
                         developer=True
-		)
-
-		ECMWF_wc_file = option(
-			name='ECMWF_wc_file',
-			group='special',
-			documentation=documentation['ECMWF_wc_file'],
-			tokens=[addSetting(name='isp',setting=CaothType('wc')),
-				addSetting(name='Input.caoth[isp].source',setting='CAOTH_FROM_ECMWF'),
-				addToken(name='Input.caoth[isp].filename',datatype=file) ],
+                )
+
+                ECMWF_wc_file = option(
+                        name='ECMWF_wc_file',
+                        group='special',
+                        documentation=documentation['ECMWF_wc_file'],
+                        tokens=[addSetting(name='isp',setting=CaothType('wc')),
+                                addSetting(name='Input.caoth[isp].source',setting='CAOTH_FROM_ECMWF'),
+                                addToken(name='Input.caoth[isp].filename',datatype=io.IOBase) ],
                         developer=True
-		)
-
-		ECMWF_ic_file = option(
-			name='ECMWF_ic_file',
-			group='special',
-			documentation=documentation['ECMWF_ic_file'],
-			tokens=[addSetting(name='isp',setting=CaothType('ic')),
-				addSetting(name='Input.caoth[isp].source',setting='CAOTH_FROM_ECMWF'),
-				addToken(name='Input.caoth[isp].filename',datatype=file) ],
+                )
+
+                ECMWF_ic_file = option(
+                        name='ECMWF_ic_file',
+                        group='special',
+                        documentation=documentation['ECMWF_ic_file'],
+                        tokens=[addSetting(name='isp',setting=CaothType('ic')),
+                                addSetting(name='Input.caoth[isp].source',setting='CAOTH_FROM_ECMWF'),
+                                addToken(name='Input.caoth[isp].filename',datatype=io.IOBase) ],
                         developer=True
-		)
+                )
 
-		ECMWF_levels_only = option(
+                ECMWF_levels_only = option(
                         name='ECMWF_levels_only',
                         group='special',
                         documentation=documentation['ECMWF_levels_only'],
@@ -207,239 +207,239 @@ class setup_special_group():
                         developer=True
                 )
 
-		ECMWF_wind_file = option(
+                ECMWF_wind_file = option(
                         name='ECMWF_wind_file',
                         group='special',
                         documentation=documentation['ECMWF_wind_file'],
-                        tokens=addToken(name='Input.filename[FN_ECMWF_WIND_MAP]',datatype=file),
+                        tokens=addToken(name='Input.filename[FN_ECMWF_WIND_MAP]',datatype=io.IOBase),
                         developer=True
                 )
 
-		satellite_geometry = option(
+                satellite_geometry = option(
                         name='satellite_geometry',
                         group='special',
                         documentation=documentation['satellite_geometry'],
-                        tokens=addToken(name='Input.filename[FN_SATGEOMETRY]',datatype=file),
+                        tokens=addToken(name='Input.filename[FN_SATGEOMETRY]',datatype=io.IOBase),
                         developer=True
                 )
 
-		satellite_pixel = option(
+                satellite_pixel = option(
                         name='satellite_pixel',
                         group='special',
                         documentation=documentation['satellite_pixel'],
                         tokens=[addToken(name='Input.sat_pixel_x',datatype=int),
-				addToken(name='Input.sat_pixel_y',datatype=int) ],
+                                addToken(name='Input.sat_pixel_y',datatype=int) ],
                         developer=True
                 )
 
-		self.options = [ ECHAM_sza,
-				ECMWF_ozone_climatology, ECMWF_wc_file, ECMWF_ic_file, ECMWF_wind_file, ECMWF_levels_only,
-				cox_and_munk_u10_map, cox_and_munk_pcl_map, cox_and_munk_sal_map,
-				cloud_fraction_map, altitude_map, albedo_map, emissivity_map,
-				surface_temperature_map, surface_type_map,
-				albedo_library, satellite_geometry, satellite_pixel,
+                self.options = [ ECHAM_sza,
+                                ECMWF_ozone_climatology, ECMWF_wc_file, ECMWF_ic_file, ECMWF_wind_file, ECMWF_levels_only,
+                                cox_and_munk_u10_map, cox_and_munk_pcl_map, cox_and_munk_sal_map,
+                                cloud_fraction_map, altitude_map, albedo_map, emissivity_map,
+                                surface_temperature_map, surface_type_map,
+                                albedo_library, satellite_geometry, satellite_pixel,
                                 refractive_index_pv]
 
-		#Special group belongs to developers options; should not be in Gui for EsasLight version; 
-		for opt in self.options:
-			opt.showInGui = False
+                #Special group belongs to developers options; should not be in Gui for EsasLight version;
+                for opt in self.options:
+                        opt.showInGui = False
 
-	def __iter__(self):
-		return iter(self.options)
+        def __iter__(self):
+                return iter(self.options)
 
 def get_special_documentation():
-	return {
-		'albedo_library' : r'''
-	Albedo libraries are a collection of spectral albedos of different surface types. 
-	This option must be used either with \code{bdrf_rpv_type} 
-	or \code{surface_type_map}, in order to select the specific surface type.
-	There are two possibilities for libraries: 
-	the built-in IGBP library or a user defined albedo library.
-
-	The built-in library of the International Geosphere Biosphere Programme is 
-	selected with 
-	\fcode{
-	     albedo_library IGBP
-	}
-	The IGBP library contains 20 surface types which are set by \code{brdf_rpv_type}:
-	\fcode{
-	 1 evergreen_needle_forest\\
-	 2 evergreen_broad_forest\\
-	 3 deciduous_needle_forest\\
-	 4 deciduous_broad_forest\\
-	 5 mixed_forest\\
-	 6 closed_shrub\\
-	 7 open_shrubs\\
-	 8 woody_savanna\\
-	 9 savanna\\
-	10 grassland\\
-	11 wetland\\
-	12 cropland\\
-	13 urban\\
-	14 crop_mosaic\\
-	15 antarctic_snow\\
-	16 desert\\
-	17 ocean_water\\
-	18 tundra\\
-	19 fresh_snow\\
-	20 sea_ice\\
-	}
-	Surface types 1 - 17 are defined by the International Geosphere Biosphere 
-	Programme (IGBP); additionally there are tundra, fresh\_snow, and sea\_ice surface types.
-	The spectral albedo of the ground is determined as a function of solar 
-	zenith angle, precitable water, and clouds. The spectral resolution 
-	equals the grid of the correlated-k Fu/Liou parameterisation.
-	This library originates from the NASA CERES/SARB Surface Properties Project, 
-	see \citet{Belward1996}.
-
-	For creating your own albedo library use \code{albedo_library path}, where \code{path} is 
-	the path of the directory where the albedo data is stored. The files are expected to have the 
-	names \code{albedo_01.dat, albedo_02.dat, ...} If \code{brdf_rpv_type 1} is specified
-	the albedo from \code{albedo_01.dat} will be used, and so on.  
-	Each file is required to have two columns:
-	Column 1 is the wavelength in nm, and column 2 the corresponding 
-	Lambertian surface albedo. The wavelength grid may be freely set. The 
-	albedo will be interpolated linearely to the wavelength grid used for the 
-	radiation calculation. Comments start with \code{\#}. Empty lines are ignored.
-	This option is similar to \code{albedo_file}, except that it offers an
-	easy way to use the option \code{surface_type_map} in combinition with albedo files.
-		''',
-
-		'albedo_map' : r'''
-	\emph{This option is preliminary and still subject to change (no wavelength dependency yet)!}
-	It gives the possibility to specify a wavelength independent albedo with the help of 
-	a \emph{netCDF} file, which is used in combinition 
-	with the options \code{latitude}, \code{longitude}, and \code{time}.
-	\fcode{
-	albedo_map file [variable_name]
-	}
-	Here \code{file} is the location of the \emph{netCDF} file,
-	The optional argument allows the name of the albedo variable in 
-	the \emph{netCDF} file to be specified (the default name is \code{AL}).
-	The albedo must be provided as function of \code{latitude} and \code{longitude} \code{AL(lat, lon)}, 
-	and may also depend on time \code{AL(time, lat, lon)}. 
-	The latitude, longitude, and time grids must be provided as doubles 
-	\code{double lat(lat)}, \code{double lon(lon)}, and \code{double time(time)}.
-	\code{uvspec} reads the value at the nearest pixel to the given \code{latitude} and 
-	\code{longitude}. No spatial interpolation or averaging of the values are performed.
-	If a time-dependent albedo is provided, the albedo data nearest to the specified time 
-	will be selected (or linear interpolated if \code{time_interpolate} is switched on). 
-		''',
-
-		'altitude_map' : r'''
-	Specifies an altitude map which is used in combinition with  
-	\code{latitude}, \code{longitude} in order to  
-	select the altitude for the simulation. 
-	No interpolation is done between the pixels of the map. 
-	The format of the call is: 
-	\fcode{ 
-	altitude_map file [variable_name] 
-	} 
-	where \code{file} is the location of the altitude map file. The map is expected to  
-	be in \emph{netCDF} format. The file must contain \code{double lat(lat)},  
-	\code{double lon(lon)}, and the altitude variable, where \code{variable_name} is the  
-	name of the surface elevation variable in the \emph{netCDF} file. The default name is Z. 
-	The altitude variable must be \code{altitude(lat, lon)}.  
-	For format discribtion see also the example map included in {\sl libRadtran},  
-	\file{data/altitude/ELEVATION_GTOPO_10min.cdf}. 
-	To use this map in \code{uvspec}, you may also use \code{altitude_map GTOPO}. This map has a resolution  
-	of 10 arc minutes and the unit of the altitude is meter. Please note that this resolution 
-	might not ne adequate for your application.  
-	If an altitude in the map is below the lowest level of the  
-	\code{atmosphere_file}, the atmospheric profiles are extrapolated assuming a constant  
-	gradient for temperature and mixing ratios. 
-		''',
-
-		'cloud_fraction_map' : r'''
-	Undocumented option.
-		''',
-
-		'cox_and_munk_u10_map' : r'''
-	Specify wind speed (in m/s) for the \citet{cox54a,cox54b}
-	ocean BRDF with the help of an \emph{netCDF} file, which is used in combinition 
-	with the options \code{latitude}, \code{longitude}, and \code{time}.
-	\fcode{
-	cox_and_munk_u10_map file
-	}
-	where \code{file} is the location of the \emph{netCDF} file. 
-	{\sl libRadtran} reads the value at the nearest pixel to the given \code{latitude} and 
-	\code{longitude}. No spatial interpolation or averaging of the values is done.
-
-	The file must contain the elements of the wind vector \code{U10} and
-	\code{V10}.  These must be specified as functions of \code{latitude}
-	and \code{longitude} \code{U10(lat, lon)}, \code{V10(lat, lon)}, or
-	additionally may also depent on time \code{U10(time, lat, lon)},
-	\code{V10(time, lat, lon)}.  If the variable time is present in the
-	file, the wind speed will be interpolated according to the option
-	\code{time_interpolate}. All grids must be provided as \code{double
-	lat(lat)}, \code{double lon(lon)}, and \code{double time(time)}.
-		''',
-
-		'cox_and_munk_pcl_map' : r'''
-	A possibility to specify pigment concentration (in mg/m3) for the Cox and Munk 
-	ocean BRDF with the help of an \emph{netCDF} file, which is used in combinition 
-	with options \code{latitude}, \code{longitude}, and \code{time}.
-	\fcode{
-	cox_and_munk_pcl_map file [variable_name]
-	}
-	where \code{file} is the location of the \emph{netCDF} file. 
-	{\sl libRadtran} reads the value at the nearest pixel to the given \code{latitude} and 
-	\code{longitude}. No spatial interpolation or averaging of the values is done.
-	
-	The default name of the pigment concentration variable is
-	\code{chlorophyll}, but can be changed with the optional argument
-	\code{variable_name}.  The pigment concentration must be provided as
-	function of \code{latitude} and \code{longitude},
-	\code{chlorophyll(lat, lon)}, or additionally may also depend on time
-	\code{chlorophyll(time, lat, lon)}.  If a time-dependent pigment
-	concentration is specified, the pigment concentration will be
-	interpolated according to the option \code{time_interpolate}. All
-	grids must be provided in the file as \code{double lat(lat)},
-	\code{double lon(lon)}, and \code{double time(time)}.
-		''',
-
-		'cox_and_munk_sal_map' : r'''
-	Specify ocean salinity (in ppt) for the \citet{cox54a,cox54b}
-	ocean BRDF with the help of an \emph{netCDF} file, which is used in combinition 
-	with the options \code{latitude}, \code{longitude}, and \code{time}.
-	\fcode{
-	cox_and_munk_pcl_map file [variable_name]
-	}
-	where \code{file} is the location of the \emph{netCDF} file. 
-	{\sl libRadtran} reads the value at the nearest pixel to the given \code{latitude} and 
-	\code{longitude}. No spatial interpolation or averaging of the values is done.
-	
-	The expected name of the pigment concentration variable is per default
-	\code{salinity}, but can be changed with the optional argument
-	\code{variable_name}.  The pigment concentration must be provided as
-	function of \code{latitude} and \code{longitude}, \code{salinity(lat,
-	lon)}, or additionally may also depent on time \code{salinity(time,
-	lat, lon)}.  If a time-dependent salinity is specified, the salinity
-	will be interpolated according to the option
-	\code{time_interpolate}. All grids must be provided as \code{double
-	lat(lat)}, \code{double lon(lon)}, and \code{double time(time)}.
-		''',	
-
-		'emissivity_map' : r'''
-	\emph{This option is preliminary and still subject to change (no wavelength dependency yet)!} 
-	Specify a wavelength independent emissivity with the help of  
-	an \emph{netCDF} file, which is used in combinition  
-	with the options \code{latitude}, \code{longitude}, and \code{time}. 
-	\fcode{ 
-	emissivity_map file [variable_name] 
-	} 
-	where \code{file} is the location of the \emph{netCDF} file.  
-	With the optional argument \code{variable_name} the name of the emissivity variable in  
-	the \emph{netCDF} file can be specified. (By default the expected name is \code{EMIS}.) 
-	The emissivity must be specified as function of \code{latitude} and \code{longitude} \code{EMIS(lat, lon)},  
-	or additionally may also depent on time \code{EMIS(time, lat, lon)}.  
-	All grids must be provided as  
-	\code{double lat(lat)}, \code{double lon(lon)}, and \code{double time(time)}. 
-	{\sl libRadtran} reads the value at the nearest pixel to the given \code{latitude} and  
-	\code{longitude}. No spatial interpolation or averaging of the values is done. 
-	If the variable time is present in the file, the emissivity data nearest to the specified time  
-	will be selected (or interpolated if \code{time_interpolate} is switched on).  
-		''',
+        return {
+                'albedo_library' : r'''
+        Albedo libraries are a collection of spectral albedos of different surface types.
+        This option must be used either with \code{bdrf_rpv_type}
+        or \code{surface_type_map}, in order to select the specific surface type.
+        There are two possibilities for libraries:
+        the built-in IGBP library or a user defined albedo library.
+
+        The built-in library of the International Geosphere Biosphere Programme is
+        selected with
+        \fcode{
+             albedo_library IGBP
+        }
+        The IGBP library contains 20 surface types which are set by \code{brdf_rpv_type}:
+        \fcode{
+         1 evergreen_needle_forest\\
+         2 evergreen_broad_forest\\
+         3 deciduous_needle_forest\\
+         4 deciduous_broad_forest\\
+         5 mixed_forest\\
+         6 closed_shrub\\
+         7 open_shrubs\\
+         8 woody_savanna\\
+         9 savanna\\
+        10 grassland\\
+        11 wetland\\
+        12 cropland\\
+        13 urban\\
+        14 crop_mosaic\\
+        15 antarctic_snow\\
+        16 desert\\
+        17 ocean_water\\
+        18 tundra\\
+        19 fresh_snow\\
+        20 sea_ice\\
+        }
+        Surface types 1 - 17 are defined by the International Geosphere Biosphere
+        Programme (IGBP); additionally there are tundra, fresh\_snow, and sea\_ice surface types.
+        The spectral albedo of the ground is determined as a function of solar
+        zenith angle, precitable water, and clouds. The spectral resolution
+        equals the grid of the correlated-k Fu/Liou parameterisation.
+        This library originates from the NASA CERES/SARB Surface Properties Project,
+        see \citet{Belward1996}.
+
+        For creating your own albedo library use \code{albedo_library path}, where \code{path} is
+        the path of the directory where the albedo data is stored. The files are expected to have the
+        names \code{albedo_01.dat, albedo_02.dat, ...} If \code{brdf_rpv_type 1} is specified
+        the albedo from \code{albedo_01.dat} will be used, and so on.
+        Each file is required to have two columns:
+        Column 1 is the wavelength in nm, and column 2 the corresponding
+        Lambertian surface albedo. The wavelength grid may be freely set. The
+        albedo will be interpolated linearely to the wavelength grid used for the
+        radiation calculation. Comments start with \code{\#}. Empty lines are ignored.
+        This option is similar to \code{albedo_file}, except that it offers an
+        easy way to use the option \code{surface_type_map} in combinition with albedo files.
+                ''',
+
+                'albedo_map' : r'''
+        \emph{This option is preliminary and still subject to change (no wavelength dependency yet)!}
+        It gives the possibility to specify a wavelength independent albedo with the help of
+        a \emph{netCDF} file, which is used in combinition
+        with the options \code{latitude}, \code{longitude}, and \code{time}.
+        \fcode{
+        albedo_map file [variable_name]
+        }
+        Here \code{file} is the location of the \emph{netCDF} file,
+        The optional argument allows the name of the albedo variable in
+        the \emph{netCDF} file to be specified (the default name is \code{AL}).
+        The albedo must be provided as function of \code{latitude} and \code{longitude} \code{AL(lat, lon)},
+        and may also depend on time \code{AL(time, lat, lon)}.
+        The latitude, longitude, and time grids must be provided as doubles
+        \code{double lat(lat)}, \code{double lon(lon)}, and \code{double time(time)}.
+        \code{uvspec} reads the value at the nearest pixel to the given \code{latitude} and
+        \code{longitude}. No spatial interpolation or averaging of the values are performed.
+        If a time-dependent albedo is provided, the albedo data nearest to the specified time
+        will be selected (or linear interpolated if \code{time_interpolate} is switched on).
+                ''',
+
+                'altitude_map' : r'''
+        Specifies an altitude map which is used in combinition with
+        \code{latitude}, \code{longitude} in order to
+        select the altitude for the simulation.
+        No interpolation is done between the pixels of the map.
+        The format of the call is:
+        \fcode{
+        altitude_map file [variable_name]
+        }
+        where \code{file} is the location of the altitude map file. The map is expected to
+        be in \emph{netCDF} format. The file must contain \code{double lat(lat)},
+        \code{double lon(lon)}, and the altitude variable, where \code{variable_name} is the
+        name of the surface elevation variable in the \emph{netCDF} file. The default name is Z.
+        The altitude variable must be \code{altitude(lat, lon)}.
+        For format discribtion see also the example map included in {\sl libRadtran},
+        \file{data/altitude/ELEVATION_GTOPO_10min.cdf}.
+        To use this map in \code{uvspec}, you may also use \code{altitude_map GTOPO}. This map has a resolution
+        of 10 arc minutes and the unit of the altitude is meter. Please note that this resolution
+        might not ne adequate for your application.
+        If an altitude in the map is below the lowest level of the
+        \code{atmosphere_file}, the atmospheric profiles are extrapolated assuming a constant
+        gradient for temperature and mixing ratios.
+                ''',
+
+                'cloud_fraction_map' : r'''
+        Undocumented option.
+                ''',
+
+                'cox_and_munk_u10_map' : r'''
+        Specify wind speed (in m/s) for the \citet{cox54a,cox54b}
+        ocean BRDF with the help of an \emph{netCDF} file, which is used in combinition
+        with the options \code{latitude}, \code{longitude}, and \code{time}.
+        \fcode{
+        cox_and_munk_u10_map file
+        }
+        where \code{file} is the location of the \emph{netCDF} file.
+        {\sl libRadtran} reads the value at the nearest pixel to the given \code{latitude} and
+        \code{longitude}. No spatial interpolation or averaging of the values is done.
+
+        The file must contain the elements of the wind vector \code{U10} and
+        \code{V10}.  These must be specified as functions of \code{latitude}
+        and \code{longitude} \code{U10(lat, lon)}, \code{V10(lat, lon)}, or
+        additionally may also depent on time \code{U10(time, lat, lon)},
+        \code{V10(time, lat, lon)}.  If the variable time is present in the
+        file, the wind speed will be interpolated according to the option
+        \code{time_interpolate}. All grids must be provided as \code{double
+        lat(lat)}, \code{double lon(lon)}, and \code{double time(time)}.
+                ''',
+
+                'cox_and_munk_pcl_map' : r'''
+        A possibility to specify pigment concentration (in mg/m3) for the Cox and Munk
+        ocean BRDF with the help of an \emph{netCDF} file, which is used in combinition
+        with options \code{latitude}, \code{longitude}, and \code{time}.
+        \fcode{
+        cox_and_munk_pcl_map file [variable_name]
+        }
+        where \code{file} is the location of the \emph{netCDF} file.
+        {\sl libRadtran} reads the value at the nearest pixel to the given \code{latitude} and
+        \code{longitude}. No spatial interpolation or averaging of the values is done.
+
+        The default name of the pigment concentration variable is
+        \code{chlorophyll}, but can be changed with the optional argument
+        \code{variable_name}.  The pigment concentration must be provided as
+        function of \code{latitude} and \code{longitude},
+        \code{chlorophyll(lat, lon)}, or additionally may also depend on time
+        \code{chlorophyll(time, lat, lon)}.  If a time-dependent pigment
+        concentration is specified, the pigment concentration will be
+        interpolated according to the option \code{time_interpolate}. All
+        grids must be provided in the file as \code{double lat(lat)},
+        \code{double lon(lon)}, and \code{double time(time)}.
+                ''',
+
+                'cox_and_munk_sal_map' : r'''
+        Specify ocean salinity (in ppt) for the \citet{cox54a,cox54b}
+        ocean BRDF with the help of an \emph{netCDF} file, which is used in combinition
+        with the options \code{latitude}, \code{longitude}, and \code{time}.
+        \fcode{
+        cox_and_munk_pcl_map file [variable_name]
+        }
+        where \code{file} is the location of the \emph{netCDF} file.
+        {\sl libRadtran} reads the value at the nearest pixel to the given \code{latitude} and
+        \code{longitude}. No spatial interpolation or averaging of the values is done.
+
+        The expected name of the pigment concentration variable is per default
+        \code{salinity}, but can be changed with the optional argument
+        \code{variable_name}.  The pigment concentration must be provided as
+        function of \code{latitude} and \code{longitude}, \code{salinity(lat,
+        lon)}, or additionally may also depent on time \code{salinity(time,
+        lat, lon)}.  If a time-dependent salinity is specified, the salinity
+        will be interpolated according to the option
+        \code{time_interpolate}. All grids must be provided as \code{double
+        lat(lat)}, \code{double lon(lon)}, and \code{double time(time)}.
+                ''',
+
+                'emissivity_map' : r'''
+        \emph{This option is preliminary and still subject to change (no wavelength dependency yet)!}
+        Specify a wavelength independent emissivity with the help of
+        an \emph{netCDF} file, which is used in combinition
+        with the options \code{latitude}, \code{longitude}, and \code{time}.
+        \fcode{
+        emissivity_map file [variable_name]
+        }
+        where \code{file} is the location of the \emph{netCDF} file.
+        With the optional argument \code{variable_name} the name of the emissivity variable in
+        the \emph{netCDF} file can be specified. (By default the expected name is \code{EMIS}.)
+        The emissivity must be specified as function of \code{latitude} and \code{longitude} \code{EMIS(lat, lon)},
+        or additionally may also depent on time \code{EMIS(time, lat, lon)}.
+        All grids must be provided as
+        \code{double lat(lat)}, \code{double lon(lon)}, and \code{double time(time)}.
+        {\sl libRadtran} reads the value at the nearest pixel to the given \code{latitude} and
+        \code{longitude}. No spatial interpolation or averaging of the values is done.
+        If the variable time is present in the file, the emissivity data nearest to the specified time
+        will be selected (or interpolated if \code{time_interpolate} is switched on).
+                ''',
 
                 'refractive_index_pv' : r'''
                 Specify refractive index of glass surface of
@@ -447,124 +447,124 @@ def get_special_documentation():
                 combination with \fcode{mc_backward_quantity ednpv}.
                 ''',
 
-		'ECHAM_sza' : r'''
-	Undocumented option.
-		''',
-
-		'ECMWF_ozone_climatology' : '''
-	The Integrated Forecast System (IFS) of the ECMWF uses a ozone 
-	climatology for radiative transfer instead of the ozone simulated by 
-	the IFS. If this option is activated the ozone profile of the 
-	\code{atmosphere_file} or \code{ECMWF_atmosphere_file} is replaced by 
-	the ozone climatology by Fortuin and Langematz (1995). 
-	(If there is also a \code{mol_file} for ozone, it modifies the ozone 
-	climatology profile.) 
-		''',
-
-		'ECMWF_ic_file' : r'''
-	\fcode{ 
-	ECMWF_ic_file file 
-	} 
-	For further information see \code{ECMWF_wc_file}.
-		''',
-
-		'ECMWF_levels_only' : r'''
-	The atmosphere considered in the simulation has the same height range 
-	as the data in the 
-	\code{ECMWF_atmosphere_file}/\code{radiosonde}-file. No further levels 
-	are added above those.  This option has only an effect in combination 
-	with \code{ECMWF_atmosphere_file} or \code{radiosonde} 
-	(this option is identical to \code{radiosonde_levels_only}). 
-		''',
-
-		'ECMWF_wc_file' : r'''
-	Reads in combination with the options \code{latitude}, 
-	\code{longitude}, and \code{time} (all mandatory) the pressure, 
-	temperature, and cloud liqid water content (CLWC) and cloud cover (CC) 
-	from an ECMWF \emph{netCDF} data file. 
-	\fcode{ 
-	ECMWF_wc_file file 
-	} 
-	No spatial interpolation of the values is done.  The data nearest to 
-	the specified \code{time} will be selected (or linearly interpolated 
-	if \code{time_interpolate} is switched on).  In order to use the ECMWF 
-	data without cloud overlap assumption, use \code{cloud_overlap off}. 
-		''',
-
-		'ECMWF_wind_file' : r'''
-	Reads in combination with the options \code{latitude}, 
-	\code{longitude}, and \code{time} (all mandatory) the wind components 
-	U, V, and W from an ECMWF \emph{netCDF} data file. 
-	\fcode{ 
-	ECMWF_wind_file file 
-	} 
-	The data nearest to the specified \code{time} will be selected (or 
-	linearly interpolated, if \code{time_interpolate} is switched on). 
-		''',
-
-		'satellite_geometry' : r'''
-	With this option the satellite geometry is determinded. The argument for this option 
-	\fcode{ 
-	satellite_geometry  netCDF_file  
-	} 
-	is the location of a \code{netCDF_file}, which must contain latitude and longitude position 
-	as well as zenith and azimuth viewing angle for each pixel. 
- 
-	%ak20100306 What is below does not belong in the general Users Guide yet. 
-	%For format specification see the example file data/satellite/MSG\_seviri/MSG\_seviri\_geometry.nc. 
-	%This option has to be used in combination with \code{satellite_pixel}. 
-	%You can also use the abbreviation 
-	%\code{satellite_geometry MSG} 
-	%for MSG simulation, \emph{but in order to use this, you have to copy the netCDF file} 
-	%\fcode{ 
-	%cp -r /data/A3/satellite_geometry/satellites libRadtran/data/ 
-	%} 
-	%\emph{which is not in cvs version, as it is too large.} 
-		''',
-
-		'satellite_pixel' : r'''
-	This option specifies which pixel of the satellite image that should be simulated.  
-	\fcode{ 
-	satellite_pixel  pixel_x pixel_y 
-	} 
-	The arguments \code{pixel_nr_x} and \code{pixel_nr_y} specifies the pixel position in the native  
-	system of the satellite, which is determinded by the option \code{satellite_geometry}. 
-		''',
-
-		'surface_temperature_map' : r'''
-	Specify a surface\_temperature map with a \emph{netCDF} file which is used in combinition 
-	with the options \code{latitude}, \code{longitude}, and \code{time}.
-	\fcode{
-	surface_temperature_map file [variable_name]
-	}
-	where \code{file} is the location of the \emph{netCDF} file. 
-	\code{libRadtran} reads the value at the nearest pixel to the given \code{latitude} and 
-	\code{longitude}. No spatial interpolation or averaging of the values is done.
-		''',
-
-		'surface_type_map' : r'''
-	Specify a surface type map, which is used in combinition with 
-	\code{albedo_library}, \code{latitude}, and \code{longitude} in order to 
-	select the surface type relevant for the simulation.
-	No pixel interpolation is done.
-	The format of the call is:
-	\fcode{
-	surface_type_map file [variable_name]
-	}
-	where \code{file} is the location of the surface type map file. The map is expected to 
-	be in \emph{netCDF} format. The file must contain the variables \code{double lat(nlat)}, 
-	\code{double lon(nlon)}, and \code{byte brdf_rpv_type (nlat, nlon)}. If the name of the 
-	surface type variable is different, the optional argument can be used in order to specify 
-	the variable name. For format specification see also 
-	\file{data/albedo/IGBP_map/SURFACE_TYPE_IGBP_10min.cdf}.
-
-	For using the IGBP map, the call is \code{surface_type_map IGBP}. This map has a resolution of 10 
-	minutes and contains the surface types 1 to 18 defined in the \code{albedo_library IGBP}. 
-	Fresh snow and sea ice are not included, as their extent is too variable. Attention:  
-	That implies e.g. that the Arctic is considered ocean\_water and not sea\_ice!
-
-	Locations on the pixel boundaries are interpreted as the pixel northward and
-	eastward respectively. E.g. location 0 N, 0 E is interpreted like the pixel ranging from
-	0 to 10min North and from 0 to 10min East.
-		''',
+                'ECHAM_sza' : r'''
+        Undocumented option.
+                ''',
+
+                'ECMWF_ozone_climatology' : '''
+        The Integrated Forecast System (IFS) of the ECMWF uses a ozone
+        climatology for radiative transfer instead of the ozone simulated by
+        the IFS. If this option is activated the ozone profile of the
+        \code{atmosphere_file} or \code{ECMWF_atmosphere_file} is replaced by
+        the ozone climatology by Fortuin and Langematz (1995).
+        (If there is also a \code{mol_file} for ozone, it modifies the ozone
+        climatology profile.)
+                ''',
+
+                'ECMWF_ic_file' : r'''
+        \fcode{
+        ECMWF_ic_file file
+        }
+        For further information see \code{ECMWF_wc_file}.
+                ''',
+
+                'ECMWF_levels_only' : r'''
+        The atmosphere considered in the simulation has the same height range
+        as the data in the
+        \code{ECMWF_atmosphere_file}/\code{radiosonde}-file. No further levels
+        are added above those.  This option has only an effect in combination
+        with \code{ECMWF_atmosphere_file} or \code{radiosonde}
+        (this option is identical to \code{radiosonde_levels_only}).
+                ''',
+
+                'ECMWF_wc_file' : r'''
+        Reads in combination with the options \code{latitude},
+        \code{longitude}, and \code{time} (all mandatory) the pressure,
+        temperature, and cloud liqid water content (CLWC) and cloud cover (CC)
+        from an ECMWF \emph{netCDF} data file.
+        \fcode{
+        ECMWF_wc_file file
+        }
+        No spatial interpolation of the values is done.  The data nearest to
+        the specified \code{time} will be selected (or linearly interpolated
+        if \code{time_interpolate} is switched on).  In order to use the ECMWF
+        data without cloud overlap assumption, use \code{cloud_overlap off}.
+                ''',
+
+                'ECMWF_wind_file' : r'''
+        Reads in combination with the options \code{latitude},
+        \code{longitude}, and \code{time} (all mandatory) the wind components
+        U, V, and W from an ECMWF \emph{netCDF} data file.
+        \fcode{
+        ECMWF_wind_file file
+        }
+        The data nearest to the specified \code{time} will be selected (or
+        linearly interpolated, if \code{time_interpolate} is switched on).
+                ''',
+
+                'satellite_geometry' : r'''
+        With this option the satellite geometry is determinded. The argument for this option
+        \fcode{
+        satellite_geometry  netCDF_file
+        }
+        is the location of a \code{netCDF_file}, which must contain latitude and longitude position
+        as well as zenith and azimuth viewing angle for each pixel.
+
+        %ak20100306 What is below does not belong in the general Users Guide yet.
+        %For format specification see the example file data/satellite/MSG\_seviri/MSG\_seviri\_geometry.nc.
+        %This option has to be used in combination with \code{satellite_pixel}.
+        %You can also use the abbreviation
+        %\code{satellite_geometry MSG}
+        %for MSG simulation, \emph{but in order to use this, you have to copy the netCDF file}
+        %\fcode{
+        %cp -r /data/A3/satellite_geometry/satellites libRadtran/data/
+        %}
+        %\emph{which is not in cvs version, as it is too large.}
+                ''',
+
+                'satellite_pixel' : r'''
+        This option specifies which pixel of the satellite image that should be simulated.
+        \fcode{
+        satellite_pixel  pixel_x pixel_y
+        }
+        The arguments \code{pixel_nr_x} and \code{pixel_nr_y} specifies the pixel position in the native
+        system of the satellite, which is determinded by the option \code{satellite_geometry}.
+                ''',
+
+                'surface_temperature_map' : r'''
+        Specify a surface\_temperature map with a \emph{netCDF} file which is used in combinition
+        with the options \code{latitude}, \code{longitude}, and \code{time}.
+        \fcode{
+        surface_temperature_map file [variable_name]
+        }
+        where \code{file} is the location of the \emph{netCDF} file.
+        \code{libRadtran} reads the value at the nearest pixel to the given \code{latitude} and
+        \code{longitude}. No spatial interpolation or averaging of the values is done.
+                ''',
+
+                'surface_type_map' : r'''
+        Specify a surface type map, which is used in combinition with
+        \code{albedo_library}, \code{latitude}, and \code{longitude} in order to
+        select the surface type relevant for the simulation.
+        No pixel interpolation is done.
+        The format of the call is:
+        \fcode{
+        surface_type_map file [variable_name]
+        }
+        where \code{file} is the location of the surface type map file. The map is expected to
+        be in \emph{netCDF} format. The file must contain the variables \code{double lat(nlat)},
+        \code{double lon(nlon)}, and \code{byte brdf_rpv_type (nlat, nlon)}. If the name of the
+        surface type variable is different, the optional argument can be used in order to specify
+        the variable name. For format specification see also
+        \file{data/albedo/IGBP_map/SURFACE_TYPE_IGBP_10min.cdf}.
+
+        For using the IGBP map, the call is \code{surface_type_map IGBP}. This map has a resolution of 10
+        minutes and contains the surface types 1 to 18 defined in the \code{albedo_library IGBP}.
+        Fresh snow and sea ice are not included, as their extent is too variable. Attention:
+        That implies e.g. that the Arctic is considered ocean\_water and not sea\_ice!
+
+        Locations on the pixel boundaries are interpreted as the pixel northward and
+        eastward respectively. E.g. location 0 N, 0 E is interpreted like the pixel ranging from
+        0 to 10min North and from 0 to 10min East.
+                ''',
 }
diff --git a/src_py/spectral_options.py b/src_py/spectral_options.py
index 43b9e6f..7d19ac4 100644
--- a/src_py/spectral_options.py
+++ b/src_py/spectral_options.py
@@ -1,29 +1,29 @@
 
 """--------------------------------------------------------------------
  * $Id$
- * 
+ *
  * This file is part of libRadtran.
  * Copyright (c) 1997-2012 by Arve Kylling, Bernhard Mayer,
  *                            Claudia Emde, Robert Buras
  *
  * ######### Contact info: http://www.libradtran.org #########
  *
- * This program is free software; you can redistribute it and/or 
- * modify it under the terms of the GNU General Public License   
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.        
- * 
- * This program is distributed in the hope that it will be useful, 
- * but WITHOUT ANY WARRANTY; without even the implied warranty of  
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the   
- * GNU General Public License for more details.                    
- * 
- * You should have received a copy of the GNU General Public License          
- * along with this program; if not, write to the Free Software                
- * Foundation, Inc., 59 Temple Place - Suite 330, 
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
  * Boston, MA 02111-1307, USA.
  *--------------------------------------------------------------------"""
-
+import io
 from option_definition import *
 
 class setup_spectral_group():
@@ -66,7 +66,7 @@ class setup_spectral_group():
 			helpstr='Location of file with wavelength grid used for the internal transmittance calculations.',
 			documentation=documentation['wavelength_grid_file'],
 			gui_inputs=(FileInput(name='Input.filename[FN_WLTRANS]'),),
-			tokens=addToken(name='Input.filename[FN_WLTRANS]', datatype=file),
+			tokens=addToken(name='Input.filename[FN_WLTRANS]', datatype=io.IOBase),
 			parents=['uvspec'],
 			non_parents=['thermal_bands_file'],
 		)
@@ -77,7 +77,7 @@ class setup_spectral_group():
 			helpstr='File with the center wavelengths and the wavelength band intervals for calculations in the thermal range.',
 			documentation=documentation['thermal_bands_file'],
 			gui_inputs=(FileInput(name='Input.filename[FN_WLBANDS]'),),
-			tokens=addToken(name='Input.filename[FN_WLBANDS]', datatype=file),
+			tokens=addToken(name='Input.filename[FN_WLBANDS]', datatype=io.IOBase),
 			parents=['uvspec'],
 			non_parents=['filter_function_file','slit_function_file'],
 		)
@@ -95,15 +95,15 @@ class setup_spectral_group():
 		source = option(
 			name='source',
 			group='spectral',
-			helpstr='Source of radiation.', 
-			documentation=documentation['source'], 
+			helpstr='Source of radiation.',
+			documentation=documentation['source'],
 			gui_inputs=(ListInput(name='Input.source', valid_range=['thermal', 'solar']),
 				    FileInput(name='Input.filename[FN_EXTRATERRESTRIAL]', optional=True),
 				    ListInput(name='Input.spectrum_unit', valid_range=['','per_nm', 'per_cm-1', 'per_band'], optional=True),),
 			tokens= [addLogical(name='Input.source', logicals=['thermal', 'solar'], setting='SRC_'),
-				 addToken(name='Input.filename[FN_EXTRATERRESTRIAL]', datatype=file, optional=True),
-				 addLogical(name='Input.spectrum_unit', logicals=['per_nm', 'per_cm-1', 'per_band'], setting='UNIT_', optional=True ) ], 
-			parents=['uvspec'], 
+				 addToken(name='Input.filename[FN_EXTRATERRESTRIAL]', datatype=io.IOBase, optional=True),
+				 addLogical(name='Input.spectrum_unit', logicals=['per_nm', 'per_cm-1', 'per_band'], setting='UNIT_', optional=True ) ],
+			parents=['uvspec'],
 			plot = {'plot_type': '2D',
 				'optional_args': {'column_names': (
 						"wavelength",
@@ -141,7 +141,7 @@ class setup_spectral_group():
 			group='spectral',
 			helpstr='File containing positions, looking directions, and opening angles of lasers and detectors for lidar simulations in MYSTIC.',
 			documentation=documentation['mc_lidar_file'],
-			tokens=addToken(name='Input.rte.mc.filename[FN_MC_LIDAR]',datatype=file),
+			tokens=addToken(name='Input.rte.mc.filename[FN_MC_LIDAR]',datatype=io.IOBase),
 			parents=['uvspec'],
 			non_parents=['source'],
 			showInGui=False,
@@ -164,8 +164,8 @@ class setup_spectral_group():
 
 		self.options = [wavelength, wavelength_index, wavelength_grid_file,
 				thermal_bands_file, thermal_bandwidth,
-				source, 
-				mc_lidar, mc_lidar_file, mc_radar, 
+				source,
+				mc_lidar, mc_lidar_file, mc_radar,
 				mc_sun_angular_size, ]
 
 	def __iter__(self):
@@ -175,7 +175,7 @@ def get_spectral_documentation():
 	return {
 		'mc_sun_angular_size' : r'''
 	At the moment only useful together with \code{mc_panorama_view}.
-	Set the angular radius of the sun in degrees. If omitted the radius is calculated 
+	Set the angular radius of the sun in degrees. If omitted the radius is calculated
 	(more or less correctly) via the earth-sun distance (not well tested).
 	If no \code{mc_backward_sun_shape_file} is given a spectral sun shape according to
 	Koepke2001 is used.
@@ -188,11 +188,11 @@ def get_spectral_documentation():
 		''',
 
 		'mc_lidar_file' : r'''
-	File containing positions, looking directions, and opening angles of 
-	lasers and detectors for lidar simulations in MYSTIC.  Only meaningful 
-	with \code{mc_lidar}. 
-	\fcode{ 
-	mc_lidar_file file 
+	File containing positions, looking directions, and opening angles of
+	lasers and detectors for lidar simulations in MYSTIC.  Only meaningful
+	with \code{mc_lidar}.
+	\fcode{
+	mc_lidar_file file
 	}
 		''',
 
@@ -206,18 +206,18 @@ def get_spectral_documentation():
 		'source' : r'''
 	Set the radiation source type
 	\fcode{
-	source  type 
+	source  type
 	}
 	where \code{type} is either \code{solar} or \code{thermal}.
-	Solar radiation is per default output in W/(m2 nm) if no \code{mol\_abs\_param} is specified 
+	Solar radiation is per default output in W/(m2 nm) if no \code{mol\_abs\_param} is specified
         or \code{mol\_abs\_param} options \code{crs}, \code{lowtran}, or \code{reptran} are specified.
         For all other \code{mol\_abs\_param} options
 	the output is integrated over the wavelength band.
-	Thermal radiation is per default output in W/(m2 cm-1), if REPTRAN is used or the bandwidth 
-	is equal to 1 cm-1 (default for \code{mol\_abs\_param lowtran}). 
+	Thermal radiation is per default output in W/(m2 cm-1), if REPTRAN is used or the bandwidth
+	is equal to 1 cm-1 (default for \code{mol\_abs\_param lowtran}).
 	Otherwise the output is the integrated flux over the
 	wavenumber interval specified by \code{thermal\_bandwidth}, \code{thermal\_bands\_file},
-	or by the \code{mol\_abs\_param} option (\code{kato}, \code{kato2}, \code{kato2.96}, 
+	or by the \code{mol\_abs\_param} option (\code{kato}, \code{kato2}, \code{kato2.96},
 	\code{fu}, or \code{avhrr\_kratz}).
 	\fcode{
 	source type [file] [unit]
@@ -226,19 +226,19 @@ def get_spectral_documentation():
         In general, \code{file} is required for solar calculations if \code{mol\_abs\_param} is not used.
 	\code{file} is ignored if \code{mol\_abs\_param} other than \code{lowtran} oder \code{reptran} is specified.
 
-	The file must contain two columns. Column 1 is the wavelength in nm, and column 2 
+	The file must contain two columns. Column 1 is the wavelength in nm, and column 2
 	the corresponding extraterrestrial flux. The user may freely use any units
 	he/she wants for the extraterrestrial flux. The wavelength  specified grid
-	defines the wavelength resolution at which results are returned. However, 
-	the wavelength range is determined by \code{wavelength}. \code{file} may be 
-	omitted for thermal radiation calculations (\code{source thermal}) as well as 
-	\code{output_quantity transmittance} and \code{output_quantity reflectivity} calculations. If omitted, the 
-	output resolution equals the internal wavelength grid which the model chooses 
+	defines the wavelength resolution at which results are returned. However,
+	the wavelength range is determined by \code{wavelength}. \code{file} may be
+	omitted for thermal radiation calculations (\code{source thermal}) as well as
+	\code{output_quantity transmittance} and \code{output_quantity reflectivity} calculations. If omitted, the
+	output resolution equals the internal wavelength grid which the model chooses
 	for the radiative transfer calculation.
 	Comments start with \code{\#}. Empty lines are ignored.
 
 	For some purposes it is useful to tell libRadtran the units of the spectrum.
-	This can be done with the optional third argument. 
+	This can be done with the optional third argument.
 	Possible choises for \code{unit} are \code{per\_nm}, \code{per\_cm-1} or \code{per\_band}.
 	If \code{unit} is set to \code{per\_nm}
 	libRadtran assumes that the unit of the spectrum is W/(m2 nm), if set to \code{per\_cm-1}
@@ -246,34 +246,34 @@ def get_spectral_documentation():
 
 		''',
 		'thermal_bandwidth' : r'''
-	Specify a constant bandwidth in cm-1 for thermal calculations. 
+	Specify a constant bandwidth in cm-1 for thermal calculations.
 	\fcode{
 	thermal\_bandwidth value
 	}
 	The default is 1 cm-1.
 	This option is ignored if used together with \code{mol\_abs\_param kato/kato2/kato2.96/fu/avhrr\_kratz}.
-			''',				
+			''',
 
 		'thermal_bands_file' : r'''
-	File with the center wavelengths and the wavelength band intervals to be used for 
-	calculations in the thermal range. 
+	File with the center wavelengths and the wavelength band intervals to be used for
+	calculations in the thermal range.
 	\fcode{
 	thermal\_bands\_file file
 	}
 	The following three columns are expected:
 	center (or reference) wavelength, lower wavelength limit, upper wavelength limit [nm].
-	\code{thermal\_bands\_file} defines the wavelength grid for the radiative transfer 
-	calculation. The RTE solver is called for each of the wavelengths in the first column. 
-	The atmospheric (scattering, absorption, etc) properties are also evaluated at these 
-	wavelengths. For thermal radiation calculations, the Planck function is integrated 
+	\code{thermal\_bands\_file} defines the wavelength grid for the radiative transfer
+	calculation. The RTE solver is called for each of the wavelengths in the first column.
+	The atmospheric (scattering, absorption, etc) properties are also evaluated at these
+	wavelengths. For thermal radiation calculations, the Planck function is integrated
 	over the wavelength bands defined in the second and third columns. The result will
-	therefore be a band-integrated irradiance which does only make sense when the 
+	therefore be a band-integrated irradiance which does only make sense when the
 	\code{source solar file} grid equals the \code{thermal\_bands\_file} grid.
 				''',
 
 		'wavelength_grid_file' : r'''
-	Location of single column file that sets the wavelength grid used for the 
-	internal transmittance calculations. 
+	Location of single column file that sets the wavelength grid used for the
+	internal transmittance calculations.
 	\fcode{
 	wavelength\_grid\_file file
 	}
@@ -283,23 +283,23 @@ def get_spectral_documentation():
 				''',
 
 		'wavelength' : r'''
-	Set the wavelength range by specifying first and last wavelength in nm. 
+	Set the wavelength range by specifying first and last wavelength in nm.
 	\fcode{
 	wavelength lambda\_0 lambda\_1
 	}
-	The default output wavelength grid is that defined in \code{source solar file}, 
-	unless \code{spline} is specified. Note that the radiative transfer calculations 
+	The default output wavelength grid is that defined in \code{source solar file},
+	unless \code{spline} is specified. Note that the radiative transfer calculations
 	are done on an internal grid which can be influenced with \code{wavelength\_grid\_file}
 	or \code{mol\_tau\_file abs file}
 				''',
 
 		'wavelength_index' : r'''
 	Set the wavelengths to be selected. To be used together with predefined wavelength grids,
-	such as \code{wavelength\_grid\_file}, \code{mol\_tau\_file abs file} and particularly 
-	useful in combination with the \code{mol\_abs\_param} option where often only a 
+	such as \code{wavelength\_grid\_file}, \code{mol\_tau\_file abs file} and particularly
+	useful in combination with the \code{mol\_abs\_param} option where often only a
 	specified number of wavelength bands is required. E.g., in combination with
 	\code{mol\_abs\_param AVHRR\_KRATZ}, \code{wavelength\_index 15 15} will select wavelength
-	index 15 which corresponds to channel 4, or \code{wavelength\_index 10 14} will select 
+	index 15 which corresponds to channel 4, or \code{wavelength\_index 10 14} will select
 	those bands required for channel 3. Indices start from 1.
 				''',
 		}
diff --git a/src_py/surface_options.py b/src_py/surface_options.py
index d2d4619..386d850 100644
--- a/src_py/surface_options.py
+++ b/src_py/surface_options.py
@@ -1,30 +1,30 @@
 
 """--------------------------------------------------------------------
  * $Id$
- * 
+ *
  * This file is part of libRadtran.
  * Copyright (c) 1997-2012 by Arve Kylling, Bernhard Mayer,
  *                            Claudia Emde, Robert Buras
  *
  * ######### Contact info: http://www.libradtran.org #########
  *
- * This program is free software; you can redistribute it and/or 
- * modify it under the terms of the GNU General Public License   
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.        
- * 
- * This program is distributed in the hope that it will be useful, 
- * but WITHOUT ANY WARRANTY; without even the implied warranty of  
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the   
- * GNU General Public License for more details.                    
- * 
- * You should have received a copy of the GNU General Public License          
- * along with this program; if not, write to the Free Software                
- * Foundation, Inc., 59 Temple Place - Suite 330, 
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
  * Boston, MA 02111-1307, USA.
  *--------------------------------------------------------------------"""
 
-
+import io
 from option_definition import *
 
 class setup_surface_group():
@@ -37,7 +37,7 @@ class setup_surface_group():
         brdf_non_parents=['albedo','albedo_file','albedo_library',
                             'brdf_rossli', 'brdf_rossli_file', 'brdf_rossli_hotspot',
                             'brdf_ambrals', 'brdf_ambrals_file', 'brdf_ambrals_hotspot',
-                            'brdf_cam', 'brdf_cam_solar_wind', 'cox_and_munk_u10_map', 
+                            'brdf_cam', 'brdf_cam_solar_wind', 'cox_and_munk_u10_map',
                             'brdf_rpv_file', 'brdf_rpv', 'brdf_rpv_library','brdf_rpv_type',
                             'brdf_hapke', 'brdf_hapke_file',
                             'mc_albedo_file', 'mc_albedo_spectral_file', 'mc_albedo_type',
@@ -52,24 +52,24 @@ class setup_surface_group():
             name='altitude',
             group='surface',
             helpstr='Set the bottom level atmosphere provided in atmosphere_file to be at the given altitude.',
-            documentation=documentation['altitude'], 
+            documentation=documentation['altitude'],
             gui_inputs=(FloatInput(name='Input.alt.altitude', default='NOT_DEFINED_FLOAT', valid_range=[-1000000.0, 1000000.0]), FloatInput(name='Input.alt.altitude_dz', valid_range=[0, 1000000.0], optional=True),),
-            tokens = [ addSetting(name='Input.alt.source',setting='ALT_DIRECT_INPUT', default='ALT_NOT_DEFINED'), 
+            tokens = [ addSetting(name='Input.alt.source',setting='ALT_DIRECT_INPUT', default='ALT_NOT_DEFINED'),
                 addToken(name='Input.alt.altitude',datatype=float, default='NOT_DEFINED_FLOAT', valid_range=[-1e6,1e6]),
                 addToken(name='Input.alt.altitude_dz', datatype=float, default=0.0, valid_range=[0,1e6], optional=True ) ],
-            parents=['uvspec'], 
+            parents=['uvspec'],
         )
 
-        
-        
+
+
         mc_elevation_file = option(
-            name='mc_elevation_file', 
+            name='mc_elevation_file',
             group='surface',
-            helpstr='Define a MYSTIC 2D elevation input file.', 
-            documentation=documentation['mc_elevation_file'], 
+            helpstr='Define a MYSTIC 2D elevation input file.',
+            documentation=documentation['mc_elevation_file'],
             gui_inputs=(FileInput(name='Input.rte.mc.filename[FN_MC_ELEVATION]'),),
-            tokens=addToken(name='Input.rte.mc.filename[FN_MC_ELEVATION]',datatype=file),
-            parents=['uvspec'], 
+            tokens=addToken(name='Input.rte.mc.filename[FN_MC_ELEVATION]',datatype=io.IOBase),
+            parents=['uvspec'],
             speaker='rte_solver',
             enable_values=("mystic","montecarlo"),
             threedmystic =True
@@ -79,11 +79,11 @@ class setup_surface_group():
             name='albedo',
             group='surface',
             helpstr='Lambertian surface albedo',
-            documentation=documentation['albedo'], 
+            documentation=documentation['albedo'],
             gui_inputs=(FloatInput(name='Input.alb.albedo', default=0.0, valid_range=[0, 1]),),
             tokens = [ addToken(name='Input.alb.albedo', datatype=float, default=0.0, valid_range=[0,1]),
-                addSetting(name='Input.alb.source', setting='ALBEDO_CONSTANT', default='NOT_DEFINED_INTEGER') ], 
-            parents=['uvspec'], 
+                addSetting(name='Input.alb.source', setting='ALBEDO_CONSTANT', default='NOT_DEFINED_INTEGER') ],
+            parents=['uvspec'],
             non_parents=brdf_non_parents,
         )
 
@@ -91,14 +91,14 @@ class setup_surface_group():
             name='albedo_file',
             group='surface',
             helpstr='Location of surface albedo file for wavelength dependent surface albedo.',
-            documentation=documentation['albedo_file'], 
+            documentation=documentation['albedo_file'],
             gui_inputs=(FileInput(name='Input.filename[FN_ALBEDO]'),),
-            tokens = [ addToken(name='Input.filename[FN_ALBEDO]', datatype=file), 
-                addSetting(name='Input.alb.source', setting='ALBEDO_FROM_ALBEDO_FILE', default='NOT_DEFINED_INTEGER'), 
-                addSetting(name='Input.alb.surf_type_map', setting=False, default=False), 
+            tokens = [ addToken(name='Input.filename[FN_ALBEDO]', datatype=io.IOBase),
+                addSetting(name='Input.alb.source', setting='ALBEDO_FROM_ALBEDO_FILE', default='NOT_DEFINED_INTEGER'),
+                addSetting(name='Input.alb.surf_type_map', setting=False, default=False),
                 addSetting(name='Input.alb.albedo', setting=-1.0, default=0.0) ],
-            parents=['uvspec'],  
-            non_parents=brdf_non_parents, 
+            parents=['uvspec'],
+            non_parents=brdf_non_parents,
             plot = {'plot_type': '2D',
                 'optional_args': {'column_names': (
                         "wavelength",
@@ -111,12 +111,12 @@ class setup_surface_group():
             name='brdf_cam',
             group='surface',
             helpstr='',
-            documentation=documentation['brdf_cam'], 
+            documentation=documentation['brdf_cam'],
             gui_inputs=( ListInput(name='id',valid_range=['pcl','sal','u10','uphi']),
                 FloatInput(name='Input.cm.cam[id]', default='NOT_DEFINED_FLOAT', valid_range=[0, 1e6]),),
             tokens = [ addLogical(name='id',logicals=['pcl','sal','u10','uphi'],setting='BRDF_CAM_'),
                 addToken(name='Input.cm.param[id]', datatype=float, valid_range=[0,1e6]),
-                addSetting(name='Input.disort2_brdf', setting='BRDF_CAM', default='BRDF_NONE') ], 
+                addSetting(name='Input.disort2_brdf', setting='BRDF_CAM', default='BRDF_NONE') ],
             parents=['uvspec'],
             non_parents=brdf_non_parents,
                         non_parent_exceptions=['brdf_cam', 'brdf_cam_solar_wind', 'cox_and_munk_u10_map', 'mc_rossli_file', 'mc_ambrals_file'],
@@ -124,13 +124,13 @@ class setup_surface_group():
             enable_values=("disort","mystic"),
             non_unique=True,
         )
-        
+
         brdf_cam_solar_wind = option(
             name='brdf_cam_solar_wind',
             group='surface',
             helpstr='Wind azimuth identical to the incoming photon azimuth.',
             documentation=documentation['brdf_cam_solar_wind'],
-            tokens=[ addSetting(name='Input.disort2_brdf', setting='BRDF_CAM', default='BRDF_NONE'), 
+            tokens=[ addSetting(name='Input.disort2_brdf', setting='BRDF_CAM', default='BRDF_NONE'),
                     addSetting(name='Input.cm.solar_wind', setting=1, default=0) ],
             parents=['uvspec'],
             non_parents=brdf_non_parents,
@@ -138,16 +138,16 @@ class setup_surface_group():
             speaker='rte_solver',
             enable_values=("mystic",)
         )
-        
+
         brdf_hapke = option(
             name='brdf_hapke',
             group='surface',
             helpstr='Constant parameters for Hapke BRDF.',
-            documentation=documentation['brdf_hapke'], 
+            documentation=documentation['brdf_hapke'],
             gui_inputs=(ListInput(name='id',valid_range=['b0','h', 'w']), FloatInput(name='Input.hapke.hapke[id]'),),
-            tokens= [addLogical( name='id', logicals=['b0','h', 'w'], setting='BRDF_HAPKE_'), 
+            tokens= [addLogical( name='id', logicals=['b0','h', 'w'], setting='BRDF_HAPKE_'),
                 addToken(name='Input.hapke.hapke[id]', datatype=float) ],
-            parents=['uvspec'], 
+            parents=['uvspec'],
             non_parents=brdf_non_parents,
             non_unique=True,
         )
@@ -155,12 +155,12 @@ class setup_surface_group():
         brdf_hapke_file = option(
             name='brdf_hapke_file',
             group='surface',
-            helpstr='File containing the Hapke BDRF parameterization.', 
-            documentation=documentation['brdf_hapke_file'], 
+            helpstr='File containing the Hapke BDRF parameterization.',
+            documentation=documentation['brdf_hapke_file'],
             gui_inputs=(FileInput(name='Input.filename[FN_HAPKE]'),),
-            tokens = [ addToken(name='Input.filename[FN_HAPKE]', datatype=file), 
-                addSetting(name='Input.hapke.source', setting='HAPKE_FROM_HAPKE_FILE', default='HAPKE_CONSTANT') ], 
-            parents=['uvspec'], 
+            tokens = [ addToken(name='Input.filename[FN_HAPKE]', datatype=io.IOBase),
+                addSetting(name='Input.hapke.source', setting='HAPKE_FROM_HAPKE_FILE', default='HAPKE_CONSTANT') ],
+            parents=['uvspec'],
             non_parents=brdf_non_parents,
         )
 
@@ -171,9 +171,9 @@ class setup_surface_group():
             documentation=documentation['brdf_rossli'],
             gui_inputs=(ListInput(name='id', valid_range=['iso','vol','geo']), FloatInput(name='Input.rossli.rossli[id]'), ),
             tokens=[ addLogical(name='id', logicals=['iso','vol','geo'], setting='BRDF_ROSSLI_'),
-                addToken(name='Input.rossli.rossli[id]', datatype=float) ], 
+                addToken(name='Input.rossli.rossli[id]', datatype=float) ],
             parents=['uvspec'],
-            non_parents=brdf_non_parents, 
+            non_parents=brdf_non_parents,
                         non_parent_exceptions=['brdf_rossli_hotspot'],
             non_unique=True,
             showInGui = False,
@@ -181,13 +181,13 @@ class setup_surface_group():
         )
 
         brdf_rossli_hotspot = option(
-            name='brdf_rossli_hotspot', 
+            name='brdf_rossli_hotspot',
             group='surface',
-            helpstr='Turn on hot spot correction factor in Ross-Li BRDF.', 
-            documentation=documentation['brdf_rossli_hotspot'], 
+            helpstr='Turn on hot spot correction factor in Ross-Li BRDF.',
+            documentation=documentation['brdf_rossli_hotspot'],
             tokens=addSetting(name='Input.rossli.hotspot', setting='BRDF_ROSSLI_HOTSPOT_ON', default='BRDF_ROSSLI_HOTSPOT_OFF'),
             parents=['uvspec'],
-            non_parents=brdf_non_parents, 
+            non_parents=brdf_non_parents,
                         non_parent_exceptions=['brdf_rossli'],
             showInGui = False,
                         developer = True
@@ -197,12 +197,12 @@ class setup_surface_group():
         brdf_rossli_file = option(
             name='brdf_rossli_file',
             group='surface',
-            helpstr='File containing the Ross-Li BDRF parameterization.', 
-            documentation=documentation['brdf_rossli_file'], 
+            helpstr='File containing the Ross-Li BDRF parameterization.',
+            documentation=documentation['brdf_rossli_file'],
             gui_inputs=(FileInput(name='Input.filename[FN_ROSSLI]'),),
-            tokens = [ addToken(name='Input.filename[FN_ROSSLI]', datatype=file), 
-                addSetting(name='Input.rossli.source', setting='ROSSLI_FROM_ROSSLI_FILE', default='ROSSLI_CONSTANT') ], 
-            parents=['uvspec'], 
+            tokens = [ addToken(name='Input.filename[FN_ROSSLI]', datatype=io.IOBase),
+                addSetting(name='Input.rossli.source', setting='ROSSLI_FROM_ROSSLI_FILE', default='ROSSLI_CONSTANT') ],
+            parents=['uvspec'],
             non_parents=brdf_non_parents,
                         non_parent_exceptions=['brdf_rossli_hotspot'],
             showInGui = False,
@@ -217,21 +217,21 @@ class setup_surface_group():
             gui_inputs=(ListInput(name='id', valid_range=['iso','vol','geo']), FloatInput(name='Input.rossli.rossli[id]'), ),
             tokens=[ addSetting(name='Input.rossli.source', setting='ROSSLI_AMBRALS_CONSTANT', default='ROSSLI_CONSTANT'),
                                 addLogical(name='id', logicals=['iso','vol','geo'], setting='BRDF_ROSSLI_'),
-                addToken(name='Input.rossli.rossli[id]', datatype=float) ], 
+                addToken(name='Input.rossli.rossli[id]', datatype=float) ],
             parents=['uvspec'],
-            non_parents=brdf_non_parents, 
+            non_parents=brdf_non_parents,
                         non_parent_exceptions=['brdf_ambrals_hotspot'],
             non_unique=True,
         )
 
         brdf_ambrals_hotspot = option(
-            name='brdf_ambrals_hotspot', 
+            name='brdf_ambrals_hotspot',
             group='surface',
-            helpstr='Turn on hot spot correction factor in Ross-Li BRDF.', 
-            documentation=documentation['brdf_ambrals_hotspot'], 
+            helpstr='Turn on hot spot correction factor in Ross-Li BRDF.',
+            documentation=documentation['brdf_ambrals_hotspot'],
             tokens=addSetting(name='Input.rossli.hotspot', setting='BRDF_ROSSLI_HOTSPOT_ON', default='BRDF_ROSSLI_HOTSPOT_OFF'),
             parents=['uvspec'],
-            non_parents=brdf_non_parents, 
+            non_parents=brdf_non_parents,
                         non_parent_exceptions=['brdf_ambrals'],
             )
 
@@ -239,12 +239,12 @@ class setup_surface_group():
         brdf_ambrals_file = option(
             name='brdf_ambrals_file',
             group='surface',
-            helpstr='File containing the Ross-Li BDRF parameterization.', 
-            documentation=documentation['brdf_ambrals_file'], 
+            helpstr='File containing the Ross-Li BDRF parameterization.',
+            documentation=documentation['brdf_ambrals_file'],
             gui_inputs=(FileInput(name='Input.filename[FN_ROSSLI]'),),
-            tokens = [ addToken(name='Input.filename[FN_ROSSLI]', datatype=file), 
-                addSetting(name='Input.rossli.source', setting='ROSSLI_FROM_AMBRALS_FILE', default='ROSSLI_CONSTANT') ], 
-            parents=['uvspec'], 
+            tokens = [ addToken(name='Input.filename[FN_ROSSLI]', datatype=io.IOBase),
+                addSetting(name='Input.rossli.source', setting='ROSSLI_FROM_AMBRALS_FILE', default='ROSSLI_CONSTANT') ],
+            parents=['uvspec'],
             non_parents=brdf_non_parents,
                         non_parent_exceptions=['brdf_ambrals_hotspot'],
         )
@@ -253,11 +253,11 @@ class setup_surface_group():
             name='fluorescence',
             group='surface',
             helpstr='Bottom surface isotropic fluorescence source.',
-            documentation=documentation['fluorescence'], 
+            documentation=documentation['fluorescence'],
             gui_inputs=(FloatInput(name='Input.flu.fluorescence'),),
             tokens = [ addToken(name='Input.flu.fluorescence', datatype=float, default=0.0),
-                addSetting(name='Input.flu.source', setting='FLUORESCENCE_CONSTANT', default='NOT_DEFINED_INTEGER') ], 
-            parents=['uvspec'], 
+                addSetting(name='Input.flu.source', setting='FLUORESCENCE_CONSTANT', default='NOT_DEFINED_INTEGER') ],
+            parents=['uvspec'],
             non_parents=['fluorescence_file'],
         )
 
@@ -265,12 +265,12 @@ class setup_surface_group():
             name='fluorescence_file',
             group='surface',
             helpstr='Bottom surface isotropic fluorescence source file, wavelength dependent.',
-            documentation=documentation['fluorescence_file'], 
+            documentation=documentation['fluorescence_file'],
             gui_inputs=(FileInput(name='Input.filename[FN_FLUORESCENCE]'),),
-            tokens = [ addToken(name='Input.filename[FN_FLUORESCENCE]', datatype=file), 
+            tokens = [ addToken(name='Input.filename[FN_FLUORESCENCE]', datatype=io.IOBase),
                 addSetting(name='Input.flu.source', setting='FLUORESCENCE_FROM_FLUORESCENCE_FILE', default='NOT_DEFINED_INTEGER') ],
-            parents=['uvspec'],  
-            non_parents=['fluorescence'], 
+            parents=['uvspec'],
+            non_parents=['fluorescence'],
             plot = {'plot_type': '2D',
                 'optional_args': {'column_names': (
                         "wavelength",
@@ -282,25 +282,25 @@ class setup_surface_group():
         brdf_rpv_file = option(
             name='brdf_rpv_file',
             group='surface',
-            helpstr='File containing the RPV BDRF parameterization.', 
-            documentation=documentation['brdf_rpv_file'], 
+            helpstr='File containing the RPV BDRF parameterization.',
+            documentation=documentation['brdf_rpv_file'],
             gui_inputs=(FileInput(name='Input.filename[FN_RPV]'),),
-            tokens = [ addToken(name='Input.filename[FN_RPV]', datatype=file), 
-                addSetting(name='Input.rpv.source', setting='RPV_FROM_RPV_FILE', default='RPV_CONSTANT') ], 
-            parents=['uvspec'], 
+            tokens = [ addToken(name='Input.filename[FN_RPV]', datatype=io.IOBase),
+                addSetting(name='Input.rpv.source', setting='RPV_FROM_RPV_FILE', default='RPV_CONSTANT') ],
+            parents=['uvspec'],
             non_parents=brdf_non_parents,
                         non_parent_exceptions=['brdf_rpv_file', 'brdf_rpv', 'brdf_rpv_library'],
         )
-        
+
         brdf_rpv = option(
             name='brdf_rpv',
             group='surface',
             helpstr='Constant RPV parameters.',
-            documentation=documentation['brdf_rpv'], 
+            documentation=documentation['brdf_rpv'],
             gui_inputs=(ListInput(name='id',valid_range=['k','rho0', 'theta', 'sigma', 't1', 't2', 'scale']), FloatInput(name='Input.rpv.rpv[id]'),),
-            tokens= [addLogical( name='id', logicals=['k','rho0', 'theta', 'sigma', 't1', 't2', 'scale'], setting='BRDF_RPV_'), 
+            tokens= [addLogical( name='id', logicals=['k','rho0', 'theta', 'sigma', 't1', 't2', 'scale'], setting='BRDF_RPV_'),
                 addToken(name='Input.rpv.rpv[id]', datatype=float) ],
-            parents=['uvspec'], 
+            parents=['uvspec'],
             non_parents=brdf_non_parents,
                         non_parent_exceptions=['brdf_rpv_file', 'brdf_rpv', 'brdf_rpv_library'],
             non_unique=True,
@@ -310,46 +310,46 @@ class setup_surface_group():
         brdf_rpv_library = option(
             name='brdf_rpv_library',
             group='surface',
-            helpstr='Collections of spectral BRDFs of different surface types.', 
-            documentation=documentation['brdf_rpv_library'], 
-            tokens=addToken(name='Input.rpv.library', datatype=str, valid_range=['IGBP', file]), 
-            parents=['uvspec'], 
+            helpstr='Collections of spectral BRDFs of different surface types.',
+            documentation=documentation['brdf_rpv_library'],
+            tokens=addToken(name='Input.rpv.library', datatype=str, valid_range=['IGBP', io.IOBase]),
+            parents=['uvspec'],
             non_parents=brdf_non_parents,
                         non_parent_exceptions=['brdf_rpv_file', 'brdf_rpv', 'brdf_rpv_library','brdf_rpv_type'],
             childs=['brdf_rpv_type']
         )
-        
+
         brdf_rpv_type = option(
             name='brdf_rpv_type',
             group='surface',
             helpstr='Select surface type.',
-            documentation=documentation['brdf_rpv_type'], 
+            documentation=documentation['brdf_rpv_type'],
             gui_inputs=(IntegerInput(name='Input.alb.surface', default='NOT_DEFINED_INTEGER', valid_range=[0, 99]),),
-            tokens = [ addToken(name='Input.alb.surface', datatype=int, default='NOT_DEFINED_INTEGER', valid_range=[0,99]), 
-                addSetting(name='Input.alb.surf_type_map', setting=False) ], 
+            tokens = [ addToken(name='Input.alb.surface', datatype=int, default='NOT_DEFINED_INTEGER', valid_range=[0,99]),
+                addSetting(name='Input.alb.surf_type_map', setting=False) ],
             non_parents=brdf_non_parents,
                         non_parent_exceptions=['brdf_rpv_file', 'brdf_rpv', 'brdf_rpv_library','brdf_rpv_type'],
-            parents=['albedo_library','brdf_rpv_library'], 
+            parents=['albedo_library','brdf_rpv_library'],
         )
-        
+
         sur_temperature = option(
-            name='sur_temperature', 
+            name='sur_temperature',
             group='surface',
             helpstr='Surface temperature.',
-            documentation=documentation['sur_temperature'], 
+            documentation=documentation['sur_temperature'],
             gui_inputs=(FloatInput(name='Input.surface_temperature'),),
-            tokens=addToken(name='Input.surface_temperature', datatype=float, default='NOT_DEFINED_FLOAT'), 
-            parents=['uvspec'], 
+            tokens=addToken(name='Input.surface_temperature', datatype=float, default='NOT_DEFINED_FLOAT'),
+            parents=['uvspec'],
         )
 
         sur_temperature_file = option(
             name='sur_temperature_file',
-            group='surface', 
+            group='surface',
             helpstr='Define a MYSTIC 2D temperature input file.',
             documentation=documentation['sur_temperature_file'],
             gui_inputs=(FileInput(name='Input.rte.mc.filename[FN_MC_TEMPERATURE]'),),
-            tokens=addToken( name='Input.rte.mc.filename[FN_MC_TEMPERATURE]', datatype=file ),	
-            parents=['uvspec'], 
+            tokens=addToken( name='Input.rte.mc.filename[FN_MC_TEMPERATURE]', datatype=io.IOBase ),
+            parents=['uvspec'],
             speaker='rte_solver',
             enable_values=("mystic","montecarlo"),
             threedmystic =True
@@ -357,12 +357,12 @@ class setup_surface_group():
 
         mc_albedo_file = option(
             name='mc_albedo_file',
-            group='surface', 
+            group='surface',
             helpstr='Define a MYSTIC 2D albedo input file.',
             documentation=documentation['mc_albedo_file'],
             gui_inputs=(FileInput(name='Input.rte.mc.filename[FN_MC_ALBEDO]'),),
-            tokens=addToken( name='Input.rte.mc.filename[FN_MC_ALBEDO]', datatype=file ),	
-            parents=['uvspec'], 
+            tokens=addToken( name='Input.rte.mc.filename[FN_MC_ALBEDO]', datatype=io.IOBase ),
+            parents=['uvspec'],
             non_parents=brdf_non_parents,
             speaker='rte_solver',
             enable_values=("mystic","montecarlo"),
@@ -371,12 +371,12 @@ class setup_surface_group():
 
         mc_albedo_type = option(
             name='mc_albedo_type',
-            group='surface', 
+            group='surface',
             helpstr='Define a MYSTIC 2D albedo type file.',
             documentation=documentation['mc_albedo_type'],
             gui_inputs=(FileInput(name='Input.rte.mc.filename[FN_MC_ALBEDO_SPECTRAL]'),),
-            tokens=addToken( name='Input.rte.mc.filename[FN_MC_ALBEDO_SPECTRAL]',datatype=file ),	
-            parents=['uvspec'], 
+            tokens=addToken( name='Input.rte.mc.filename[FN_MC_ALBEDO_SPECTRAL]',datatype=io.IOBase ),
+            parents=['uvspec'],
             non_parents=brdf_non_parents,
                         non_parent_exceptions=['mc_albedo_spectral_file'],
             speaker='rte_solver',
@@ -387,12 +387,12 @@ class setup_surface_group():
 
         mc_albedo_spectral_file = option(
             name='mc_albedo_spectral_file',
-            group='surface', 
+            group='surface',
             helpstr='Define a MYSTIC 2D spectral albedo input file.',
             documentation=documentation['mc_albedo_spectral_file'],
             gui_inputs=(FileInput(name='Input.rte.mc.filename[FN_MC_ALBEDO_TYPE]'),),
-            tokens=addToken( name='Input.rte.mc.filename[FN_MC_ALBEDO_TYPE]', datatype=file ),
-            parents=['uvspec'], 
+            tokens=addToken( name='Input.rte.mc.filename[FN_MC_ALBEDO_TYPE]', datatype=io.IOBase ),
+            parents=['uvspec'],
             non_parents=brdf_non_parents,
                         non_parent_exceptions=['mc_albedo_type'],
             speaker='rte_solver',
@@ -405,10 +405,10 @@ class setup_surface_group():
             name='mc_rossli_file',
             group='surface',
             helpstr='Define a MYSTIC 2D Ross-Li BRDF input file.',
-            documentation=documentation['mc_rossli_file'], 
+            documentation=documentation['mc_rossli_file'],
             gui_inputs=(FileInput(name='Input.rte.mc.filename[FN_MC_ROSSLI]'),),
-            tokens=addToken(name='Input.rte.mc.filename[FN_MC_ROSSLI]', datatype=file),	
-            parents=['uvspec'], 
+            tokens=addToken(name='Input.rte.mc.filename[FN_MC_ROSSLI]', datatype=io.IOBase),
+            parents=['uvspec'],
             non_parents=brdf_non_parents,
                         non_parent_exceptions=['brdf_cam', 'brdf_cam_solar_wind', 'cox_and_munk_u10_map'],
             speaker='rte_solver',
@@ -422,10 +422,10 @@ class setup_surface_group():
             name='mc_ambrals_file',
             group='surface',
             helpstr='Define a MYSTIC 2D AMBRALS (Ross-Li) BRDF input file.',
-            documentation=documentation['mc_ambrals_file'], 
+            documentation=documentation['mc_ambrals_file'],
             gui_inputs=(FileInput(name='Input.rte.mc.filename[FN_MC_AMBRALS]'),),
-            tokens=addToken(name='Input.rte.mc.filename[FN_MC_AMBRALS]', datatype=file),	
-            parents=['uvspec'], 
+            tokens=addToken(name='Input.rte.mc.filename[FN_MC_AMBRALS]', datatype=io.IOBase),
+            parents=['uvspec'],
             non_parents=brdf_non_parents,
                         non_parent_exceptions=['brdf_cam', 'brdf_cam_solar_wind', 'cox_and_munk_u10_map'],
             speaker='rte_solver',
@@ -435,12 +435,12 @@ class setup_surface_group():
 
         mc_ambrals_type = option(
             name='mc_ambrals_type',
-            group='surface', 
+            group='surface',
             helpstr='Define a MYSTIC 2D ambrals spectral BRDF type file.',
             documentation=documentation['mc_ambrals_type'],
             gui_inputs=(FileInput(name='Input.rte.mc.filename[FN_MC_AMBRALS_SPECTRAL]'),),
-            tokens=addToken( name='Input.rte.mc.filename[FN_MC_AMBRALS_SPECTRAL]',datatype=file ),	
-            parents=['uvspec'], 
+            tokens=addToken( name='Input.rte.mc.filename[FN_MC_AMBRALS_SPECTRAL]',datatype=io.IOBase ),
+            parents=['uvspec'],
             non_parents=brdf_non_parents,
                         non_parent_exceptions=['mc_ambrals_spectral_file'],
             speaker='rte_solver',
@@ -451,12 +451,12 @@ class setup_surface_group():
 
         mc_ambrals_spectral_file = option(
             name='mc_ambrals_spectral_file',
-            group='surface', 
+            group='surface',
             helpstr='Define a MYSTIC 2D ambrals spectral BRDF input file.',
             documentation=documentation['mc_ambrals_spectral_file'],
             gui_inputs=(FileInput(name='Input.rte.mc.filename[FN_MC_AMBRALS_TYPE]'),),
-            tokens=addToken(name='Input.rte.mc.filename[FN_MC_AMBRALS_TYPE]', datatype=file),
-            parents=['uvspec'], 
+            tokens=addToken(name='Input.rte.mc.filename[FN_MC_AMBRALS_TYPE]', datatype=io.IOBase),
+            parents=['uvspec'],
             non_parents=brdf_non_parents,
                         non_parent_exceptions=['mc_ambrals_type'],
             speaker='rte_solver',
@@ -469,10 +469,10 @@ class setup_surface_group():
             name='mc_rpv_file',
             group='surface',
             helpstr='Define a MYSTIC 2D RPV BRDF input file.',
-            documentation=documentation['mc_rpv_file'], 
+            documentation=documentation['mc_rpv_file'],
             gui_inputs=(FileInput(name='Input.rte.mc.filename[FN_MC_RPV]'),),
-            tokens=addToken(name='Input.rte.mc.filename[FN_MC_RPV]', datatype=file),	
-            parents=['uvspec'], 
+            tokens=addToken(name='Input.rte.mc.filename[FN_MC_RPV]', datatype=io.IOBase),
+            parents=['uvspec'],
             non_parents=brdf_non_parents,
                         non_parent_exceptions=['brdf_cam', 'brdf_cam_solar_wind', 'cox_and_munk_u10_map'],
             speaker='rte_solver',
@@ -482,12 +482,12 @@ class setup_surface_group():
 
         mc_rpv_type = option(
             name='mc_rpv_type',
-            group='surface', 
+            group='surface',
             helpstr='Define a MYSTIC 2D rpv spectral BRDF type file.',
             documentation=documentation['mc_rpv_type'],
             gui_inputs=(FileInput(name='Input.rte.mc.filename[FN_MC_RPV_SPECTRAL]'),),
-            tokens=addToken( name='Input.rte.mc.filename[FN_MC_RPV_SPECTRAL]',datatype=file ),	
-            parents=['uvspec'], 
+            tokens=addToken( name='Input.rte.mc.filename[FN_MC_RPV_SPECTRAL]',datatype=io.IOBase ),
+            parents=['uvspec'],
             non_parents=brdf_non_parents,
                         non_parent_exceptions=['mc_rpv_spectral_file'],
             speaker='rte_solver',
@@ -498,12 +498,12 @@ class setup_surface_group():
 
         mc_rpv_spectral_file = option(
             name='mc_rpv_spectral_file',
-            group='surface', 
+            group='surface',
             helpstr='Define a MYSTIC 2D rpv spectral BRDF input file.',
             documentation=documentation['mc_rpv_spectral_file'],
             gui_inputs=(FileInput(name='Input.rte.mc.filename[FN_MC_RPV2D_TYPE]'),),
-            tokens=addToken( name='Input.rte.mc.filename[FN_MC_RPV2D_TYPE]', datatype=file ),
-            parents=['uvspec'], 
+            tokens=addToken( name='Input.rte.mc.filename[FN_MC_RPV2D_TYPE]', datatype=io.IOBase ),
+            parents=['uvspec'],
             non_parents=brdf_non_parents,
                         non_parent_exceptions=['mc_rpv_type'],
             speaker='rte_solver',
@@ -517,7 +517,7 @@ class setup_surface_group():
             group='surface',
             helpstr='Define a triangular surface for MYSTIC.',
             documentation=documentation['mc_triangular_surface_file'],
-            tokens=addToken( name='Input.rte.mc.filename[FN_MC_TRIANGULAR_SURFACE]', datatype=file ),
+            tokens=addToken( name='Input.rte.mc.filename[FN_MC_TRIANGULAR_SURFACE]', datatype=io.IOBase ),
             parents=['uvspec'],
             non_parents=brdf_non_parents,
             speaker='rte_solver',
@@ -527,12 +527,12 @@ class setup_surface_group():
 
         bpdf_tsang_u10 = option(
             name='bpdf_tsang_u10',
-            group='surface', 
+            group='surface',
             documentation=documentation['bpdf_tsang_u10'],
             gui_inputs=(FloatInput(name='Input.bpdf.u10'),),
             tokens= [ addToken( name='Input.bpdf.u10', datatype=float ),
                 addSetting( name='Input.bpdf.type', setting='BPDF_TSANG' ) ],
-            parents=['uvspec'], 
+            parents=['uvspec'],
             non_parents=brdf_non_parents,
             mystic=True,
         )
@@ -540,23 +540,23 @@ class setup_surface_group():
         self.options = [altitude,
                 mc_elevation_file,
                 albedo, albedo_file, mc_albedo_file,
-                                mc_albedo_spectral_file, mc_albedo_type, 
+                                mc_albedo_spectral_file, mc_albedo_type,
                 brdf_rossli,brdf_rossli_hotspot,
                                 brdf_rossli_file,
-                mc_rossli_file, 
+                mc_rossli_file,
                 brdf_ambrals,brdf_ambrals_hotspot,
                                 brdf_ambrals_file,
-                mc_ambrals_file, 
-                brdf_cam, 
-                brdf_cam_solar_wind, 
+                mc_ambrals_file,
+                brdf_cam,
+                brdf_cam_solar_wind,
                 bpdf_tsang_u10,
-                brdf_rpv_library, 
-                brdf_rpv, brdf_rpv_type, mc_rpv_type, mc_ambrals_type, 
+                brdf_rpv_library,
+                brdf_rpv, brdf_rpv_type, mc_rpv_type, mc_ambrals_type,
                 brdf_hapke, brdf_hapke_file,
                 brdf_rpv_file, mc_rpv_file, mc_rpv_spectral_file,
                 mc_ambrals_spectral_file, mc_triangular_surface_file,
                 fluorescence, fluorescence_file,
-                sur_temperature, sur_temperature_file, 
+                sur_temperature, sur_temperature_file,
                 ]
 
     def __iter__(self):
@@ -594,13 +594,13 @@ def get_surface_documentation():
     to that used internally for the radiative transfer calculation!
         ''',
         'brdf_ambrals' : r'''
-    AMBRALS (Ross-Li) BRDF, a three-parameter BRDF fit for vegetated and 
+    AMBRALS (Ross-Li) BRDF, a three-parameter BRDF fit for vegetated and
     non-vegetated surfaces \citep{roujean1992,wanner97,lucht2000,
         schaaf2002}, based on the RossThickLiSparseReciprocal
         model. The implementation is according to
         \cite{lucht2000}. See also http://www-modis.bu.edu/brdf/models.html.
     \fcode{
-    brdf\_ambrals variable value 
+    brdf\_ambrals variable value
     }
     \code{variable} can be one of the following:
     \begin{description}
@@ -631,12 +631,12 @@ def get_surface_documentation():
     to that used internally for the radiative transfer calculation!
         ''',
         'brdf_rossli' : r'''
-        This is the \cite{Lin2015} implementation of the Ross-Li (AMBRALS) BRDF, see also 
+        This is the \cite{Lin2015} implementation of the Ross-Li (AMBRALS) BRDF, see also
         \code{brdf\_ambrals} BRDF. For unknown reasons, these formulas
         differ in their overall factors of the three terms from the factors in
         \cite{lucht2000}. Identical results can be obtained by using: f\_iso=$\pi$ k\_iso, f\_geo=$\pi$ k\_geo, f\_vol = 4 k\_vol / 3.
     \fcode{
-    brdf\_rossli variable value 
+    brdf\_rossli variable value
     }
     \code{variable} can be one of the following:
     \begin{description}
@@ -673,7 +673,7 @@ def get_surface_documentation():
     \item[sigma] Constant RPV sigma, to be used for snow \citep{Degunther2000b}.
     \item[t1] Constant RPV t1, to be used for snow \citep{Degunther2000b}.
     \item[t2] Constant RPV t2, to be used for snow \citep{Degunther2000b}.
-    \item[scale] Apply a constant scaling factor for the RPV BRDF. 
+    \item[scale] Apply a constant scaling factor for the RPV BRDF.
     Required e.g. if the the albedo should be set to a certain value. This
     factor is only used by \code{rte\_solver disort}, \code{rte\_solver
     fdisort2}\ifmystic{ and \code{rte\_solver mystic}}.
@@ -681,15 +681,15 @@ def get_surface_documentation():
         ''',
 
         'bpdf_tsang_u10' : r'''
-    Wind speed for ocean BPDF (in m/s) at present only available with 
+    Wind speed for ocean BPDF (in m/s) at present only available with
     \code{rte\_solver mystic}.
     \fcode{
     bpdf\_tsang\_u10 value
     }
-    The BPDF model has been developed by \citet{Tsang1985}. 
+    The BPDF model has been developed by \citet{Tsang1985}.
     The wind speed is the most important parameter affecting the ocean reflectance
-    matrix. The BPDF model also takes into account shadowing by surface waves. 
-    The model has been implemented in a FORTRAN routine by Mishchenko 
+    matrix. The BPDF model also takes into account shadowing by surface waves.
+    The model has been implemented in a FORTRAN routine by Mishchenko
     (http://www.giss.nasa.gov/staff/mmishchenko/brf/)
     which has been included into {\sl libRadtran}.
         ''',
@@ -710,7 +710,7 @@ def get_surface_documentation():
         ''',
 
 
-        
+
         'mc_rpv_file' : r'''
     Define a MYSTIC 2D RPV BRDF input file.
     \fcode{
@@ -753,7 +753,7 @@ def get_surface_documentation():
     where Nx and Ny are the number of grid boxes in x- and y-direction,
     dx and dy are the size of the pixels in km.
     In the second and the following lines the indices in x- and y-direction
-    (ix=1...Nx; iy=1...Ny) and the three parameters iso, vol, and geo. 
+    (ix=1...Nx; iy=1...Ny) and the three parameters iso, vol, and geo.
 
     Optionally, it is now possibly to mix Ross-Li with Cox and Munk
     (CaM). To this end, the format of the albedo file is:
@@ -782,7 +782,7 @@ def get_surface_documentation():
     where Nx and Ny are the number of grid boxes in x- and y-direction,
     dx and dy are the size of the pixels in km.
     In the second and the following lines the indices in x- and y-direction
-    (ix=1...Nx; iy=1...Ny) and the albedo of the pixel are specified. 
+    (ix=1...Nx; iy=1...Ny) and the albedo of the pixel are specified.
         ''',
 
         'mc_albedo_spectral_file' : r'''
@@ -800,11 +800,11 @@ def get_surface_documentation():
         ''',
 
         'mc_elevation_file' : r'''
-    Define a MYSTIC 2D elevation input file. 
+    Define a MYSTIC 2D elevation input file.
     \fcode{
     mc\_elevation\_file file
     }
-    The 
+    The
     expected format of the elevation file is:
     \fcode{
     Nx  Ny  dx  dy
@@ -817,35 +817,35 @@ def get_surface_documentation():
     (ix=1...Nx, iy=1...Ny) and the elevation in km of each point are specified.
 
     Attention: While the other files refer to grid boxes,
-    the elevation is defined at grid points. It has to be this 
-    way because each "elevation pixel" contains a surface 
+    the elevation is defined at grid points. It has to be this
+    way because each "elevation pixel" contains a surface
     which is defined by the four cornes of the pixel. If the
-    grid covers an area of 200x200 km$^2$ and the pixel sizes 
-    are dx = 1km and dy = 1km, the elevation has to be defined 
+    grid covers an area of 200x200 km$^2$ and the pixel sizes
+    are dx = 1km and dy = 1km, the elevation has to be defined
     at 201x201 points (ix = 1 .. Nx, iy = 1 .. Ny).
 
-    Also, make sure that the elevation doesn't cross or 
+    Also, make sure that the elevation doesn't cross or
     even touch the 1D surface. Since the default altitude is 0
     that means that the minimum elevation must be larger than 0!
         ''',
 
         'altitude' : r'''
-    Set the bottom level in the model atmosphere provided in 
+    Set the bottom level in the model atmosphere provided in
     \code{atmosphere\_file} to be at the given altitude above sea level (km).
     \fcode{
-    altitude 0.73   \# Altitude of IFU, Garmisch-Partenkirchen 
+    altitude 0.73   \# Altitude of IFU, Garmisch-Partenkirchen
     }
-    The profiles of pressure, temperature, molecular absorbers, 
-    ice and water clouds are cut at the specified altitude. 
+    The profiles of pressure, temperature, molecular absorbers,
+    ice and water clouds are cut at the specified altitude.
     The aerosol profile is not affected by \code{altitude} but starts
-    right from the model surface. This is a convenient way for the user to calculate the 
+    right from the model surface. This is a convenient way for the user to calculate the
     radiation at other altitudes than sealevel. Note that \code{altitude} is very different
     from \code{zout} where the radiation is calculated at an altitude of zout
-    above the surface. E.g. to calculate the radiation field 1 km above the surface 
-    at a location at 0.73 km above sealevel, one would specify '\code{altitude} 0.73' 
+    above the surface. E.g. to calculate the radiation field 1 km above the surface
+    at a location at 0.73 km above sealevel, one would specify '\code{altitude} 0.73'
     and '\code{zout} 1.0'.
-    If an altitude is specified which is below the lowest level in the 
-    \code{atmosphere\_file}, the atmospheric profiles are extrapolated assuming a constant 
+    If an altitude is specified which is below the lowest level in the
+    \code{atmosphere\_file}, the atmospheric profiles are extrapolated assuming a constant
     gradient for temperature and mixing ratios.
     A second optional argument may be given to \code{altitude} as e.g.
     \fcode{
@@ -865,17 +865,17 @@ def get_surface_documentation():
         ''',
 
         'mc_triangular_surface_file' : r'''
-    Define a triangular surface for MYSTIC. 
+    Define a triangular surface for MYSTIC.
     \fcode{
         mc\_triangular\_surface\_file file
     }
     The file includes the description of a trianglar surfaces.
     It is expected in  {\sl netcdf}-Format and
-    should include the following fields: 
+    should include the following fields:
     \fcode{vertices (n_vert,3)} Location of vertices (x,y,z)
     \fcode{triangles (n_tris,3)} Indices of vertices for each triangle (three
     corners)
-    \fcode{albedo (n_tris)} Surface albedo for each triangle. 
+    \fcode{albedo (n_tris)} Surface albedo for each triangle.
         ''',
 
         'albedo' : r'''
@@ -884,21 +884,21 @@ def get_surface_documentation():
         albedo value
     }
     where \code{value} is a number between 0.0 and 1.0,
-    constant for all wavelengths. For wavelength dependent surface albedo 
+    constant for all wavelengths. For wavelength dependent surface albedo
     use \code{albedo\_file}. The default albedo is 0.0.
         ''',
 
         'albedo_file' : r'''
-    Location of surface albedo file for wavelength dependent surface albedo. 
+    Location of surface albedo file for wavelength dependent surface albedo.
     \fcode{
     albedo\_file file
     }
     The file must have two columns.
-    Column 1 is the wavelength in nm, and column 2 the corresponding 
-    Lambertian surface albedo. An arbitrary wavelength grid may be chosen as the 
-    albedo will be interpolated linearely to the wavelength grid used for the 
+    Column 1 is the wavelength in nm, and column 2 the corresponding
+    Lambertian surface albedo. An arbitrary wavelength grid may be chosen as the
+    albedo will be interpolated linearely to the wavelength grid used for the
     radiation calculation. Comments start with \code{\#}. Empty lines are ignored.
-    A large collection of spectral albedos are available e.g. at http://speclib.jpl.nasa.gov/ 
+    A large collection of spectral albedos are available e.g. at http://speclib.jpl.nasa.gov/
     \citep{Baldridge2009}.
         ''',
 
@@ -907,41 +907,41 @@ def get_surface_documentation():
     \fcode{
         fluorescence value
     }
-    where \code{value} is a number greater or equal to 0.0, 
+    where \code{value} is a number greater or equal to 0.0,
     constant for all wavelengths.
-    Must be used together with  \code{source solar file}. The units of the fluorescence should 
+    Must be used together with  \code{source solar file}. The units of the fluorescence should
     obviously be the same as for the solar source in \code{source solar file}.
-    For wavelength dependent fluorescence use \code{fluorescence\_file}. The default fluorescence is 0.0. 
+    For wavelength dependent fluorescence use \code{fluorescence\_file}. The default fluorescence is 0.0.
     Currently only works with the \code{disort} solver.
         ''',
 
         'fluorescence_file' : r'''
-    Location of fluorescence file for wavelength dependent fluorescence emission 
-    from the bottom surface. 
+    Location of fluorescence file for wavelength dependent fluorescence emission
+    from the bottom surface.
     \fcode{
         fluorescence\_file file
     }
     The file must have two columns.
-    Column 1 is the wavelength in nm, and column 2 the corresponding 
-    fluorescence. An arbitrary wavelength grid may be chosen as the 
-    fluorescence will be interpolated linearely to the wavelength grid used for the 
+    Column 1 is the wavelength in nm, and column 2 the corresponding
+    fluorescence. An arbitrary wavelength grid may be chosen as the
+    fluorescence will be interpolated linearely to the wavelength grid used for the
     radiation calculation. Comments start with \code{\#}. Empty lines are ignored.
-    Currently only works with the \code{disort} solver. Furthermore. if \code{raman} is 
-    not set, \code{wavelength\_grid\_file} 
+    Currently only works with the \code{disort} solver. Furthermore. if \code{raman} is
+    not set, \code{wavelength\_grid\_file}
     must be specified with the same resolution as the \code{source solar file}, and the first value
-    must be the value specified by \code{wavelength}. The units of the fluorescence should 
+    must be the value specified by \code{wavelength}. The units of the fluorescence should
     obviously be the same as for the \code{source solar file}.
         ''',
 
         'brdf_rpv_type' : r'''
     With this option the (RPV) BRDF surface type is selected.
-    This option can be used with \code{albedo\_library} in order to select a spectral albedo 
+    This option can be used with \code{albedo\_library} in order to select a spectral albedo
     or with \code{brdf\_rpv\_library} in order to select a BRDF function.
     \fcode{
     brdf\_rpv\_type surface\_type\_number
     }
     where \code{surface\_type\_number} is an integer starting from 0,
-    where 0 refers to a black surface and the following numbers to 
+    where 0 refers to a black surface and the following numbers to
     the entries in the specified \code{library}.
         ''',
 
@@ -965,15 +965,15 @@ def get_surface_documentation():
         ''',
 
         'brdf_rpv_library' : r'''
-    The rpv libraries are collections of spectral BRDFs of different surface types, 
-    This option must be used either with \code{brdf\_rpv\_type} 
+    The rpv libraries are collections of spectral BRDFs of different surface types,
+    This option must be used either with \code{brdf\_rpv\_type}
     or \code{surface\_type\_map}, in order to select the specific surface type.
-                
-    For using a \code{brdf\_rpv\_library} write 
+
+    For using a \code{brdf\_rpv\_library} write
     \fcode{
-    brdf\_rpv\_library library\_path 
+    brdf\_rpv\_library library\_path
     }
-    where \code{library\_path} is the path of the directory, where the BRDF data is stored. The files are 
+    where \code{library\_path} is the path of the directory, where the BRDF data is stored. The files are
     expected to have the names \code{IGBP.01.rpv, IGBP.02.rpv, ...} If \code{brdf\_rpv\_type 1} is specified
     the BRDF from \code{IGBP.01.rpv} will be used, and so on.
     Each file must have the structure like an \code{brdf\_rpv\_file}.
@@ -999,14 +999,14 @@ def get_surface_documentation():
     }
     \code{variable} can be one of the following:
     \begin{description}
-    \parameter{pcl} 
+    \parameter{pcl}
     Pigment concentration for \citet{cox54a,cox54b} ocean BRDF (in mg/m$^{-3}$).
-    The default value is 0.01 mg/m$^{-3}$. 
+    The default value is 0.01 mg/m$^{-3}$.
     \parameter{sal}
-    Salinity for \citet{cox54a,cox54b} ocean BRDF (in "per mille", 0.1\%; this 
-        unit is equivalent to the other common units for salinity, 
+    Salinity for \citet{cox54a,cox54b} ocean BRDF (in "per mille", 0.1\%; this
+        unit is equivalent to the other common units for salinity,
         ppt - parts per thousand, psu - practical salinity unit).
-    The default value is 34.3. 
+    The default value is 34.3.
     \parameter{u10}
     Wind speed for \citet{cox54a,cox54b} ocean BRDF (in m/s).
     The wind speed is the most important parameter affecting ocean BRDF.  The
@@ -1018,10 +1018,10 @@ def get_surface_documentation():
     Default value is 0 degrees,
         which is wind from the South. 90 degrees corresponds to wind from the West, etc. (Honestly, this was
         never truly validated. It could possibly be that 0 is wind from the North, 90 is wind from the East, etc.)
-    The option is only implemented for the \code{mystic} solver. 
+    The option is only implemented for the \code{mystic} solver.
         \end{description}
 
-    At present only available with \code{rte\_solver disort}, 
+    At present only available with \code{rte\_solver disort},
         \ifmystic{\code{rte\_solver mystic}}
         and \code{rte\_solver fdisort2}.  The
         number of streams (\code{number\_of\_streams}) is automatically increased to 16 if
@@ -1039,7 +1039,7 @@ def get_surface_documentation():
         ''',
 
         'sur_temperature' : r'''
-    Surface temperature, used for thermal infrared calculations. 
+    Surface temperature, used for thermal infrared calculations.
     \fcode{
     sur\_temperature value
     }
@@ -1060,6 +1060,6 @@ def get_surface_documentation():
     where Nx and Ny are the number of grid boxes in x- and y-direction,
     dx and dy are the size of the grid boxes in km.
     In the second and the following lines the indices in x- and y-direction
-    and the temperature of the pixel are specified. 
+    and the temperature of the pixel are specified.
         ''',
     }
diff --git a/src_py/translate.py b/src_py/translate.py
index d370852..a4c035d 100644
--- a/src_py/translate.py
+++ b/src_py/translate.py
@@ -4,7 +4,7 @@ def translate_input(inputfile, outputname='',force=False):
 
 	lines=inputfile.readlines()
 	inputfile.close()
-	
+
 	#preparser
 	preparse_dict = preparse(lines)
 	zip_source		= search_for_zip_source(lines)
@@ -13,10 +13,10 @@ def translate_input(inputfile, outputname='',force=False):
 		if os.path.exists(outputname):
 			if not force:
 				import sys
-				print """Error occured!\nFilename {0} for new input file already exists.\nPlease call python with another output filename:\n
+				print("""Error occured!\nFilename {0} for new input file already exists.\nPlease call python with another output filename:\n
 				python {1} --new_filename new_file.inp\n
 				or overwrite file with:\n
-				python {1} --new_filename new_file.inp --force""".format(outputname,inputfile.name)
+				python {1} --new_filename new_file.inp --force""".format(outputname,inputfile.name))
 				sys.exit()
 	else: outputname = False
 
@@ -38,7 +38,7 @@ def preparse(lines):
 	for line in lines:
 		match_str=((line.split('#')[0]).strip()).split()
 		if not match_str: continue
-		for key in preparse_dict.keys():
+		for key in list(preparse_dict.keys()):
 			if key == 'mc_spectral_is_wvl':
 				if match_str[0] == key: preparse_dict[key] = match_str[1]
 			else:
@@ -54,13 +54,13 @@ def search_for_zip_source(lines):
 	unit=''
         for line in lines:
 		match_str=((line.split('#')[0]).strip()).split()
-                if match_str and match_str[0]=='solar_file': 
+                if match_str and match_str[0]=='solar_file':
 			if len(match_str) > 1: solarfile= match_str[1]
 			if len(match_str) > 2: unit	= match_str[2]
 
         for line in lines:
 		match_str=((line.split('#')[0]).strip()).split()
-                if match_str and match_str[0]=='source': 
+                if match_str and match_str[0]=='source':
 			if len(match_str) > 1: source = match_str[1]
 
 	if source and solarfile:
@@ -72,30 +72,30 @@ def translate(lines,preparse_dict={},zip_source=False,outputfile=''):
 	if outputfile:
 		try:
 			output = file(outputfile,'w')
-		except Exception,e:
+		except Exception as e:
 			import sys
-			print "Exception occured when opening file: ",e
+			print("Exception occured when opening file: ",e)
 			sys.exit()
 
 
 	for line in lines:
 		line_translate = translate_line(line,preparse_dict=preparse_dict,zip_source=zip_source)
-		
+
 		if outputfile:
 			output.write(line_translate)
 		else:
-			if line_translate: print line_translate.strip()
+			if line_translate: print(line_translate.strip())
 
 	if zip_source:
                 if outputfile:
                         output.write(zip_source)
                 else:
-                        print zip_source
+                        print(zip_source)
 
 
 	if outputfile: output.close()
 
- 
+
 def translate_line(line,preparse_dict={},zip_source=False):
 	import re
 	match_str=((line.split('#')[0]).strip()).split()
@@ -103,7 +103,7 @@ def translate_line(line,preparse_dict={},zip_source=False):
 	if not match_str:			return line
 
 	#spectral_options
-	if match_str[0]=='transmittance_wl_file':	return re.sub('transmittance_wl_file',      'wavelength_grid_file',     line,count=1)	
+	if match_str[0]=='transmittance_wl_file':	return re.sub('transmittance_wl_file',      'wavelength_grid_file',     line,count=1)
 	if match_str[0]=='wvn':		return re.sub('wvn',		'wavelength',		line,count=1)
 	if match_str[0]=='wvn_index':	return re.sub('wvn_index',	'wavelength_index',	line,count=1)
 
@@ -115,7 +115,7 @@ def translate_line(line,preparse_dict={},zip_source=False):
 		if zip_source:	return ''
 		else:		return line
 	if match_str[0]=='mc_sun_radius':	return re.sub('mc_sun_radius',	'mc_sun_angular_size',  line,count=1)
-	
+
 	#generell_atmosphere_options
 	if match_str[0]=='wc_level':		return re.sub('wc_level',	'interpret_as_level wc',line,count=1)
 	if match_str[0]=='ic_level':		return re.sub('ic_level',	'interpret_as_level ic',line,count=1)
@@ -125,25 +125,25 @@ def translate_line(line,preparse_dict={},zip_source=False):
 	if match_str[0]=='aerosol_no_scattering':	return re.sub('aerosol_no_scattering','no_scattering aer',	line,count=1)
 	if match_str[0]=='no_rayleigh':		return re.sub('no_rayleigh','no_scattering mol',	line,count=1)
 	if match_str[0]=='no_molecular_absorption':	return re.sub('no_molecular_absorption','no_absorption mol',	line,count=1)
-	if match_str[0]=='reverse':		return re.sub('reverse',	      'reverse_atmosphere',  line,count=1)	
+	if match_str[0]=='reverse':		return re.sub('reverse',	      'reverse_atmosphere',  line,count=1)
 
 	#molecular_atmosphere_options
-	if match_str[0]=='correlated_k':	return re.sub('correlated_k',	      'mol_abs_param',  line,count=1)	
-	if match_str[0]=='fu_h2o_continuum':	
+	if match_str[0]=='correlated_k':	return re.sub('correlated_k',	      'mol_abs_param',  line,count=1)
+	if match_str[0]=='fu_h2o_continuum':
 		line = re.sub('fu_h2o_continuum',     'ck_fu_h2o_continuum',  line,count=1)
 		if   match_str[1]=='2.1': return re.sub('2.1', 'v2.1', line, count=1)
 		elif match_str[1]=='2.4': return re.sub('2.4', 'v2.4', line, count=1)
 		else: return line
-	if match_str[0]=='absorption':		return re.sub('absorption',	      'ck_lowtran_absorption',  line,count=1)	
-	if match_str[0]=='molecular_tau_file':	return re.sub('molecular_tau_file',   'mol_tau_file abs',  line,count=1)	
-	if match_str[0]=='rayleigh_tau_file':	return re.sub('rayleigh_tau_file',    'mol_tau_file sca',  line,count=1)	
-	if match_str[0]=='dens_file':		
+	if match_str[0]=='absorption':		return re.sub('absorption',	      'ck_lowtran_absorption',  line,count=1)
+	if match_str[0]=='molecular_tau_file':	return re.sub('molecular_tau_file',   'mol_tau_file abs',  line,count=1)
+	if match_str[0]=='rayleigh_tau_file':	return re.sub('rayleigh_tau_file',    'mol_tau_file sca',  line,count=1)
+	if match_str[0]=='dens_file':
 		if len(match_str) == 4:	return 'mol_file {1} {3} {2}\n'.format( *match_str )
-		else: 			return re.sub('dens_file', 'mol_file', line, count =1) 
+		else: 			return re.sub('dens_file', 'mol_file', line, count =1)
 	if match_str[0]=='rh_file':	return 'mol_file H2O {1} rh\n'.format( *match_str )
-	if match_str[0]=='rayleigh_crs':	return re.sub('rayleigh_crs',	      'crs_model rayleigh',  line,count=1)	
-	if match_str[0]=='o3_crs':		return re.sub('o3_crs',	 	      'crs_model O3', 	     line,count=1)	
-	if match_str[0]=='no2_crs':		return re.sub('no2_crs',	      'crs_model NO2', 	     line,count=1)	
+	if match_str[0]=='rayleigh_crs':	return re.sub('rayleigh_crs',	      'crs_model rayleigh',  line,count=1)
+	if match_str[0]=='o3_crs':		return re.sub('o3_crs',	 	      'crs_model O3', 	     line,count=1)
+	if match_str[0]=='no2_crs':		return re.sub('no2_crs',	      'crs_model NO2', 	     line,count=1)
 	if match_str[0]=='ozone_column':	return 'mol_modify O3 {1} DU\n'.format( *match_str )
 	if match_str[0]=='h2o_precip':		return 'mol_modify H2O {1} MM\n'.format( *match_str )
 	if match_str[0]=='no2_column_du':	return 'mol_modify NO2 {1} DU\n'.format( *match_str )
@@ -163,11 +163,11 @@ def translate_line(line,preparse_dict={},zip_source=False):
 	if match_str[0]=='co2_mixing_ratio':	return 'mixing_ratio CO2 {1}\n'.format( *match_str )
 
 	#aerosol_options
-	if match_str[0]=='aerosol_gg_file':	return re.sub('aerosol_gg_file',      'aerosol_file gg',     line,count=1)	
-	if match_str[0]=='aerosol_ssa_file':	return re.sub('aerosol_ssa_file',     'aerosol_file ssa',    line,count=1)	
-	if match_str[0]=='aerosol_tau_file':	return re.sub('aerosol_tau_file',     'aerosol_file tau',    line,count=1)	
-	if match_str[0]=='aerosol_files':	return re.sub('aerosol_files',	      'aerosol_file explicit',     line,count=1)	
-	if match_str[0]=='aerosol_moments_file':return re.sub('aerosol_moments_file', 'aerosol_file moments',     line,count=1)	
+	if match_str[0]=='aerosol_gg_file':	return re.sub('aerosol_gg_file',      'aerosol_file gg',     line,count=1)
+	if match_str[0]=='aerosol_ssa_file':	return re.sub('aerosol_ssa_file',     'aerosol_file ssa',    line,count=1)
+	if match_str[0]=='aerosol_tau_file':	return re.sub('aerosol_tau_file',     'aerosol_file tau',    line,count=1)
+	if match_str[0]=='aerosol_files':	return re.sub('aerosol_files',	      'aerosol_file explicit',     line,count=1)
+	if match_str[0]=='aerosol_moments_file':return re.sub('aerosol_moments_file', 'aerosol_file moments',     line,count=1)
 	if match_str[0]=='aerosol_set_gg':	return re.sub('aerosol_set_gg',	'aerosol_modify gg set',	line,count=1)
 	if match_str[0]=='aerosol_set_ssa':	return re.sub('aerosol_set_ssa',	'aerosol_modify ssa set',	line,count=1)
 	if match_str[0]=='aerosol_set_tau':	return re.sub('aerosol_set_tau',	'aerosol_modify tau set',	line,count=1)
@@ -175,7 +175,7 @@ def translate_line(line,preparse_dict={},zip_source=False):
 	if match_str[0]=='aerosol_scale_gg':	return re.sub('aerosol_scale_gg',	'aerosol_modify gg scale',	line,count=1)
 	if match_str[0]=='aerosol_scale_ssa':	return re.sub('aerosol_scale_ssa',	'aerosol_modify ssa scale',	line,count=1)
 	if match_str[0]=='aerosol_scale_tau':	return re.sub('aerosol_scale_tau',	'aerosol_modify tau scale',	line,count=1)
-	if match_str[0]=='angstrom':		return re.sub('angstrom',	      'aerosol_angstrom',  line,count=1)	
+	if match_str[0]=='angstrom':		return re.sub('angstrom',	      'aerosol_angstrom',  line,count=1)
 
 	#profile_options
 	if match_str[0]=='profile_set_gg':	return re.sub('profile_set_gg\s+'+match_str[1],		'profile_modify %s gg set'% (match_str[1]) ,	line,count=1)
@@ -191,13 +191,13 @@ def translate_line(line,preparse_dict={},zip_source=False):
 	if match_str[0]=='profile_properties_interpolate': return ''
 
 	#cloud_options
-	if match_str[0]=='wc_file':		
+	if match_str[0]=='wc_file':
 		if match_str[1]=='1D' or match_str[1]=='3D' or match_str[1]=='moments' or match_str[1]=='ipa' or match_str[1]=='ipa_files':		return line
 		else:				return re.sub('wc_file',	'wc_file 1D',		line,count=1)
 	if match_str[0]=='mc_wcloud_file':	return re.sub('mc_wcloud_file',	'wc_file 3D',		line,count=1)
 	if match_str[0]=='wc_files':		return re.sub('wc_files',	'wc_file moments',	line,count=1)
 	if match_str[0]=='wc_ipa_files':	return re.sub('wc_ipa_files',	'wc_file ipa_files',	line,count=1)
-	if match_str[0]=='ic_file':		
+	if match_str[0]=='ic_file':
 		if match_str[1]=='1D' or match_str[1]=='3D' or match_str[1]=='moments' or match_str[1]=='ipa' or match_str[1]=='ipa_files':		return line
 		else:				return re.sub('ic_file',	'ic_file 1D',		line,count=1)
 	if match_str[0]=='mc_icloud_file':	return re.sub('mc_icloud_file',	'ic_file 3D',		line,count=1)
@@ -229,7 +229,7 @@ def translate_line(line,preparse_dict={},zip_source=False):
 	if match_str[0]=='wc_properties_interpolate': return ''
 	if match_str[0]=='ic_properties_interpolate': return ''
 	if match_str[0]=='ic_fu_reff':		return re.sub('ic_fu_reff',	'ic_fu reff_def on',	line,count=1)
-	if match_str[0]=='ic_fu_tau':		
+	if match_str[0]=='ic_fu_tau':
 		if match_str[1] == 'scaled':		line = re.sub('scaled',	'on',	line,count=1)
 		elif match_str[1] == 'unscaled':	line = re.sub('unscaled','off',	line,count=1)
 		return re.sub('ic_fu_tau',     'ic_fu deltascaling',	line,count=1)
@@ -287,7 +287,7 @@ def translate_line(line,preparse_dict={},zip_source=False):
 
 	#mc_options
 	if match_str[0]=='mc_ris_optical_depth':	return re.sub('mc_ris_optical_depth',	'mc_ris optical_depth',    line,count=1)
-	if match_str[0]=='mc_ris_factor':	
+	if match_str[0]=='mc_ris_factor':
 		if len(match_str) > 1:	return re.sub('mc_ris_factor',	'mc_ris factor',    line,count=1)
 		else:			return 'mc_ris optical_depth 1\n'
 	if match_str[0]=='mc_spectral_is_wvl' : return ''
@@ -328,28 +328,28 @@ def translate_line(line,preparse_dict={},zip_source=False):
 	if match_str[0]=='filter_function_file':
 		if preparse_dict['filter_function_normalize']:	return re.sub(match_str[1],	'{} normalize'.format(match_str[1]), line,count=1)
 		else:				return line
-	
+
 	return line
 
 
 import argparse
 #read input from cmd-line arguments
 parser = argparse.ArgumentParser(description='Python programm to translate old uvspec input file to new input files.')
-parser.add_argument('inputfile', type=file, 
+parser.add_argument('inputfile', type=file,
 			help='Name of uvspec input-file to translate from old to new input style.')
 parser.add_argument('--new_filename', default='', type=str,
 			help='Name of new style uvspec input-file.')
 parser.add_argument('--force', action='store_true', default=False,
 			help='Overwrite new_filename if file already exists.' )
 
-try: 
+try:
 	args = parser.parse_args()
-except IOError,e:
+except IOError as e:
 	import sys
-	print "Error occured while parsing cmd-line-arguments: ",e
+	print("Error occured while parsing cmd-line-arguments: ",e)
 	sys.exit(1)
-except Exception,e:
-	print e
+except Exception as e:
+	print(e)
 	pass
 
 translate_input(args.inputfile, args.new_filename, args.force)
diff --git a/src_py/writeLex.py b/src_py/writeLex.py
index a9e1cb3..c1e1066 100644
--- a/src_py/writeLex.py
+++ b/src_py/writeLex.py
@@ -23,6 +23,8 @@
  * Foundation, Inc., 59 Temple Place - Suite 330, 
  * Boston, MA 02111-1307, USA.
  *--------------------------------------------------------------------"""
+
+import io
 from option_definition import *
 
 found_lidar     = "no"
@@ -30,291 +32,291 @@ found_mystic    = "yes"
 found_mystic3d  = "no"
 
 def writeLex():
-	import os
+        import os
 
-	pwd = os.getcwd()
-	
-	options = loadOptions()					#load python dictionary with input options
-	lexParser = loadLexStarter(pwd+'/lex_starter.l')	#load lexStarter.l
-	lexParser = insertInputOption(lexParser,options)	#add input options from python dictionary to lex parser
-	lexParser = insertDocu(lexParser,options)		#add documentation to python dictionary
-	lexParser = insertInitialisations(lexParser,options)	#add default initialisations
+        pwd = os.getcwd()
+        
+        options = loadOptions()                                 #load python dictionary with input options
+        lexParser = loadLexStarter(pwd+'/lex_starter.l')        #load lexStarter.l
+        lexParser = insertInputOption(lexParser,options)        #add input options from python dictionary to lex parser
+        lexParser = insertDocu(lexParser,options)               #add documentation to python dictionary
+        lexParser = insertInitialisations(lexParser,options)    #add default initialisations
 
-	writeUvspecLex(lexParser,pwd+'/uvspec_lex.l')
+        writeUvspecLex(lexParser,pwd+'/uvspec_lex.l')
 
 def loadOptionsHelper():
-	"""
-	Returns a list of all the groups.
-	Used in the GUI.
-	"""
-	import aerosol_options, cloud_options, profile_options, geometry_options, special_options
-	import mc_options, spectral_options, surface_options, molecular_options, solver_options, output_options, general_atmosphere_options
-
-	profile = profile_options.setup_cloud_group()
-	cloud = cloud_options.setup_cloud_group()
-	aer = aerosol_options.setup_aerosol_group()
-	special = special_options.setup_special_group()
-
-	mc = mc_options.setup_mc_group()
-	spectral = spectral_options.setup_spectral_group()
-	gen_atm = general_atmosphere_options.setup_general_atm_group()
-	sur = surface_options.setup_surface_group()
-	mol = molecular_options.setup_molecular_group()
-	sol = solver_options.setup_solver_group()
-	out = output_options.setup_output_group()
-	geom = geometry_options.setup_geometry_group()
-
-	list_of_groups=[spectral, gen_atm, mol, aer, profile, cloud, sur, sol, mc, geom, out, special]
-	for group in list_of_groups:
-		for option in group:
-			if found_lidar == 'no' and option['islidar']:		group.options.remove(option)
-			elif found_mystic == 'no' and option['mystic']:		group.options.remove(option)
-			elif found_mystic3d == 'no' and option['threedmystic']:	group.options.remove(option)
-
-	return list_of_groups 
+        """
+        Returns a list of all the groups.
+        Used in the GUI.
+        """
+        import aerosol_options, cloud_options, profile_options, geometry_options, special_options
+        import mc_options, spectral_options, surface_options, molecular_options, solver_options, output_options, general_atmosphere_options
+
+        profile = profile_options.setup_cloud_group()
+        cloud = cloud_options.setup_cloud_group()
+        aer = aerosol_options.setup_aerosol_group()
+        special = special_options.setup_special_group()
+
+        mc = mc_options.setup_mc_group()
+        spectral = spectral_options.setup_spectral_group()
+        gen_atm = general_atmosphere_options.setup_general_atm_group()
+        sur = surface_options.setup_surface_group()
+        mol = molecular_options.setup_molecular_group()
+        sol = solver_options.setup_solver_group()
+        out = output_options.setup_output_group()
+        geom = geometry_options.setup_geometry_group()
+
+        list_of_groups=[spectral, gen_atm, mol, aer, profile, cloud, sur, sol, mc, geom, out, special]
+        for group in list_of_groups:
+                for option in group:
+                        if found_lidar == 'no' and option['islidar']:           group.options.remove(option)
+                        elif found_mystic == 'no' and option['mystic']:         group.options.remove(option)
+                        elif found_mystic3d == 'no' and option['threedmystic']: group.options.remove(option)
+
+        return list_of_groups 
 
 def loadOptions():
-	options={}
-	
-	for group in loadOptionsHelper():
-		for option in group:
-			options[option.get('name')]=option
-	return options	
+        options={}
+        
+        for group in loadOptionsHelper():
+                for option in group:
+                        options[option.get('name')]=option
+        return options  
 
 def loadLexStarter(filename):
-	import os
+        import os
 
-	#read lex file
-	pwd = os.getcwd()
-	lexstarter = open(filename,'r')
-	text = lexstarter.read()
-	lexstarter.close()
-	return text
+        #read lex file
+        pwd = os.getcwd()
+        lexstarter = open(filename,'r')
+        text = lexstarter.read()
+        lexstarter.close()
+        return text
 
 def writeUvspecLex(text,filename):
-	newlex = open(filename,'w')
-	newlex.write(text)
-	newlex.close()
+        newlex = open(filename,'w')
+        newlex.write(text)
+        newlex.close()
 
 def getStr(string):
-	if str(string) == 'True': return 'TRUE'
-	elif str(string) == 'False': return 'FALSE'
-	else: return str(string)
-		
+        if str(string) == 'True': return 'TRUE'
+        elif str(string) == 'False': return 'FALSE'
+        else: return str(string)
+                
 
 def getTypeScan(dtype, valid_range):
-	if dtype == str or dtype == file:
-		return '{SPACE_WORD}'
-	elif dtype == Dimension:
-		return '{SPACE}+{DIM}'
-	elif dtype == ProfileType:
-		return '{SPACE_PROFILETYPE}'
-	elif dtype == SignedFloats :
-		return '{SIGNED_FLOATS}'
-	elif dtype == Integers :
-		return '{INTEGERS}'
-	elif dtype == CaothType or dtype == CaothoffType :
-		return '{SPACE_WORD}'
-	elif dtype == int:
-		return '{SPACE_INTEGER}'
-	elif dtype == long:
-		return '{SPACE_FLOAT}'
-	elif dtype == float or dtype == Double:
-		if valid_range and valid_range[0] >= 0:
-			return '{SPACE_FLOAT}'
-		else:
-			return '{SPACE_SIGNED_FLOAT}'
-	else: print 'ERROR: datatype not known: ', dtype
+        if dtype == str or dtype == io.IOBase:
+                return '{SPACE_WORD}'
+        elif dtype == Dimension:
+                return '{SPACE}+{DIM}'
+        elif dtype == ProfileType:
+                return '{SPACE_PROFILETYPE}'
+        elif dtype == SignedFloats :
+                return '{SIGNED_FLOATS}'
+        elif dtype == Integers :
+                return '{INTEGERS}'
+        elif dtype == CaothType or dtype == CaothoffType :
+                return '{SPACE_WORD}'
+        elif dtype == int:
+                return '{SPACE_INTEGER}'
+        elif dtype == int:
+                return '{SPACE_FLOAT}'
+        elif dtype == float or dtype == Double:
+                if valid_range and valid_range[0] >= 0:
+                        return '{SPACE_FLOAT}'
+                else:
+                        return '{SPACE_SIGNED_FLOAT}'
+        else: print('ERROR: datatype not known: ', dtype)
 
 def yytext2type(dtype):
-	if dtype == str or dtype == file or dtype == ProfileType:
-		return 'yytext2string'
-	elif dtype == float:
-		return 'yytext2float'
-	elif dtype == Double:
-		return 'yytext2double'
-	elif dtype == int:
-		return 'yytext2int'
-	elif dtype == long:
-		return '(long int) yytext2double'
+        if dtype == str or dtype == io.IOBase or dtype == ProfileType:
+                return 'yytext2string'
+        elif dtype == float:
+                return 'yytext2float'
+        elif dtype == Double:
+                return 'yytext2double'
+        elif dtype == int:
+                return 'yytext2int'
+        elif dtype == int:
+                return '(long int) yytext2double'
 
 def getLexOptions(group):
 
-	inputOption = ''
-	
-	for name, option in sorted(group.iteritems()):
-		# Do something completly different
-		if hasattr(option, "writeLex"):
-			inputOption += option.writeLex()
-		# Do the usual
-		else:
-			tokens = option.get('tokens')
-
-			#write input option name
-			inputOption += name
-
-			nTokens, rules, optional = lexRules(tokens)
-
-			#write setting of input arguments
-			variableSetting = '' 
-			itok = 1
-			for tok in tokens: 
-				if tok.get('optional'):		variableSetting += '\tif ( ntokens >= %d )\t {\n\t' %( itok )
-
-				if isinstance(tok, addSetting):
-					variableSetting += '\t%s = %s;\n' %(tok.get('name'),
+        inputOption = ''
+        
+        for name, option in sorted(group.items()):
+                # Do something completly different
+                if hasattr(option, "writeLex"):
+                        inputOption += option.writeLex()
+                # Do the usual
+                else:
+                        tokens = option.get('tokens')
+
+                        #write input option name
+                        inputOption += name
+
+                        nTokens, rules, optional = lexRules(tokens)
+
+                        #write setting of input arguments
+                        variableSetting = '' 
+                        itok = 1
+                        for tok in tokens: 
+                                if tok.get('optional'):         variableSetting += '\tif ( ntokens >= %d )\t {\n\t' %( itok )
+
+                                if isinstance(tok, addSetting):
+                                        variableSetting += '\t%s = %s;\n' %(tok.get('name'),
                                                                 getStr(tok.get('setting')))
 
-				elif isinstance(tok,addLogical):
-					itok += 1
-					variableSetting += getLogicals(tok,itok,nTokens)
-					
-				else:
-					try:
-						itok += 1	
-						variableSetting += getTokens(tok,itok, str(nTokens) )
-					except Exception, e:
-						print 'ERROR found in input option %s :\n\t Datatype %s of variable %s not known!' % (
-							option.get('name'), tok.get('datatype'), tok.get('name') )
-						print e
-				if  tok.get('optional'):         variableSetting += '\t}\n'
+                                elif isinstance(tok,addLogical):
+                                        itok += 1
+                                        variableSetting += getLogicals(tok,itok,nTokens)
+                                        
+                                else:
+                                        try:
+                                                itok += 1       
+                                                variableSetting += getTokens(tok,itok, str(nTokens) )
+                                        except Exception as e:
+                                                print('ERROR found in input option %s :\n\t Datatype %s of variable %s not known!' % (
+                                                        option.get('name'), tok.get('datatype'), tok.get('name') ))
+                                                print(e)
+                                if  tok.get('optional'):         variableSetting += '\t}\n'
 
-			inputOption += '%s {\n%s%s}\n' %( rules, optional, variableSetting )
+                        inputOption += '%s {\n%s%s}\n' %( rules, optional, variableSetting )
 
-	return inputOption
+        return inputOption
 
 def lexRules(tokens):
-	nTokens=1; 
-	tokenStr=''; rules=''; optional=''
-	for tok in tokens:
-		if isinstance(tok,addSetting):
-			continue
-		else:
-			rules += getTypeScan(tok.get('datatype'),	   tok.get('valid_range'))
-			nTokens +=1
-			tokenStr = str(nTokens)
-			if tok.get('optional'):
-				tokenStr = 'ntokens+1'
-				optional = '\tntokens = yytext2ntokens(yytext);\n'
-				rules += '?'
-	return [ tokenStr, rules, optional ]
+        nTokens=1; 
+        tokenStr=''; rules=''; optional=''
+        for tok in tokens:
+                if isinstance(tok,addSetting):
+                        continue
+                else:
+                        rules += getTypeScan(tok.get('datatype'),          tok.get('valid_range'))
+                        nTokens +=1
+                        tokenStr = str(nTokens)
+                        if tok.get('optional'):
+                                tokenStr = 'ntokens+1'
+                                optional = '\tntokens = yytext2ntokens(yytext);\n'
+                                rules += '?'
+        return [ tokenStr, rules, optional ]
 
 def getTokens(tok,itok,nTokens):
 
-	dtype = tok.get('datatype')
-	if dtype == file:
-		inputStr = '\tyytextCstring ( %s, yytext, %d, %s);\n' % ( tok.get('name'), itok, str(nTokens) ) 
-	elif dtype == SignedFloats:
-		inputStr = '\tntokens = yytext2ntokens(yytext);\n\t%s =  yytext2floats(yytext, ntokens);\n' % ( tok.get('name') )
-	elif dtype == Integers:
-		inputStr = '\tntokens = yytext2ntokens(yytext);\n\t%s =  yytext2integers(yytext, ntokens);\n' % ( tok.get('name') )
-	elif dtype == CaothType:
-		inputStr = '\t%s = get_caoth_index(&Input.caoth,&Input.n_caoth, yytext2string(yytext, %d, %s),0);\n' % (  tok.get('name'), itok, str(nTokens) )
-	elif dtype == CaothoffType:
-		inputStr = '\t%s = get_caothoff_index(&Input.caothoff,&Input.n_caothoff, yytext2string(yytext, %d, %s));\n' % (  tok.get('name'), itok, str(nTokens) )
-	else:
-		inputStr = '\t%s = %s(yytext, %d, %s);\n' % ( tok.get('name'),
-			  yytext2type(tok.get('datatype')),
-			  itok, str(nTokens) )
-	return inputStr
+        dtype = tok.get('datatype')
+        if dtype == io.IOBase:
+                inputStr = '\tyytextCstring ( %s, yytext, %d, %s);\n' % ( tok.get('name'), itok, str(nTokens) ) 
+        elif dtype == SignedFloats:
+                inputStr = '\tntokens = yytext2ntokens(yytext);\n\t%s =  yytext2floats(yytext, ntokens);\n' % ( tok.get('name') )
+        elif dtype == Integers:
+                inputStr = '\tntokens = yytext2ntokens(yytext);\n\t%s =  yytext2integers(yytext, ntokens);\n' % ( tok.get('name') )
+        elif dtype == CaothType:
+                inputStr = '\t%s = get_caoth_index(&Input.caoth,&Input.n_caoth, yytext2string(yytext, %d, %s),0);\n' % (  tok.get('name'), itok, str(nTokens) )
+        elif dtype == CaothoffType:
+                inputStr = '\t%s = get_caothoff_index(&Input.caothoff,&Input.n_caothoff, yytext2string(yytext, %d, %s));\n' % (  tok.get('name'), itok, str(nTokens) )
+        else:
+                inputStr = '\t%s = %s(yytext, %d, %s);\n' % ( tok.get('name'),
+                          yytext2type(tok.get('datatype')),
+                          itok, str(nTokens) )
+        return inputStr
 
 
 
 def getLogicals(tok,itok,nTokens):
-	import re
-
-	#dictionary to subsitute charakters like + - . to underscore _ for matching definition in C code
-	rdict={'-': '_',  '.': '_',  '+':'_' }
-	regex = re.compile("(%s)" % "|".join(map(re.escape, rdict.keys())))
-
-	#uvspec_lex.l : read token for string comparison
-	inputStr = '\ts = yytext2string(yytext, {0}, {1});\n\t'.format(itok,nTokens)
-
-	#string comparison to set logical values
-	logicals = tok.get('logicals')
-	for ilog,log in enumerate(sorted(logicals)):
-		if ilog == 0:	inputStr += 'if'
-		else:		inputStr += 'else if'
-		if len(logicals) == 1:  # one logical -> destination = 1
-			inputStr += ' ( strcasecmp("{0}", s)==0 )\t{{ {1} = 1; }}\n\t'.format(log,tok.get('destination'))
-		else: #more logicals -> destination is logical in uppercase, this variable should be defined in uvspec.h!
-			inputStr += ' ( strcasecmp("{0}", s)==0 )\t{{ {1} = {2}{3}; }}\n\t'.format(log,tok.get('destination'), tok.get('setting'), ( regex.sub(lambda mo: rdict[mo.string[mo.start():mo.end()]], str(log)) ).upper() ) 
-	if tok.get('logical_file'):  #save token to destination_filename
-		inputStr += 'else\t{{ {0} = {1}FILE;\n\t\t strcpy ( {0}_filename, s ); }}\n\t'.format(tok.get('destination'), tok.get('setting'))
-	else:	#raise error
-		inputStr += r'else\t{{fprintf(stderr,"Option %s  has an invalid argument {0} on line %d: %s\\n", yytext, line_number+1, s); ierror++;}} \n\t'.format(itok-1)
-	inputStr += 'free(s); \n'
-	return inputStr
+        import re
+
+        #dictionary to subsitute charakters like + - . to underscore _ for matching definition in C code
+        rdict={'-': '_',  '.': '_',  '+':'_' }
+        regex = re.compile("(%s)" % "|".join(map(re.escape, list(rdict.keys()))))
+
+        #uvspec_lex.l : read token for string comparison
+        inputStr = '\ts = yytext2string(yytext, {0}, {1});\n\t'.format(itok,nTokens)
+
+        #string comparison to set logical values
+        logicals = tok.get('logicals')
+        for ilog,log in enumerate(sorted(logicals)):
+                if ilog == 0:   inputStr += 'if'
+                else:           inputStr += 'else if'
+                if len(logicals) == 1:  # one logical -> destination = 1
+                        inputStr += ' ( strcasecmp("{0}", s)==0 )\t{{ {1} = 1; }}\n\t'.format(log,tok.get('destination'))
+                else: #more logicals -> destination is logical in uppercase, this variable should be defined in uvspec.h!
+                        inputStr += ' ( strcasecmp("{0}", s)==0 )\t{{ {1} = {2}{3}; }}\n\t'.format(log,tok.get('destination'), tok.get('setting'), ( regex.sub(lambda mo: rdict[mo.string[mo.start():mo.end()]], str(log)) ).upper() ) 
+        if tok.get('logical_file'):  #save token to destination_filename
+                inputStr += 'else\t{{ {0} = {1}FILE;\n\t\t strcpy ( {0}_filename, s ); }}\n\t'.format(tok.get('destination'), tok.get('setting'))
+        else:   #raise error
+                inputStr += r'else\t{{fprintf(stderr,"Option %s  has an invalid argument {0} on line %d: %s\\n", yytext, line_number+1, s); ierror++;}} \n\t'.format(itok-1)
+        inputStr += 'free(s); \n'
+        return inputStr
 
 
 def insertInputOption(text,options):
-	import re
+        import re
 
-	#insert input options to lexfile
-	groupInput = getLexOptions(options)
-	text = re.sub('\n.*PYTHON_OPTIONS.*\n' , '\n%s\n' %(groupInput), text, count=1)
-	return text
+        #insert input options to lexfile
+        groupInput = getLexOptions(options)
+        text = re.sub('\n.*PYTHON_OPTIONS.*\n' , '\n%s\n' %(groupInput), text, count=1)
+        return text
 
 def insertDocu(text,options):
-	import re
-
-	#get new documentation
-	docu={}
-	for key,val in sorted(options.iteritems()):                  
-		docu[key]=val['documentation']
-	
-	#get whole documentation
-	doclist = docu.keys() + re.findall('(?<=option{)\w+',text)
-	doclist.sort( key = lambda member: member.lower() )
-	
-	#insert documentation to lexfile
-	for iopt, option in enumerate(reversed(doclist)):
-		i=len(doclist)-1-iopt
-		if docu.has_key(option) and doclist.count(option) == 1:
-			if i<len(doclist)-1:
-				if   text.find('\\ifthreedmystic{\n\\option{%s}' %(doclist[i+1])) > 0: n = text.find('\\ifthreedmystic{\n\\option{%s}' %(doclist[i+1])) 
-				elif text.find('\\ifmystic{\n\\option{%s}'	 %(doclist[i+1])) > 0: n = text.find('\\ifmystic{\n\\option{%s}' %(doclist[i+1])) 
-				elif text.find('\\iflidar{\n\\option{%s}' 	 %(doclist[i+1])) > 0: n = text.find('\\iflidar{\n\\option{%s}' %(doclist[i+1]))
-				elif text.find('\\undocumented{\n\\option{%s}' 	 %(doclist[i+1])) > 0: n = text.find('\\undocumented{\n\\option{%s}' %(doclist[i+1])) 
-				elif text.find('\\option{%s}' 			 %(doclist[i+1])) > 0: n = text.find('\\option{%s}' %(doclist[i+1]))
-				else: n = text.find('%DOCUMENTATION END')
-			else: n = text.find('%DOCUMENTATION END')
-
-			if options[option].get('developer'):
-				text = '%s\\undocumented{\n\\option{%s}%s}\n%s' %(text[:n], option, docu[option], text[n:])
-			elif options[option].get('islidar'):
-				text = '%s\\iflidar{\n\\option{%s}%s}\n%s' %(text[:n], option, docu[option], text[n:])
-			elif options[option].get('threedmystic'):
-				text = '%s\\ifthreedmystic{\n\\option{%s}%s}\n%s' %(text[:n], option, docu[option], text[n:])
-			elif options[option].get('mystic'):
-				text = '%s\\ifmystic{\n\\option{%s}%s}\n%s' %(text[:n], option, docu[option], text[n:])
-			else:
-				text = '%s\\option{%s}%s\n%s' %(text[:n], option, docu[option], text[n:])
-
-	return text
+        import re
+
+        #get new documentation
+        docu={}
+        for key,val in sorted(options.items()):                  
+                docu[key]=val['documentation']
+        
+        #get whole documentation
+        doclist = list(docu.keys()) + re.findall('(?<=option{)\w+',text)
+        doclist.sort( key = lambda member: member.lower() )
+        
+        #insert documentation to lexfile
+        for iopt, option in enumerate(reversed(doclist)):
+                i=len(doclist)-1-iopt
+                if option in docu and doclist.count(option) == 1:
+                        if i<len(doclist)-1:
+                                if   text.find('\\ifthreedmystic{\n\\option{%s}' %(doclist[i+1])) > 0: n = text.find('\\ifthreedmystic{\n\\option{%s}' %(doclist[i+1])) 
+                                elif text.find('\\ifmystic{\n\\option{%s}'       %(doclist[i+1])) > 0: n = text.find('\\ifmystic{\n\\option{%s}' %(doclist[i+1])) 
+                                elif text.find('\\iflidar{\n\\option{%s}'        %(doclist[i+1])) > 0: n = text.find('\\iflidar{\n\\option{%s}' %(doclist[i+1]))
+                                elif text.find('\\undocumented{\n\\option{%s}'   %(doclist[i+1])) > 0: n = text.find('\\undocumented{\n\\option{%s}' %(doclist[i+1])) 
+                                elif text.find('\\option{%s}'                    %(doclist[i+1])) > 0: n = text.find('\\option{%s}' %(doclist[i+1]))
+                                else: n = text.find('%DOCUMENTATION END')
+                        else: n = text.find('%DOCUMENTATION END')
+
+                        if options[option].get('developer'):
+                                text = '%s\\undocumented{\n\\option{%s}%s}\n%s' %(text[:n], option, docu[option], text[n:])
+                        elif options[option].get('islidar'):
+                                text = '%s\\iflidar{\n\\option{%s}%s}\n%s' %(text[:n], option, docu[option], text[n:])
+                        elif options[option].get('threedmystic'):
+                                text = '%s\\ifthreedmystic{\n\\option{%s}%s}\n%s' %(text[:n], option, docu[option], text[n:])
+                        elif options[option].get('mystic'):
+                                text = '%s\\ifmystic{\n\\option{%s}%s}\n%s' %(text[:n], option, docu[option], text[n:])
+                        else:
+                                text = '%s\\option{%s}%s\n%s' %(text[:n], option, docu[option], text[n:])
+
+        return text
 
 def insertInitialisations(text,options):
-	import re
-
-	#get sorted initialisations
-	inits = {}
-	for val in options.itervalues():
-		#get default initialisation of tokens
-		for initialize in ['tokens', 'settings']:
-			if val.get(initialize):
-				for tok in val.get(initialize):
-					if tok.get('default') != None: 
-						if inits.has_key(tok.get('name')) and inits[tok.get('name')] != tok.get('default'): 
-
-							print 'ERROR: \nvariable %s has different initialisations: %s and %s\n Please check your option definitions again.\n' %(
-								tok.get('name'), getStr(inits[tok.get('name')]), getStr(tok.get('default')) )
-						else: inits[tok.get('name')] = tok.get('default')
-	
-	initialisation = ''
-	for key in sorted(inits.keys()):
-		initialisation += '  %s = %s;\n' %(key,getStr(inits.get(key)) )
-	text = re.sub('\n.*PYTHON INITIALISATIONS.*\n' , '\n%s\n' %(initialisation), text, count=1)
-	return text
+        import re
+
+        #get sorted initialisations
+        inits = {}
+        for val in options.values():
+                #get default initialisation of tokens
+                for initialize in ['tokens', 'settings']:
+                        if val.get(initialize):
+                                for tok in val.get(initialize):
+                                        if tok.get('default') != None: 
+                                                if tok.get('name') in inits and inits[tok.get('name')] != tok.get('default'): 
+
+                                                        print('ERROR: \nvariable %s has different initialisations: %s and %s\n Please check your option definitions again.\n' %(
+                                                                tok.get('name'), getStr(inits[tok.get('name')]), getStr(tok.get('default')) ))
+                                                else: inits[tok.get('name')] = tok.get('default')
+        
+        initialisation = ''
+        for key in sorted(inits.keys()):
+                initialisation += '  %s = %s;\n' %(key,getStr(inits.get(key)) )
+        text = re.sub('\n.*PYTHON INITIALISATIONS.*\n' , '\n%s\n' %(initialisation), text, count=1)
+        return text
 
 if __name__ == "__main__":
-	writeLex()
+        writeLex()
diff --git a/src_py/writeLex.py.in b/src_py/writeLex.py.in
index 0313495..4df2784 100644
--- a/src_py/writeLex.py.in
+++ b/src_py/writeLex.py.in
@@ -23,6 +23,8 @@
  * Foundation, Inc., 59 Temple Place - Suite 330, 
  * Boston, MA 02111-1307, USA.
  *--------------------------------------------------------------------"""
+
+import io
 from option_definition import *
 
 found_lidar     = "@FOUND_LIDAR@"
@@ -30,291 +32,291 @@ found_mystic    = "@FOUND_MYSTIC@"
 found_mystic3d  = "@FOUND_MYSTIC3D@"
 
 def writeLex():
-	import os
+        import os
+
+        pwd = os.getcwd()
 
-	pwd = os.getcwd()
-	
-	options = loadOptions()					#load python dictionary with input options
-	lexParser = loadLexStarter(pwd+'/lex_starter.l')	#load lexStarter.l
-	lexParser = insertInputOption(lexParser,options)	#add input options from python dictionary to lex parser
-	lexParser = insertDocu(lexParser,options)		#add documentation to python dictionary
-	lexParser = insertInitialisations(lexParser,options)	#add default initialisations
+        options = loadOptions()                                 #load python dictionary with input options
+        lexParser = loadLexStarter(pwd+'/lex_starter.l')        #load lexStarter.l
+        lexParser = insertInputOption(lexParser,options)        #add input options from python dictionary to lex parser
+        lexParser = insertDocu(lexParser,options)               #add documentation to python dictionary
+        lexParser = insertInitialisations(lexParser,options)    #add default initialisations
 
-	writeUvspecLex(lexParser,pwd+'/uvspec_lex.l')
+        writeUvspecLex(lexParser,pwd+'/uvspec_lex.l')
 
 def loadOptionsHelper():
-	"""
-	Returns a list of all the groups.
-	Used in the GUI.
-	"""
-	import aerosol_options, cloud_options, profile_options, geometry_options, special_options
-	import mc_options, spectral_options, surface_options, molecular_options, solver_options, output_options, general_atmosphere_options
-
-	profile = profile_options.setup_cloud_group()
-	cloud = cloud_options.setup_cloud_group()
-	aer = aerosol_options.setup_aerosol_group()
-	special = special_options.setup_special_group()
-
-	mc = mc_options.setup_mc_group()
-	spectral = spectral_options.setup_spectral_group()
-	gen_atm = general_atmosphere_options.setup_general_atm_group()
-	sur = surface_options.setup_surface_group()
-	mol = molecular_options.setup_molecular_group()
-	sol = solver_options.setup_solver_group()
-	out = output_options.setup_output_group()
-	geom = geometry_options.setup_geometry_group()
-
-	list_of_groups=[spectral, gen_atm, mol, aer, profile, cloud, sur, sol, mc, geom, out, special]
-	for group in list_of_groups:
-		for option in group:
-			if found_lidar == 'no' and option['islidar']:		group.options.remove(option)
-			elif found_mystic == 'no' and option['mystic']:		group.options.remove(option)
-			elif found_mystic3d == 'no' and option['threedmystic']:	group.options.remove(option)
-
-	return list_of_groups 
+        """
+        Returns a list of all the groups.
+        Used in the GUI.
+        """
+        import aerosol_options, cloud_options, profile_options, geometry_options, special_options
+        import mc_options, spectral_options, surface_options, molecular_options, solver_options, output_options, general_atmosphere_options
+
+        profile = profile_options.setup_cloud_group()
+        cloud = cloud_options.setup_cloud_group()
+        aer = aerosol_options.setup_aerosol_group()
+        special = special_options.setup_special_group()
+
+        mc = mc_options.setup_mc_group()
+        spectral = spectral_options.setup_spectral_group()
+        gen_atm = general_atmosphere_options.setup_general_atm_group()
+        sur = surface_options.setup_surface_group()
+        mol = molecular_options.setup_molecular_group()
+        sol = solver_options.setup_solver_group()
+        out = output_options.setup_output_group()
+        geom = geometry_options.setup_geometry_group()
+
+        list_of_groups=[spectral, gen_atm, mol, aer, profile, cloud, sur, sol, mc, geom, out, special]
+        for group in list_of_groups:
+                for option in group:
+                        if found_lidar == 'no' and option['islidar']:           group.options.remove(option)
+                        elif found_mystic == 'no' and option['mystic']:         group.options.remove(option)
+                        elif found_mystic3d == 'no' and option['threedmystic']: group.options.remove(option)
+
+        return list_of_groups 
 
 def loadOptions():
-	options={}
-	
-	for group in loadOptionsHelper():
-		for option in group:
-			options[option.get('name')]=option
-	return options	
+        options={}
+        
+        for group in loadOptionsHelper():
+                for option in group:
+                        options[option.get('name')]=option
+        return options  
 
 def loadLexStarter(filename):
-	import os
+        import os
 
-	#read lex file
-	pwd = os.getcwd()
-	lexstarter = open(filename,'r')
-	text = lexstarter.read()
-	lexstarter.close()
-	return text
+        #read lex file
+        pwd = os.getcwd()
+        lexstarter = open(filename,'r')
+        text = lexstarter.read()
+        lexstarter.close()
+        return text
 
 def writeUvspecLex(text,filename):
-	newlex = open(filename,'w')
-	newlex.write(text)
-	newlex.close()
+        newlex = open(filename,'w')
+        newlex.write(text)
+        newlex.close()
 
 def getStr(string):
-	if str(string) == 'True': return 'TRUE'
-	elif str(string) == 'False': return 'FALSE'
-	else: return str(string)
-		
+        if str(string) == 'True': return 'TRUE'
+        elif str(string) == 'False': return 'FALSE'
+        else: return str(string)
+                
 
 def getTypeScan(dtype, valid_range):
-	if dtype == str or dtype == file:
-		return '{SPACE_WORD}'
-	elif dtype == Dimension:
-		return '{SPACE}+{DIM}'
-	elif dtype == ProfileType:
-		return '{SPACE_PROFILETYPE}'
-	elif dtype == SignedFloats :
-		return '{SIGNED_FLOATS}'
-	elif dtype == Integers :
-		return '{INTEGERS}'
-	elif dtype == CaothType or dtype == CaothoffType :
-		return '{SPACE_WORD}'
-	elif dtype == int:
-		return '{SPACE_INTEGER}'
-	elif dtype == long:
-		return '{SPACE_FLOAT}'
-	elif dtype == float or dtype == Double:
-		if valid_range and valid_range[0] >= 0:
-			return '{SPACE_FLOAT}'
-		else:
-			return '{SPACE_SIGNED_FLOAT}'
-	else: print 'ERROR: datatype not known: ', dtype
+        if dtype == str or dtype == io.IOBase:
+                return '{SPACE_WORD}'
+        elif dtype == Dimension:
+                return '{SPACE}+{DIM}'
+        elif dtype == ProfileType:
+                return '{SPACE_PROFILETYPE}'
+        elif dtype == SignedFloats :
+                return '{SIGNED_FLOATS}'
+        elif dtype == Integers :
+                return '{INTEGERS}'
+        elif dtype == CaothType or dtype == CaothoffType :
+                return '{SPACE_WORD}'
+        elif dtype == int:
+                return '{SPACE_INTEGER}'
+        elif dtype == int:
+                return '{SPACE_FLOAT}'
+        elif dtype == float or dtype == Double:
+                if valid_range and valid_range[0] >= 0:
+                        return '{SPACE_FLOAT}'
+                else:
+                        return '{SPACE_SIGNED_FLOAT}'
+        else: print('ERROR: datatype not known: ', dtype)
 
 def yytext2type(dtype):
-	if dtype == str or dtype == file or dtype == ProfileType:
-		return 'yytext2string'
-	elif dtype == float:
-		return 'yytext2float'
-	elif dtype == Double:
-		return 'yytext2double'
-	elif dtype == int:
-		return 'yytext2int'
-	elif dtype == long:
-		return '(long int) yytext2double'
+        if dtype == str or dtype == io.IOBase or dtype == ProfileType:
+                return 'yytext2string'
+        elif dtype == float:
+                return 'yytext2float'
+        elif dtype == Double:
+                return 'yytext2double'
+        elif dtype == int:
+                return 'yytext2int'
+        elif dtype == int:
+                return '(long int) yytext2double'
 
 def getLexOptions(group):
 
-	inputOption = ''
-	
-	for name, option in sorted(group.iteritems()):
-		# Do something completly different
-		if hasattr(option, "writeLex"):
-			inputOption += option.writeLex()
-		# Do the usual
-		else:
-			tokens = option.get('tokens')
-
-			#write input option name
-			inputOption += name
-
-			nTokens, rules, optional = lexRules(tokens)
-
-			#write setting of input arguments
-			variableSetting = '' 
-			itok = 1
-			for tok in tokens: 
-				if tok.get('optional'):		variableSetting += '\tif ( ntokens >= %d )\t {\n\t' %( itok )
-
-				if isinstance(tok, addSetting):
-					variableSetting += '\t%s = %s;\n' %(tok.get('name'),
+        inputOption = ''
+        
+        for name, option in sorted(group.items()):
+                # Do something completly different
+                if hasattr(option, "writeLex"):
+                        inputOption += option.writeLex()
+                # Do the usual
+                else:
+                        tokens = option.get('tokens')
+
+                        #write input option name
+                        inputOption += name
+
+                        nTokens, rules, optional = lexRules(tokens)
+
+                        #write setting of input arguments
+                        variableSetting = '' 
+                        itok = 1
+                        for tok in tokens: 
+                                if tok.get('optional'):         variableSetting += '\tif ( ntokens >= %d )\t {\n\t' %( itok )
+
+                                if isinstance(tok, addSetting):
+                                        variableSetting += '\t%s = %s;\n' %(tok.get('name'),
                                                                 getStr(tok.get('setting')))
 
-				elif isinstance(tok,addLogical):
-					itok += 1
-					variableSetting += getLogicals(tok,itok,nTokens)
-					
-				else:
-					try:
-						itok += 1	
-						variableSetting += getTokens(tok,itok, str(nTokens) )
-					except Exception, e:
-						print 'ERROR found in input option %s :\n\t Datatype %s of variable %s not known!' % (
-							option.get('name'), tok.get('datatype'), tok.get('name') )
-						print e
-				if  tok.get('optional'):         variableSetting += '\t}\n'
+                                elif isinstance(tok,addLogical):
+                                        itok += 1
+                                        variableSetting += getLogicals(tok,itok,nTokens)
+                                        
+                                else:
+                                        try:
+                                                itok += 1       
+                                                variableSetting += getTokens(tok,itok, str(nTokens) )
+                                        except Exception as e:
+                                                print('ERROR found in input option %s :\n\t Datatype %s of variable %s not known!' % (
+                                                        option.get('name'), tok.get('datatype'), tok.get('name') ))
+                                                print(e)
+                                if  tok.get('optional'):         variableSetting += '\t}\n'
 
-			inputOption += '%s {\n%s%s}\n' %( rules, optional, variableSetting )
+                        inputOption += '%s {\n%s%s}\n' %( rules, optional, variableSetting )
 
-	return inputOption
+        return inputOption
 
 def lexRules(tokens):
-	nTokens=1; 
-	tokenStr=''; rules=''; optional=''
-	for tok in tokens:
-		if isinstance(tok,addSetting):
-			continue
-		else:
-			rules += getTypeScan(tok.get('datatype'),	   tok.get('valid_range'))
-			nTokens +=1
-			tokenStr = str(nTokens)
-			if tok.get('optional'):
-				tokenStr = 'ntokens+1'
-				optional = '\tntokens = yytext2ntokens(yytext);\n'
-				rules += '?'
-	return [ tokenStr, rules, optional ]
+        nTokens=1; 
+        tokenStr=''; rules=''; optional=''
+        for tok in tokens:
+                if isinstance(tok,addSetting):
+                        continue
+                else:
+                        rules += getTypeScan(tok.get('datatype'),          tok.get('valid_range'))
+                        nTokens +=1
+                        tokenStr = str(nTokens)
+                        if tok.get('optional'):
+                                tokenStr = 'ntokens+1'
+                                optional = '\tntokens = yytext2ntokens(yytext);\n'
+                                rules += '?'
+        return [ tokenStr, rules, optional ]
 
 def getTokens(tok,itok,nTokens):
 
-	dtype = tok.get('datatype')
-	if dtype == file:
-		inputStr = '\tyytextCstring ( %s, yytext, %d, %s);\n' % ( tok.get('name'), itok, str(nTokens) ) 
-	elif dtype == SignedFloats:
-		inputStr = '\tntokens = yytext2ntokens(yytext);\n\t%s =  yytext2floats(yytext, ntokens);\n' % ( tok.get('name') )
-	elif dtype == Integers:
-		inputStr = '\tntokens = yytext2ntokens(yytext);\n\t%s =  yytext2integers(yytext, ntokens);\n' % ( tok.get('name') )
-	elif dtype == CaothType:
-		inputStr = '\t%s = get_caoth_index(&Input.caoth,&Input.n_caoth, yytext2string(yytext, %d, %s),0);\n' % (  tok.get('name'), itok, str(nTokens) )
-	elif dtype == CaothoffType:
-		inputStr = '\t%s = get_caothoff_index(&Input.caothoff,&Input.n_caothoff, yytext2string(yytext, %d, %s));\n' % (  tok.get('name'), itok, str(nTokens) )
-	else:
-		inputStr = '\t%s = %s(yytext, %d, %s);\n' % ( tok.get('name'),
-			  yytext2type(tok.get('datatype')),
-			  itok, str(nTokens) )
-	return inputStr
+        dtype = tok.get('datatype')
+        if dtype == io.IOBase:
+                inputStr = '\tyytextCstring ( %s, yytext, %d, %s);\n' % ( tok.get('name'), itok, str(nTokens) ) 
+        elif dtype == SignedFloats:
+                inputStr = '\tntokens = yytext2ntokens(yytext);\n\t%s =  yytext2floats(yytext, ntokens);\n' % ( tok.get('name') )
+        elif dtype == Integers:
+                inputStr = '\tntokens = yytext2ntokens(yytext);\n\t%s =  yytext2integers(yytext, ntokens);\n' % ( tok.get('name') )
+        elif dtype == CaothType:
+                inputStr = '\t%s = get_caoth_index(&Input.caoth,&Input.n_caoth, yytext2string(yytext, %d, %s),0);\n' % (  tok.get('name'), itok, str(nTokens) )
+        elif dtype == CaothoffType:
+                inputStr = '\t%s = get_caothoff_index(&Input.caothoff,&Input.n_caothoff, yytext2string(yytext, %d, %s));\n' % (  tok.get('name'), itok, str(nTokens) )
+        else:
+                inputStr = '\t%s = %s(yytext, %d, %s);\n' % ( tok.get('name'),
+                          yytext2type(tok.get('datatype')),
+                          itok, str(nTokens) )
+        return inputStr
 
 
 
 def getLogicals(tok,itok,nTokens):
-	import re
-
-	#dictionary to subsitute charakters like + - . to underscore _ for matching definition in C code
-	rdict={'-': '_',  '.': '_',  '+':'_' }
-	regex = re.compile("(%s)" % "|".join(map(re.escape, rdict.keys())))
-
-	#uvspec_lex.l : read token for string comparison
-	inputStr = '\ts = yytext2string(yytext, {0}, {1});\n\t'.format(itok,nTokens)
-
-	#string comparison to set logical values
-	logicals = tok.get('logicals')
-	for ilog,log in enumerate(sorted(logicals)):
-		if ilog == 0:	inputStr += 'if'
-		else:		inputStr += 'else if'
-		if len(logicals) == 1:  # one logical -> destination = 1
-			inputStr += ' ( strcasecmp("{0}", s)==0 )\t{{ {1} = 1; }}\n\t'.format(log,tok.get('destination'))
-		else: #more logicals -> destination is logical in uppercase, this variable should be defined in uvspec.h!
-			inputStr += ' ( strcasecmp("{0}", s)==0 )\t{{ {1} = {2}{3}; }}\n\t'.format(log,tok.get('destination'), tok.get('setting'), ( regex.sub(lambda mo: rdict[mo.string[mo.start():mo.end()]], str(log)) ).upper() ) 
-	if tok.get('logical_file'):  #save token to destination_filename
-		inputStr += 'else\t{{ {0} = {1}FILE;\n\t\t strcpy ( {0}_filename, s ); }}\n\t'.format(tok.get('destination'), tok.get('setting'))
-	else:	#raise error
-		inputStr += r'else\t{{fprintf(stderr,"Option %s  has an invalid argument {0} on line %d: %s\\n", yytext, line_number+1, s); ierror++;}} \n\t'.format(itok-1)
-	inputStr += 'free(s); \n'
-	return inputStr
+        import re
+
+        #dictionary to subsitute charakters like + - . to underscore _ for matching definition in C code
+        rdict={'-': '_',  '.': '_',  '+':'_' }
+        regex = re.compile("(%s)" % "|".join(map(re.escape, list(rdict.keys()))))
+
+        #uvspec_lex.l : read token for string comparison
+        inputStr = '\ts = yytext2string(yytext, {0}, {1});\n\t'.format(itok,nTokens)
+
+        #string comparison to set logical values
+        logicals = tok.get('logicals')
+        for ilog,log in enumerate(sorted(logicals)):
+                if ilog == 0:   inputStr += 'if'
+                else:           inputStr += 'else if'
+                if len(logicals) == 1:  # one logical -> destination = 1
+                        inputStr += ' ( strcasecmp("{0}", s)==0 )\t{{ {1} = 1; }}\n\t'.format(log,tok.get('destination'))
+                else: #more logicals -> destination is logical in uppercase, this variable should be defined in uvspec.h!
+                        inputStr += ' ( strcasecmp("{0}", s)==0 )\t{{ {1} = {2}{3}; }}\n\t'.format(log,tok.get('destination'), tok.get('setting'), ( regex.sub(lambda mo: rdict[mo.string[mo.start():mo.end()]], str(log)) ).upper() ) 
+        if tok.get('logical_file'):  #save token to destination_filename
+                inputStr += 'else\t{{ {0} = {1}FILE;\n\t\t strcpy ( {0}_filename, s ); }}\n\t'.format(tok.get('destination'), tok.get('setting'))
+        else:   #raise error
+                inputStr += r'else\t{{fprintf(stderr,"Option %s  has an invalid argument {0} on line %d: %s\\n", yytext, line_number+1, s); ierror++;}} \n\t'.format(itok-1)
+        inputStr += 'free(s); \n'
+        return inputStr
 
 
 def insertInputOption(text,options):
-	import re
+        import re
 
-	#insert input options to lexfile
-	groupInput = getLexOptions(options)
-	text = re.sub('\n.*PYTHON_OPTIONS.*\n' , '\n%s\n' %(groupInput), text, count=1)
-	return text
+        #insert input options to lexfile
+        groupInput = getLexOptions(options)
+        text = re.sub('\n.*PYTHON_OPTIONS.*\n' , '\n%s\n' %(groupInput), text, count=1)
+        return text
 
 def insertDocu(text,options):
-	import re
-
-	#get new documentation
-	docu={}
-	for key,val in sorted(options.iteritems()):                  
-		docu[key]=val['documentation']
-	
-	#get whole documentation
-	doclist = docu.keys() + re.findall('(?<=option{)\w+',text)
-	doclist.sort( key = lambda member: member.lower() )
-	
-	#insert documentation to lexfile
-	for iopt, option in enumerate(reversed(doclist)):
-		i=len(doclist)-1-iopt
-		if docu.has_key(option) and doclist.count(option) == 1:
-			if i<len(doclist)-1:
-				if   text.find('\\ifthreedmystic{\n\\option{%s}' %(doclist[i+1])) > 0: n = text.find('\\ifthreedmystic{\n\\option{%s}' %(doclist[i+1])) 
-				elif text.find('\\ifmystic{\n\\option{%s}'	 %(doclist[i+1])) > 0: n = text.find('\\ifmystic{\n\\option{%s}' %(doclist[i+1])) 
-				elif text.find('\\iflidar{\n\\option{%s}' 	 %(doclist[i+1])) > 0: n = text.find('\\iflidar{\n\\option{%s}' %(doclist[i+1]))
-				elif text.find('\\undocumented{\n\\option{%s}' 	 %(doclist[i+1])) > 0: n = text.find('\\undocumented{\n\\option{%s}' %(doclist[i+1])) 
-				elif text.find('\\option{%s}' 			 %(doclist[i+1])) > 0: n = text.find('\\option{%s}' %(doclist[i+1]))
-				else: n = text.find('%DOCUMENTATION END')
-			else: n = text.find('%DOCUMENTATION END')
-
-			if options[option].get('developer'):
-				text = '%s\\undocumented{\n\\option{%s}%s}\n%s' %(text[:n], option, docu[option], text[n:])
-			elif options[option].get('islidar'):
-				text = '%s\\iflidar{\n\\option{%s}%s}\n%s' %(text[:n], option, docu[option], text[n:])
-			elif options[option].get('threedmystic'):
-				text = '%s\\ifthreedmystic{\n\\option{%s}%s}\n%s' %(text[:n], option, docu[option], text[n:])
-			elif options[option].get('mystic'):
-				text = '%s\\ifmystic{\n\\option{%s}%s}\n%s' %(text[:n], option, docu[option], text[n:])
-			else:
-				text = '%s\\option{%s}%s\n%s' %(text[:n], option, docu[option], text[n:])
-
-	return text
+        import re
+
+        #get new documentation
+        docu={}
+        for key,val in sorted(options.items()):                  
+                docu[key]=val['documentation']
+        
+        #get whole documentation
+        doclist = list(docu.keys()) + re.findall('(?<=option{)\w+',text)
+        doclist.sort( key = lambda member: member.lower() )
+        
+        #insert documentation to lexfile
+        for iopt, option in enumerate(reversed(doclist)):
+                i=len(doclist)-1-iopt
+                if option in docu and doclist.count(option) == 1:
+                        if i<len(doclist)-1:
+                                if   text.find('\\ifthreedmystic{\n\\option{%s}' %(doclist[i+1])) > 0: n = text.find('\\ifthreedmystic{\n\\option{%s}' %(doclist[i+1])) 
+                                elif text.find('\\ifmystic{\n\\option{%s}'       %(doclist[i+1])) > 0: n = text.find('\\ifmystic{\n\\option{%s}' %(doclist[i+1])) 
+                                elif text.find('\\iflidar{\n\\option{%s}'        %(doclist[i+1])) > 0: n = text.find('\\iflidar{\n\\option{%s}' %(doclist[i+1]))
+                                elif text.find('\\undocumented{\n\\option{%s}'   %(doclist[i+1])) > 0: n = text.find('\\undocumented{\n\\option{%s}' %(doclist[i+1])) 
+                                elif text.find('\\option{%s}'                    %(doclist[i+1])) > 0: n = text.find('\\option{%s}' %(doclist[i+1]))
+                                else: n = text.find('%DOCUMENTATION END')
+                        else: n = text.find('%DOCUMENTATION END')
+
+                        if options[option].get('developer'):
+                                text = '%s\\undocumented{\n\\option{%s}%s}\n%s' %(text[:n], option, docu[option], text[n:])
+                        elif options[option].get('islidar'):
+                                text = '%s\\iflidar{\n\\option{%s}%s}\n%s' %(text[:n], option, docu[option], text[n:])
+                        elif options[option].get('threedmystic'):
+                                text = '%s\\ifthreedmystic{\n\\option{%s}%s}\n%s' %(text[:n], option, docu[option], text[n:])
+                        elif options[option].get('mystic'):
+                                text = '%s\\ifmystic{\n\\option{%s}%s}\n%s' %(text[:n], option, docu[option], text[n:])
+                        else:
+                                text = '%s\\option{%s}%s\n%s' %(text[:n], option, docu[option], text[n:])
+
+        return text
 
 def insertInitialisations(text,options):
-	import re
-
-	#get sorted initialisations
-	inits = {}
-	for val in options.itervalues():
-		#get default initialisation of tokens
-		for initialize in ['tokens', 'settings']:
-			if val.get(initialize):
-				for tok in val.get(initialize):
-					if tok.get('default') != None: 
-						if inits.has_key(tok.get('name')) and inits[tok.get('name')] != tok.get('default'): 
-
-							print 'ERROR: \nvariable %s has different initialisations: %s and %s\n Please check your option definitions again.\n' %(
-								tok.get('name'), getStr(inits[tok.get('name')]), getStr(tok.get('default')) )
-						else: inits[tok.get('name')] = tok.get('default')
-	
-	initialisation = ''
-	for key in sorted(inits.keys()):
-		initialisation += '  %s = %s;\n' %(key,getStr(inits.get(key)) )
-	text = re.sub('\n.*PYTHON INITIALISATIONS.*\n' , '\n%s\n' %(initialisation), text, count=1)
-	return text
+        import re
+
+        #get sorted initialisations
+        inits = {}
+        for val in options.values():
+                #get default initialisation of tokens
+                for initialize in ['tokens', 'settings']:
+                        if val.get(initialize):
+                                for tok in val.get(initialize):
+                                        if tok.get('default') != None: 
+                                                if tok.get('name') in inits and inits[tok.get('name')] != tok.get('default'): 
+
+                                                        print('ERROR: \nvariable %s has different initialisations: %s and %s\n Please check your option definitions again.\n' %(
+                                                                tok.get('name'), getStr(inits[tok.get('name')]), getStr(tok.get('default')) ))
+                                                else: inits[tok.get('name')] = tok.get('default')
+        
+        initialisation = ''
+        for key in sorted(inits.keys()):
+                initialisation += '  %s = %s;\n' %(key,getStr(inits.get(key)) )
+        text = re.sub('\n.*PYTHON INITIALISATIONS.*\n' , '\n%s\n' %(initialisation), text, count=1)
+        return text
 
 if __name__ == "__main__":
-	writeLex()
+        writeLex()
